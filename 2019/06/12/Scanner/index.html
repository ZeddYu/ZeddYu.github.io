<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=manifest href=/manifest.json><meta name=description content="最近要写个端口扫描器，学习整理了一下目前的端口扫描器技术。
"><title>浅谈端口扫描技术</title>
<link rel=canonical href=https://blog.zeddyu.info/2019/06/12/Scanner/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="浅谈端口扫描技术">
<meta property="og:description" content="最近要写个端口扫描器，学习整理了一下目前的端口扫描器技术。
">
<meta property="og:url" content="https://blog.zeddyu.info/2019/06/12/Scanner/">
<meta property="og:site_name" content="Zeddy's Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Sec"><meta property="article:tag" content="端口扫描"><meta property="article:published_time" content="2019-06-12T10:45:47+00:00"><meta property="article:modified_time" content="2019-06-12T10:45:47+00:00">
<meta name=twitter:site content="@ZeddYu_Lu">
<meta name=twitter:creator content="@ZeddYu_Lu"><meta name=twitter:title content="浅谈端口扫描技术">
<meta name=twitter:description content="最近要写个端口扫描器，学习整理了一下目前的端口扫描器技术。
">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-112937997-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://blog.zeddyu.info class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/Sec/ style=background-color:#0b0;color:#fff>
Sec
</a>
</header>
<h2 class=article-title>
<a href=/2019/06/12/Scanner/>浅谈端口扫描技术</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jun 12, 2019</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
18 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>最近要写个端口扫描器，学习整理了一下目前的<strong>端口扫描器</strong>技术。</p>
<p>按照目前的协议类型，我们大致可以知道有：</p>
<blockquote>
<p>​ 一个IP地址可以有65535(2^16)个端口，范围则是从0到65535(2^16-1)，每个端口按照协议又可以分为两种类型：一种是TCP端口；另一种是UDP端口。</p>
<p>​ TCP、UDP都是IP层的传输协议，其中TCP是面向连接、可靠的字节流服务；UDP则是不可靠的，面向数据报的服务。每一个端口都会支持这两种协议，因此可以基于这两种协议进行端口扫描。</p>
</blockquote>
<p>以及现在还有通过在 TCP/IP 模型中的网络层 ICMP 协议来探测端口的扫描技术。</p>
<h1 id=tcp>TCP</h1>
<p>TCP报文这里就不再细讲了，也不是重点，放一张TCP数据报文的图，具体可以去百度百科了解：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605164642.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605164642.png loading=lazy>
</a>
</figure></p>
<p>TCP三次握手：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605163446.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605163446.png loading=lazy>
</a>
</figure></p>
<h2 id=tcp-connect-scan>TCP CONNECT SCAN</h2>
<p>原理很简单，与目标端口建立3次握手，如果成功建立则为<code>open</code>，收到<code>RST</code>则为<code>close</code></p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165105.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165105.png loading=lazy alt="TCP CONNECT SCAN">
</a>
<figcaption>TCP CONNECT SCAN</figcaption>
</figure></p>
<h3 id=usage>usage</h3>
<p>MSF 模块：</p>
<pre tabindex=0><code>use auxiliary/scanner/portscan/tcp
</code></pre><p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190608234213.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190608234213.png loading=lazy>
</a>
</figure></p>
<p>Nmap 选项参数：</p>
<pre tabindex=0><code>nmap -sT scanme.nmap.org
</code></pre><h2 id=tcp-syn-scan>TCP SYN SCAN</h2>
<p>也称为TCP半连接扫描，只发送三次握手的第一次SYN报文段，如果收到<code>ACK+SYN</code>则为<code>open</code>，收到<code>RST</code>则为<code>close</code>，这种好处是不必等待三次握手完全完成，速度快且不容易被防火墙记录进日志。</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165140.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165140.png loading=lazy alt="TCP SYN SCAN">
</a>
<figcaption>TCP SYN SCAN</figcaption>
</figure></p>
<p>Nmap 处理方式：</p>
<table>
<thead>
<tr>
<th>Probe Response</th>
<th>Assigned State</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP SYN/ACK response</td>
<td><code>open</code></td>
</tr>
<tr>
<td>TCP RST response</td>
<td><code>closed</code></td>
</tr>
<tr>
<td>No response received (even after retransmissions)</td>
<td><code>filtered</code></td>
</tr>
<tr>
<td>ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13)</td>
<td><code>filtered</code></td>
</tr>
</tbody>
</table>
<h3 id=usage-1>usage</h3>
<p>MSF 模块：</p>
<pre tabindex=0><code>use auxiliary/scanner/portscan/syn
</code></pre><p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609010618.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609010618.png loading=lazy>
</a>
</figure></p>
<p>Nmap 参数</p>
<pre tabindex=0><code>nmap -sS scanme.nmap.org
</code></pre><h2 id=tcp-xmas-tree-scan>TCP Xmas Tree SCAN</h2>
<p>客户端向服务端发送带有 <code>PSH</code>，<code>FIN</code>，<code>URG</code> 标识的数据包(即不含有<code>ACK SYN RST</code>)，被称为TCP Xmas Tree扫描。其利用的是<code>RFC</code>的规定:</p>
<blockquote>
<p>​ 如果不设置SYN，RST，或者ACK位的报文发送到开放端口，理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。</p>
</blockquote>
<p>那么就有：</p>
<blockquote>
<p>​ 如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK, 任何其它三种(FIN，PSH，and URG)的组合都行。</p>
</blockquote>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165320.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165320.png loading=lazy alt="TCP XMAS TREE SCAN">
</a>
<figcaption>TCP XMAS TREE SCAN</figcaption>
</figure></p>
<p>Nmap 对 NULL, FIN, or Xmas 扫描的处理：</p>
<table>
<thead>
<tr>
<th>Probe Response</th>
<th>Assigned State</th>
</tr>
</thead>
<tbody>
<tr>
<td>No response received (even after retransmissions)</td>
<td><code>open or filtered</code></td>
</tr>
<tr>
<td>TCP RST packet</td>
<td><code>closed</code></td>
</tr>
<tr>
<td>ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13)</td>
<td><code>filtered</code></td>
</tr>
</tbody>
</table>
<h3 id=usage-2>usage</h3>
<p>MSF 模块：</p>
<pre tabindex=0><code>use auxiliary/scanner/portscan/xmas
</code></pre><p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609011211.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609011211.png loading=lazy>
</a>
</figure></p>
<p>Nmap 选项参数：</p>
<pre tabindex=0><code>Null scan (`-sN`)

Does not set any bits (TCP flag header is 0)

FIN scan (`-sF`)

Sets just the TCP FIN bit.

Xmas scan (`-sX`)

Sets the FIN, PSH, and URG flags, lighting the packet up like a Christmas tree.
</code></pre><h2 id=tcp-null-scan>TCP NULL SCAN</h2>
<p>空扫描即<code>flag</code>位全 0 ，如果没有回复则为<code>open</code>，收到<code>RST</code>则为<code>close</code></p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165511.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165511.png loading=lazy alt="TCP NULL SCAN">
</a>
<figcaption>TCP NULL SCAN</figcaption>
</figure></p>
<h2 id=tcp-ack-scan>TCP ACK SCAN</h2>
<p>使用TCP ACK扫描不能够确定端口的关闭或者开放，因为当发送给对方一个含有 ACK 表示的TCP报文的时候，都返回含有RST标志的报文，无论端口是开放或者关闭。所以，不能使用TCP ACK扫描来确定端口是否开放或者关闭。但是可以利用它来扫描防火墙的配置，用它来发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。</p>
<p>向服务端发送一个带有 ACK 标识的数据包，如果收到带有 RST 标识的响应，则说明服务端没有过滤，不存在状态防火墙。</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165649.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605165649.png loading=lazy alt="TCP ACK SCAN">
</a>
<figcaption>TCP ACK SCAN</figcaption>
</figure></p>
<h3 id=usage-3>usage</h3>
<p>可以使用 msf 的模块</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>use auxiliary/scanner/portscan/ack
</code></pre></div><p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609011455.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609011455.png loading=lazy>
</a>
</figure></p>
<p>Nmap 可以用以下命令</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nmap -sA scanme.nmap.org
</code></pre></div><h2 id=tcp-window-scan>TCP WINDOW SCAN</h2>
<p>TCP 窗口扫描的流程类似于 ACK 扫描，都是向服务端发送带有 ACK 标识的数据包，不同的在于 TCP 窗口扫描会检查收到的 RST 数据包中的窗口大小，如果 RST 数据包中的窗口大小不为零，则说明目标端口是开放的。</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170017.jpg>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170017.jpg loading=lazy alt="TCP WINDOW SCAN">
</a>
<figcaption>TCP WINDOW SCAN</figcaption>
</figure></p>
<p>如果 RST 数据包中的窗口大小为零，则说明目标端口处于关闭状态。</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170009.jpg>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170009.jpg loading=lazy alt="TCP WINDOW SCAN">
</a>
<figcaption>TCP WINDOW SCAN</figcaption>
</figure></p>
<p>Nmap 对 TCP Window 扫描的处理：</p>
<table>
<thead>
<tr>
<th>Probe Response</th>
<th>Assigned State</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP RST response with non-zero window field</td>
<td><code>open</code></td>
</tr>
<tr>
<td>TCP RST response with zero window field</td>
<td><code>closed</code></td>
</tr>
<tr>
<td>No response received (even after retransmissions)</td>
<td><code>filtered</code></td>
</tr>
<tr>
<td>ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13)</td>
<td><code>filtered</code></td>
</tr>
</tbody>
</table>
<h3 id=usage-4>usage</h3>
<p>Nmap 扫描参数：</p>
<pre tabindex=0><code>nmap -sW docsrv.caldera.com
</code></pre><h2 id=tcp-idle-scan>TCP Idle Scan</h2>
<p>1998年，安全研究员Antirez（曾参与编辑nmap中有关hping2工具的相关文章）在Bugtraq邮件列表中发布了一篇关于新的端口扫描技术的文章。Idle Scan，也就慢慢的为众人所了解，它允许进行完全盲目的端口扫描。事实上，攻击者可以不用向目标发送数据包就完成扫描工作！相反，用猥琐的边信道攻击是能够让扫描映射到一个Zombie 主机上的。除了极其隐蔽的情况，这种扫描方式允许挖掘机器之间基于IP的信任关系。</p>
<p>虽然 Idle Scan 比目前讨论的任何技术都复杂，但您无需成为TCP / IP专家就能理解它。你只需要知道这些就够了：</p>
<ul>
<li>
<p>确定TCP端口是否打开的一种方法是向端口发送SYN（会话建立）数据包。如果端口打开，目标机器将响应SYN / ACK（会话请求确认）数据包，如果端口关闭，则响应RST（重置）。这是前面讨论的SYN扫描的基础。</p>
</li>
<li>
<p>接收未经请求的SYN / ACK数据包的计算机将使用RST进行响应。未经请求的RST将被忽略。</p>
</li>
<li>
<p>Internet上的每个IP数据包都有一个片段标识号（IP ID）。由于许多操作系统只是为它们发送的每个数据包递增此数字，因此探测IPID可以告诉攻击者自上次探测以来已发送了多少数据包。</p>
</li>
</ul>
<p>结合以上特征，就可以伪造身份去扫描目标网络，所以看起来就像是无辜的 Zombie 主机在扫描。</p>
<h3 id=idle-scan-step-by-step>Idle Scan Step by Step</h3>
<p>从本质上来看，Idle Scan 只需要重复3个步骤就ok了。</p>
<ol>
<li>探查Zombie的IP ID并记录下来。</li>
<li>在Zombie主机上伪造一个包，然后把包发送给目标主机端口。根据端口的状态，目标主机可能会也有可能不会导致Zombie主机IPID值增加。</li>
<li>再探查Zombie主机的IP ID。比较两次得到IPID值</li>
</ol>
<p>经过这样一个流程，Zombie主机的 IP ID 应该会增加1~2。如果只是增加了1，那么就可以说明Zombie主机还没有发出任何包，当然，响应攻击者的探查请求除外。没有发送包也就意味着目标端口没有被打开（也可能是目标主机向Zombie主机发送了一个RST包，导致请求被忽略，或者是根本就是什么都没有做）。增加的如果是2，那就表明Zombie主机成功在两个探测器之间发送了包。这种情况一般情况都意味着目标端口是开着的（目标大概会向Zombie主机发送一个SYN/ACK包去响应攻击者伪造的SYN，从Zombie主机诱导RST包）。如果是增加了一个比2还大的数字，那么就说明Zombie主机太糟糕了！它可能不能胜任预测IPID数值，也可能是正在忙于其他与Idle Scan无关的事情。</p>
<p>虽然关闭了端口和被过滤的端口会发生的事情稍微有点点不同，但是攻击者处理的方法都一样，IPID都只是增加1。所以，在Idel Scan中无法区别端口到底是关闭的还是已经过滤了。当Nmap记录的IPID增加了1，也就被标记成了close丨filterred。</p>
<p>以下三张图大略可以说明端口被打开，关闭，过滤的情况。</p>
<p>端口开放：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609152056.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609152056.png loading=lazy>
</a>
</figure></p>
<p>端口关闭：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609155715.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609155715.png loading=lazy>
</a>
</figure></p>
<p>端口被过滤：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609160207.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609160207.png loading=lazy>
</a>
</figure></p>
<p>Idel Scan根本上来讲就是一个隐性扫描，Nmap提供了decoy scanning (-D)，帮助使用者保护自己的身份。如果不是使用的（类似Idel Scan扫描方式）仍然需要攻击者通过自身真实IP向目标发送数据包以获取扫描结果。Idel Scan扫描结果其中之一就有入侵检测系统通常会发送一个Zombie主机已经开始扫描的通知。所以它可以作为一个框架去扫描另外一个目标，当你查阅入侵检测系统（IDS）时，请记住这种可能性。</p>
<p>Idel Scan的一个独特优势便是，它可以绕开某些过滤防火墙和路由器。IP源地址过滤，是一种常见的（虽然很弱）用于限制机器连接到敏感主机或者说网络上的安全机制。举个例子，一个公司数据库服务器，只允许公共网络连接。或者，家庭用户只允许SSH连接到工作机上面。</p>
<p>Idel Scanning有时也可以被用来映射信任关系，关键在于Idel Scan最终会从Zombie主机获取开放端口列表。一个正常的扫描对于上述数据库服务器可能会显示没有端口开放，但是当将Zombie主机作为Web Sever的IP，使用Idel Scan就可能将数据库相关开放端口暴露出来。</p>
<p>映射出的这些信任关系就可能作为攻击者优先考虑的目标，上面所讨论的方式手法很猥琐哇！</p>
<p>Idel Scan有一个缺点就是它比其他一些扫描方式所花费的时间更长。尽管在《<a class=link href=http://nmap.org/book/idlescan.html#scan-methods-idle-scan-algorithms target=_blank rel=noopener>Idel Scan算法实现</a>》章节中有对Idel Scan的优化算法，一个只需要15秒就可以完成的SYN，Idel Scan或许需要15分钟才能够完成。另一个问题就是你必须能够发送欺骗包，伪装成好像他们来自Zombie主机一般，让他们到达目标主机。许多ISP服务商（特别是拨号和住宅宽带供应商）目前执行出口过滤来防止这类数据包欺骗。高端供应商（比如说主机托管，T1-Services）就不太可能这么做。如果实际存在这个过滤，Nmap会在你尝试的每一个Zombie主机上显示一个快速错误消息。如果不能够更换ISP服务商，那么最好尝试在让ISP服务商给你更换一个IP。有时候这个过滤仅仅只是阻止了客户使用范围之外的欺骗IP地址。Idel Scan另外一个难点就是你必须寻找一个正在工作的Zombie主机。</p>
<p>上述描述的是Idel Scan的基础水平。在Nmap上实现却是有些复杂，最关键的差异在于Nmap能够同时执行，而且误报少。</p>
<p>Parallelizing idle scan由于是间接推导出端口所以，他比其他扫描方式要更加的猥琐。如果Nmap探测目标主机上的多个端口，然后检测Zombie主机上新的IP ID值，IP ID的值增加了多少就显示出目标开放了多少个端口。实际上这并不是一个和严重的问题，绝大多数端口在大型扫描结果中基本上都是被关闭或者被过滤。由于只有开放端口才可以让IP ID值增加，Nmap会认为没有增加量，然后整个组的端口就被标记成了关闭或者被过滤。Nmap可以并行扫描一百组端口。如果Nmap在探测一组端口的时候Zombie主机IP ID同时也增加了，就说明在这一组端口中一定有开放的端口。Nmap继而使用二进制搜索发现开放的端口。它将数据组分成两份，分别发送探测信息，如果一个数据组显示没有开放端口，那么这一数据组的端口都将被标记为被关闭或者被过滤。如果一个数据组显示有开放端口，那么在把这个数据组分成两份，重复以上步骤，直到最终将开放端口都找出来。虽然这种方式更复杂，但是这种方式可以节约扫描时间。</p>
<p>可靠性是Idel Scan的另一个问题。如果Zombie主机在扫描时向任何不相干的机器发送数据包，其IP ID会增加。这就会让Nmap误以为已经寻找到开放的端口了。幸运的是，并行扫描在这里也是有很大作用的。如果Nmap在一个组中扫描100个端口，那么IP ID就会增加标识两个开放端口，Nmap将这组数据分成50端口一个小组。当Nmap同时在两个小组中进行IP ID扫描时，Zombie主机IP ID总的增加量就在加了一次。另外，Nmap如果探测到不一致，那么它会重新探测。基于检测可靠的Zombie主机，Nmap还会修改组大小以及扫描时间。如果Nmap发现有大量不一致的结果，它将退出，并提示用户选择更好的Zombie主机。</p>
<p>具体操作可以参考<a class=link href=https://nmap.org/book/idlescan.html target=_blank rel=noopener>TCP Idle Scan (-sI)</a></p>
<h2 id=tcp-maimon-scan>TCP Maimon Scan</h2>
<p>Maimon Scan 以其发现者 Uriel Maimon 命名。 他在 Phrack 杂志第49期（1996年11月）中描述了这种技术。 除了探测器是FIN / ACK之外，此技术与NULL，FIN和Xmas扫描完全相同。 根据RFC 793（TCP），响应于这样的探测，应该生成RST分组，无论端口是打开还是关闭。 但是，如果端口打开，许多BSD派生系统只会丢弃数据包。 Nmap利用这一点来确定开放端口，如下表所示：</p>
<p>Nmap 对 TCP Maimon Scan 的处理：</p>
<table>
<thead>
<tr>
<th>Probe Response</th>
<th>Assigned State</th>
</tr>
</thead>
<tbody>
<tr>
<td>No response received (even after retransmissions)</td>
<td><code>open or filtered</code></td>
</tr>
<tr>
<td>TCP RST packet</td>
<td><code>closed</code></td>
</tr>
<tr>
<td>ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13)</td>
<td><code>filtered</code></td>
</tr>
</tbody>
</table>
<h3 id=usage-5>usage</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nmap -sM para

Starting Nmap <span class=o>(</span> http://nmap.org <span class=o>)</span>
All <span class=m>1000</span> scanned ports on para <span class=o>(</span>192.168.10.191<span class=o>)</span> are: closed
MAC Address: 00:60:1D:38:32:90 <span class=o>(</span>Lucent Technologies<span class=o>)</span>

Nmap <span class=k>done</span>: <span class=m>1</span> IP address <span class=o>(</span><span class=m>1</span> host up<span class=o>)</span> scanned in 4.19 seconds
</code></pre></div><h2 id=tcp-ftp-bounce-scan>TCP FTP Bounce Scan</h2>
<p>FTP协议（RFC 959）的一个有趣特性是支持代理FTP连接。这允许用户连接到一个FTP服务器，然后要求将文件发送到第三方服务器。这样的功能在很多层面上被滥用，因此大多数服务器已停止支持它。此功能允许的滥用功能之一是通过 FTP 服务器进行扫描其他主机端口。只需要求 FTP 服务器依次将文件发送到目标主机的每个端口就可以了。回显消息将描述端口是否打开。这是绕过防火墙的好方法，因为内部的 FTP 服务器通常放置在比旧的 Internet 主机都能访问到的其他主机的位置上。</p>
<p>Nmap支持使用-b选项进行FTP反弹扫描。它采用<code>&lt;username>:&lt;password>@&lt;server>:&lt;port></code>形式的参数。 <code>&lt;Server></code>是易受攻击的FTP服务器的名称或IP地址。与普通URL一样，您可以省略<code>&lt;username>:&lt;password></code>，在这种情况下，将使用匿名登录凭据（<code>user:anonymous password:-wwwuser@</code>）。端口号（和前面的冒号）也可以省略，在这种情况下，使用<code>&lt;server></code>上的默认FTP端口（21）。</p>
<p>使用 FTP Bounce Scan 较为频繁的用户更好地习惯了对回显消息的处理。这个漏洞在1997年Nmap发布时很普遍，但已在很大程度上得到修复。易受攻击的服务器仍然存在，所以当其他所有服务器都失败时，这个方法值得一试。如果您的目标是绕过防火墙，请扫描目标网络以查找开放的21端口（如果使用版本检测扫描所有端口，则扫描任何FTP服务），然后尝试使用每个端口进行 Bounce Scan。 Nmap会告诉您主机是否容易受到攻击。如果您只是试图掩盖您的曲目，您不需要（事实上，不应该）限制目标网络上的主机。在为易受攻击的FTP服务器扫描随机Internet地址之前，请考虑系统管理员可能不会允许这样滥用其服务器。</p>
<h3 id=usage-6>usage</h3>
<p>Nmap 扫描方式：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nmap -p 22,25,135 -Pn -v -b XXX.YY.111.2 scanme.nmap.org

Starting Nmap <span class=o>(</span> http://nmap.org <span class=o>)</span>
Attempting connection to ftp://anonymous:-wwwuser@@XXX.YY.111.2:21
Connected:220 JD FTP Server Ready
Login credentials accepted by ftp server!
Initiating TCP ftp bounce scan against scanme.nmap.org <span class=o>(</span>64.13.134.52<span class=o>)</span>
Adding open port 22/tcp
Adding open port 25/tcp
Scanned <span class=m>3</span> ports in <span class=m>12</span> seconds via the Bounce scan.
Nmap scan report <span class=k>for</span> scanme.nmap.org <span class=o>(</span>64.13.134.52<span class=o>)</span>
PORT    STATE    SERVICE
22/tcp  open     ssh
25/tcp  open     smtp
135/tcp filtered msrpc

Nmap <span class=k>done</span>: <span class=m>1</span> IP address <span class=o>(</span><span class=m>1</span> host up<span class=o>)</span> scanned in 21.79 seconds
</code></pre></div><h1 id=udp>UDP</h1>
<p>在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。</p>
<p>UDP适用于不需要或在程序中执行错误检查和纠正的应用，它避免了协议栈中此类处理的开销。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取。</p>
<h2 id=udp-scan>UDP SCAN</h2>
<p>UDP扫描比较简单，一般如果返回<code>ICMP port unreachable</code>说明端口是关闭的，而如果没有回应或有回应(有些UDP服务是有回应的但不常见)则认为是<code>open</code>，但由于UDP的不可靠性，无法判断报文段是丢了还是没有回应，所以一般扫描器会发送多次，然后根据结果再判断。这也是为什么UDP扫描这么慢的原因。</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170208.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170208.png loading=lazy>
</a>
</figure></p>
<p>虽然因特网上最流行的服务运行在TCP协议上，但UDP服务被广泛部署。 DNS，SNMP和DHCP（注册端口53,161 / 162和67/68）是最常见的三种。 由于UDP扫描通常比TCP更慢且更困难，因此某些安全审核员会忽略这些端口。 这是一个错误，因为可利用的UDP服务非常普遍，攻击者肯定不会忽略整个协议。</p>
<p>UDP扫描通过向每个目标端口发送UDP数据包来工作。 对于大多数端口，此数据包将为空（无有效负载），但对于一些更常见的端口，将发送特定于协议的有效负载。 根据响应或缺少响应，端口被分配给四种状态之一，如下表所示：</p>
<p>Nmap 对 UDP Scan 的处理：</p>
<table>
<thead>
<tr>
<th>Probe Response</th>
<th>Assigned State</th>
</tr>
</thead>
<tbody>
<tr>
<td>Any UDP response from target port (unusual)</td>
<td><code>open</code></td>
</tr>
<tr>
<td>No response received (even after retransmissions)</td>
<td><code>open or filtered</code></td>
</tr>
<tr>
<td>ICMP port unreachable error (type 3, code 3)</td>
<td><code>closed</code></td>
</tr>
<tr>
<td>Other ICMP unreachable errors (type 3, code 1, 2, 9, 10, or 13)</td>
<td><code>filtered</code></td>
</tr>
</tbody>
</table>
<h3 id=usage-7>usage</h3>
<p>Nmap 选项参数：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nmap -sU scanme.nmap.org
</code></pre></div><p>Nmap 有很多选项可以提升 UDP Scan 的准确性与速度，这里不再深入讲解，具体可以参考<a class=link href=https://nmap.org/book/scan-methods-udp-scan.html target=_blank rel=noopener>UDP Scan (-sU)</a></p>
<h1 id=icmp>ICMP</h1>
<p>ICMP 格式：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170742.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170742.png loading=lazy>
</a>
</figure></p>
<blockquote>
<p>​ 根据网络协议，如果按照协议出现了错误，那么接收端将产生一个icmp的错误报文。这些错误报文并不是主动发送的，而是由于错误，根据协议自动产生。</p>
</blockquote>
<p>ICMP 相关类型解释：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605164952.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605164952.png loading=lazy>
</a>
</figure></p>
<p>一般如果数据包被防火墙过滤的话，会收到一个 ICMP 数据包，其中类型为3，代码为1，2，3，9，10或13。</p>
<h2 id=icmp-scan>ICMP SCAN</h2>
<p>常见的利用：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170934.png>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190605170934.png loading=lazy>
</a>
</figure></p>
<h1 id=sctp>SCTP</h1>
<p>这里我们简单介绍一下 SCTP 协议。</p>
<blockquote>
<p>流控制传输协议（英语：Stream Control Transmission Protocol，缩写：SCTP）是在2000年由IETF的SIGTRAN工作组定义的一个传输层协议。RFC 4960详细地定义了SCTP，介绍性的文档是RFC 3286。</p>
<p>作为一个传输层协议，SCTP可以理解为和TCP及UDP相类似的。它提供的服务有点像TCP，又同时将UDP的一些优点相结合。是一种提供了可靠、高效、有序的数据传输协议。相比之下TCP是面向字节的，而SCTP是针对成帧的消息。</p>
<p>SCTP主要的贡献是对多重联外线路的支持，一个端点可以由多于一个 IP地址 组成，使得传输可在主机间或网卡间做到透明的网络容错备援。</p>
<p>SCTP最初是被设计用于在IP上传输电话协议（SS7），把 SS7 信令网络的一些可靠特性引入IP。IETF 的这方面的工作称为信令传输 SIGTRAN。</p>
<p>SCTP将数据传给应用层的方式，是将数据视为message（bytes的集合），SCTP的特征是message-oriented，意思就是说它发送的是一串message（每一个message是byte为单位的集合），相对于TCP是以byte为单位，发送的是破碎的流。在SCTP发送端用一个动作提交消息，接收端也是用一个动作取出消息传给对应的应用程序。相较于TCP，是一个流导向的协议，可靠地且有顺序地发送以bytes为单位的流。然而TCP并不允许接收端知道发送端的应用程序调用提交bytes集合的次数。在发送端TCP只是简单的附加更多bytes在queue里等待着送到网络上，而SCTP是将要提交的outband message都保有自己独立的queue。</p>
</blockquote>
<p>简而言之，SCTP是TCP和UDP协议的一种相对较新的替代方案，它结合了TCP和UDP的大多数特性，还增加了多宿主和多流等新功能。它主要用于SS7 / SIGTRAN相关服务，但也有可能用于其他应用程序。</p>
<p>下图是 TCP 与 SCTP 建立连接的对比图：</p>
<p><figure>
<a href=https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609005059.jpg>
<img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master/https://blogpic-1254145318.cos.ap-shanghai.myqcloud.com/20190609005059.jpg loading=lazy>
</a>
</figure></p>
<h2 id=sctp-init-scan>SCTP INIT scan</h2>
<p>SCTP INIT扫描是TCP SYN扫描的SCTP等效物。它可以快速执行，在快速网络上每秒扫描数千个端口，而不受限制性防火墙的限制。与SYN扫描一样，INIT扫描相对不显眼且隐蔽，因为它永远不会完成SCTP关联。它还允许在打开，关闭和过滤状态之间进行清晰，可靠的区分。</p>
<p>此技术通常称为半开扫描，因为您不打开完整的SCTP关联。您发送一个INIT块，就好像您要打开一个真正的关联，然后等待响应。 INIT-ACK块表示端口正在侦听（打开），而ABORT块表示非侦听器。如果在多次重新传输后未收到响应，则将端口标记为已过滤。如果收到ICMP不可达错误（类型3，代码0,1,2,3,9,10或13），则端口也会被标记为已过滤。</p>
<h3 id=usage-8>usage</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nmap -sY ip
</code></pre></div><h2 id=sctp-cookie-echo-scan>SCTP COOKIE ECHO SCAN</h2>
<p>SCTP COOKIE ECHO SCAN 是一种更先进的SCTP扫描。 它利用了SCTP实现应该在开放端口上静默丢弃包含COOKIE ECHO块的数据包这一事实，但如果端口关闭则发送ABORT。 这种扫描类型的优点是端口扫描不像INIT扫描那么明显。 此外，可能存在阻止INIT块的非状态防火墙规则集，但不阻止COOKIE ECHO块。 不要误以为这会使端口扫描不可见; 一个好的IDS也能够检测到SCTP COOKIE ECHO扫描。 缺点是SCTP COOKIE ECHO扫描不能区分打开和过滤的端口，在这两种情况下都会打开状态。</p>
<h3 id=usage-9>usage</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nmap -sZ ip
</code></pre></div><h1 id=ip>IP</h1>
<h2 id=ip-scan>IP Scan</h2>
<p>IP协议扫描允许您确定目标计算机支持哪些IP协议（TCP，ICMP，IGMP等）。这在技术上不是端口扫描，因为它循环通过IP协议号而不是TCP或UDP端口号。然而，它仍然使用<code>-p</code>选项来选择扫描的协议号，以正常的端口表格式报告其结果，甚至使用与真正的端口扫描方法相同的底层扫描引擎。所以它足够接近它所属的端口扫描。</p>
<p>协议扫描的工作方式与UDP扫描类似。它不是遍历UDP数据包的端口号字段，而是发送IP数据包标头并迭代通过8位IP协议字段。标头通常是空的，不包含任何数据，甚至不包括所声明协议的正确标头。某些流行协议（包括TCP，UDP和ICMP）例外。包含适当的协议头，因为一些系统不会发送它们，因为Nmap已经具有创建它们的功能。协议扫描不是在观察ICMP端口不可达消息，而是在寻找ICMP协议不可达消息。如下表显示了对IP探测的响应如何映射到端口状态。</p>
<p>Nmap 对 IP Scan 的处理：</p>
<table>
<thead>
<tr>
<th>Probe Response</th>
<th>Assigned State</th>
</tr>
</thead>
<tbody>
<tr>
<td>Any response in any protocol from target host</td>
<td><code>open</code> (for protocol used by response, not necessarily probe protocol)</td>
</tr>
<tr>
<td>ICMP protocol unreachable error (type 3, code 2)</td>
<td><code>closed</code></td>
</tr>
<tr>
<td>Other ICMP unreachable errors (type 3, code 1, 3, 9, 10, or 13)</td>
<td><code>filtered</code> (though they prove ICMP is open if sent from the target machine)</td>
</tr>
<tr>
<td>No response received (even after retransmissions)</td>
<td><code>open or filtered</code></td>
</tr>
</tbody>
</table>
<p>与TCP或UDP协议中的开放端口一样，每个开放协议都是潜在的利用向量。此外，协议扫描结果有助于确定机器的用途以及采用何种类型的数据包过滤。终端主机通常只有TCP，UDP，ICMP和（有时）IGMP打开，而路由器通常提供更多，包括路由相关协议，如GRE和EGP。防火墙和VPN网关可能会显示与加密相关的协议，如IPsec和SWIPE。</p>
<p>与UDP扫描期间收到的ICMP端口不可达消息一样，ICMP协议不可达消息通常是速率限制的。例如，默认Linux 2.4.20框中每秒发送的ICMP目标无法访问响应不超过一个。由于只有256个可能的协议号，因此与65,536端口UDP扫描相比，这不是问题。</p>
<h3 id=usage-10>usage</h3>
<p>协议扫描的使用方法与命令行上的大多数其他扫描技术的使用方法相同。除了一般的Nmap选项外，请简单指定<code>-sO</code>。普通端口<code>-p</code>选项用于选择协议号。或者，您可以使用<code>-F</code>扫描nmap-protocols数据库中列出的所有协议。默认情况下，Nmap扫描所有256个可能的值。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>nmap -sO 62.233.173.90 para

Starting Nmap <span class=o>(</span> http://nmap.org <span class=o>)</span>
Nmap scan report <span class=k>for</span> ntwklan-62-233-173-90.devs.futuro.pl <span class=o>(</span>62.233.173.90<span class=o>)</span>
Not shown: <span class=m>240</span> closed ports
PROTOCOL STATE         SERVICE
<span class=m>1</span>        open          icmp                    
<span class=m>4</span>        open<span class=p>|</span>filtered ip                      
<span class=m>6</span>        open          tcp                     
<span class=m>8</span>        open<span class=p>|</span>filtered egp                     
<span class=m>9</span>        open<span class=p>|</span>filtered igp                     
<span class=m>17</span>       filtered      udp                     
<span class=m>47</span>       open<span class=p>|</span>filtered gre                     
<span class=m>53</span>       filtered      swipe                   
<span class=m>54</span>       open<span class=p>|</span>filtered narp                    
<span class=m>55</span>       filtered      mobile                  
<span class=m>77</span>       filtered      sun-nd                  
<span class=m>80</span>       open<span class=p>|</span>filtered iso-ip                  
<span class=m>88</span>       open<span class=p>|</span>filtered eigrp                   
<span class=m>89</span>       open<span class=p>|</span>filtered ospfigp                 
<span class=m>94</span>       open<span class=p>|</span>filtered ipip                    
<span class=m>103</span>      filtered      pim                     

Nmap scan report <span class=k>for</span> para <span class=o>(</span>192.168.10.191<span class=o>)</span>
Not shown: <span class=m>252</span> closed ports
PROTOCOL STATE         SERVICE
<span class=m>1</span>        open          icmp                    
<span class=m>2</span>        open<span class=p>|</span>filtered igmp                    
<span class=m>6</span>        open          tcp                     
<span class=m>17</span>       filtered      udp                     
MAC Address: 00:60:1D:38:32:90 <span class=o>(</span>Lucent Technologies<span class=o>)</span>

Nmap <span class=k>done</span>: <span class=m>2</span> IP addresses <span class=o>(</span><span class=m>2</span> hosts up<span class=o>)</span> scanned in 458.04 seconds
</code></pre></div><h1 id=reference>Reference</h1>
<p><a class=link href=https://hellohxk.com/blog/scanning-principle/ target=_blank rel=noopener>扫描器原理总结</a></p>
<p><a class=link href=https://xiaix.me/duan-kou-sao-miao-yuan-li-ji-shi-xian/ target=_blank rel=noopener>端口扫描原理及实现</a></p>
<p><a class=link href=https://nmap.org/book/scan-methods.html target=_blank rel=noopener>Nmap Docs- Chapter 5. Port Scanning Techniques and Algorithms</a></p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/Sec/>Sec</a>
<a href=/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/>端口扫描</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
<div class="notice notice-tip">
<div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div>
<p>I am looking for some guys who have a strong interest in CTFs to build a team focused on international CTFs that are on the ctftime.org, if anyone is interested in this idea you can take a look at here: <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>Advertisements</a></p><br>
<p>想了解更多有意思的国际赛 CTF 中 Web 知识技巧，欢迎加入我的 <a class=link href=https://blog.zeddyu.info/advertisement/#%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83 target=_blank rel=noopener>知识星球</a> ; 另外我正在召集一群小伙伴组建一支专注国际 CTF 的队伍，如果有感兴趣的小伙伴也可在 <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>International CTF Team</a> 查看详情</p><br>
</div>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/2021/04/20/tls-poison/>
<div class=article-details>
<h2 class=article-title>一篇文章带你读懂 TLS Poison 攻击</h2>
</div>
</a>
</article>
<article>
<a href=/2019/12/08/HTTP-Smuggling-en/>
<div class=article-details>
<h2 class=article-title>Help you understand HTTP Smuggling in one article</h2>
</div>
</a>
</article>
<article>
<a href=/2019/12/05/HTTP-Smuggling/>
<div class=article-details>
<h2 class=article-title>一篇文章带你读懂 HTTP Smuggling 攻击</h2>
</div>
</a>
</article>
<article>
<a href=/2019/06/07/LFI2RCE/>
<div class=article-details>
<h2 class=article-title>LFI2RCE</h2>
</div>
</a>
</article>
<article>
<a href=/2019/04/11/PHP%E5%A4%8D%E6%9D%82%E5%8F%98%E9%87%8F/>
<div class=article-details>
<h2 class=article-title>从一道题讲PHP复杂变量</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div class=disqus-container>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//ZeddYu.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style>
<script>window.addEventListener('onColorSchemeChange',a=>{DISQUS&&DISQUS.reset({reload:!0})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2018 -
2021 Zeddy's Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#tcp-connect-scan>TCP CONNECT SCAN</a>
<ol>
<li><a href=#usage>usage</a></li>
</ol>
</li>
<li><a href=#tcp-syn-scan>TCP SYN SCAN</a>
<ol>
<li><a href=#usage-1>usage</a></li>
</ol>
</li>
<li><a href=#tcp-xmas-tree-scan>TCP Xmas Tree SCAN</a>
<ol>
<li><a href=#usage-2>usage</a></li>
</ol>
</li>
<li><a href=#tcp-null-scan>TCP NULL SCAN</a></li>
<li><a href=#tcp-ack-scan>TCP ACK SCAN</a>
<ol>
<li><a href=#usage-3>usage</a></li>
</ol>
</li>
<li><a href=#tcp-window-scan>TCP WINDOW SCAN</a>
<ol>
<li><a href=#usage-4>usage</a></li>
</ol>
</li>
<li><a href=#tcp-idle-scan>TCP Idle Scan</a>
<ol>
<li><a href=#idle-scan-step-by-step>Idle Scan Step by Step</a></li>
</ol>
</li>
<li><a href=#tcp-maimon-scan>TCP Maimon Scan</a>
<ol>
<li><a href=#usage-5>usage</a></li>
</ol>
</li>
<li><a href=#tcp-ftp-bounce-scan>TCP FTP Bounce Scan</a>
<ol>
<li><a href=#usage-6>usage</a></li>
</ol>
</li>
</ol>
<ol>
<li><a href=#udp-scan>UDP SCAN</a>
<ol>
<li><a href=#usage-7>usage</a></li>
</ol>
</li>
</ol>
<ol>
<li><a href=#icmp-scan>ICMP SCAN</a></li>
</ol>
<ol>
<li><a href=#sctp-init-scan>SCTP INIT scan</a>
<ol>
<li><a href=#usage-8>usage</a></li>
</ol>
</li>
<li><a href=#sctp-cookie-echo-scan>SCTP COOKIE ECHO SCAN</a>
<ol>
<li><a href=#usage-9>usage</a></li>
</ol>
</li>
</ol>
<ol>
<li><a href=#ip-scan>IP Scan</a>
<ol>
<li><a href=#usage-10>usage</a></li>
</ol>
</li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//ts/main.js defer></script>
<script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>