<!doctype html><html lang=en-us>
<head><meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<link rel=manifest href=/manifest.json><meta name=description content="上周参与了 hxp CTF ，其中有两个 PHP Web 题目令人印象深刻，也产生了一种让我拍手称快的、对我来说算是新的 LFI 方法，这里就将本次比赛题目分析写一下。当然我不确定这个是不是新方法，若有错误，希望各位师傅们斧正，多多海涵
"><title>hxp CTF 2021 - A New Novel LFI</title>
<link rel=canonical href=https://blog.zeddyu.info/2021/12/27/2021-12-20-ANewNovelLFI/>
<link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="hxp CTF 2021 - A New Novel LFI">
<meta property="og:description" content="上周参与了 hxp CTF ，其中有两个 PHP Web 题目令人印象深刻，也产生了一种让我拍手称快的、对我来说算是新的 LFI 方法，这里就将本次比赛题目分析写一下。当然我不确定这个是不是新方法，若有错误，希望各位师傅们斧正，多多海涵
">
<meta property="og:url" content="https://blog.zeddyu.info/2021/12/27/2021-12-20-ANewNovelLFI/">
<meta property="og:site_name" content="Zeddy's Blog">
<meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="CTF"><meta property="article:published_time" content="2021-12-27T15:32:24+08:00"><meta property="article:modified_time" content="2021-12-27T15:32:24+08:00">
<meta name=twitter:site content="@ZeddYu_Lu">
<meta name=twitter:creator content="@ZeddYu_Lu"><meta name=twitter:title content="hxp CTF 2021 - A New Novel LFI">
<meta name=twitter:description content="上周参与了 hxp CTF ，其中有两个 PHP Web 题目令人印象深刻，也产生了一种让我拍手称快的、对我来说算是新的 LFI 方法，这里就将本次比赛题目分析写一下。当然我不确定这个是不是新方法，若有错误，希望各位师傅们斧正，多多海涵
">
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-112937997-1','auto'),ga('send','pageview'))</script>
</head>
<body class="article-page has-toc">
<script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script>
<div class="container main-container flex
extended">
<div id=article-toolbar>
<a href=https://blog.zeddyu.info class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg>
<span>Back</span>
</a>
</div>
<main class="main full-width">
<article class=main-article>
<header class=article-header>
<div class=article-details>
<header class=article-category>
<a href=/categories/CTF/ style=background-color:#ce0000;color:#fff>
CTF
</a>
</header>
<h2 class=article-title>
<a href=/2021/12/27/2021-12-20-ANewNovelLFI/>hxp CTF 2021 - A New Novel LFI</a>
</h2>
<footer class=article-time>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 27, 2021</time>
</div>
<div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>
13 minute read
</time>
</div>
</footer>
</div>
</header>
<section class=article-content>
<p>上周参与了 hxp CTF ，其中有两个 PHP Web 题目令人印象深刻，也产生了一种让我拍手称快的、对我来说算是新的 LFI 方法，这里就将本次比赛题目分析写一下。当然我不确定这个是不是新方法，若有错误，希望各位师傅们斧正，多多海涵</p>
<div class="notice notice-tip">
<div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>文章首发于跳跳堂：<a href=https://tttang.com/archive/1384/>hxp CTF 2021 - A New Novel LFI</a></p></div>
<h2 id=tldr>TL;DR</h2>
<ul>
<li>Nginx 在后端 Fastcgi 响应过大 或 请求正文 body 过大时会产生临时文件</li>
<li>通过多重链接绕过 PHP LFI stat 限制完成 LFI</li>
</ul>
<p>本文主要介绍 hxp CTF 2021 中的两种新的 LFI 方法，第一部分主要介绍第一种方法，主要分析 Nginx 部分源码；第二部分简略介绍第二种方法。</p>
<h2 id=includers-revenge---nginx-fastcgi-temp-lfi>Includer&rsquo;s revenge - Nginx Fastcgi Temp LFI</h2>
<p>附件地址：https://2021.ctf.link/assets/files/includer&rsquo;s%20revenge-25377e1ebb23d014.tar.xz</p>
<p>题目代码比较简单：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=o>&lt;?</span><span class=nx>php</span> 
<span class=p>(</span><span class=nv>$_GET</span><span class=p>[</span><span class=s1>&#39;action&#39;</span><span class=p>]</span> <span class=o>??</span> <span class=s1>&#39;read&#39;</span> <span class=p>)</span> <span class=o>===</span> <span class=s1>&#39;read&#39;</span> <span class=o>?</span> <span class=nx>readfile</span><span class=p>(</span><span class=nv>$_GET</span><span class=p>[</span><span class=s1>&#39;file&#39;</span><span class=p>]</span> <span class=o>??</span> <span class=s1>&#39;index.php&#39;</span><span class=p>)</span> <span class=o>:</span> <span class=k>include_once</span><span class=p>(</span><span class=nv>$_GET</span><span class=p>[</span><span class=s1>&#39;file&#39;</span><span class=p>]</span> <span class=o>??</span> <span class=s1>&#39;index.php&#39;</span><span class=p>);</span>
</code></pre></div><p>可以说是 onelinephp 了，当然如果光看这些代码，我们可以直接用 36c3 hxp CTF includer 的解法解掉，用 <code>compress.zip://http://</code> 产生临时文件，包含即可，具体可以看看我之前写的 writeup ：<a class=link href=https://blog.zeddyu.info/2020/01/08/36c3-web/#includer target=_blank rel=noopener>36c3 学习记录#inlcuder</a></p>
<p>当然这里既然标了 revenge 肯定说明有一些不同的地方，结合题目给我们的附件，我们可以发现相对上一次 includer 题目有了比较大区别，主要在 Dockerfile 里面：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=k>RUN</span> chown -R root:root /var/www <span class=o>&amp;&amp;</span> <span class=se>\
</span><span class=se></span>    find /var/www -type d -exec chmod <span class=m>555</span> <span class=o>{}</span> <span class=se>\;</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span><span class=se></span>    find /var/www -type f -exec chmod <span class=m>444</span> <span class=o>{}</span> <span class=se>\;</span> <span class=o>&amp;&amp;</span> <span class=se>\
</span><span class=se></span>    chown -R root:root /tmp /var/tmp /var/lib/php/sessions <span class=o>&amp;&amp;</span> <span class=se>\
</span><span class=se></span>    chmod -R <span class=m>000</span> /tmp /var/tmp /var/lib/php/sessions<span class=err>
</span></code></pre></div><p>出题人这里竟然狠心把 php tmp 目录以及一些临时目录都弄得不可写了，所以导致之前题目的产生临时文件的方法就失效了。</p>
<p>所以很明显，我们需要找到另一个产生临时文件，将其包含的方法。</p>
<h3 id=how-to-produce-tmp-files>How To Produce Tmp Files</h3>
<p>由于之前我觉得 36c3 includer 那个题出的真是令我很赞叹，在某些比赛出题的时候，我也考虑过 php 是不是可以有其他产生临时文件的方法，所以自己也去看了一段时间 php 源码，其产生临时文件主要是通过 <code>php_stream_fopen_tmpfile</code> 这个函数，然而这个函数调用都没几处，所以之前我太菜了就没有挖到了，所以根据我之前的经验，在这里可能并不是 php 的原因。</p>
<p>所以我并没有过多纠结 php 的问题，在 Dockerfile 中我注意到出题人有一行可能类似于 Tip 的操作</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-dockerfile data-lang=dockerfile><span class=k>RUN</span> ! find / -writable -or -user <span class=k>$(</span>id -un<span class=k>)</span> -or -group <span class=k>$(</span>id -Gn<span class=p>|</span>sed -e <span class=s1>&#39;s/ / -or -group /g&#39;</span><span class=k>)</span> 2&gt; /dev/null <span class=p>|</span> grep -Ev -m <span class=m>1</span> <span class=err>&#39;</span>^<span class=o>(</span>/dev/<span class=p>|</span>/run/<span class=p>|</span>/proc/<span class=p>|</span>/sys/<span class=p>|</span>/var/lock<span class=p>|</span>/var/log/nginx/error.log<span class=p>|</span>/var/log/nginx/access.log<span class=o>)</span><span class=err>
</span></code></pre></div><p>既然我们要找一个 www-data 用户可写的地方，我们可以参考这个命令把系统中所有的都找出来，看看有没有什么猫腻：</p>
<pre tabindex=0><code>/dev/core
/dev/stderr
/dev/stdout
/dev/stdin
/dev/fd
/dev/ptmx
/dev/urandom
/dev/zero
/dev/tty
/dev/full
/dev/random
/dev/null
/dev/shm
/dev/mqueue
/dev/pts/1
/dev/pts/ptmx
/run/lock
/run/php
/run/php/php7.4-fpm.sock
/run/php/php7.4-fpm.pid
/proc/keys
/proc/kcore
/proc/timer_list
/proc/sched_debug
/var/lock
/var/lib/nginx/scgi
/var/lib/nginx/body
/var/lib/nginx/uwsgi
/var/lib/nginx/proxy
/var/lib/nginx/fastcgi
/var/log/nginx/access.log
/var/log/nginx/error.log
</code></pre><p>以上我略去了很多 <code>/proc/xxxx</code> ，所以挨个看下来，很明显，似乎后面 nginx 的可能就是我们要的答案，我们可以在网络上搜索一下相关目录用来干嘛的，最后发现 <code>/var/lib/nginx/fastcgi</code> 目录是 Nginx 的 <code>http-fastcgi-temp-path</code> ，看到 temp 这里就感觉很有意思了，意味着我们可能通过 Nginx 来产生一些文件，并且通过一些搜索我们知道这些临时文件格式是: <code>/var/lib/nginx/fastcgi/x/y/0000000yx</code></p>
<p>那这临时文件用来干嘛呢？通过阅读 Nginx 文档 <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffering target=_blank rel=noopener>fastcgi_buffering 部分</a>：</p>
<blockquote>
<table>
<thead>
<tr>
<th style=text-align:left>Syntax:</th>
<th><code>fastcgi_buffering on | off;</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Default:</td>
<td><code>fastcgi_buffering on;</code></td>
</tr>
<tr>
<td style=text-align:left>Context:</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
</tbody>
</table>
<p>This directive appeared in version 1.5.6.</p>
<p>Enables or disables buffering of responses from the FastCGI server.</p>
<p>When buffering is enabled, nginx receives a response from the FastCGI server as soon as possible, saving it into the buffers set by the <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffer_size target=_blank rel=noopener>fastcgi_buffer_size</a> and <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffers target=_blank rel=noopener>fastcgi_buffers</a> directives. If the whole response does not fit into memory, a part of it can be saved to a <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_temp_path target=_blank rel=noopener>temporary file</a> on the disk. Writing to temporary files is controlled by the <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_max_temp_file_size target=_blank rel=noopener>fastcgi_max_temp_file_size</a> and <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_temp_file_write_size target=_blank rel=noopener>fastcgi_temp_file_write_size</a> directives.</p>
<p>When buffering is disabled, the response is passed to a client synchronously, immediately as it is received. nginx will not try to read the whole response from the FastCGI server. The maximum size of the data that nginx can receive from the server at a time is set by the <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_buffer_size target=_blank rel=noopener>fastcgi_buffer_size</a> directive.</p>
<p>Buffering can also be enabled or disabled by passing “<code>yes</code>” or “<code>no</code>” in the “X-Accel-Buffering” response header field. This capability can be disabled using the <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_ignore_headers target=_blank rel=noopener>fastcgi_ignore_headers</a> directive.</p>
</blockquote>
<p>我们大致可以知道当 Nginx 接收来自 FastCGI 的响应时，若大小超过限定值不适合以内存的形式来存储的时候，一部分就会以临时文件的方式保存到磁盘上。</p>
<p>再通过一些资料了解<sup><a class=link href=#ref01>[1]</a></sup><sup><a class=link href=#ref02>[2]</a></sup>，这个阈值的大小大概在 32KB 左右，并且又根据 <a class=link href=https://0xstubs.org/risks-of-nginx-fastcgi-buffering-or-how-itunes-can-mess-with-your-nextcloud-server/ target=_blank rel=noopener>Risks of nginx fastcgi buffering or, how iTunes can mess with your Nextcloud server</a> 文章我们可以知道 Nginx 确实可以在 <code>/var/lib/nginx/fastcgi</code> 下产生临时文件。</p>
<p>那么接下来我们只需要简单验证一下，并看一下临时文件内容是什么。我这里简单使用了 python 产生了一个有顺序内容的 tmp 文件：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>with</span> <span class=nb>open</span><span class=p>(</span><span class=s2>&#34;tmp&#34;</span><span class=p>)</span> <span class=k>as</span> <span class=n>file</span><span class=p>:</span>
  <span class=k>for</span> <span class=n>i</span> <span class=ow>in</span> <span class=nb>range</span><span class=p>(</span><span class=mi>500000</span><span class=p>):</span>
    <span class=n>file</span><span class=o>.</span><span class=n>write</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>%5s</span><span class=s2>&#34;</span> <span class=o>%</span> <span class=nb>str</span><span class=p>(</span><span class=n>i</span><span class=p>))</span>
</code></pre></div><p>尝试测试，发现虽然产生了文件夹，但是没有文件，于是我加上了 inotify 监控一下文件行动，并且可以使用 <code>strace</code> 进一步确认：</p>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/9055388f-ef61-4628-b036-48b0ab7d3e3b.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/9055388f-ef61-4628-b036-48b0ab7d3e3b.png loading=lazy>
</a>
</figure></p>
<p>我们可以从 inotify 中看到，几乎 Nginx 是创建完文件就立即删除了，但是我们可以基本确认 Nginx 确实可以产生临时文件，只不过创建就被删除了导致我们无法判断文件内容到底是啥。</p>
<p>同时我们可以发现 Niginx 创建临时文件有所规律，为了检查文件内容，我们可以计算出下一次 Nginx 产生临时文件的位置，再对其上级目录使用 <code>chattr +a </code> 临时禁止临时文件删除，这样我们就可以看到文件内容了：</p>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/efc3ed0c-eba9-4761-8108-7b7e39d2d368.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/efc3ed0c-eba9-4761-8108-7b7e39d2d368.png loading=lazy>
</a>
</figure></p>
<p>可以看到临时文件内容就是我们远程 vps 上放的 tmp 文件内容的一部分。</p>
<h3 id=how-nginx-produce-tmp-files>How Nginx Produce Tmp Files</h3>
<p>接着问题来了：为什么 Nginx 创建文件就立即删除了？有没有窗口期？能不能使用竞争包含呢？</p>
<p>为了弄懂这些问题，便只能直接看 Nginx 源码了，于是直接参考一些 debug 教程弄一个 debug 环境起来即可。</p>
<p>Nginx 关于临时文件的地方并不多，不难找到 <code>ngx_open_tempfile</code>这个函数：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=n>ngx_fd_t</span>
<span class=nf>ngx_open_tempfile</span><span class=p>(</span><span class=n>u_char</span> <span class=o>*</span><span class=n>name</span><span class=p>,</span> <span class=n>ngx_uint_t</span> <span class=n>persistent</span><span class=p>,</span> <span class=n>ngx_uint_t</span> <span class=n>access</span><span class=p>)</span>
<span class=p>{</span>
    <span class=n>ngx_fd_t</span>  <span class=n>fd</span><span class=p>;</span>

    <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>((</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>name</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=o>|</span><span class=n>O_EXCL</span><span class=o>|</span><span class=n>O_RDWR</span><span class=p>,</span>
              <span class=n>access</span> <span class=o>?</span> <span class=nl>access</span> <span class=p>:</span> <span class=mo>0600</span><span class=p>);</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>fd</span> <span class=o>!=</span> <span class=o>-</span><span class=mi>1</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>persistent</span><span class=p>)</span> <span class=p>{</span>
        <span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=n>unlink</span><span class=p>((</span><span class=k>const</span> <span class=kt>char</span> <span class=o>*</span><span class=p>)</span> <span class=n>name</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=k>return</span> <span class=n>fd</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>Fastcgi 产生临时文件时候的调用栈：</p>
<pre tabindex=0><code>ngx_create_temp_file(ngx_file_t * file, ngx_path_t * path, ngx_pool_t * pool, ngx_uint_t persistent, ngx_uint_t clean, ngx_uint_t access) (/home/zeddy/Desktop/nginx-1.18.0/src/core/ngx_file.c:143)
ngx_write_chain_to_temp_file(ngx_temp_file_t * tf, ngx_chain_t * chain) (/home/zeddy/Desktop/nginx-1.18.0/src/core/ngx_file.c:114)
ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t * p) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event_pipe.c:843)
ngx_event_pipe_read_upstream(ngx_event_pipe_t * p) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event_pipe.c:277)
ngx_event_pipe(ngx_event_pipe_t * p, ngx_int_t do_write) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event_pipe.c:49)
ngx_http_upstream_process_upstream(ngx_http_request_t * r, ngx_http_upstream_t * u) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_upstream.c:3944)
ngx_http_upstream_handler(ngx_event_t * ev) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_upstream.c:1286)
ngx_epoll_process_events(ngx_cycle_t * cycle, ngx_msec_t timer, ngx_uint_t flags) (/home/zeddy/Desktop/nginx-1.18.0/src/event/modules/ngx_epoll_module.c:901)
ngx_process_events_and_timers(ngx_cycle_t * cycle) (/home/zeddy/Desktop/nginx-1.18.0/src/event/ngx_event.c:247)
ngx_single_process_cycle(ngx_cycle_t * cycle) (/home/zeddy/Desktop/nginx-1.18.0/src/os/unix/ngx_process_cycle.c:310)
main(int argc, char * const * argv) (/home/zeddy/Desktop/nginx-1.18.0/src/core/nginx.c:379)
</code></pre><p>我们从中可以知道如果要让 Nginx 保存临时文件，得满足一个 if 条件，然而我们仔细看该条件，由于是<strong>与</strong>条件，我们可以知道得同时满足才能进入该 if 条件，我们分析一下该 if 条件</p>
<ul>
<li><code>fd != -1</code> : <code>fd</code>是 <code>open</code> 函数的返回值，我们可以知道只有当 <code>open</code> 函数打开失败的时候才会返回 -1 ，也就是该临时文件不存在的情况下，换句话说就是只要临时文件被 <code>open</code> 函数成功打开，这个条件就是成立的</li>
<li><code>persistent</code>: 该条件从函数上下文我们看不出来有什么关系，需要更进一步分析，通过分析代码，我们可以发现该变量主要在以下三个地方可能被赋值为 1 ：
<ul>
<li>一个地方是 src/http/ngx_http_request_body.c#456 处：<code>tf->persistent = r->request_body_in_persistent_file;</code></li>
<li>另一个地方是 src/http/ngx_http_upstream.c#4087 处: <code>tf->persistent = 1;</code></li>
<li>还有一个地方是 src/http/ngx_http_upstream.c#3144 处: <code>p->temp_file->persistent = 1;</code></li>
</ul>
</li>
</ul>
<p>我们分别对这几个地方进行详细分析及跟进。</p>
<h4 id=client_body_in_file_only>client_body_in_file_only</h4>
<p>第一个地方是 src/http/ngx_http_request_body.c#456 处：<code>tf->persistent = r->request_body_in_persistent_file;</code>，继续跟进 <code>request_body_in_persistent_file</code> 成员变量，找到其赋值的地方为 src/http/ngx_http_core_module.c#1315 中的 <code>ngx_http_update_location_config</code> 函数当中。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>if</span> <span class=p>(</span><span class=n>clcf</span><span class=o>-&gt;</span><span class=n>client_body_in_file_only</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>r</span><span class=o>-&gt;</span><span class=n>request_body_in_file_only</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>r</span><span class=o>-&gt;</span><span class=n>request_body_in_persistent_file</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=n>r</span><span class=o>-&gt;</span><span class=n>request_body_in_clean_file</span> <span class=o>=</span>
        <span class=n>clcf</span><span class=o>-&gt;</span><span class=n>client_body_in_file_only</span> <span class=o>==</span> <span class=n>NGX_HTTP_REQUEST_BODY_FILE_CLEAN</span><span class=p>;</span>
    <span class=n>r</span><span class=o>-&gt;</span><span class=n>request_body_file_log_level</span> <span class=o>=</span> <span class=n>NGX_LOG_NOTICE</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>此处我们可以根据上下文判断出该处主要是用于判断是否开启 <a class=link href=http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_in_file_only target=_blank rel=noopener>client_body_in_file_only</a> 选项，根据文档我们可以知道：</p>
<blockquote>
<table>
<thead>
<tr>
<th style=text-align:left>Syntax:</th>
<th><strong>client_body_in_file_only</strong> on | clean | off;</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Default:</td>
<td><code>client_body_in_file_only off;</code></td>
</tr>
<tr>
<td style=text-align:left>Context:</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
</tbody>
</table>
<p>Determines whether nginx should save the entire client request body into a file. This directive can be used during debugging, or when using the <code>$request_body_file</code> variable, or the <a class=link href=http://nginx.org/en/docs/http/ngx_http_perl_module.html#methods target=_blank rel=noopener>$r->request_body_file</a> method of the module <a class=link href=http://nginx.org/en/docs/http/ngx_http_perl_module.html target=_blank rel=noopener>ngx_http_perl_module</a>.</p>
<p>When set to the value <code>on</code>, temporary files are not removed after request processing.</p>
<p>The value <code>clean</code> will cause the temporary files left after request processing to be removed.</p>
</blockquote>
<p>在该选项开启后，Nginx 对于请求的 body 内容会以临时文件的形式存储起来，但是默认为 off ，题目并没有开启，所以这里不用考虑。</p>
<h4 id=fastcgi_store>fastcgi_store</h4>
<p>另一个地方是 src/http/ngx_http_upstream.c#4087 处：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>void</span>
<span class=nf>ngx_http_upstream_store</span><span class=p>(</span><span class=n>ngx_http_request_t</span> <span class=o>*</span><span class=n>r</span><span class=p>,</span> <span class=n>ngx_http_upstream_t</span> <span class=o>*</span><span class=n>u</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>//...
</span><span class=c1></span>    <span class=n>tf</span> <span class=o>=</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>temp_file</span><span class=p>;</span>

    <span class=k>if</span> <span class=p>(</span><span class=n>tf</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>.</span><span class=n>fd</span> <span class=o>==</span> <span class=n>NGX_INVALID_FILE</span><span class=p>)</span> <span class=p>{</span>

        <span class=cm>/* create file for empty 200 response */</span>

        <span class=n>tf</span> <span class=o>=</span> <span class=n>ngx_pcalloc</span><span class=p>(</span><span class=n>r</span><span class=o>-&gt;</span><span class=n>pool</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ngx_temp_file_t</span><span class=p>));</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>tf</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
            <span class=k>return</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>tf</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>NGX_INVALID_FILE</span><span class=p>;</span>
        <span class=n>tf</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>.</span><span class=n>log</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>connection</span><span class=o>-&gt;</span><span class=n>log</span><span class=p>;</span>
        <span class=n>tf</span><span class=o>-&gt;</span><span class=n>path</span> <span class=o>=</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>conf</span><span class=o>-&gt;</span><span class=n>temp_path</span><span class=p>;</span>
        <span class=n>tf</span><span class=o>-&gt;</span><span class=n>pool</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>pool</span><span class=p>;</span>
        <span class=n>tf</span><span class=o>-&gt;</span><span class=n>persistent</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>

        <span class=k>if</span> <span class=p>(</span><span class=n>ngx_create_temp_file</span><span class=p>(</span><span class=o>&amp;</span><span class=n>tf</span><span class=o>-&gt;</span><span class=n>file</span><span class=p>,</span> <span class=n>tf</span><span class=o>-&gt;</span><span class=n>path</span><span class=p>,</span> <span class=n>tf</span><span class=o>-&gt;</span><span class=n>pool</span><span class=p>,</span>
                                 <span class=n>tf</span><span class=o>-&gt;</span><span class=n>persistent</span><span class=p>,</span> <span class=n>tf</span><span class=o>-&gt;</span><span class=n>clean</span><span class=p>,</span> <span class=n>tf</span><span class=o>-&gt;</span><span class=n>access</span><span class=p>)</span>
            <span class=o>!=</span> <span class=n>NGX_OK</span><span class=p>)</span>
        <span class=p>{</span>
            <span class=k>return</span><span class=p>;</span>
        <span class=p>}</span>

        <span class=n>u</span><span class=o>-&gt;</span><span class=n>pipe</span><span class=o>-&gt;</span><span class=n>temp_file</span> <span class=o>=</span> <span class=n>tf</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>//...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>往上找该函数调用：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>peer</span><span class=p>.</span><span class=n>connection</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>store</span><span class=p>)</span> <span class=p>{</span>
        <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>upstream_eof</span> <span class=o>||</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>upstream_done</span><span class=p>)</span> <span class=p>{</span>
            <span class=n>tf</span> <span class=o>=</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>temp_file</span><span class=p>;</span>
            <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>headers_in</span><span class=p>.</span><span class=n>status_n</span> <span class=o>==</span> <span class=n>NGX_HTTP_OK</span>
                <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>upstream_done</span> <span class=o>||</span> <span class=n>p</span><span class=o>-&gt;</span><span class=n>length</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span><span class=p>)</span>
                <span class=o>&amp;&amp;</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>headers_in</span><span class=p>.</span><span class=n>content_length_n</span> <span class=o>==</span> <span class=o>-</span><span class=mi>1</span>
                    <span class=o>||</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>headers_in</span><span class=p>.</span><span class=n>content_length_n</span> <span class=o>==</span> <span class=n>tf</span><span class=o>-&gt;</span><span class=n>offset</span><span class=p>))</span>
            <span class=p>{</span>
                <span class=n>ngx_http_upstream_store</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>u</span><span class=p>);</span>
            <span class=p>}</span>
        <span class=p>}</span>
    <span class=p>}</span>
<span class=c1>//...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>得知此处有几个条件，可能都相对比较苛刻，于是我先看 <code>u->store</code> 成员变量的赋值，找到该成员变量主要是在 src/http/ngx_http_upstream.c# 610 处的 <code>ngx_http_upstream_init_request</code> 函数中得到赋值：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>void</span>
<span class=nf>ngx_http_upstream_init_request</span><span class=p>(</span><span class=n>ngx_http_request_t</span> <span class=o>*</span><span class=n>r</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>//...
</span><span class=c1></span>    <span class=n>u</span> <span class=o>=</span> <span class=n>r</span><span class=o>-&gt;</span><span class=n>upstream</span><span class=p>;</span>
<span class=cp>#if (NGX_HTTP_CACHE)
</span><span class=cp></span>    <span class=k>if</span> <span class=p>(</span><span class=n>u</span><span class=o>-&gt;</span><span class=n>conf</span><span class=o>-&gt;</span><span class=n>cache</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>ngx_int_t</span>  <span class=n>rc</span><span class=p>;</span>
        <span class=n>rc</span> <span class=o>=</span> <span class=n>ngx_http_upstream_cache</span><span class=p>(</span><span class=n>r</span><span class=p>,</span> <span class=n>u</span><span class=p>);</span>
        <span class=c1>//...
</span><span class=c1></span>    <span class=p>}</span>
<span class=cp>#endif
</span><span class=cp></span>    <span class=n>u</span><span class=o>-&gt;</span><span class=n>store</span> <span class=o>=</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>conf</span><span class=o>-&gt;</span><span class=n>store</span><span class=p>;</span>
    <span class=c1>//...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>我们可以根据此处上下文，并且查阅一些相关源码资料知道此处 <code>u->conf->store</code> 来自解析配置 <a class=link href=http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_store target=_blank rel=noopener>fastcgi_store</a></p>
<blockquote>
<table>
<thead>
<tr>
<th style=text-align:left>Syntax:</th>
<th><strong>fastcgi_store</strong> on | off | string;</th>
</tr>
</thead>
<tbody>
<tr>
<td style=text-align:left>Default:</td>
<td><code>fastcgi_store off;</code></td>
</tr>
<tr>
<td style=text-align:left>Context:</td>
<td><code>http</code>, <code>server</code>, <code>location</code></td>
</tr>
</tbody>
</table>
<p>Enables saving of files to a disk. The <code>on</code> parameter saves files with paths corresponding to the directives <a class=link href=http://nginx.org/en/docs/http/ngx_http_core_module.html#alias target=_blank rel=noopener>alias</a> or <a class=link href=http://nginx.org/en/docs/http/ngx_http_core_module.html#root target=_blank rel=noopener>root</a>.</p>
</blockquote>
<p>默认为关闭状态，当我们将这个选项开启为 on 的时候，可以发现我们产生的临时文件最后才消失。因为这个地方需要手动开启，所以在默认情况下我们也很难利用。</p>
<h4 id=cache>cache</h4>
<p>还有一个地方是 src/http/ngx_http_upstream.c#3144 处：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>void</span>
<span class=nf>ngx_http_upstream_send_response</span><span class=p>(</span><span class=n>ngx_http_request_t</span> <span class=o>*</span><span class=n>r</span><span class=p>,</span> <span class=n>ngx_http_upstream_t</span> <span class=o>*</span><span class=n>u</span><span class=p>)</span>
<span class=p>{</span>
    <span class=c1>//...
</span><span class=c1></span>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>cacheable</span> <span class=o>=</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>cacheable</span> <span class=o>||</span> <span class=n>u</span><span class=o>-&gt;</span><span class=n>store</span><span class=p>;</span>
    <span class=c1>//...
</span><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>p</span><span class=o>-&gt;</span><span class=n>cacheable</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>p</span><span class=o>-&gt;</span><span class=n>temp_file</span><span class=o>-&gt;</span><span class=n>persistent</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>
    <span class=c1>//...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>很明显，这个临时文件是作缓存使用的，<code>u->store</code> 上面我们知道了是需要通过配置设置，所以我们接下来，但是我们仍然可以跟一下条件中的 <code>p->cacheable</code> 成员变量，其中只有在 src/http/ngx_http_upstream.c#860 处的 <code>ngx_http_upstream_cache</code> 函数被设置成了 1 ，但是该函数需要开启宏 <code>NGX_HTTP_CACHE</code> ，我们可以在 auto/modules#99 处找到该宏定义</p>
<pre tabindex=0><code>if [ $HTTP_CACHE = YES ]; then
  have=NGX_HTTP_CACHE . auto/have
  HTTP_SRCS=&quot;$HTTP_SRCS $HTTP_FILE_CACHE_SRCS&quot;
fi
</code></pre><p>接着可以在 auto/options 找到 <code>$HTTP_CACHE</code> 的定义默认为 YES ，只有当编译增加选项 <code>--without-http-cache</code> 才会将该宏定义为 FALSE ，也就是说如果正常开启， Nginx 是默认开启这个宏的。</p>
<p>但是该函数还会受到 src/http/ngx_http_upstream.c#569 处的限制 <code>u->conf->cache</code> ，并且通过查看一些文档<sup><a class=link href=#ref03>[3]</a></sup><sup><a class=link href=#ref04>[4]</a></sup> ，发现知道这里的 <code>config->cache</code> 也是与 <code>proxy_cache</code> 配置有关的，查阅文档知道 <a class=link href=http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache target=_blank rel=noopener>proxy_cache</a> 配置选项默认为 off ，所以这里我们也不考虑。</p>
<h3 id=tmp-files-after-deleted>Tmp Files After Deleted</h3>
<p>由于 Nginx 在 <code>ngx_open_tempfile</code> 函数中，创建临时文件后又立马删掉了临时文件，并且从以上源码审计来看，没有很好的方式让 <code>persistent</code> 变量为 1 ，所以在不能修改默认配置的情况下，直接让临时文件保存下来是基本不可能的。</p>
<p>那我们有没有一个时间窗去包含临时文件呢？由于这创建、删除函数间隔非常短，即使有能让 Nginx Crash 的方法，也很难把握这个时间点，基本上也是没有一个时间窗去直接包含的。</p>
<p>但是我在审计的同时，也产生了一个问题：既然 Nginx 将临时文件用于存储 Fastcgi 响应的临时存储，但是为什么创建之后就删除了？为什么删除之后还持续向里面写内容？难不成删除以后的读写操作还仍然有效？？？</p>
<p>我觉得这是从开发角度思考来说，仅通过审计这些代码无法解释以上问题，但是这里如果熟悉 Linux 的同学就能意识到，其实以上这些问题可能都不是问题。</p>
<blockquote>
<p>On <a class=link href=https://en.wikipedia.org/wiki/Linux target=_blank rel=noopener>Linux</a>, the set of file descriptors open in a process can be accessed under the path <code>/proc/PID/fd/</code>, where PID is the <a class=link href=https://en.wikipedia.org/wiki/Process_identifier target=_blank rel=noopener>process identifier</a>.</p>
</blockquote>
<p><strong>众所周知</strong> ( 我应该是全世界最后一个知道的人了吧 )，如果打开一个进程打开了某个文件，某个文件就会出现在 <code>/proc/PID/fd/</code> 目录下，但是如果这个文件在没有被关闭的情况下就被删除了呢？</p>
<p>我们大概可以用 c 简单复刻一个大概的 demo ，使用如下代码模拟 Nginx 对于临时文件处理的行为，但是最后不关闭文件句柄，使用 <code>sleep</code> 模拟进程挂起的状态:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=cp>#include</span> <span class=cpf>&lt;sys/types.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;sys/stat.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;fcntl.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;error.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
    <span class=n>puts</span><span class=p>(</span><span class=s>&#34;[+] test for open/unlink/write [+]</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>fd</span> <span class=o>=</span> <span class=n>open</span><span class=p>(</span><span class=s>&#34;test.txt&#34;</span><span class=p>,</span> <span class=n>O_CREAT</span><span class=o>|</span><span class=n>O_EXCL</span><span class=o>|</span><span class=n>O_RDWR</span><span class=p>,</span> <span class=mo>0600</span><span class=p>);</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;open file with fd %d,try unlink</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>fd</span><span class=p>);</span>

    <span class=n>unlink</span><span class=p>(</span><span class=s>&#34;test.txt&#34;</span><span class=p>);</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;unlink file, try write content</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=k>if</span><span class=p>(</span><span class=n>write</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=s>&#34;&lt;?php phpinfo();?&gt;&#34;</span><span class=p>,</span> <span class=mi>19</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>19</span><span class=p>)</span>
    <span class=p>{</span>
        <span class=n>printf</span><span class=p>(</span><span class=s>&#34;write file error!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=kt>char</span> <span class=n>buffer</span><span class=p>[</span><span class=mh>0x10</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
    <span class=n>lseek</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span><span class=n>SEEK_SET</span><span class=p>);</span>
    <span class=kt>int</span> <span class=n>size</span> <span class=o>=</span> <span class=n>read</span><span class=p>(</span><span class=n>fd</span><span class=p>,</span> <span class=n>buffer</span> <span class=p>,</span> <span class=mi>19</span><span class=p>);</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;read size is %d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>size</span><span class=p>);</span>
    <span class=n>printf</span><span class=p>(</span><span class=s>&#34;read buffer is %s</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span><span class=n>buffer</span><span class=p>);</span>

    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>sleep</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>
    <span class=p>}</span>
    <span class=c1>// close(fd);
</span><span class=c1></span>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><p>编译运行以上代码，我们可以在对应的 <code>/proc/pid/fd</code> 下找到我们删除的文件 ，可以看到虽然显示是被删除了，但是我们依然可以读取到文件内容，所以我们是不是可以直接用 php 进行文件包含呢？</p>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/91910e52-9528-46d4-87f7-7ea4905ba9c7.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/91910e52-9528-46d4-87f7-7ea4905ba9c7.png loading=lazy>
</a>
</figure></p>
<h3 id=bypass-php-file-stat>Bypass PHP File Stat</h3>
<p>虽然这并不是第一次出现过这个技巧了，但是可能比赛的时候大多数人都没想起来，对于 <code>include</code> 函数，在进行包含的时候，会使用 <code>php_sys_lstat</code> 函数判断路径，这里已经有师傅整理过很详细的文章了：<a class=link href=https://www.anquanke.com/post/id/213235#h3-5 target=_blank rel=noopener>php源码分析 require_once 绕过不能重复包含文件的限制</a></p>
<blockquote>
<p><code>php_sys_lstat()</code>实际上就是linux的<code>lstat()</code>，这个函数是用来获取一些文件相关的信息，成功执行时，返回0。失败返回-1，并且会设置<code>errno</code>，因为之前符号链接过多，所以<code>errno</code>就都是<code>ELOOP</code>，符号链接的循环数量真正取决于<code>SYMLOOP_MAX</code>，这是个<code>runtime-value</code>，它的值不能小于<code>_POSIX_SYMLOOP_MAX</code>。</p>
</blockquote>
<p>所以虽然直接包含会显示文件不存在，但是这里依然适用于使用多层符号链接绕过的场景，进而包含执行 php 代码，并且根据一开始我们实验的图看到，其实 Nginx 对于临时文件句柄的关闭往往在最后才进行关闭，所以这个过程中有足够的时间让我们去进行竞争包含。</p>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/9882b4ce-4414-4d2e-8401-38a70bde4a51.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/9882b4ce-4414-4d2e-8401-38a70bde4a51.png loading=lazy>
</a>
</figure></p>
<h3 id=chain-together>Chain Together</h3>
<p>所以到这里我们可以有了一个大概的想法：竞争包含 proc 目录下的临时文件。但是最后一个问题就是，既然我们要去包含 Nginx 进程下的文件，我们就需要知道对应的 pid 以及 fd 下具体的文件名，怎么才能获取到这些信息呢？</p>
<p>这时我们就需要用到文件读取进行获取 proc 目录下的其他文件了，这里我们只需要本地搭个 Nginx 进程并启动，对比其进程的 proc 目录文件与其他进程文件区别就可以了。</p>
<p>而进程间比较容易区别的就是通过 <code>/proc/cmdline</code> ，如果是 Nginx Worker 进程，我们可以读取到文件内容为 <code>nginx: worker process</code> 即可找到 Nginx Worker 进程；因为 Master 进程不处理请求，所以我们没必要找 Nginx Master 进程。</p>
<p>当然，Nginx 会有很多 Worker 进程，但是一般来说 Worker 数量不会超过 cpu 核心数量，我们可以通过 <code>/proc/cpuinfo</code> 中的 processor 个数得到 cpu 数量，我们可以对比找到的 Nginx Worker Pid 数量以及 CPU 数量来校验我们大概找的对不对。</p>
<p>那怎么确定用哪一个 PID 呢？以及 fd 怎么办呢？由于 Nginx 的调度策略我们确实没有办法确定具体哪一个 worker 分配了任务，但是一般来说是 8 个 worker ，实际本地测试 fd 序号一般不超过 70 ，即使爆破也只是 8*70 ，能在常数时间内得到解答。</p>
<p>总结起来整个过程就是：</p>
<ul>
<li>让后端 php 请求一个过大的文件</li>
<li>Fastcgi 返回响应包过大，导致 Nginx 需要产生临时文件进行缓存</li>
<li>虽然 Nginx 删除了<code>/var/lib/nginx/fastcgi</code>下的临时文件，但是在 <code>/proc/pid/fd/</code> 下我们可以找到被删除的文件</li>
<li>遍历 pid 以及 fd ，使用多重链接绕过 PHP 包含策略完成 LFI</li>
</ul>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/791b1c5b-9e8f-4682-aca9-2cd84f2065ad.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/791b1c5b-9e8f-4682-aca9-2cd84f2065ad.png loading=lazy>
</a>
</figure></p>
<p>这里需要注意的是把握好自己生成的 tmp 文件大小以及 curl 命令，可以生成后自己 debug 看一下 fd 目录下的文件存活多久。</p>
<h2 id=counter--nginx-request-body-temp-lfi>Counter && Nginx Request Body Temp LFI</h2>
<p>Counter 也是一道 PHP 的题目，也是一道与 LFI 有关的题目，但是在这篇文章中，我并不想写这道题的预期，我们继续来写这个题的非预期。</p>
<p>还记得我们上文分析的 client_body_in_file_only 选项看到的文档说明吗？</p>
<blockquote>
<p>Determines whether nginx should save the entire client request body into a file</p>
</blockquote>
<p>虽然这个也需要配置，但是结合我们上文分析的结果，以及之前我们也看到 Nginx 有个相关的目录 <code>/var/lib/nginx/body</code> ，难不成 Nginx 对于过大的 Request Body 也会产生临时文件？</p>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/885a8c0e-c747-4e4e-a7ab-7f7780b83267.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/885a8c0e-c747-4e4e-a7ab-7f7780b83267.png loading=lazy>
</a>
</figure></p>
<p>这里只要试一试就可以了，就不再过多分析了，基本与 Fastcgi 产生临时文件一致，创建临时文件的时候的调用栈：</p>
<pre tabindex=0><code>ngx_create_temp_file(ngx_file_t * file, ngx_path_t * path, ngx_pool_t * pool, ngx_uint_t persistent, ngx_uint_t clean, ngx_uint_t access) (/home/zeddy/Desktop/nginx-1.18.0/src/core/ngx_file.c:143)
ngx_write_chain_to_temp_file(ngx_temp_file_t * tf, ngx_chain_t * chain) (/home/zeddy/Desktop/nginx-1.18.0/src/core/ngx_file.c:114)
ngx_http_write_request_body(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request_body.c:483)
ngx_http_request_body_save_filter(ngx_http_request_t * r, ngx_chain_t * in) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request_body.c:1132)
ngx_http_request_body_length_filter(ngx_chain_t * in, ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request_body.c:921)
ngx_http_request_body_filter(ngx_http_request_t * r, ngx_chain_t * in) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request_body.c:855)
ngx_http_do_read_client_request_body(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request_body.c:292)
ngx_http_read_client_request_body(ngx_http_request_t * r, ngx_http_client_body_handler_pt post_handler) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request_body.c:185)
ngx_http_fastcgi_handler(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/modules/ngx_http_fastcgi_module.c:748)
ngx_http_core_content_phase(ngx_http_request_t * r, ngx_http_phase_handler_t * ph) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_core_module.c:1247)
ngx_http_core_run_phases(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_core_module.c:868)
ngx_http_handler(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_core_module.c:851)
ngx_http_internal_redirect(ngx_http_request_t * r, ngx_str_t * uri, ngx_str_t * args) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_core_module.c:2530)
ngx_http_index_handler(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/modules/ngx_http_index_module.c:277)
ngx_http_core_content_phase(ngx_http_request_t * r, ngx_http_phase_handler_t * ph) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_core_module.c:1254)
ngx_http_core_run_phases(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_core_module.c:868)
ngx_http_handler(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_core_module.c:851)
ngx_http_process_request(ngx_http_request_t * r) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request.c:2060)
ngx_http_process_request_headers(ngx_event_t * rev) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request.c:1480)
ngx_http_process_request_line(ngx_event_t * rev) (/home/zeddy/Desktop/nginx-1.18.0/src/http/ngx_http_request.c:1151)
</code></pre><p>这里简单只用了一句话 <code>include</code> 作为测试：</p>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/2af3c122-6989-4282-923b-b29da30d436b.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/2af3c122-6989-4282-923b-b29da30d436b.png loading=lazy>
</a>
</figure></p>
<p>我们可以把发送的报文 Content-Length 头部增加一定数额，并且在发送完数据的时候 <code>sleep</code> 避免 Nginx 过早关闭，可以看到我们可以直接包含了临时文件执行了 php 代码，这个方法相对 Nginx Fastcgi 的方法来说更实用。</p>
<p>这里需要注意的是把握好不要过早关闭 socket ，会导致 Nginx 过早关闭文件句柄导致我们无法竞争到。</p>
<h2 id=conclusion>Conclusion</h2>
<p>由于我比较菜，比赛的时候只分析了部分 Nginx 源码，通过各类文章深入理解了一下 Nginx 实现原理，一直卡在如何让临时文件保存的问题上，所以最后也没有做出来。</p>
<p>整体做(坐)下来，我感觉整个题很符合我的味口，不仅因为之前自己尝试挖临时文件的一些 Tricks 最后没有挖到，导致看到这个题的时候就会感觉很兴奋（尽然有人能挖出来了！我学爆！），尽管自己比赛没做出来；而且也因为通过两天坐牢阅读 Nginx 源码、调试 Nginx ，我觉得其中过程的收获与最后知道怎么结题、这个比较通用的新颖的 LFI 技巧是相等的。</p>
<p>当然，这里只是根据题目按图索骥，利用 Nginx 特性完成 LFI 的利用，其他 Server 也可能存在类似的利用特点，但是说到底终究还是个 LFI ，至于其他 Server 的利用就等待师傅们继续深入挖掘了。</p>
<p>另外，赛后跟几个队以及作者交流了一下，作者对于 Fastcgi Tmp 的做法表示是预期做法，但是 Body 做法确实非预期了；@Super Guesser 队伍使用了 Body 非预期做法解掉了 Counter ；@pasten ，这场比赛的冠军队伍，曾试图竞争 Fastcgi Tmp 文件，导致打了很多流量。</p>
<blockquote>
<p>23:23 &lt;<em>0xbb</em>> yes pasten did that for sure<br>
23:23 &lt;zeddyu> i think it is impossible<br>
23:24 &lt;zeddyu> lol<br>
23:24 &lt;zeddyu> how<br>
23:24 &lt;<em>0xbb</em>> nope you can do it with a lot of force<br>
23:24 &lt;<em>0xbb</em>> 16 x core Germany<br>
23:24 &lt;zeddyu> gods<br>
23:24 &lt;<em>0xbb</em>> we saw peek 1.7 gigabits I think :D<br>
23:24 &lt;<em>0xbb</em>> but they were gentle :D<br></p>
</blockquote>
<p>赛后官方放出了流量统计图：</p>
<p><figure>
<a href=https://storage.tttang.com/media/attachment/2021/12/22/c3f92a9e-271f-49ce-b36c-e3ee82883e29.png><img src=https://storage.tttang.com/media/attachment/2021/12/22/c3f92a9e-271f-49ce-b36c-e3ee82883e29.png loading=lazy>
</a>
</figure></p>
<p>可以看到 includer&rsquo;s revenge 这个题流量交互确实很频繁 2333</p>
<p>另外的另外，不得不佩服作者的出题技巧，虽然整体看起来可能并不是特别难，但是我觉得国内能与作者抗衡的也只有那位某队副队、曾在某个比赛拿下 250 万奖金的成功人士了吧（</p>
<p>另外的另外的另外，由于 Counter 题目的预期与本文介绍的 LFI 技巧没太大关系， 所以不写在本文，如果有同学感兴趣，或者也想了解一些有趣的 Web CTF 题目的解题方法的，可以尝试了解一下我目前运营的星球：</p>
<blockquote>
<p>我正在「Funny Web CTF」和朋友们讨论有趣的话题，你⼀起来吧？https://t.zsxq.com/7y7iAuf</p>
</blockquote>
<h2 id=references>References</h2>
<ol>
<li><a id=ref01><a class=link href=https://gist.github.com/magnetikonline/11312172 target=_blank rel=noopener>Nginx FastCGI response buffer sizes</a></a></li>
<li><a id=ref02><a class=link href=https://gist.github.com/ikennaokpala/5792a71cfae6818035eedc8abd9ae7b4 target=_blank rel=noopener>Nginx FastCGI response buffer sizes</a></a></li>
<li><a href=#ref03><a class=link href=https://www.kancloud.cn/digest/understandingnginx/202606 target=_blank rel=noopener>Nginx 中 upstream 机制的实现</a></a></li>
<li><a href=#ref04><a class=link href=https://www.iteye.com/blog/bollaxu-888748 target=_blank rel=noopener>Nginx Proxy Cache分析</a></a></li>
</ol>
</section>
<footer class=article-footer>
<section class=article-tags>
<a href=/tags/CTF/>CTF</a>
</section>
<section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span>
</section>
<div class="notice notice-tip">
<div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div>
<p>I am looking for some guys who have a strong interest in CTFs to build a team focused on international CTFs that are on the ctftime.org, if anyone is interested in this idea you can take a look at here: <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>Advertisements</a></p><br>
<p>想了解更多有意思的国际赛 CTF 中 Web 知识技巧，欢迎加入我的 <a class=link href=https://blog.zeddyu.info/advertisement/#%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83 target=_blank rel=noopener>知识星球</a> ; 另外我正在召集一群小伙伴组建一支专注国际 CTF 的队伍，如果有感兴趣的小伙伴也可在 <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>International CTF Team</a> 查看详情</p><br>
</div>
</footer>
</article>
<aside class=related-contents--wrapper>
<h2 class=section-title>Related contents</h2>
<div class=related-contents>
<div class="flex article-list--tile">
<article>
<a href=/2022/01/08/2022-01-08-TheEndOfLFI/>
<div class=article-details>
<h2 class=article-title>hxp CTF 2021 - The End Of LFI?</h2>
</div>
</a>
</article>
<article>
<a href=/2021/08/02/cybrics-checkin-2021/>
<div class=article-details>
<h2 class=article-title>Writeup for Web-Checkin in CyBRICS CTF 2021 (Mirror)</h2>
</div>
</a>
</article>
<article>
<a href=/2021/07/21/google-qual-2021/>
<div class=article-details>
<h2 class=article-title>Two Webs' Writeup in Google CTF Quals 2021</h2>
</div>
</a>
</article>
<article>
<a href=/2021/05/19/tls-ctf/>
<div class=article-details>
<h2 class=article-title>TLS-Poison 攻击方式在 CTF 中的利用实践</h2>
</div>
</a>
</article>
<article>
<a href=/2020/10/15/Defcon28final/>
<div class=article-details>
<h2 class=article-title>DEFCON 28 Final 杂记</h2>
</div>
</a>
</article>
</div>
</div>
</aside>
<div class=disqus-container>
<div id=disqus_thread></div>
<script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var b=document,a=b.createElement('script');a.async=!0,a.src='//ZeddYu.disqus.com/embed.js',a.setAttribute('data-timestamp',+new Date),(b.head||b.body).appendChild(a)})()</script>
<noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript>
<a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a>
</div>
<style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style>
<script>window.addEventListener('onColorSchemeChange',a=>{DISQUS&&DISQUS.reset({reload:!0})})</script>
<footer class=site-footer>
<section class=copyright>
&copy;
2018 -
2022 Zeddy's Blog
</section>
<section class=powerby>
Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> <br>
Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a>
</section>
</footer>
<div class=pswp tabindex=-1 role=dialog aria-hidden=true>
<div class=pswp__bg></div>
<div class=pswp__scroll-wrap>
<div class=pswp__container>
<div class=pswp__item></div>
<div class=pswp__item></div>
<div class=pswp__item></div>
</div>
<div class="pswp__ui pswp__ui--hidden">
<div class=pswp__top-bar>
<div class=pswp__counter></div>
<button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
<div class=pswp__preloader>
<div class=pswp__preloader__icn>
<div class=pswp__preloader__cut>
<div class=pswp__preloader__donut></div>
</div>
</div>
</div>
</div>
<div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
<div class=pswp__share-tooltip></div>
</div>
<button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
</button>
<div class=pswp__caption>
<div class=pswp__caption__center></div>
</div>
</div>
</div>
</div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous>
</main>
<aside class="sidebar right-sidebar sticky">
<section class="widget archives">
<div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
</div>
<h2 class="widget-title section-title">Table of contents</h2>
<div class=widget--toc>
<nav id=TableOfContents>
<ol>
<li><a href=#tldr>TL;DR</a></li>
<li><a href=#includers-revenge---nginx-fastcgi-temp-lfi>Includer&rsquo;s revenge - Nginx Fastcgi Temp LFI</a>
<ol>
<li><a href=#how-to-produce-tmp-files>How To Produce Tmp Files</a></li>
<li><a href=#how-nginx-produce-tmp-files>How Nginx Produce Tmp Files</a>
<ol>
<li><a href=#client_body_in_file_only>client_body_in_file_only</a></li>
<li><a href=#fastcgi_store>fastcgi_store</a></li>
<li><a href=#cache>cache</a></li>
</ol>
</li>
<li><a href=#tmp-files-after-deleted>Tmp Files After Deleted</a></li>
<li><a href=#bypass-php-file-stat>Bypass PHP File Stat</a></li>
<li><a href=#chain-together>Chain Together</a></li>
</ol>
</li>
<li><a href=#counter--nginx-request-body-temp-lfi>Counter && Nginx Request Body Temp LFI</a></li>
<li><a href=#conclusion>Conclusion</a></li>
<li><a href=#references>References</a></li>
</ol>
</nav>
</div>
</section>
</aside>
</div>
<script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//ts/main.js defer></script>
<script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script>
<script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script>
</body>
</html>